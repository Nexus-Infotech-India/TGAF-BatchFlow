
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model Batch
 * 
 */
export type Batch = $Result.DefaultSelection<Prisma.$BatchPayload>
/**
 * Model ExportLog
 * 
 */
export type ExportLog = $Result.DefaultSelection<Prisma.$ExportLogPayload>
/**
 * Model Methodology
 * 
 */
export type Methodology = $Result.DefaultSelection<Prisma.$MethodologyPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductParameter
 * 
 */
export type ProductParameter = $Result.DefaultSelection<Prisma.$ProductParameterPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UnitOfMeasurement
 * 
 */
export type UnitOfMeasurement = $Result.DefaultSelection<Prisma.$UnitOfMeasurementPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Standard
 * 
 */
export type Standard = $Result.DefaultSelection<Prisma.$StandardPayload>
/**
 * Model StandardCategory
 * 
 */
export type StandardCategory = $Result.DefaultSelection<Prisma.$StandardCategoryPayload>
/**
 * Model ProductStandardCategory
 * 
 */
export type ProductStandardCategory = $Result.DefaultSelection<Prisma.$ProductStandardCategoryPayload>
/**
 * Model StandardParameter
 * 
 */
export type StandardParameter = $Result.DefaultSelection<Prisma.$StandardParameterPayload>
/**
 * Model StandardDefinition
 * 
 */
export type StandardDefinition = $Result.DefaultSelection<Prisma.$StandardDefinitionPayload>
/**
 * Model BatchParameterValue
 * 
 */
export type BatchParameterValue = $Result.DefaultSelection<Prisma.$BatchParameterValuePayload>
/**
 * Model TrainingCalendar
 * 
 */
export type TrainingCalendar = $Result.DefaultSelection<Prisma.$TrainingCalendarPayload>
/**
 * Model Training
 * 
 */
export type Training = $Result.DefaultSelection<Prisma.$TrainingPayload>
/**
 * Model TrainingSession
 * 
 */
export type TrainingSession = $Result.DefaultSelection<Prisma.$TrainingSessionPayload>
/**
 * Model TrainingDocument
 * 
 */
export type TrainingDocument = $Result.DefaultSelection<Prisma.$TrainingDocumentPayload>
/**
 * Model Participant
 * 
 */
export type Participant = $Result.DefaultSelection<Prisma.$ParticipantPayload>
/**
 * Model TrainingParticipant
 * 
 */
export type TrainingParticipant = $Result.DefaultSelection<Prisma.$TrainingParticipantPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model TrainingPhoto
 * 
 */
export type TrainingPhoto = $Result.DefaultSelection<Prisma.$TrainingPhotoPayload>
/**
 * Model TrainingFeedback
 * 
 */
export type TrainingFeedback = $Result.DefaultSelection<Prisma.$TrainingFeedbackPayload>
/**
 * Model FeedbackForm
 * 
 */
export type FeedbackForm = $Result.DefaultSelection<Prisma.$FeedbackFormPayload>
/**
 * Model TrainingFollowup
 * 
 */
export type TrainingFollowup = $Result.DefaultSelection<Prisma.$TrainingFollowupPayload>
/**
 * Model TrainingNotification
 * 
 */
export type TrainingNotification = $Result.DefaultSelection<Prisma.$TrainingNotificationPayload>
/**
 * Model TrainingInviteToken
 * 
 */
export type TrainingInviteToken = $Result.DefaultSelection<Prisma.$TrainingInviteTokenPayload>
/**
 * Model TrainingSessionPhoto
 * 
 */
export type TrainingSessionPhoto = $Result.DefaultSelection<Prisma.$TrainingSessionPhotoPayload>
/**
 * Model Auditor
 * 
 */
export type Auditor = $Result.DefaultSelection<Prisma.$AuditorPayload>
/**
 * Model Audit
 * 
 */
export type Audit = $Result.DefaultSelection<Prisma.$AuditPayload>
/**
 * Model AuditInspectionItem
 * 
 */
export type AuditInspectionItem = $Result.DefaultSelection<Prisma.$AuditInspectionItemPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Finding
 * 
 */
export type Finding = $Result.DefaultSelection<Prisma.$FindingPayload>
/**
 * Model CorrectiveAction
 * 
 */
export type CorrectiveAction = $Result.DefaultSelection<Prisma.$CorrectiveActionPayload>
/**
 * Model AuditDocument
 * 
 */
export type AuditDocument = $Result.DefaultSelection<Prisma.$AuditDocumentPayload>
/**
 * Model PreAuditChecklistItem
 * 
 */
export type PreAuditChecklistItem = $Result.DefaultSelection<Prisma.$PreAuditChecklistItemPayload>
/**
 * Model AuditReminder
 * 
 */
export type AuditReminder = $Result.DefaultSelection<Prisma.$AuditReminderPayload>
/**
 * Model AuditNotification
 * 
 */
export type AuditNotification = $Result.DefaultSelection<Prisma.$AuditNotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BatchStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type BatchStatus = (typeof BatchStatus)[keyof typeof BatchStatus]


export const NotificationType: {
  BATCH_SUBMITTED: 'BATCH_SUBMITTED',
  BATCH_APPROVED: 'BATCH_APPROVED',
  BATCH_REJECTED: 'BATCH_REJECTED',
  SYSTEM: 'SYSTEM'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const SampleAnalysisStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type SampleAnalysisStatus = (typeof SampleAnalysisStatus)[keyof typeof SampleAnalysisStatus]


export const StandardStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  DEPRECATED: 'DEPRECATED'
};

export type StandardStatus = (typeof StandardStatus)[keyof typeof StandardStatus]


export const ParameterDataType: {
  TEXT: 'TEXT',
  FLOAT: 'FLOAT',
  INTEGER: 'INTEGER',
  BOOLEAN: 'BOOLEAN',
  PERCENTAGE: 'PERCENTAGE',
  DATE: 'DATE'
};

export type ParameterDataType = (typeof ParameterDataType)[keyof typeof ParameterDataType]


export const TrainingType: {
  TECHNICAL: 'TECHNICAL',
  SAFETY: 'SAFETY',
  COMPLIANCE: 'COMPLIANCE',
  ONBOARDING: 'ONBOARDING',
  PROFESSIONAL_DEVELOPMENT: 'PROFESSIONAL_DEVELOPMENT',
  WORKSHOP: 'WORKSHOP',
  SEMINAR: 'SEMINAR'
};

export type TrainingType = (typeof TrainingType)[keyof typeof TrainingType]


export const TrainingStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  POSTPONED: 'POSTPONED'
};

export type TrainingStatus = (typeof TrainingStatus)[keyof typeof TrainingStatus]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  EXCUSED: 'EXCUSED'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const DocumentType: {
  COURSE_MATERIAL: 'COURSE_MATERIAL',
  PRESENTATION: 'PRESENTATION',
  AGENDA: 'AGENDA',
  GUIDELINE: 'GUIDELINE',
  CERTIFICATE: 'CERTIFICATE',
  ASSESSMENT: 'ASSESSMENT',
  FEEDBACK_FORM: 'FEEDBACK_FORM',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const ParticipantType: {
  INTERNAL: 'INTERNAL',
  EXTERNAL: 'EXTERNAL'
};

export type ParticipantType = (typeof ParticipantType)[keyof typeof ParticipantType]


export const AuditType: {
  INTERNAL: 'INTERNAL',
  EXTERNAL: 'EXTERNAL'
};

export type AuditType = (typeof AuditType)[keyof typeof AuditType]


export const AuditStatus: {
  PLANNED: 'PLANNED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  DELAYED: 'DELAYED'
};

export type AuditStatus = (typeof AuditStatus)[keyof typeof AuditStatus]


export const FindingType: {
  OBSERVATION: 'OBSERVATION',
  NON_CONFORMITY: 'NON_CONFORMITY',
  MAJOR_NON_CONFORMITY: 'MAJOR_NON_CONFORMITY',
  OPPORTUNITY_FOR_IMPROVEMENT: 'OPPORTUNITY_FOR_IMPROVEMENT'
};

export type FindingType = (typeof FindingType)[keyof typeof FindingType]


export const FindingStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  VERIFIED: 'VERIFIED',
  CLOSED: 'CLOSED'
};

export type FindingStatus = (typeof FindingStatus)[keyof typeof FindingStatus]


export const AuditDocumentType: {
  CHECKLIST: 'CHECKLIST',
  PROCEDURE: 'PROCEDURE',
  CERTIFICATE: 'CERTIFICATE',
  EVIDENCE: 'EVIDENCE',
  REPORT: 'REPORT',
  OTHER: 'OTHER'
};

export type AuditDocumentType = (typeof AuditDocumentType)[keyof typeof AuditDocumentType]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type Priority = (typeof Priority)[keyof typeof Priority]

}

export type BatchStatus = $Enums.BatchStatus

export const BatchStatus: typeof $Enums.BatchStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type SampleAnalysisStatus = $Enums.SampleAnalysisStatus

export const SampleAnalysisStatus: typeof $Enums.SampleAnalysisStatus

export type StandardStatus = $Enums.StandardStatus

export const StandardStatus: typeof $Enums.StandardStatus

export type ParameterDataType = $Enums.ParameterDataType

export const ParameterDataType: typeof $Enums.ParameterDataType

export type TrainingType = $Enums.TrainingType

export const TrainingType: typeof $Enums.TrainingType

export type TrainingStatus = $Enums.TrainingStatus

export const TrainingStatus: typeof $Enums.TrainingStatus

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type ParticipantType = $Enums.ParticipantType

export const ParticipantType: typeof $Enums.ParticipantType

export type AuditType = $Enums.AuditType

export const AuditType: typeof $Enums.AuditType

export type AuditStatus = $Enums.AuditStatus

export const AuditStatus: typeof $Enums.AuditStatus

export type FindingType = $Enums.FindingType

export const FindingType: typeof $Enums.FindingType

export type FindingStatus = $Enums.FindingStatus

export const FindingStatus: typeof $Enums.FindingStatus

export type AuditDocumentType = $Enums.AuditDocumentType

export const AuditDocumentType: typeof $Enums.AuditDocumentType

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ActivityLogs
 * const activityLogs = await prisma.activityLog.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ActivityLogs
   * const activityLogs = await prisma.activityLog.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batch`: Exposes CRUD operations for the **Batch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Batches
    * const batches = await prisma.batch.findMany()
    * ```
    */
  get batch(): Prisma.BatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exportLog`: Exposes CRUD operations for the **ExportLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExportLogs
    * const exportLogs = await prisma.exportLog.findMany()
    * ```
    */
  get exportLog(): Prisma.ExportLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.methodology`: Exposes CRUD operations for the **Methodology** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Methodologies
    * const methodologies = await prisma.methodology.findMany()
    * ```
    */
  get methodology(): Prisma.MethodologyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productParameter`: Exposes CRUD operations for the **ProductParameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductParameters
    * const productParameters = await prisma.productParameter.findMany()
    * ```
    */
  get productParameter(): Prisma.ProductParameterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitOfMeasurement`: Exposes CRUD operations for the **UnitOfMeasurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitOfMeasurements
    * const unitOfMeasurements = await prisma.unitOfMeasurement.findMany()
    * ```
    */
  get unitOfMeasurement(): Prisma.UnitOfMeasurementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.standard`: Exposes CRUD operations for the **Standard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Standards
    * const standards = await prisma.standard.findMany()
    * ```
    */
  get standard(): Prisma.StandardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.standardCategory`: Exposes CRUD operations for the **StandardCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StandardCategories
    * const standardCategories = await prisma.standardCategory.findMany()
    * ```
    */
  get standardCategory(): Prisma.StandardCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productStandardCategory`: Exposes CRUD operations for the **ProductStandardCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductStandardCategories
    * const productStandardCategories = await prisma.productStandardCategory.findMany()
    * ```
    */
  get productStandardCategory(): Prisma.ProductStandardCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.standardParameter`: Exposes CRUD operations for the **StandardParameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StandardParameters
    * const standardParameters = await prisma.standardParameter.findMany()
    * ```
    */
  get standardParameter(): Prisma.StandardParameterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.standardDefinition`: Exposes CRUD operations for the **StandardDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StandardDefinitions
    * const standardDefinitions = await prisma.standardDefinition.findMany()
    * ```
    */
  get standardDefinition(): Prisma.StandardDefinitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batchParameterValue`: Exposes CRUD operations for the **BatchParameterValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BatchParameterValues
    * const batchParameterValues = await prisma.batchParameterValue.findMany()
    * ```
    */
  get batchParameterValue(): Prisma.BatchParameterValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingCalendar`: Exposes CRUD operations for the **TrainingCalendar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingCalendars
    * const trainingCalendars = await prisma.trainingCalendar.findMany()
    * ```
    */
  get trainingCalendar(): Prisma.TrainingCalendarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.training`: Exposes CRUD operations for the **Training** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trainings
    * const trainings = await prisma.training.findMany()
    * ```
    */
  get training(): Prisma.TrainingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingSession`: Exposes CRUD operations for the **TrainingSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingSessions
    * const trainingSessions = await prisma.trainingSession.findMany()
    * ```
    */
  get trainingSession(): Prisma.TrainingSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingDocument`: Exposes CRUD operations for the **TrainingDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingDocuments
    * const trainingDocuments = await prisma.trainingDocument.findMany()
    * ```
    */
  get trainingDocument(): Prisma.TrainingDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.participant`: Exposes CRUD operations for the **Participant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Participants
    * const participants = await prisma.participant.findMany()
    * ```
    */
  get participant(): Prisma.ParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingParticipant`: Exposes CRUD operations for the **TrainingParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingParticipants
    * const trainingParticipants = await prisma.trainingParticipant.findMany()
    * ```
    */
  get trainingParticipant(): Prisma.TrainingParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingPhoto`: Exposes CRUD operations for the **TrainingPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingPhotos
    * const trainingPhotos = await prisma.trainingPhoto.findMany()
    * ```
    */
  get trainingPhoto(): Prisma.TrainingPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingFeedback`: Exposes CRUD operations for the **TrainingFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingFeedbacks
    * const trainingFeedbacks = await prisma.trainingFeedback.findMany()
    * ```
    */
  get trainingFeedback(): Prisma.TrainingFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedbackForm`: Exposes CRUD operations for the **FeedbackForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedbackForms
    * const feedbackForms = await prisma.feedbackForm.findMany()
    * ```
    */
  get feedbackForm(): Prisma.FeedbackFormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingFollowup`: Exposes CRUD operations for the **TrainingFollowup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingFollowups
    * const trainingFollowups = await prisma.trainingFollowup.findMany()
    * ```
    */
  get trainingFollowup(): Prisma.TrainingFollowupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingNotification`: Exposes CRUD operations for the **TrainingNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingNotifications
    * const trainingNotifications = await prisma.trainingNotification.findMany()
    * ```
    */
  get trainingNotification(): Prisma.TrainingNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingInviteToken`: Exposes CRUD operations for the **TrainingInviteToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingInviteTokens
    * const trainingInviteTokens = await prisma.trainingInviteToken.findMany()
    * ```
    */
  get trainingInviteToken(): Prisma.TrainingInviteTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingSessionPhoto`: Exposes CRUD operations for the **TrainingSessionPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingSessionPhotos
    * const trainingSessionPhotos = await prisma.trainingSessionPhoto.findMany()
    * ```
    */
  get trainingSessionPhoto(): Prisma.TrainingSessionPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditor`: Exposes CRUD operations for the **Auditor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditors
    * const auditors = await prisma.auditor.findMany()
    * ```
    */
  get auditor(): Prisma.AuditorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audit`: Exposes CRUD operations for the **Audit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audits
    * const audits = await prisma.audit.findMany()
    * ```
    */
  get audit(): Prisma.AuditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditInspectionItem`: Exposes CRUD operations for the **AuditInspectionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditInspectionItems
    * const auditInspectionItems = await prisma.auditInspectionItem.findMany()
    * ```
    */
  get auditInspectionItem(): Prisma.AuditInspectionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.finding`: Exposes CRUD operations for the **Finding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Findings
    * const findings = await prisma.finding.findMany()
    * ```
    */
  get finding(): Prisma.FindingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.correctiveAction`: Exposes CRUD operations for the **CorrectiveAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CorrectiveActions
    * const correctiveActions = await prisma.correctiveAction.findMany()
    * ```
    */
  get correctiveAction(): Prisma.CorrectiveActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditDocument`: Exposes CRUD operations for the **AuditDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditDocuments
    * const auditDocuments = await prisma.auditDocument.findMany()
    * ```
    */
  get auditDocument(): Prisma.AuditDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preAuditChecklistItem`: Exposes CRUD operations for the **PreAuditChecklistItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PreAuditChecklistItems
    * const preAuditChecklistItems = await prisma.preAuditChecklistItem.findMany()
    * ```
    */
  get preAuditChecklistItem(): Prisma.PreAuditChecklistItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditReminder`: Exposes CRUD operations for the **AuditReminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditReminders
    * const auditReminders = await prisma.auditReminder.findMany()
    * ```
    */
  get auditReminder(): Prisma.AuditReminderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditNotification`: Exposes CRUD operations for the **AuditNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditNotifications
    * const auditNotifications = await prisma.auditNotification.findMany()
    * ```
    */
  get auditNotification(): Prisma.AuditNotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ActivityLog: 'ActivityLog',
    Batch: 'Batch',
    ExportLog: 'ExportLog',
    Methodology: 'Methodology',
    Notification: 'Notification',
    Permission: 'Permission',
    Product: 'Product',
    ProductParameter: 'ProductParameter',
    Role: 'Role',
    UnitOfMeasurement: 'UnitOfMeasurement',
    User: 'User',
    Standard: 'Standard',
    StandardCategory: 'StandardCategory',
    ProductStandardCategory: 'ProductStandardCategory',
    StandardParameter: 'StandardParameter',
    StandardDefinition: 'StandardDefinition',
    BatchParameterValue: 'BatchParameterValue',
    TrainingCalendar: 'TrainingCalendar',
    Training: 'Training',
    TrainingSession: 'TrainingSession',
    TrainingDocument: 'TrainingDocument',
    Participant: 'Participant',
    TrainingParticipant: 'TrainingParticipant',
    Attendance: 'Attendance',
    TrainingPhoto: 'TrainingPhoto',
    TrainingFeedback: 'TrainingFeedback',
    FeedbackForm: 'FeedbackForm',
    TrainingFollowup: 'TrainingFollowup',
    TrainingNotification: 'TrainingNotification',
    TrainingInviteToken: 'TrainingInviteToken',
    TrainingSessionPhoto: 'TrainingSessionPhoto',
    Auditor: 'Auditor',
    Audit: 'Audit',
    AuditInspectionItem: 'AuditInspectionItem',
    Department: 'Department',
    Finding: 'Finding',
    CorrectiveAction: 'CorrectiveAction',
    AuditDocument: 'AuditDocument',
    PreAuditChecklistItem: 'PreAuditChecklistItem',
    AuditReminder: 'AuditReminder',
    AuditNotification: 'AuditNotification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "activityLog" | "batch" | "exportLog" | "methodology" | "notification" | "permission" | "product" | "productParameter" | "role" | "unitOfMeasurement" | "user" | "standard" | "standardCategory" | "productStandardCategory" | "standardParameter" | "standardDefinition" | "batchParameterValue" | "trainingCalendar" | "training" | "trainingSession" | "trainingDocument" | "participant" | "trainingParticipant" | "attendance" | "trainingPhoto" | "trainingFeedback" | "feedbackForm" | "trainingFollowup" | "trainingNotification" | "trainingInviteToken" | "trainingSessionPhoto" | "auditor" | "audit" | "auditInspectionItem" | "department" | "finding" | "correctiveAction" | "auditDocument" | "preAuditChecklistItem" | "auditReminder" | "auditNotification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      Batch: {
        payload: Prisma.$BatchPayload<ExtArgs>
        fields: Prisma.BatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findFirst: {
            args: Prisma.BatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findMany: {
            args: Prisma.BatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          create: {
            args: Prisma.BatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          createMany: {
            args: Prisma.BatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          delete: {
            args: Prisma.BatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          update: {
            args: Prisma.BatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          deleteMany: {
            args: Prisma.BatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          upsert: {
            args: Prisma.BatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          aggregate: {
            args: Prisma.BatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatch>
          }
          groupBy: {
            args: Prisma.BatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchCountArgs<ExtArgs>
            result: $Utils.Optional<BatchCountAggregateOutputType> | number
          }
        }
      }
      ExportLog: {
        payload: Prisma.$ExportLogPayload<ExtArgs>
        fields: Prisma.ExportLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExportLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExportLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>
          }
          findFirst: {
            args: Prisma.ExportLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExportLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>
          }
          findMany: {
            args: Prisma.ExportLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>[]
          }
          create: {
            args: Prisma.ExportLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>
          }
          createMany: {
            args: Prisma.ExportLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExportLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>[]
          }
          delete: {
            args: Prisma.ExportLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>
          }
          update: {
            args: Prisma.ExportLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>
          }
          deleteMany: {
            args: Prisma.ExportLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExportLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExportLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>[]
          }
          upsert: {
            args: Prisma.ExportLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>
          }
          aggregate: {
            args: Prisma.ExportLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExportLog>
          }
          groupBy: {
            args: Prisma.ExportLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExportLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExportLogCountArgs<ExtArgs>
            result: $Utils.Optional<ExportLogCountAggregateOutputType> | number
          }
        }
      }
      Methodology: {
        payload: Prisma.$MethodologyPayload<ExtArgs>
        fields: Prisma.MethodologyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MethodologyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MethodologyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>
          }
          findFirst: {
            args: Prisma.MethodologyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MethodologyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>
          }
          findMany: {
            args: Prisma.MethodologyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>[]
          }
          create: {
            args: Prisma.MethodologyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>
          }
          createMany: {
            args: Prisma.MethodologyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MethodologyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>[]
          }
          delete: {
            args: Prisma.MethodologyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>
          }
          update: {
            args: Prisma.MethodologyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>
          }
          deleteMany: {
            args: Prisma.MethodologyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MethodologyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MethodologyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>[]
          }
          upsert: {
            args: Prisma.MethodologyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>
          }
          aggregate: {
            args: Prisma.MethodologyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMethodology>
          }
          groupBy: {
            args: Prisma.MethodologyGroupByArgs<ExtArgs>
            result: $Utils.Optional<MethodologyGroupByOutputType>[]
          }
          count: {
            args: Prisma.MethodologyCountArgs<ExtArgs>
            result: $Utils.Optional<MethodologyCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductParameter: {
        payload: Prisma.$ProductParameterPayload<ExtArgs>
        fields: Prisma.ProductParameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductParameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductParameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductParameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductParameterPayload>
          }
          findFirst: {
            args: Prisma.ProductParameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductParameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductParameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductParameterPayload>
          }
          findMany: {
            args: Prisma.ProductParameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductParameterPayload>[]
          }
          create: {
            args: Prisma.ProductParameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductParameterPayload>
          }
          createMany: {
            args: Prisma.ProductParameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductParameterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductParameterPayload>[]
          }
          delete: {
            args: Prisma.ProductParameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductParameterPayload>
          }
          update: {
            args: Prisma.ProductParameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductParameterPayload>
          }
          deleteMany: {
            args: Prisma.ProductParameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductParameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductParameterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductParameterPayload>[]
          }
          upsert: {
            args: Prisma.ProductParameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductParameterPayload>
          }
          aggregate: {
            args: Prisma.ProductParameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductParameter>
          }
          groupBy: {
            args: Prisma.ProductParameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductParameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductParameterCountArgs<ExtArgs>
            result: $Utils.Optional<ProductParameterCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UnitOfMeasurement: {
        payload: Prisma.$UnitOfMeasurementPayload<ExtArgs>
        fields: Prisma.UnitOfMeasurementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitOfMeasurementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitOfMeasurementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>
          }
          findFirst: {
            args: Prisma.UnitOfMeasurementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitOfMeasurementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>
          }
          findMany: {
            args: Prisma.UnitOfMeasurementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>[]
          }
          create: {
            args: Prisma.UnitOfMeasurementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>
          }
          createMany: {
            args: Prisma.UnitOfMeasurementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitOfMeasurementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>[]
          }
          delete: {
            args: Prisma.UnitOfMeasurementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>
          }
          update: {
            args: Prisma.UnitOfMeasurementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>
          }
          deleteMany: {
            args: Prisma.UnitOfMeasurementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitOfMeasurementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitOfMeasurementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>[]
          }
          upsert: {
            args: Prisma.UnitOfMeasurementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>
          }
          aggregate: {
            args: Prisma.UnitOfMeasurementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitOfMeasurement>
          }
          groupBy: {
            args: Prisma.UnitOfMeasurementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitOfMeasurementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitOfMeasurementCountArgs<ExtArgs>
            result: $Utils.Optional<UnitOfMeasurementCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Standard: {
        payload: Prisma.$StandardPayload<ExtArgs>
        fields: Prisma.StandardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StandardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StandardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>
          }
          findFirst: {
            args: Prisma.StandardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StandardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>
          }
          findMany: {
            args: Prisma.StandardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>[]
          }
          create: {
            args: Prisma.StandardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>
          }
          createMany: {
            args: Prisma.StandardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StandardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>[]
          }
          delete: {
            args: Prisma.StandardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>
          }
          update: {
            args: Prisma.StandardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>
          }
          deleteMany: {
            args: Prisma.StandardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StandardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StandardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>[]
          }
          upsert: {
            args: Prisma.StandardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>
          }
          aggregate: {
            args: Prisma.StandardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStandard>
          }
          groupBy: {
            args: Prisma.StandardGroupByArgs<ExtArgs>
            result: $Utils.Optional<StandardGroupByOutputType>[]
          }
          count: {
            args: Prisma.StandardCountArgs<ExtArgs>
            result: $Utils.Optional<StandardCountAggregateOutputType> | number
          }
        }
      }
      StandardCategory: {
        payload: Prisma.$StandardCategoryPayload<ExtArgs>
        fields: Prisma.StandardCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StandardCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StandardCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>
          }
          findFirst: {
            args: Prisma.StandardCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StandardCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>
          }
          findMany: {
            args: Prisma.StandardCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>[]
          }
          create: {
            args: Prisma.StandardCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>
          }
          createMany: {
            args: Prisma.StandardCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StandardCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>[]
          }
          delete: {
            args: Prisma.StandardCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>
          }
          update: {
            args: Prisma.StandardCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>
          }
          deleteMany: {
            args: Prisma.StandardCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StandardCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StandardCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>[]
          }
          upsert: {
            args: Prisma.StandardCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>
          }
          aggregate: {
            args: Prisma.StandardCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStandardCategory>
          }
          groupBy: {
            args: Prisma.StandardCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<StandardCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StandardCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<StandardCategoryCountAggregateOutputType> | number
          }
        }
      }
      ProductStandardCategory: {
        payload: Prisma.$ProductStandardCategoryPayload<ExtArgs>
        fields: Prisma.ProductStandardCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductStandardCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStandardCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductStandardCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStandardCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductStandardCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStandardCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductStandardCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStandardCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductStandardCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStandardCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductStandardCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStandardCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductStandardCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductStandardCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStandardCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductStandardCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStandardCategoryPayload>
          }
          update: {
            args: Prisma.ProductStandardCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStandardCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductStandardCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductStandardCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductStandardCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStandardCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductStandardCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStandardCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductStandardCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductStandardCategory>
          }
          groupBy: {
            args: Prisma.ProductStandardCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductStandardCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductStandardCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductStandardCategoryCountAggregateOutputType> | number
          }
        }
      }
      StandardParameter: {
        payload: Prisma.$StandardParameterPayload<ExtArgs>
        fields: Prisma.StandardParameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StandardParameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StandardParameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>
          }
          findFirst: {
            args: Prisma.StandardParameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StandardParameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>
          }
          findMany: {
            args: Prisma.StandardParameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>[]
          }
          create: {
            args: Prisma.StandardParameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>
          }
          createMany: {
            args: Prisma.StandardParameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StandardParameterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>[]
          }
          delete: {
            args: Prisma.StandardParameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>
          }
          update: {
            args: Prisma.StandardParameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>
          }
          deleteMany: {
            args: Prisma.StandardParameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StandardParameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StandardParameterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>[]
          }
          upsert: {
            args: Prisma.StandardParameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>
          }
          aggregate: {
            args: Prisma.StandardParameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStandardParameter>
          }
          groupBy: {
            args: Prisma.StandardParameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<StandardParameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.StandardParameterCountArgs<ExtArgs>
            result: $Utils.Optional<StandardParameterCountAggregateOutputType> | number
          }
        }
      }
      StandardDefinition: {
        payload: Prisma.$StandardDefinitionPayload<ExtArgs>
        fields: Prisma.StandardDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StandardDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StandardDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>
          }
          findFirst: {
            args: Prisma.StandardDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StandardDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>
          }
          findMany: {
            args: Prisma.StandardDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>[]
          }
          create: {
            args: Prisma.StandardDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>
          }
          createMany: {
            args: Prisma.StandardDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StandardDefinitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>[]
          }
          delete: {
            args: Prisma.StandardDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>
          }
          update: {
            args: Prisma.StandardDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.StandardDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StandardDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StandardDefinitionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>[]
          }
          upsert: {
            args: Prisma.StandardDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>
          }
          aggregate: {
            args: Prisma.StandardDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStandardDefinition>
          }
          groupBy: {
            args: Prisma.StandardDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StandardDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StandardDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<StandardDefinitionCountAggregateOutputType> | number
          }
        }
      }
      BatchParameterValue: {
        payload: Prisma.$BatchParameterValuePayload<ExtArgs>
        fields: Prisma.BatchParameterValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchParameterValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchParameterValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>
          }
          findFirst: {
            args: Prisma.BatchParameterValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchParameterValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>
          }
          findMany: {
            args: Prisma.BatchParameterValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>[]
          }
          create: {
            args: Prisma.BatchParameterValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>
          }
          createMany: {
            args: Prisma.BatchParameterValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchParameterValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>[]
          }
          delete: {
            args: Prisma.BatchParameterValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>
          }
          update: {
            args: Prisma.BatchParameterValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>
          }
          deleteMany: {
            args: Prisma.BatchParameterValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchParameterValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchParameterValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>[]
          }
          upsert: {
            args: Prisma.BatchParameterValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>
          }
          aggregate: {
            args: Prisma.BatchParameterValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchParameterValue>
          }
          groupBy: {
            args: Prisma.BatchParameterValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchParameterValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchParameterValueCountArgs<ExtArgs>
            result: $Utils.Optional<BatchParameterValueCountAggregateOutputType> | number
          }
        }
      }
      TrainingCalendar: {
        payload: Prisma.$TrainingCalendarPayload<ExtArgs>
        fields: Prisma.TrainingCalendarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingCalendarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingCalendarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>
          }
          findFirst: {
            args: Prisma.TrainingCalendarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingCalendarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>
          }
          findMany: {
            args: Prisma.TrainingCalendarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>[]
          }
          create: {
            args: Prisma.TrainingCalendarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>
          }
          createMany: {
            args: Prisma.TrainingCalendarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingCalendarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>[]
          }
          delete: {
            args: Prisma.TrainingCalendarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>
          }
          update: {
            args: Prisma.TrainingCalendarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>
          }
          deleteMany: {
            args: Prisma.TrainingCalendarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingCalendarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingCalendarUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>[]
          }
          upsert: {
            args: Prisma.TrainingCalendarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>
          }
          aggregate: {
            args: Prisma.TrainingCalendarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingCalendar>
          }
          groupBy: {
            args: Prisma.TrainingCalendarGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingCalendarGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingCalendarCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingCalendarCountAggregateOutputType> | number
          }
        }
      }
      Training: {
        payload: Prisma.$TrainingPayload<ExtArgs>
        fields: Prisma.TrainingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          findFirst: {
            args: Prisma.TrainingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          findMany: {
            args: Prisma.TrainingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>[]
          }
          create: {
            args: Prisma.TrainingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          createMany: {
            args: Prisma.TrainingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>[]
          }
          delete: {
            args: Prisma.TrainingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          update: {
            args: Prisma.TrainingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>[]
          }
          upsert: {
            args: Prisma.TrainingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          aggregate: {
            args: Prisma.TrainingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTraining>
          }
          groupBy: {
            args: Prisma.TrainingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingCountAggregateOutputType> | number
          }
        }
      }
      TrainingSession: {
        payload: Prisma.$TrainingSessionPayload<ExtArgs>
        fields: Prisma.TrainingSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          findFirst: {
            args: Prisma.TrainingSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          findMany: {
            args: Prisma.TrainingSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>[]
          }
          create: {
            args: Prisma.TrainingSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          createMany: {
            args: Prisma.TrainingSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>[]
          }
          delete: {
            args: Prisma.TrainingSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          update: {
            args: Prisma.TrainingSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          deleteMany: {
            args: Prisma.TrainingSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>[]
          }
          upsert: {
            args: Prisma.TrainingSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          aggregate: {
            args: Prisma.TrainingSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingSession>
          }
          groupBy: {
            args: Prisma.TrainingSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingSessionCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingSessionCountAggregateOutputType> | number
          }
        }
      }
      TrainingDocument: {
        payload: Prisma.$TrainingDocumentPayload<ExtArgs>
        fields: Prisma.TrainingDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          findFirst: {
            args: Prisma.TrainingDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          findMany: {
            args: Prisma.TrainingDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>[]
          }
          create: {
            args: Prisma.TrainingDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          createMany: {
            args: Prisma.TrainingDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>[]
          }
          delete: {
            args: Prisma.TrainingDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          update: {
            args: Prisma.TrainingDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>[]
          }
          upsert: {
            args: Prisma.TrainingDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          aggregate: {
            args: Prisma.TrainingDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingDocument>
          }
          groupBy: {
            args: Prisma.TrainingDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingDocumentCountAggregateOutputType> | number
          }
        }
      }
      Participant: {
        payload: Prisma.$ParticipantPayload<ExtArgs>
        fields: Prisma.ParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          findFirst: {
            args: Prisma.ParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          findMany: {
            args: Prisma.ParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>[]
          }
          create: {
            args: Prisma.ParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          createMany: {
            args: Prisma.ParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>[]
          }
          delete: {
            args: Prisma.ParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          update: {
            args: Prisma.ParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          aggregate: {
            args: Prisma.ParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParticipant>
          }
          groupBy: {
            args: Prisma.ParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ParticipantCountAggregateOutputType> | number
          }
        }
      }
      TrainingParticipant: {
        payload: Prisma.$TrainingParticipantPayload<ExtArgs>
        fields: Prisma.TrainingParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>
          }
          findFirst: {
            args: Prisma.TrainingParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>
          }
          findMany: {
            args: Prisma.TrainingParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>[]
          }
          create: {
            args: Prisma.TrainingParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>
          }
          createMany: {
            args: Prisma.TrainingParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>[]
          }
          delete: {
            args: Prisma.TrainingParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>
          }
          update: {
            args: Prisma.TrainingParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>
          }
          deleteMany: {
            args: Prisma.TrainingParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>[]
          }
          upsert: {
            args: Prisma.TrainingParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>
          }
          aggregate: {
            args: Prisma.TrainingParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingParticipant>
          }
          groupBy: {
            args: Prisma.TrainingParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingParticipantCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      TrainingPhoto: {
        payload: Prisma.$TrainingPhotoPayload<ExtArgs>
        fields: Prisma.TrainingPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>
          }
          findFirst: {
            args: Prisma.TrainingPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>
          }
          findMany: {
            args: Prisma.TrainingPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>[]
          }
          create: {
            args: Prisma.TrainingPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>
          }
          createMany: {
            args: Prisma.TrainingPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>[]
          }
          delete: {
            args: Prisma.TrainingPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>
          }
          update: {
            args: Prisma.TrainingPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>
          }
          deleteMany: {
            args: Prisma.TrainingPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>[]
          }
          upsert: {
            args: Prisma.TrainingPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>
          }
          aggregate: {
            args: Prisma.TrainingPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingPhoto>
          }
          groupBy: {
            args: Prisma.TrainingPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingPhotoCountAggregateOutputType> | number
          }
        }
      }
      TrainingFeedback: {
        payload: Prisma.$TrainingFeedbackPayload<ExtArgs>
        fields: Prisma.TrainingFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>
          }
          findFirst: {
            args: Prisma.TrainingFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>
          }
          findMany: {
            args: Prisma.TrainingFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>[]
          }
          create: {
            args: Prisma.TrainingFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>
          }
          createMany: {
            args: Prisma.TrainingFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>[]
          }
          delete: {
            args: Prisma.TrainingFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>
          }
          update: {
            args: Prisma.TrainingFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.TrainingFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingFeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>[]
          }
          upsert: {
            args: Prisma.TrainingFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>
          }
          aggregate: {
            args: Prisma.TrainingFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingFeedback>
          }
          groupBy: {
            args: Prisma.TrainingFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingFeedbackCountAggregateOutputType> | number
          }
        }
      }
      FeedbackForm: {
        payload: Prisma.$FeedbackFormPayload<ExtArgs>
        fields: Prisma.FeedbackFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackFormPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackFormPayload>
          }
          findMany: {
            args: Prisma.FeedbackFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackFormPayload>[]
          }
          create: {
            args: Prisma.FeedbackFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackFormPayload>
          }
          createMany: {
            args: Prisma.FeedbackFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackFormPayload>[]
          }
          delete: {
            args: Prisma.FeedbackFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackFormPayload>
          }
          update: {
            args: Prisma.FeedbackFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackFormPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedbackFormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackFormPayload>[]
          }
          upsert: {
            args: Prisma.FeedbackFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackFormPayload>
          }
          aggregate: {
            args: Prisma.FeedbackFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedbackForm>
          }
          groupBy: {
            args: Prisma.FeedbackFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackFormCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackFormCountAggregateOutputType> | number
          }
        }
      }
      TrainingFollowup: {
        payload: Prisma.$TrainingFollowupPayload<ExtArgs>
        fields: Prisma.TrainingFollowupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingFollowupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingFollowupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>
          }
          findFirst: {
            args: Prisma.TrainingFollowupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingFollowupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>
          }
          findMany: {
            args: Prisma.TrainingFollowupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>[]
          }
          create: {
            args: Prisma.TrainingFollowupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>
          }
          createMany: {
            args: Prisma.TrainingFollowupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingFollowupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>[]
          }
          delete: {
            args: Prisma.TrainingFollowupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>
          }
          update: {
            args: Prisma.TrainingFollowupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>
          }
          deleteMany: {
            args: Prisma.TrainingFollowupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingFollowupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingFollowupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>[]
          }
          upsert: {
            args: Prisma.TrainingFollowupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>
          }
          aggregate: {
            args: Prisma.TrainingFollowupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingFollowup>
          }
          groupBy: {
            args: Prisma.TrainingFollowupGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingFollowupGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingFollowupCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingFollowupCountAggregateOutputType> | number
          }
        }
      }
      TrainingNotification: {
        payload: Prisma.$TrainingNotificationPayload<ExtArgs>
        fields: Prisma.TrainingNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>
          }
          findFirst: {
            args: Prisma.TrainingNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>
          }
          findMany: {
            args: Prisma.TrainingNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>[]
          }
          create: {
            args: Prisma.TrainingNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>
          }
          createMany: {
            args: Prisma.TrainingNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>[]
          }
          delete: {
            args: Prisma.TrainingNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>
          }
          update: {
            args: Prisma.TrainingNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>
          }
          deleteMany: {
            args: Prisma.TrainingNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>[]
          }
          upsert: {
            args: Prisma.TrainingNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>
          }
          aggregate: {
            args: Prisma.TrainingNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingNotification>
          }
          groupBy: {
            args: Prisma.TrainingNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingNotificationCountAggregateOutputType> | number
          }
        }
      }
      TrainingInviteToken: {
        payload: Prisma.$TrainingInviteTokenPayload<ExtArgs>
        fields: Prisma.TrainingInviteTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingInviteTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingInviteTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingInviteTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingInviteTokenPayload>
          }
          findFirst: {
            args: Prisma.TrainingInviteTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingInviteTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingInviteTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingInviteTokenPayload>
          }
          findMany: {
            args: Prisma.TrainingInviteTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingInviteTokenPayload>[]
          }
          create: {
            args: Prisma.TrainingInviteTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingInviteTokenPayload>
          }
          createMany: {
            args: Prisma.TrainingInviteTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingInviteTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingInviteTokenPayload>[]
          }
          delete: {
            args: Prisma.TrainingInviteTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingInviteTokenPayload>
          }
          update: {
            args: Prisma.TrainingInviteTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingInviteTokenPayload>
          }
          deleteMany: {
            args: Prisma.TrainingInviteTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingInviteTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingInviteTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingInviteTokenPayload>[]
          }
          upsert: {
            args: Prisma.TrainingInviteTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingInviteTokenPayload>
          }
          aggregate: {
            args: Prisma.TrainingInviteTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingInviteToken>
          }
          groupBy: {
            args: Prisma.TrainingInviteTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingInviteTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingInviteTokenCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingInviteTokenCountAggregateOutputType> | number
          }
        }
      }
      TrainingSessionPhoto: {
        payload: Prisma.$TrainingSessionPhotoPayload<ExtArgs>
        fields: Prisma.TrainingSessionPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingSessionPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingSessionPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPhotoPayload>
          }
          findFirst: {
            args: Prisma.TrainingSessionPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingSessionPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPhotoPayload>
          }
          findMany: {
            args: Prisma.TrainingSessionPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPhotoPayload>[]
          }
          create: {
            args: Prisma.TrainingSessionPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPhotoPayload>
          }
          createMany: {
            args: Prisma.TrainingSessionPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingSessionPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPhotoPayload>[]
          }
          delete: {
            args: Prisma.TrainingSessionPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPhotoPayload>
          }
          update: {
            args: Prisma.TrainingSessionPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPhotoPayload>
          }
          deleteMany: {
            args: Prisma.TrainingSessionPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingSessionPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingSessionPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPhotoPayload>[]
          }
          upsert: {
            args: Prisma.TrainingSessionPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPhotoPayload>
          }
          aggregate: {
            args: Prisma.TrainingSessionPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingSessionPhoto>
          }
          groupBy: {
            args: Prisma.TrainingSessionPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingSessionPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingSessionPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingSessionPhotoCountAggregateOutputType> | number
          }
        }
      }
      Auditor: {
        payload: Prisma.$AuditorPayload<ExtArgs>
        fields: Prisma.AuditorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditorPayload>
          }
          findFirst: {
            args: Prisma.AuditorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditorPayload>
          }
          findMany: {
            args: Prisma.AuditorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditorPayload>[]
          }
          create: {
            args: Prisma.AuditorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditorPayload>
          }
          createMany: {
            args: Prisma.AuditorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditorPayload>[]
          }
          delete: {
            args: Prisma.AuditorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditorPayload>
          }
          update: {
            args: Prisma.AuditorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditorPayload>
          }
          deleteMany: {
            args: Prisma.AuditorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditorPayload>[]
          }
          upsert: {
            args: Prisma.AuditorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditorPayload>
          }
          aggregate: {
            args: Prisma.AuditorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditor>
          }
          groupBy: {
            args: Prisma.AuditorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditorCountArgs<ExtArgs>
            result: $Utils.Optional<AuditorCountAggregateOutputType> | number
          }
        }
      }
      Audit: {
        payload: Prisma.$AuditPayload<ExtArgs>
        fields: Prisma.AuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          findFirst: {
            args: Prisma.AuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          findMany: {
            args: Prisma.AuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>[]
          }
          create: {
            args: Prisma.AuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          createMany: {
            args: Prisma.AuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>[]
          }
          delete: {
            args: Prisma.AuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          update: {
            args: Prisma.AuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          deleteMany: {
            args: Prisma.AuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>[]
          }
          upsert: {
            args: Prisma.AuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          aggregate: {
            args: Prisma.AuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit>
          }
          groupBy: {
            args: Prisma.AuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditCountArgs<ExtArgs>
            result: $Utils.Optional<AuditCountAggregateOutputType> | number
          }
        }
      }
      AuditInspectionItem: {
        payload: Prisma.$AuditInspectionItemPayload<ExtArgs>
        fields: Prisma.AuditInspectionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditInspectionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditInspectionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditInspectionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditInspectionItemPayload>
          }
          findFirst: {
            args: Prisma.AuditInspectionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditInspectionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditInspectionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditInspectionItemPayload>
          }
          findMany: {
            args: Prisma.AuditInspectionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditInspectionItemPayload>[]
          }
          create: {
            args: Prisma.AuditInspectionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditInspectionItemPayload>
          }
          createMany: {
            args: Prisma.AuditInspectionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditInspectionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditInspectionItemPayload>[]
          }
          delete: {
            args: Prisma.AuditInspectionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditInspectionItemPayload>
          }
          update: {
            args: Prisma.AuditInspectionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditInspectionItemPayload>
          }
          deleteMany: {
            args: Prisma.AuditInspectionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditInspectionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditInspectionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditInspectionItemPayload>[]
          }
          upsert: {
            args: Prisma.AuditInspectionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditInspectionItemPayload>
          }
          aggregate: {
            args: Prisma.AuditInspectionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditInspectionItem>
          }
          groupBy: {
            args: Prisma.AuditInspectionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditInspectionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditInspectionItemCountArgs<ExtArgs>
            result: $Utils.Optional<AuditInspectionItemCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Finding: {
        payload: Prisma.$FindingPayload<ExtArgs>
        fields: Prisma.FindingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FindingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FindingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FindingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>
          }
          findFirst: {
            args: Prisma.FindingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FindingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FindingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>
          }
          findMany: {
            args: Prisma.FindingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>[]
          }
          create: {
            args: Prisma.FindingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>
          }
          createMany: {
            args: Prisma.FindingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FindingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>[]
          }
          delete: {
            args: Prisma.FindingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>
          }
          update: {
            args: Prisma.FindingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>
          }
          deleteMany: {
            args: Prisma.FindingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FindingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FindingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>[]
          }
          upsert: {
            args: Prisma.FindingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FindingPayload>
          }
          aggregate: {
            args: Prisma.FindingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinding>
          }
          groupBy: {
            args: Prisma.FindingGroupByArgs<ExtArgs>
            result: $Utils.Optional<FindingGroupByOutputType>[]
          }
          count: {
            args: Prisma.FindingCountArgs<ExtArgs>
            result: $Utils.Optional<FindingCountAggregateOutputType> | number
          }
        }
      }
      CorrectiveAction: {
        payload: Prisma.$CorrectiveActionPayload<ExtArgs>
        fields: Prisma.CorrectiveActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CorrectiveActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrectiveActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CorrectiveActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrectiveActionPayload>
          }
          findFirst: {
            args: Prisma.CorrectiveActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrectiveActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CorrectiveActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrectiveActionPayload>
          }
          findMany: {
            args: Prisma.CorrectiveActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrectiveActionPayload>[]
          }
          create: {
            args: Prisma.CorrectiveActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrectiveActionPayload>
          }
          createMany: {
            args: Prisma.CorrectiveActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CorrectiveActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrectiveActionPayload>[]
          }
          delete: {
            args: Prisma.CorrectiveActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrectiveActionPayload>
          }
          update: {
            args: Prisma.CorrectiveActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrectiveActionPayload>
          }
          deleteMany: {
            args: Prisma.CorrectiveActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CorrectiveActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CorrectiveActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrectiveActionPayload>[]
          }
          upsert: {
            args: Prisma.CorrectiveActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrectiveActionPayload>
          }
          aggregate: {
            args: Prisma.CorrectiveActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCorrectiveAction>
          }
          groupBy: {
            args: Prisma.CorrectiveActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CorrectiveActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CorrectiveActionCountArgs<ExtArgs>
            result: $Utils.Optional<CorrectiveActionCountAggregateOutputType> | number
          }
        }
      }
      AuditDocument: {
        payload: Prisma.$AuditDocumentPayload<ExtArgs>
        fields: Prisma.AuditDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditDocumentPayload>
          }
          findFirst: {
            args: Prisma.AuditDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditDocumentPayload>
          }
          findMany: {
            args: Prisma.AuditDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditDocumentPayload>[]
          }
          create: {
            args: Prisma.AuditDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditDocumentPayload>
          }
          createMany: {
            args: Prisma.AuditDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditDocumentPayload>[]
          }
          delete: {
            args: Prisma.AuditDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditDocumentPayload>
          }
          update: {
            args: Prisma.AuditDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditDocumentPayload>
          }
          deleteMany: {
            args: Prisma.AuditDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditDocumentPayload>[]
          }
          upsert: {
            args: Prisma.AuditDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditDocumentPayload>
          }
          aggregate: {
            args: Prisma.AuditDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditDocument>
          }
          groupBy: {
            args: Prisma.AuditDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<AuditDocumentCountAggregateOutputType> | number
          }
        }
      }
      PreAuditChecklistItem: {
        payload: Prisma.$PreAuditChecklistItemPayload<ExtArgs>
        fields: Prisma.PreAuditChecklistItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreAuditChecklistItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreAuditChecklistItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreAuditChecklistItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreAuditChecklistItemPayload>
          }
          findFirst: {
            args: Prisma.PreAuditChecklistItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreAuditChecklistItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreAuditChecklistItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreAuditChecklistItemPayload>
          }
          findMany: {
            args: Prisma.PreAuditChecklistItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreAuditChecklistItemPayload>[]
          }
          create: {
            args: Prisma.PreAuditChecklistItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreAuditChecklistItemPayload>
          }
          createMany: {
            args: Prisma.PreAuditChecklistItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PreAuditChecklistItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreAuditChecklistItemPayload>[]
          }
          delete: {
            args: Prisma.PreAuditChecklistItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreAuditChecklistItemPayload>
          }
          update: {
            args: Prisma.PreAuditChecklistItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreAuditChecklistItemPayload>
          }
          deleteMany: {
            args: Prisma.PreAuditChecklistItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PreAuditChecklistItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PreAuditChecklistItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreAuditChecklistItemPayload>[]
          }
          upsert: {
            args: Prisma.PreAuditChecklistItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreAuditChecklistItemPayload>
          }
          aggregate: {
            args: Prisma.PreAuditChecklistItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreAuditChecklistItem>
          }
          groupBy: {
            args: Prisma.PreAuditChecklistItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreAuditChecklistItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreAuditChecklistItemCountArgs<ExtArgs>
            result: $Utils.Optional<PreAuditChecklistItemCountAggregateOutputType> | number
          }
        }
      }
      AuditReminder: {
        payload: Prisma.$AuditReminderPayload<ExtArgs>
        fields: Prisma.AuditReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditReminderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditReminderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditReminderPayload>
          }
          findFirst: {
            args: Prisma.AuditReminderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditReminderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditReminderPayload>
          }
          findMany: {
            args: Prisma.AuditReminderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditReminderPayload>[]
          }
          create: {
            args: Prisma.AuditReminderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditReminderPayload>
          }
          createMany: {
            args: Prisma.AuditReminderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditReminderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditReminderPayload>[]
          }
          delete: {
            args: Prisma.AuditReminderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditReminderPayload>
          }
          update: {
            args: Prisma.AuditReminderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditReminderPayload>
          }
          deleteMany: {
            args: Prisma.AuditReminderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditReminderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditReminderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditReminderPayload>[]
          }
          upsert: {
            args: Prisma.AuditReminderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditReminderPayload>
          }
          aggregate: {
            args: Prisma.AuditReminderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditReminder>
          }
          groupBy: {
            args: Prisma.AuditReminderGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditReminderCountArgs<ExtArgs>
            result: $Utils.Optional<AuditReminderCountAggregateOutputType> | number
          }
        }
      }
      AuditNotification: {
        payload: Prisma.$AuditNotificationPayload<ExtArgs>
        fields: Prisma.AuditNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditNotificationPayload>
          }
          findFirst: {
            args: Prisma.AuditNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditNotificationPayload>
          }
          findMany: {
            args: Prisma.AuditNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditNotificationPayload>[]
          }
          create: {
            args: Prisma.AuditNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditNotificationPayload>
          }
          createMany: {
            args: Prisma.AuditNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditNotificationPayload>[]
          }
          delete: {
            args: Prisma.AuditNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditNotificationPayload>
          }
          update: {
            args: Prisma.AuditNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditNotificationPayload>
          }
          deleteMany: {
            args: Prisma.AuditNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditNotificationPayload>[]
          }
          upsert: {
            args: Prisma.AuditNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditNotificationPayload>
          }
          aggregate: {
            args: Prisma.AuditNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditNotification>
          }
          groupBy: {
            args: Prisma.AuditNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<AuditNotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    activityLog?: ActivityLogOmit
    batch?: BatchOmit
    exportLog?: ExportLogOmit
    methodology?: MethodologyOmit
    notification?: NotificationOmit
    permission?: PermissionOmit
    product?: ProductOmit
    productParameter?: ProductParameterOmit
    role?: RoleOmit
    unitOfMeasurement?: UnitOfMeasurementOmit
    user?: UserOmit
    standard?: StandardOmit
    standardCategory?: StandardCategoryOmit
    productStandardCategory?: ProductStandardCategoryOmit
    standardParameter?: StandardParameterOmit
    standardDefinition?: StandardDefinitionOmit
    batchParameterValue?: BatchParameterValueOmit
    trainingCalendar?: TrainingCalendarOmit
    training?: TrainingOmit
    trainingSession?: TrainingSessionOmit
    trainingDocument?: TrainingDocumentOmit
    participant?: ParticipantOmit
    trainingParticipant?: TrainingParticipantOmit
    attendance?: AttendanceOmit
    trainingPhoto?: TrainingPhotoOmit
    trainingFeedback?: TrainingFeedbackOmit
    feedbackForm?: FeedbackFormOmit
    trainingFollowup?: TrainingFollowupOmit
    trainingNotification?: TrainingNotificationOmit
    trainingInviteToken?: TrainingInviteTokenOmit
    trainingSessionPhoto?: TrainingSessionPhotoOmit
    auditor?: AuditorOmit
    audit?: AuditOmit
    auditInspectionItem?: AuditInspectionItemOmit
    department?: DepartmentOmit
    finding?: FindingOmit
    correctiveAction?: CorrectiveActionOmit
    auditDocument?: AuditDocumentOmit
    preAuditChecklistItem?: PreAuditChecklistItemOmit
    auditReminder?: AuditReminderOmit
    auditNotification?: AuditNotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BatchCountOutputType
   */

  export type BatchCountOutputType = {
    ActivityLog: number
    Notification: number
    standards: number
    methodologies: number
    unitOfMeasurements: number
    parameterValues: number
  }

  export type BatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActivityLog?: boolean | BatchCountOutputTypeCountActivityLogArgs
    Notification?: boolean | BatchCountOutputTypeCountNotificationArgs
    standards?: boolean | BatchCountOutputTypeCountStandardsArgs
    methodologies?: boolean | BatchCountOutputTypeCountMethodologiesArgs
    unitOfMeasurements?: boolean | BatchCountOutputTypeCountUnitOfMeasurementsArgs
    parameterValues?: boolean | BatchCountOutputTypeCountParameterValuesArgs
  }

  // Custom InputTypes
  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCountOutputType
     */
    select?: BatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountMethodologiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MethodologyWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountUnitOfMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfMeasurementWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountParameterValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchParameterValueWhereInput
  }


  /**
   * Count Type MethodologyCountOutputType
   */

  export type MethodologyCountOutputType = {
    Standards: number
    batches: number
    batchParameterValues: number
    standardDefinitions: number
  }

  export type MethodologyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Standards?: boolean | MethodologyCountOutputTypeCountStandardsArgs
    batches?: boolean | MethodologyCountOutputTypeCountBatchesArgs
    batchParameterValues?: boolean | MethodologyCountOutputTypeCountBatchParameterValuesArgs
    standardDefinitions?: boolean | MethodologyCountOutputTypeCountStandardDefinitionsArgs
  }

  // Custom InputTypes
  /**
   * MethodologyCountOutputType without action
   */
  export type MethodologyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyCountOutputType
     */
    select?: MethodologyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MethodologyCountOutputType without action
   */
  export type MethodologyCountOutputTypeCountStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
  }

  /**
   * MethodologyCountOutputType without action
   */
  export type MethodologyCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * MethodologyCountOutputType without action
   */
  export type MethodologyCountOutputTypeCountBatchParameterValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchParameterValueWhereInput
  }

  /**
   * MethodologyCountOutputType without action
   */
  export type MethodologyCountOutputTypeCountStandardDefinitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardDefinitionWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    Role: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | PermissionCountOutputTypeCountRoleArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    Batch: number
    standardCategories: number
    parameters: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | ProductCountOutputTypeCountBatchArgs
    standardCategories?: boolean | ProductCountOutputTypeCountStandardCategoriesArgs
    parameters?: boolean | ProductCountOutputTypeCountParametersArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStandardCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStandardCategoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountParametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductParameterWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    User: number
    Permission: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | RoleCountOutputTypeCountUserArgs
    Permission?: boolean | RoleCountOutputTypeCountPermissionArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }


  /**
   * Count Type UnitOfMeasurementCountOutputType
   */

  export type UnitOfMeasurementCountOutputType = {
    Standards: number
    batchParameterValues: number
    standardParameters: number
    standardDefinitions: number
    batches: number
  }

  export type UnitOfMeasurementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Standards?: boolean | UnitOfMeasurementCountOutputTypeCountStandardsArgs
    batchParameterValues?: boolean | UnitOfMeasurementCountOutputTypeCountBatchParameterValuesArgs
    standardParameters?: boolean | UnitOfMeasurementCountOutputTypeCountStandardParametersArgs
    standardDefinitions?: boolean | UnitOfMeasurementCountOutputTypeCountStandardDefinitionsArgs
    batches?: boolean | UnitOfMeasurementCountOutputTypeCountBatchesArgs
  }

  // Custom InputTypes
  /**
   * UnitOfMeasurementCountOutputType without action
   */
  export type UnitOfMeasurementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurementCountOutputType
     */
    select?: UnitOfMeasurementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitOfMeasurementCountOutputType without action
   */
  export type UnitOfMeasurementCountOutputTypeCountStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
  }

  /**
   * UnitOfMeasurementCountOutputType without action
   */
  export type UnitOfMeasurementCountOutputTypeCountBatchParameterValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchParameterValueWhereInput
  }

  /**
   * UnitOfMeasurementCountOutputType without action
   */
  export type UnitOfMeasurementCountOutputTypeCountStandardParametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardParameterWhereInput
  }

  /**
   * UnitOfMeasurementCountOutputType without action
   */
  export type UnitOfMeasurementCountOutputTypeCountStandardDefinitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardDefinitionWhereInput
  }

  /**
   * UnitOfMeasurementCountOutputType without action
   */
  export type UnitOfMeasurementCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ActivityLog: number
    Batch_Batch_checkerIdToUser: number
    Batch_Batch_makerIdToUser: number
    Notification: number
    StandardsCreated: number
    StandardsModified: number
    standardDefinitionsCreated: number
    standardDefinitionsModified: number
    trainerTrainings: number
    createdTrainings: number
    uploadedDocuments: number
    uploadedPhotos: number
    assignedFollowups: number
    createdFollowups: number
    trainingNotifications: number
    auditeeAudits: number
    createdAudits: number
    assignedFindings: number
    assignedActions: number
    verifiedActions: number
    uploadedAuditDocuments: number
    createdReminders: number
    receivedReminders: number
    auditNotifications: number
    responsibleForChecklistItems: number
    createdChecklistItems: number
    inspectedItems: number
    uploadedFeedbackForms: number
    uploadedSessionPhotos: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActivityLog?: boolean | UserCountOutputTypeCountActivityLogArgs
    Batch_Batch_checkerIdToUser?: boolean | UserCountOutputTypeCountBatch_Batch_checkerIdToUserArgs
    Batch_Batch_makerIdToUser?: boolean | UserCountOutputTypeCountBatch_Batch_makerIdToUserArgs
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs
    StandardsCreated?: boolean | UserCountOutputTypeCountStandardsCreatedArgs
    StandardsModified?: boolean | UserCountOutputTypeCountStandardsModifiedArgs
    standardDefinitionsCreated?: boolean | UserCountOutputTypeCountStandardDefinitionsCreatedArgs
    standardDefinitionsModified?: boolean | UserCountOutputTypeCountStandardDefinitionsModifiedArgs
    trainerTrainings?: boolean | UserCountOutputTypeCountTrainerTrainingsArgs
    createdTrainings?: boolean | UserCountOutputTypeCountCreatedTrainingsArgs
    uploadedDocuments?: boolean | UserCountOutputTypeCountUploadedDocumentsArgs
    uploadedPhotos?: boolean | UserCountOutputTypeCountUploadedPhotosArgs
    assignedFollowups?: boolean | UserCountOutputTypeCountAssignedFollowupsArgs
    createdFollowups?: boolean | UserCountOutputTypeCountCreatedFollowupsArgs
    trainingNotifications?: boolean | UserCountOutputTypeCountTrainingNotificationsArgs
    auditeeAudits?: boolean | UserCountOutputTypeCountAuditeeAuditsArgs
    createdAudits?: boolean | UserCountOutputTypeCountCreatedAuditsArgs
    assignedFindings?: boolean | UserCountOutputTypeCountAssignedFindingsArgs
    assignedActions?: boolean | UserCountOutputTypeCountAssignedActionsArgs
    verifiedActions?: boolean | UserCountOutputTypeCountVerifiedActionsArgs
    uploadedAuditDocuments?: boolean | UserCountOutputTypeCountUploadedAuditDocumentsArgs
    createdReminders?: boolean | UserCountOutputTypeCountCreatedRemindersArgs
    receivedReminders?: boolean | UserCountOutputTypeCountReceivedRemindersArgs
    auditNotifications?: boolean | UserCountOutputTypeCountAuditNotificationsArgs
    responsibleForChecklistItems?: boolean | UserCountOutputTypeCountResponsibleForChecklistItemsArgs
    createdChecklistItems?: boolean | UserCountOutputTypeCountCreatedChecklistItemsArgs
    inspectedItems?: boolean | UserCountOutputTypeCountInspectedItemsArgs
    uploadedFeedbackForms?: boolean | UserCountOutputTypeCountUploadedFeedbackFormsArgs
    uploadedSessionPhotos?: boolean | UserCountOutputTypeCountUploadedSessionPhotosArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBatch_Batch_checkerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBatch_Batch_makerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStandardsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStandardsModifiedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStandardDefinitionsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardDefinitionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStandardDefinitionsModifiedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardDefinitionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrainerTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPhotoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFollowupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFollowupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrainingNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditeeAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedFindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FindingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorrectiveActionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerifiedActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorrectiveActionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedAuditDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditReminderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditReminderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResponsibleForChecklistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreAuditChecklistItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedChecklistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreAuditChecklistItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInspectedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditInspectionItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedFeedbackFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackFormWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedSessionPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingSessionPhotoWhereInput
  }


  /**
   * Count Type StandardCountOutputType
   */

  export type StandardCountOutputType = {
    batches: number
    methodologies: number
    units: number
  }

  export type StandardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | StandardCountOutputTypeCountBatchesArgs
    methodologies?: boolean | StandardCountOutputTypeCountMethodologiesArgs
    units?: boolean | StandardCountOutputTypeCountUnitsArgs
  }

  // Custom InputTypes
  /**
   * StandardCountOutputType without action
   */
  export type StandardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCountOutputType
     */
    select?: StandardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StandardCountOutputType without action
   */
  export type StandardCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * StandardCountOutputType without action
   */
  export type StandardCountOutputTypeCountMethodologiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MethodologyWhereInput
  }

  /**
   * StandardCountOutputType without action
   */
  export type StandardCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfMeasurementWhereInput
  }


  /**
   * Count Type StandardCategoryCountOutputType
   */

  export type StandardCategoryCountOutputType = {
    parameters: number
    Standards: number
    products: number
  }

  export type StandardCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameters?: boolean | StandardCategoryCountOutputTypeCountParametersArgs
    Standards?: boolean | StandardCategoryCountOutputTypeCountStandardsArgs
    products?: boolean | StandardCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * StandardCategoryCountOutputType without action
   */
  export type StandardCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategoryCountOutputType
     */
    select?: StandardCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StandardCategoryCountOutputType without action
   */
  export type StandardCategoryCountOutputTypeCountParametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardParameterWhereInput
  }

  /**
   * StandardCategoryCountOutputType without action
   */
  export type StandardCategoryCountOutputTypeCountStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
  }

  /**
   * StandardCategoryCountOutputType without action
   */
  export type StandardCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStandardCategoryWhereInput
  }


  /**
   * Count Type StandardParameterCountOutputType
   */

  export type StandardParameterCountOutputType = {
    batchValues: number
    standards: number
    products: number
  }

  export type StandardParameterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batchValues?: boolean | StandardParameterCountOutputTypeCountBatchValuesArgs
    standards?: boolean | StandardParameterCountOutputTypeCountStandardsArgs
    products?: boolean | StandardParameterCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * StandardParameterCountOutputType without action
   */
  export type StandardParameterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameterCountOutputType
     */
    select?: StandardParameterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StandardParameterCountOutputType without action
   */
  export type StandardParameterCountOutputTypeCountBatchValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchParameterValueWhereInput
  }

  /**
   * StandardParameterCountOutputType without action
   */
  export type StandardParameterCountOutputTypeCountStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardDefinitionWhereInput
  }

  /**
   * StandardParameterCountOutputType without action
   */
  export type StandardParameterCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductParameterWhereInput
  }


  /**
   * Count Type TrainingCalendarCountOutputType
   */

  export type TrainingCalendarCountOutputType = {
    trainings: number
  }

  export type TrainingCalendarCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | TrainingCalendarCountOutputTypeCountTrainingsArgs
  }

  // Custom InputTypes
  /**
   * TrainingCalendarCountOutputType without action
   */
  export type TrainingCalendarCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendarCountOutputType
     */
    select?: TrainingCalendarCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingCalendarCountOutputType without action
   */
  export type TrainingCalendarCountOutputTypeCountTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWhereInput
  }


  /**
   * Count Type TrainingCountOutputType
   */

  export type TrainingCountOutputType = {
    sessions: number
    documents: number
    attendance: number
    participants: number
    photos: number
    feedback: number
    followups: number
    notifications: number
    inviteTokens: number
    feedbackForms: number
  }

  export type TrainingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | TrainingCountOutputTypeCountSessionsArgs
    documents?: boolean | TrainingCountOutputTypeCountDocumentsArgs
    attendance?: boolean | TrainingCountOutputTypeCountAttendanceArgs
    participants?: boolean | TrainingCountOutputTypeCountParticipantsArgs
    photos?: boolean | TrainingCountOutputTypeCountPhotosArgs
    feedback?: boolean | TrainingCountOutputTypeCountFeedbackArgs
    followups?: boolean | TrainingCountOutputTypeCountFollowupsArgs
    notifications?: boolean | TrainingCountOutputTypeCountNotificationsArgs
    inviteTokens?: boolean | TrainingCountOutputTypeCountInviteTokensArgs
    feedbackForms?: boolean | TrainingCountOutputTypeCountFeedbackFormsArgs
  }

  // Custom InputTypes
  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCountOutputType
     */
    select?: TrainingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingSessionWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDocumentWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingParticipantWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPhotoWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFeedbackWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFollowupWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingNotificationWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountInviteTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingInviteTokenWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountFeedbackFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackFormWhereInput
  }


  /**
   * Count Type TrainingSessionCountOutputType
   */

  export type TrainingSessionCountOutputType = {
    attendance: number
    feedbackForms: number
    photos: number
  }

  export type TrainingSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | TrainingSessionCountOutputTypeCountAttendanceArgs
    feedbackForms?: boolean | TrainingSessionCountOutputTypeCountFeedbackFormsArgs
    photos?: boolean | TrainingSessionCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes
  /**
   * TrainingSessionCountOutputType without action
   */
  export type TrainingSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionCountOutputType
     */
    select?: TrainingSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingSessionCountOutputType without action
   */
  export type TrainingSessionCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * TrainingSessionCountOutputType without action
   */
  export type TrainingSessionCountOutputTypeCountFeedbackFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackFormWhereInput
  }

  /**
   * TrainingSessionCountOutputType without action
   */
  export type TrainingSessionCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingSessionPhotoWhereInput
  }


  /**
   * Count Type ParticipantCountOutputType
   */

  export type ParticipantCountOutputType = {
    trainings: number
    attendances: number
    feedbacks: number
    inviteTokens: number
    feedbackForms: number
  }

  export type ParticipantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | ParticipantCountOutputTypeCountTrainingsArgs
    attendances?: boolean | ParticipantCountOutputTypeCountAttendancesArgs
    feedbacks?: boolean | ParticipantCountOutputTypeCountFeedbacksArgs
    inviteTokens?: boolean | ParticipantCountOutputTypeCountInviteTokensArgs
    feedbackForms?: boolean | ParticipantCountOutputTypeCountFeedbackFormsArgs
  }

  // Custom InputTypes
  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantCountOutputType
     */
    select?: ParticipantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingParticipantWhereInput
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFeedbackWhereInput
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountInviteTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingInviteTokenWhereInput
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountFeedbackFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackFormWhereInput
  }


  /**
   * Count Type AuditorCountOutputType
   */

  export type AuditorCountOutputType = {
    audits: number
  }

  export type AuditorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audits?: boolean | AuditorCountOutputTypeCountAuditsArgs
  }

  // Custom InputTypes
  /**
   * AuditorCountOutputType without action
   */
  export type AuditorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditorCountOutputType
     */
    select?: AuditorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuditorCountOutputType without action
   */
  export type AuditorCountOutputTypeCountAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
  }


  /**
   * Count Type AuditCountOutputType
   */

  export type AuditCountOutputType = {
    findings: number
    documents: number
    actions: number
    reminders: number
    notifications: number
    checklistItems: number
    inspectionItems: number
  }

  export type AuditCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    findings?: boolean | AuditCountOutputTypeCountFindingsArgs
    documents?: boolean | AuditCountOutputTypeCountDocumentsArgs
    actions?: boolean | AuditCountOutputTypeCountActionsArgs
    reminders?: boolean | AuditCountOutputTypeCountRemindersArgs
    notifications?: boolean | AuditCountOutputTypeCountNotificationsArgs
    checklistItems?: boolean | AuditCountOutputTypeCountChecklistItemsArgs
    inspectionItems?: boolean | AuditCountOutputTypeCountInspectionItemsArgs
  }

  // Custom InputTypes
  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditCountOutputType
     */
    select?: AuditCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeCountFindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FindingWhereInput
  }

  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditDocumentWhereInput
  }

  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorrectiveActionWhereInput
  }

  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeCountRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditReminderWhereInput
  }

  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditNotificationWhereInput
  }

  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeCountChecklistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreAuditChecklistItemWhereInput
  }

  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeCountInspectionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditInspectionItemWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    audits: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audits?: boolean | DepartmentCountOutputTypeCountAuditsArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
  }


  /**
   * Count Type FindingCountOutputType
   */

  export type FindingCountOutputType = {
    actions: number
  }

  export type FindingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actions?: boolean | FindingCountOutputTypeCountActionsArgs
  }

  // Custom InputTypes
  /**
   * FindingCountOutputType without action
   */
  export type FindingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FindingCountOutputType
     */
    select?: FindingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FindingCountOutputType without action
   */
  export type FindingCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorrectiveActionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    batchId: string | null
    action: string | null
    details: string | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    batchId: string | null
    action: string | null
    details: string | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    batchId: number
    action: number
    details: number
    createdAt: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    batchId?: true
    action?: true
    details?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    batchId?: true
    action?: true
    details?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    batchId?: true
    action?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    userId: string
    batchId: string | null
    action: string
    details: string | null
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    batchId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    Batch?: boolean | ActivityLog$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    batchId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    Batch?: boolean | ActivityLog$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    batchId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    Batch?: boolean | ActivityLog$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    batchId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "batchId" | "action" | "details" | "createdAt", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | ActivityLog$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | ActivityLog$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | ActivityLog$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      Batch: Prisma.$BatchPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      batchId: string | null
      action: string
      details: string | null
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Batch<T extends ActivityLog$BatchArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$BatchArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly userId: FieldRef<"ActivityLog", 'String'>
    readonly batchId: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly details: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog.Batch
   */
  export type ActivityLog$BatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model Batch
   */

  export type AggregateBatch = {
    _count: BatchCountAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  export type BatchMinAggregateOutputType = {
    id: string | null
    batchNumber: string | null
    productId: string | null
    dateOfProduction: Date | null
    bestBeforeDate: Date | null
    sampleAnalysisStarted: Date | null
    sampleAnalysisCompleted: Date | null
    sampleAnalysisStatus: $Enums.SampleAnalysisStatus | null
    makerId: string | null
    checkerId: string | null
    status: $Enums.BatchStatus | null
    rejectionRemarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchMaxAggregateOutputType = {
    id: string | null
    batchNumber: string | null
    productId: string | null
    dateOfProduction: Date | null
    bestBeforeDate: Date | null
    sampleAnalysisStarted: Date | null
    sampleAnalysisCompleted: Date | null
    sampleAnalysisStatus: $Enums.SampleAnalysisStatus | null
    makerId: string | null
    checkerId: string | null
    status: $Enums.BatchStatus | null
    rejectionRemarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchCountAggregateOutputType = {
    id: number
    batchNumber: number
    productId: number
    dateOfProduction: number
    bestBeforeDate: number
    sampleAnalysisStarted: number
    sampleAnalysisCompleted: number
    sampleAnalysisStatus: number
    makerId: number
    checkerId: number
    status: number
    rejectionRemarks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BatchMinAggregateInputType = {
    id?: true
    batchNumber?: true
    productId?: true
    dateOfProduction?: true
    bestBeforeDate?: true
    sampleAnalysisStarted?: true
    sampleAnalysisCompleted?: true
    sampleAnalysisStatus?: true
    makerId?: true
    checkerId?: true
    status?: true
    rejectionRemarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchMaxAggregateInputType = {
    id?: true
    batchNumber?: true
    productId?: true
    dateOfProduction?: true
    bestBeforeDate?: true
    sampleAnalysisStarted?: true
    sampleAnalysisCompleted?: true
    sampleAnalysisStatus?: true
    makerId?: true
    checkerId?: true
    status?: true
    rejectionRemarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchCountAggregateInputType = {
    id?: true
    batchNumber?: true
    productId?: true
    dateOfProduction?: true
    bestBeforeDate?: true
    sampleAnalysisStarted?: true
    sampleAnalysisCompleted?: true
    sampleAnalysisStatus?: true
    makerId?: true
    checkerId?: true
    status?: true
    rejectionRemarks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batch to aggregate.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Batches
    **/
    _count?: true | BatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchMaxAggregateInputType
  }

  export type GetBatchAggregateType<T extends BatchAggregateArgs> = {
        [P in keyof T & keyof AggregateBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatch[P]>
      : GetScalarType<T[P], AggregateBatch[P]>
  }




  export type BatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithAggregationInput | BatchOrderByWithAggregationInput[]
    by: BatchScalarFieldEnum[] | BatchScalarFieldEnum
    having?: BatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchCountAggregateInputType | true
    _min?: BatchMinAggregateInputType
    _max?: BatchMaxAggregateInputType
  }

  export type BatchGroupByOutputType = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date
    bestBeforeDate: Date
    sampleAnalysisStarted: Date | null
    sampleAnalysisCompleted: Date | null
    sampleAnalysisStatus: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId: string | null
    status: $Enums.BatchStatus
    rejectionRemarks: string | null
    createdAt: Date
    updatedAt: Date
    _count: BatchCountAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  type GetBatchGroupByPayload<T extends BatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchGroupByOutputType[P]>
            : GetScalarType<T[P], BatchGroupByOutputType[P]>
        }
      >
    >


  export type BatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchNumber?: boolean
    productId?: boolean
    dateOfProduction?: boolean
    bestBeforeDate?: boolean
    sampleAnalysisStarted?: boolean
    sampleAnalysisCompleted?: boolean
    sampleAnalysisStatus?: boolean
    makerId?: boolean
    checkerId?: boolean
    status?: boolean
    rejectionRemarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ActivityLog?: boolean | Batch$ActivityLogArgs<ExtArgs>
    User_Batch_checkerIdToUser?: boolean | Batch$User_Batch_checkerIdToUserArgs<ExtArgs>
    User_Batch_makerIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    Notification?: boolean | Batch$NotificationArgs<ExtArgs>
    standards?: boolean | Batch$standardsArgs<ExtArgs>
    methodologies?: boolean | Batch$methodologiesArgs<ExtArgs>
    unitOfMeasurements?: boolean | Batch$unitOfMeasurementsArgs<ExtArgs>
    parameterValues?: boolean | Batch$parameterValuesArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchNumber?: boolean
    productId?: boolean
    dateOfProduction?: boolean
    bestBeforeDate?: boolean
    sampleAnalysisStarted?: boolean
    sampleAnalysisCompleted?: boolean
    sampleAnalysisStatus?: boolean
    makerId?: boolean
    checkerId?: boolean
    status?: boolean
    rejectionRemarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User_Batch_checkerIdToUser?: boolean | Batch$User_Batch_checkerIdToUserArgs<ExtArgs>
    User_Batch_makerIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchNumber?: boolean
    productId?: boolean
    dateOfProduction?: boolean
    bestBeforeDate?: boolean
    sampleAnalysisStarted?: boolean
    sampleAnalysisCompleted?: boolean
    sampleAnalysisStatus?: boolean
    makerId?: boolean
    checkerId?: boolean
    status?: boolean
    rejectionRemarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User_Batch_checkerIdToUser?: boolean | Batch$User_Batch_checkerIdToUserArgs<ExtArgs>
    User_Batch_makerIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectScalar = {
    id?: boolean
    batchNumber?: boolean
    productId?: boolean
    dateOfProduction?: boolean
    bestBeforeDate?: boolean
    sampleAnalysisStarted?: boolean
    sampleAnalysisCompleted?: boolean
    sampleAnalysisStatus?: boolean
    makerId?: boolean
    checkerId?: boolean
    status?: boolean
    rejectionRemarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "batchNumber" | "productId" | "dateOfProduction" | "bestBeforeDate" | "sampleAnalysisStarted" | "sampleAnalysisCompleted" | "sampleAnalysisStatus" | "makerId" | "checkerId" | "status" | "rejectionRemarks" | "createdAt" | "updatedAt", ExtArgs["result"]["batch"]>
  export type BatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActivityLog?: boolean | Batch$ActivityLogArgs<ExtArgs>
    User_Batch_checkerIdToUser?: boolean | Batch$User_Batch_checkerIdToUserArgs<ExtArgs>
    User_Batch_makerIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    Notification?: boolean | Batch$NotificationArgs<ExtArgs>
    standards?: boolean | Batch$standardsArgs<ExtArgs>
    methodologies?: boolean | Batch$methodologiesArgs<ExtArgs>
    unitOfMeasurements?: boolean | Batch$unitOfMeasurementsArgs<ExtArgs>
    parameterValues?: boolean | Batch$parameterValuesArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Batch_checkerIdToUser?: boolean | Batch$User_Batch_checkerIdToUserArgs<ExtArgs>
    User_Batch_makerIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type BatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Batch_checkerIdToUser?: boolean | Batch$User_Batch_checkerIdToUserArgs<ExtArgs>
    User_Batch_makerIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $BatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Batch"
    objects: {
      ActivityLog: Prisma.$ActivityLogPayload<ExtArgs>[]
      User_Batch_checkerIdToUser: Prisma.$UserPayload<ExtArgs> | null
      User_Batch_makerIdToUser: Prisma.$UserPayload<ExtArgs>
      Product: Prisma.$ProductPayload<ExtArgs>
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
      standards: Prisma.$StandardPayload<ExtArgs>[]
      methodologies: Prisma.$MethodologyPayload<ExtArgs>[]
      unitOfMeasurements: Prisma.$UnitOfMeasurementPayload<ExtArgs>[]
      parameterValues: Prisma.$BatchParameterValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      batchNumber: string
      productId: string
      dateOfProduction: Date
      bestBeforeDate: Date
      sampleAnalysisStarted: Date | null
      sampleAnalysisCompleted: Date | null
      sampleAnalysisStatus: $Enums.SampleAnalysisStatus
      makerId: string
      checkerId: string | null
      status: $Enums.BatchStatus
      rejectionRemarks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["batch"]>
    composites: {}
  }

  type BatchGetPayload<S extends boolean | null | undefined | BatchDefaultArgs> = $Result.GetResult<Prisma.$BatchPayload, S>

  type BatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchCountAggregateInputType | true
    }

  export interface BatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Batch'], meta: { name: 'Batch' } }
    /**
     * Find zero or one Batch that matches the filter.
     * @param {BatchFindUniqueArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchFindUniqueArgs>(args: SelectSubset<T, BatchFindUniqueArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Batch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchFindUniqueOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchFindFirstArgs>(args?: SelectSubset<T, BatchFindFirstArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Batches
     * const batches = await prisma.batch.findMany()
     * 
     * // Get first 10 Batches
     * const batches = await prisma.batch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchWithIdOnly = await prisma.batch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchFindManyArgs>(args?: SelectSubset<T, BatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Batch.
     * @param {BatchCreateArgs} args - Arguments to create a Batch.
     * @example
     * // Create one Batch
     * const Batch = await prisma.batch.create({
     *   data: {
     *     // ... data to create a Batch
     *   }
     * })
     * 
     */
    create<T extends BatchCreateArgs>(args: SelectSubset<T, BatchCreateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Batches.
     * @param {BatchCreateManyArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchCreateManyArgs>(args?: SelectSubset<T, BatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Batches and returns the data saved in the database.
     * @param {BatchCreateManyAndReturnArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Batch.
     * @param {BatchDeleteArgs} args - Arguments to delete one Batch.
     * @example
     * // Delete one Batch
     * const Batch = await prisma.batch.delete({
     *   where: {
     *     // ... filter to delete one Batch
     *   }
     * })
     * 
     */
    delete<T extends BatchDeleteArgs>(args: SelectSubset<T, BatchDeleteArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Batch.
     * @param {BatchUpdateArgs} args - Arguments to update one Batch.
     * @example
     * // Update one Batch
     * const batch = await prisma.batch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchUpdateArgs>(args: SelectSubset<T, BatchUpdateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Batches.
     * @param {BatchDeleteManyArgs} args - Arguments to filter Batches to delete.
     * @example
     * // Delete a few Batches
     * const { count } = await prisma.batch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchDeleteManyArgs>(args?: SelectSubset<T, BatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchUpdateManyArgs>(args: SelectSubset<T, BatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches and returns the data updated in the database.
     * @param {BatchUpdateManyAndReturnArgs} args - Arguments to update many Batches.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Batch.
     * @param {BatchUpsertArgs} args - Arguments to update or create a Batch.
     * @example
     * // Update or create a Batch
     * const batch = await prisma.batch.upsert({
     *   create: {
     *     // ... data to create a Batch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Batch we want to update
     *   }
     * })
     */
    upsert<T extends BatchUpsertArgs>(args: SelectSubset<T, BatchUpsertArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCountArgs} args - Arguments to filter Batches to count.
     * @example
     * // Count the number of Batches
     * const count = await prisma.batch.count({
     *   where: {
     *     // ... the filter for the Batches we want to count
     *   }
     * })
    **/
    count<T extends BatchCountArgs>(
      args?: Subset<T, BatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchAggregateArgs>(args: Subset<T, BatchAggregateArgs>): Prisma.PrismaPromise<GetBatchAggregateType<T>>

    /**
     * Group by Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchGroupByArgs['orderBy'] }
        : { orderBy?: BatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Batch model
   */
  readonly fields: BatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Batch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ActivityLog<T extends Batch$ActivityLogArgs<ExtArgs> = {}>(args?: Subset<T, Batch$ActivityLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User_Batch_checkerIdToUser<T extends Batch$User_Batch_checkerIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, Batch$User_Batch_checkerIdToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User_Batch_makerIdToUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Notification<T extends Batch$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, Batch$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standards<T extends Batch$standardsArgs<ExtArgs> = {}>(args?: Subset<T, Batch$standardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    methodologies<T extends Batch$methodologiesArgs<ExtArgs> = {}>(args?: Subset<T, Batch$methodologiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unitOfMeasurements<T extends Batch$unitOfMeasurementsArgs<ExtArgs> = {}>(args?: Subset<T, Batch$unitOfMeasurementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parameterValues<T extends Batch$parameterValuesArgs<ExtArgs> = {}>(args?: Subset<T, Batch$parameterValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Batch model
   */
  interface BatchFieldRefs {
    readonly id: FieldRef<"Batch", 'String'>
    readonly batchNumber: FieldRef<"Batch", 'String'>
    readonly productId: FieldRef<"Batch", 'String'>
    readonly dateOfProduction: FieldRef<"Batch", 'DateTime'>
    readonly bestBeforeDate: FieldRef<"Batch", 'DateTime'>
    readonly sampleAnalysisStarted: FieldRef<"Batch", 'DateTime'>
    readonly sampleAnalysisCompleted: FieldRef<"Batch", 'DateTime'>
    readonly sampleAnalysisStatus: FieldRef<"Batch", 'SampleAnalysisStatus'>
    readonly makerId: FieldRef<"Batch", 'String'>
    readonly checkerId: FieldRef<"Batch", 'String'>
    readonly status: FieldRef<"Batch", 'BatchStatus'>
    readonly rejectionRemarks: FieldRef<"Batch", 'String'>
    readonly createdAt: FieldRef<"Batch", 'DateTime'>
    readonly updatedAt: FieldRef<"Batch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Batch findUnique
   */
  export type BatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findUniqueOrThrow
   */
  export type BatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findFirst
   */
  export type BatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findFirstOrThrow
   */
  export type BatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findMany
   */
  export type BatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batches to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch create
   */
  export type BatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Batch.
     */
    data: XOR<BatchCreateInput, BatchUncheckedCreateInput>
  }

  /**
   * Batch createMany
   */
  export type BatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Batch createManyAndReturn
   */
  export type BatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Batch update
   */
  export type BatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Batch.
     */
    data: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
    /**
     * Choose, which Batch to update.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch updateMany
   */
  export type BatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
  }

  /**
   * Batch updateManyAndReturn
   */
  export type BatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Batch upsert
   */
  export type BatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Batch to update in case it exists.
     */
    where: BatchWhereUniqueInput
    /**
     * In case the Batch found by the `where` argument doesn't exist, create a new Batch with this data.
     */
    create: XOR<BatchCreateInput, BatchUncheckedCreateInput>
    /**
     * In case the Batch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
  }

  /**
   * Batch delete
   */
  export type BatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter which Batch to delete.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch deleteMany
   */
  export type BatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batches to delete
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to delete.
     */
    limit?: number
  }

  /**
   * Batch.ActivityLog
   */
  export type Batch$ActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Batch.User_Batch_checkerIdToUser
   */
  export type Batch$User_Batch_checkerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Batch.Notification
   */
  export type Batch$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Batch.standards
   */
  export type Batch$standardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    cursor?: StandardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * Batch.methodologies
   */
  export type Batch$methodologiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    where?: MethodologyWhereInput
    orderBy?: MethodologyOrderByWithRelationInput | MethodologyOrderByWithRelationInput[]
    cursor?: MethodologyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MethodologyScalarFieldEnum | MethodologyScalarFieldEnum[]
  }

  /**
   * Batch.unitOfMeasurements
   */
  export type Batch$unitOfMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    where?: UnitOfMeasurementWhereInput
    orderBy?: UnitOfMeasurementOrderByWithRelationInput | UnitOfMeasurementOrderByWithRelationInput[]
    cursor?: UnitOfMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitOfMeasurementScalarFieldEnum | UnitOfMeasurementScalarFieldEnum[]
  }

  /**
   * Batch.parameterValues
   */
  export type Batch$parameterValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    where?: BatchParameterValueWhereInput
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    cursor?: BatchParameterValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * Batch without action
   */
  export type BatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
  }


  /**
   * Model ExportLog
   */

  export type AggregateExportLog = {
    _count: ExportLogCountAggregateOutputType | null
    _min: ExportLogMinAggregateOutputType | null
    _max: ExportLogMaxAggregateOutputType | null
  }

  export type ExportLogMinAggregateOutputType = {
    id: string | null
    fileName: string | null
    exportType: string | null
    exportedBy: string | null
    exportedAt: Date | null
  }

  export type ExportLogMaxAggregateOutputType = {
    id: string | null
    fileName: string | null
    exportType: string | null
    exportedBy: string | null
    exportedAt: Date | null
  }

  export type ExportLogCountAggregateOutputType = {
    id: number
    fileName: number
    exportType: number
    exportedBy: number
    exportedAt: number
    _all: number
  }


  export type ExportLogMinAggregateInputType = {
    id?: true
    fileName?: true
    exportType?: true
    exportedBy?: true
    exportedAt?: true
  }

  export type ExportLogMaxAggregateInputType = {
    id?: true
    fileName?: true
    exportType?: true
    exportedBy?: true
    exportedAt?: true
  }

  export type ExportLogCountAggregateInputType = {
    id?: true
    fileName?: true
    exportType?: true
    exportedBy?: true
    exportedAt?: true
    _all?: true
  }

  export type ExportLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportLog to aggregate.
     */
    where?: ExportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportLogs to fetch.
     */
    orderBy?: ExportLogOrderByWithRelationInput | ExportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExportLogs
    **/
    _count?: true | ExportLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExportLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExportLogMaxAggregateInputType
  }

  export type GetExportLogAggregateType<T extends ExportLogAggregateArgs> = {
        [P in keyof T & keyof AggregateExportLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExportLog[P]>
      : GetScalarType<T[P], AggregateExportLog[P]>
  }




  export type ExportLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportLogWhereInput
    orderBy?: ExportLogOrderByWithAggregationInput | ExportLogOrderByWithAggregationInput[]
    by: ExportLogScalarFieldEnum[] | ExportLogScalarFieldEnum
    having?: ExportLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExportLogCountAggregateInputType | true
    _min?: ExportLogMinAggregateInputType
    _max?: ExportLogMaxAggregateInputType
  }

  export type ExportLogGroupByOutputType = {
    id: string
    fileName: string
    exportType: string
    exportedBy: string
    exportedAt: Date
    _count: ExportLogCountAggregateOutputType | null
    _min: ExportLogMinAggregateOutputType | null
    _max: ExportLogMaxAggregateOutputType | null
  }

  type GetExportLogGroupByPayload<T extends ExportLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExportLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExportLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExportLogGroupByOutputType[P]>
            : GetScalarType<T[P], ExportLogGroupByOutputType[P]>
        }
      >
    >


  export type ExportLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    exportType?: boolean
    exportedBy?: boolean
    exportedAt?: boolean
  }, ExtArgs["result"]["exportLog"]>

  export type ExportLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    exportType?: boolean
    exportedBy?: boolean
    exportedAt?: boolean
  }, ExtArgs["result"]["exportLog"]>

  export type ExportLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    exportType?: boolean
    exportedBy?: boolean
    exportedAt?: boolean
  }, ExtArgs["result"]["exportLog"]>

  export type ExportLogSelectScalar = {
    id?: boolean
    fileName?: boolean
    exportType?: boolean
    exportedBy?: boolean
    exportedAt?: boolean
  }

  export type ExportLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fileName" | "exportType" | "exportedBy" | "exportedAt", ExtArgs["result"]["exportLog"]>

  export type $ExportLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExportLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileName: string
      exportType: string
      exportedBy: string
      exportedAt: Date
    }, ExtArgs["result"]["exportLog"]>
    composites: {}
  }

  type ExportLogGetPayload<S extends boolean | null | undefined | ExportLogDefaultArgs> = $Result.GetResult<Prisma.$ExportLogPayload, S>

  type ExportLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExportLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExportLogCountAggregateInputType | true
    }

  export interface ExportLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExportLog'], meta: { name: 'ExportLog' } }
    /**
     * Find zero or one ExportLog that matches the filter.
     * @param {ExportLogFindUniqueArgs} args - Arguments to find a ExportLog
     * @example
     * // Get one ExportLog
     * const exportLog = await prisma.exportLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExportLogFindUniqueArgs>(args: SelectSubset<T, ExportLogFindUniqueArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExportLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExportLogFindUniqueOrThrowArgs} args - Arguments to find a ExportLog
     * @example
     * // Get one ExportLog
     * const exportLog = await prisma.exportLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExportLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ExportLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExportLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogFindFirstArgs} args - Arguments to find a ExportLog
     * @example
     * // Get one ExportLog
     * const exportLog = await prisma.exportLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExportLogFindFirstArgs>(args?: SelectSubset<T, ExportLogFindFirstArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExportLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogFindFirstOrThrowArgs} args - Arguments to find a ExportLog
     * @example
     * // Get one ExportLog
     * const exportLog = await prisma.exportLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExportLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ExportLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExportLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExportLogs
     * const exportLogs = await prisma.exportLog.findMany()
     * 
     * // Get first 10 ExportLogs
     * const exportLogs = await prisma.exportLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exportLogWithIdOnly = await prisma.exportLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExportLogFindManyArgs>(args?: SelectSubset<T, ExportLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExportLog.
     * @param {ExportLogCreateArgs} args - Arguments to create a ExportLog.
     * @example
     * // Create one ExportLog
     * const ExportLog = await prisma.exportLog.create({
     *   data: {
     *     // ... data to create a ExportLog
     *   }
     * })
     * 
     */
    create<T extends ExportLogCreateArgs>(args: SelectSubset<T, ExportLogCreateArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExportLogs.
     * @param {ExportLogCreateManyArgs} args - Arguments to create many ExportLogs.
     * @example
     * // Create many ExportLogs
     * const exportLog = await prisma.exportLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExportLogCreateManyArgs>(args?: SelectSubset<T, ExportLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExportLogs and returns the data saved in the database.
     * @param {ExportLogCreateManyAndReturnArgs} args - Arguments to create many ExportLogs.
     * @example
     * // Create many ExportLogs
     * const exportLog = await prisma.exportLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExportLogs and only return the `id`
     * const exportLogWithIdOnly = await prisma.exportLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExportLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ExportLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExportLog.
     * @param {ExportLogDeleteArgs} args - Arguments to delete one ExportLog.
     * @example
     * // Delete one ExportLog
     * const ExportLog = await prisma.exportLog.delete({
     *   where: {
     *     // ... filter to delete one ExportLog
     *   }
     * })
     * 
     */
    delete<T extends ExportLogDeleteArgs>(args: SelectSubset<T, ExportLogDeleteArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExportLog.
     * @param {ExportLogUpdateArgs} args - Arguments to update one ExportLog.
     * @example
     * // Update one ExportLog
     * const exportLog = await prisma.exportLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExportLogUpdateArgs>(args: SelectSubset<T, ExportLogUpdateArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExportLogs.
     * @param {ExportLogDeleteManyArgs} args - Arguments to filter ExportLogs to delete.
     * @example
     * // Delete a few ExportLogs
     * const { count } = await prisma.exportLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExportLogDeleteManyArgs>(args?: SelectSubset<T, ExportLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExportLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExportLogs
     * const exportLog = await prisma.exportLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExportLogUpdateManyArgs>(args: SelectSubset<T, ExportLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExportLogs and returns the data updated in the database.
     * @param {ExportLogUpdateManyAndReturnArgs} args - Arguments to update many ExportLogs.
     * @example
     * // Update many ExportLogs
     * const exportLog = await prisma.exportLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExportLogs and only return the `id`
     * const exportLogWithIdOnly = await prisma.exportLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExportLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ExportLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExportLog.
     * @param {ExportLogUpsertArgs} args - Arguments to update or create a ExportLog.
     * @example
     * // Update or create a ExportLog
     * const exportLog = await prisma.exportLog.upsert({
     *   create: {
     *     // ... data to create a ExportLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExportLog we want to update
     *   }
     * })
     */
    upsert<T extends ExportLogUpsertArgs>(args: SelectSubset<T, ExportLogUpsertArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExportLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogCountArgs} args - Arguments to filter ExportLogs to count.
     * @example
     * // Count the number of ExportLogs
     * const count = await prisma.exportLog.count({
     *   where: {
     *     // ... the filter for the ExportLogs we want to count
     *   }
     * })
    **/
    count<T extends ExportLogCountArgs>(
      args?: Subset<T, ExportLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExportLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExportLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExportLogAggregateArgs>(args: Subset<T, ExportLogAggregateArgs>): Prisma.PrismaPromise<GetExportLogAggregateType<T>>

    /**
     * Group by ExportLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExportLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExportLogGroupByArgs['orderBy'] }
        : { orderBy?: ExportLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExportLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExportLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExportLog model
   */
  readonly fields: ExportLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExportLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExportLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExportLog model
   */
  interface ExportLogFieldRefs {
    readonly id: FieldRef<"ExportLog", 'String'>
    readonly fileName: FieldRef<"ExportLog", 'String'>
    readonly exportType: FieldRef<"ExportLog", 'String'>
    readonly exportedBy: FieldRef<"ExportLog", 'String'>
    readonly exportedAt: FieldRef<"ExportLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExportLog findUnique
   */
  export type ExportLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * Filter, which ExportLog to fetch.
     */
    where: ExportLogWhereUniqueInput
  }

  /**
   * ExportLog findUniqueOrThrow
   */
  export type ExportLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * Filter, which ExportLog to fetch.
     */
    where: ExportLogWhereUniqueInput
  }

  /**
   * ExportLog findFirst
   */
  export type ExportLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * Filter, which ExportLog to fetch.
     */
    where?: ExportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportLogs to fetch.
     */
    orderBy?: ExportLogOrderByWithRelationInput | ExportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportLogs.
     */
    cursor?: ExportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportLogs.
     */
    distinct?: ExportLogScalarFieldEnum | ExportLogScalarFieldEnum[]
  }

  /**
   * ExportLog findFirstOrThrow
   */
  export type ExportLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * Filter, which ExportLog to fetch.
     */
    where?: ExportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportLogs to fetch.
     */
    orderBy?: ExportLogOrderByWithRelationInput | ExportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportLogs.
     */
    cursor?: ExportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportLogs.
     */
    distinct?: ExportLogScalarFieldEnum | ExportLogScalarFieldEnum[]
  }

  /**
   * ExportLog findMany
   */
  export type ExportLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * Filter, which ExportLogs to fetch.
     */
    where?: ExportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportLogs to fetch.
     */
    orderBy?: ExportLogOrderByWithRelationInput | ExportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExportLogs.
     */
    cursor?: ExportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportLogs.
     */
    skip?: number
    distinct?: ExportLogScalarFieldEnum | ExportLogScalarFieldEnum[]
  }

  /**
   * ExportLog create
   */
  export type ExportLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * The data needed to create a ExportLog.
     */
    data: XOR<ExportLogCreateInput, ExportLogUncheckedCreateInput>
  }

  /**
   * ExportLog createMany
   */
  export type ExportLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExportLogs.
     */
    data: ExportLogCreateManyInput | ExportLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExportLog createManyAndReturn
   */
  export type ExportLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * The data used to create many ExportLogs.
     */
    data: ExportLogCreateManyInput | ExportLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExportLog update
   */
  export type ExportLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * The data needed to update a ExportLog.
     */
    data: XOR<ExportLogUpdateInput, ExportLogUncheckedUpdateInput>
    /**
     * Choose, which ExportLog to update.
     */
    where: ExportLogWhereUniqueInput
  }

  /**
   * ExportLog updateMany
   */
  export type ExportLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExportLogs.
     */
    data: XOR<ExportLogUpdateManyMutationInput, ExportLogUncheckedUpdateManyInput>
    /**
     * Filter which ExportLogs to update
     */
    where?: ExportLogWhereInput
    /**
     * Limit how many ExportLogs to update.
     */
    limit?: number
  }

  /**
   * ExportLog updateManyAndReturn
   */
  export type ExportLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * The data used to update ExportLogs.
     */
    data: XOR<ExportLogUpdateManyMutationInput, ExportLogUncheckedUpdateManyInput>
    /**
     * Filter which ExportLogs to update
     */
    where?: ExportLogWhereInput
    /**
     * Limit how many ExportLogs to update.
     */
    limit?: number
  }

  /**
   * ExportLog upsert
   */
  export type ExportLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * The filter to search for the ExportLog to update in case it exists.
     */
    where: ExportLogWhereUniqueInput
    /**
     * In case the ExportLog found by the `where` argument doesn't exist, create a new ExportLog with this data.
     */
    create: XOR<ExportLogCreateInput, ExportLogUncheckedCreateInput>
    /**
     * In case the ExportLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExportLogUpdateInput, ExportLogUncheckedUpdateInput>
  }

  /**
   * ExportLog delete
   */
  export type ExportLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * Filter which ExportLog to delete.
     */
    where: ExportLogWhereUniqueInput
  }

  /**
   * ExportLog deleteMany
   */
  export type ExportLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportLogs to delete
     */
    where?: ExportLogWhereInput
    /**
     * Limit how many ExportLogs to delete.
     */
    limit?: number
  }

  /**
   * ExportLog without action
   */
  export type ExportLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
  }


  /**
   * Model Methodology
   */

  export type AggregateMethodology = {
    _count: MethodologyCountAggregateOutputType | null
    _min: MethodologyMinAggregateOutputType | null
    _max: MethodologyMaxAggregateOutputType | null
  }

  export type MethodologyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    procedure: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MethodologyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    procedure: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MethodologyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    procedure: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MethodologyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    procedure?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MethodologyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    procedure?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MethodologyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    procedure?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MethodologyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Methodology to aggregate.
     */
    where?: MethodologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Methodologies to fetch.
     */
    orderBy?: MethodologyOrderByWithRelationInput | MethodologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MethodologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Methodologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Methodologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Methodologies
    **/
    _count?: true | MethodologyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MethodologyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MethodologyMaxAggregateInputType
  }

  export type GetMethodologyAggregateType<T extends MethodologyAggregateArgs> = {
        [P in keyof T & keyof AggregateMethodology]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMethodology[P]>
      : GetScalarType<T[P], AggregateMethodology[P]>
  }




  export type MethodologyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MethodologyWhereInput
    orderBy?: MethodologyOrderByWithAggregationInput | MethodologyOrderByWithAggregationInput[]
    by: MethodologyScalarFieldEnum[] | MethodologyScalarFieldEnum
    having?: MethodologyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MethodologyCountAggregateInputType | true
    _min?: MethodologyMinAggregateInputType
    _max?: MethodologyMaxAggregateInputType
  }

  export type MethodologyGroupByOutputType = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt: Date
    updatedAt: Date
    _count: MethodologyCountAggregateOutputType | null
    _min: MethodologyMinAggregateOutputType | null
    _max: MethodologyMaxAggregateOutputType | null
  }

  type GetMethodologyGroupByPayload<T extends MethodologyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MethodologyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MethodologyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MethodologyGroupByOutputType[P]>
            : GetScalarType<T[P], MethodologyGroupByOutputType[P]>
        }
      >
    >


  export type MethodologySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    procedure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Standards?: boolean | Methodology$StandardsArgs<ExtArgs>
    batches?: boolean | Methodology$batchesArgs<ExtArgs>
    batchParameterValues?: boolean | Methodology$batchParameterValuesArgs<ExtArgs>
    standardDefinitions?: boolean | Methodology$standardDefinitionsArgs<ExtArgs>
    _count?: boolean | MethodologyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["methodology"]>

  export type MethodologySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    procedure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["methodology"]>

  export type MethodologySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    procedure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["methodology"]>

  export type MethodologySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    procedure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MethodologyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "procedure" | "createdAt" | "updatedAt", ExtArgs["result"]["methodology"]>
  export type MethodologyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Standards?: boolean | Methodology$StandardsArgs<ExtArgs>
    batches?: boolean | Methodology$batchesArgs<ExtArgs>
    batchParameterValues?: boolean | Methodology$batchParameterValuesArgs<ExtArgs>
    standardDefinitions?: boolean | Methodology$standardDefinitionsArgs<ExtArgs>
    _count?: boolean | MethodologyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MethodologyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MethodologyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MethodologyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Methodology"
    objects: {
      Standards: Prisma.$StandardPayload<ExtArgs>[]
      batches: Prisma.$BatchPayload<ExtArgs>[]
      batchParameterValues: Prisma.$BatchParameterValuePayload<ExtArgs>[]
      standardDefinitions: Prisma.$StandardDefinitionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      procedure: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["methodology"]>
    composites: {}
  }

  type MethodologyGetPayload<S extends boolean | null | undefined | MethodologyDefaultArgs> = $Result.GetResult<Prisma.$MethodologyPayload, S>

  type MethodologyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MethodologyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MethodologyCountAggregateInputType | true
    }

  export interface MethodologyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Methodology'], meta: { name: 'Methodology' } }
    /**
     * Find zero or one Methodology that matches the filter.
     * @param {MethodologyFindUniqueArgs} args - Arguments to find a Methodology
     * @example
     * // Get one Methodology
     * const methodology = await prisma.methodology.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MethodologyFindUniqueArgs>(args: SelectSubset<T, MethodologyFindUniqueArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Methodology that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MethodologyFindUniqueOrThrowArgs} args - Arguments to find a Methodology
     * @example
     * // Get one Methodology
     * const methodology = await prisma.methodology.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MethodologyFindUniqueOrThrowArgs>(args: SelectSubset<T, MethodologyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Methodology that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyFindFirstArgs} args - Arguments to find a Methodology
     * @example
     * // Get one Methodology
     * const methodology = await prisma.methodology.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MethodologyFindFirstArgs>(args?: SelectSubset<T, MethodologyFindFirstArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Methodology that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyFindFirstOrThrowArgs} args - Arguments to find a Methodology
     * @example
     * // Get one Methodology
     * const methodology = await prisma.methodology.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MethodologyFindFirstOrThrowArgs>(args?: SelectSubset<T, MethodologyFindFirstOrThrowArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Methodologies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Methodologies
     * const methodologies = await prisma.methodology.findMany()
     * 
     * // Get first 10 Methodologies
     * const methodologies = await prisma.methodology.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const methodologyWithIdOnly = await prisma.methodology.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MethodologyFindManyArgs>(args?: SelectSubset<T, MethodologyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Methodology.
     * @param {MethodologyCreateArgs} args - Arguments to create a Methodology.
     * @example
     * // Create one Methodology
     * const Methodology = await prisma.methodology.create({
     *   data: {
     *     // ... data to create a Methodology
     *   }
     * })
     * 
     */
    create<T extends MethodologyCreateArgs>(args: SelectSubset<T, MethodologyCreateArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Methodologies.
     * @param {MethodologyCreateManyArgs} args - Arguments to create many Methodologies.
     * @example
     * // Create many Methodologies
     * const methodology = await prisma.methodology.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MethodologyCreateManyArgs>(args?: SelectSubset<T, MethodologyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Methodologies and returns the data saved in the database.
     * @param {MethodologyCreateManyAndReturnArgs} args - Arguments to create many Methodologies.
     * @example
     * // Create many Methodologies
     * const methodology = await prisma.methodology.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Methodologies and only return the `id`
     * const methodologyWithIdOnly = await prisma.methodology.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MethodologyCreateManyAndReturnArgs>(args?: SelectSubset<T, MethodologyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Methodology.
     * @param {MethodologyDeleteArgs} args - Arguments to delete one Methodology.
     * @example
     * // Delete one Methodology
     * const Methodology = await prisma.methodology.delete({
     *   where: {
     *     // ... filter to delete one Methodology
     *   }
     * })
     * 
     */
    delete<T extends MethodologyDeleteArgs>(args: SelectSubset<T, MethodologyDeleteArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Methodology.
     * @param {MethodologyUpdateArgs} args - Arguments to update one Methodology.
     * @example
     * // Update one Methodology
     * const methodology = await prisma.methodology.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MethodologyUpdateArgs>(args: SelectSubset<T, MethodologyUpdateArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Methodologies.
     * @param {MethodologyDeleteManyArgs} args - Arguments to filter Methodologies to delete.
     * @example
     * // Delete a few Methodologies
     * const { count } = await prisma.methodology.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MethodologyDeleteManyArgs>(args?: SelectSubset<T, MethodologyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Methodologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Methodologies
     * const methodology = await prisma.methodology.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MethodologyUpdateManyArgs>(args: SelectSubset<T, MethodologyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Methodologies and returns the data updated in the database.
     * @param {MethodologyUpdateManyAndReturnArgs} args - Arguments to update many Methodologies.
     * @example
     * // Update many Methodologies
     * const methodology = await prisma.methodology.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Methodologies and only return the `id`
     * const methodologyWithIdOnly = await prisma.methodology.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MethodologyUpdateManyAndReturnArgs>(args: SelectSubset<T, MethodologyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Methodology.
     * @param {MethodologyUpsertArgs} args - Arguments to update or create a Methodology.
     * @example
     * // Update or create a Methodology
     * const methodology = await prisma.methodology.upsert({
     *   create: {
     *     // ... data to create a Methodology
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Methodology we want to update
     *   }
     * })
     */
    upsert<T extends MethodologyUpsertArgs>(args: SelectSubset<T, MethodologyUpsertArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Methodologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyCountArgs} args - Arguments to filter Methodologies to count.
     * @example
     * // Count the number of Methodologies
     * const count = await prisma.methodology.count({
     *   where: {
     *     // ... the filter for the Methodologies we want to count
     *   }
     * })
    **/
    count<T extends MethodologyCountArgs>(
      args?: Subset<T, MethodologyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MethodologyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Methodology.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MethodologyAggregateArgs>(args: Subset<T, MethodologyAggregateArgs>): Prisma.PrismaPromise<GetMethodologyAggregateType<T>>

    /**
     * Group by Methodology.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MethodologyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MethodologyGroupByArgs['orderBy'] }
        : { orderBy?: MethodologyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MethodologyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMethodologyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Methodology model
   */
  readonly fields: MethodologyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Methodology.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MethodologyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Standards<T extends Methodology$StandardsArgs<ExtArgs> = {}>(args?: Subset<T, Methodology$StandardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    batches<T extends Methodology$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Methodology$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    batchParameterValues<T extends Methodology$batchParameterValuesArgs<ExtArgs> = {}>(args?: Subset<T, Methodology$batchParameterValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standardDefinitions<T extends Methodology$standardDefinitionsArgs<ExtArgs> = {}>(args?: Subset<T, Methodology$standardDefinitionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Methodology model
   */
  interface MethodologyFieldRefs {
    readonly id: FieldRef<"Methodology", 'String'>
    readonly name: FieldRef<"Methodology", 'String'>
    readonly description: FieldRef<"Methodology", 'String'>
    readonly procedure: FieldRef<"Methodology", 'String'>
    readonly createdAt: FieldRef<"Methodology", 'DateTime'>
    readonly updatedAt: FieldRef<"Methodology", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Methodology findUnique
   */
  export type MethodologyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * Filter, which Methodology to fetch.
     */
    where: MethodologyWhereUniqueInput
  }

  /**
   * Methodology findUniqueOrThrow
   */
  export type MethodologyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * Filter, which Methodology to fetch.
     */
    where: MethodologyWhereUniqueInput
  }

  /**
   * Methodology findFirst
   */
  export type MethodologyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * Filter, which Methodology to fetch.
     */
    where?: MethodologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Methodologies to fetch.
     */
    orderBy?: MethodologyOrderByWithRelationInput | MethodologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Methodologies.
     */
    cursor?: MethodologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Methodologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Methodologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Methodologies.
     */
    distinct?: MethodologyScalarFieldEnum | MethodologyScalarFieldEnum[]
  }

  /**
   * Methodology findFirstOrThrow
   */
  export type MethodologyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * Filter, which Methodology to fetch.
     */
    where?: MethodologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Methodologies to fetch.
     */
    orderBy?: MethodologyOrderByWithRelationInput | MethodologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Methodologies.
     */
    cursor?: MethodologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Methodologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Methodologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Methodologies.
     */
    distinct?: MethodologyScalarFieldEnum | MethodologyScalarFieldEnum[]
  }

  /**
   * Methodology findMany
   */
  export type MethodologyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * Filter, which Methodologies to fetch.
     */
    where?: MethodologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Methodologies to fetch.
     */
    orderBy?: MethodologyOrderByWithRelationInput | MethodologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Methodologies.
     */
    cursor?: MethodologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Methodologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Methodologies.
     */
    skip?: number
    distinct?: MethodologyScalarFieldEnum | MethodologyScalarFieldEnum[]
  }

  /**
   * Methodology create
   */
  export type MethodologyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * The data needed to create a Methodology.
     */
    data: XOR<MethodologyCreateInput, MethodologyUncheckedCreateInput>
  }

  /**
   * Methodology createMany
   */
  export type MethodologyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Methodologies.
     */
    data: MethodologyCreateManyInput | MethodologyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Methodology createManyAndReturn
   */
  export type MethodologyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * The data used to create many Methodologies.
     */
    data: MethodologyCreateManyInput | MethodologyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Methodology update
   */
  export type MethodologyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * The data needed to update a Methodology.
     */
    data: XOR<MethodologyUpdateInput, MethodologyUncheckedUpdateInput>
    /**
     * Choose, which Methodology to update.
     */
    where: MethodologyWhereUniqueInput
  }

  /**
   * Methodology updateMany
   */
  export type MethodologyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Methodologies.
     */
    data: XOR<MethodologyUpdateManyMutationInput, MethodologyUncheckedUpdateManyInput>
    /**
     * Filter which Methodologies to update
     */
    where?: MethodologyWhereInput
    /**
     * Limit how many Methodologies to update.
     */
    limit?: number
  }

  /**
   * Methodology updateManyAndReturn
   */
  export type MethodologyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * The data used to update Methodologies.
     */
    data: XOR<MethodologyUpdateManyMutationInput, MethodologyUncheckedUpdateManyInput>
    /**
     * Filter which Methodologies to update
     */
    where?: MethodologyWhereInput
    /**
     * Limit how many Methodologies to update.
     */
    limit?: number
  }

  /**
   * Methodology upsert
   */
  export type MethodologyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * The filter to search for the Methodology to update in case it exists.
     */
    where: MethodologyWhereUniqueInput
    /**
     * In case the Methodology found by the `where` argument doesn't exist, create a new Methodology with this data.
     */
    create: XOR<MethodologyCreateInput, MethodologyUncheckedCreateInput>
    /**
     * In case the Methodology was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MethodologyUpdateInput, MethodologyUncheckedUpdateInput>
  }

  /**
   * Methodology delete
   */
  export type MethodologyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * Filter which Methodology to delete.
     */
    where: MethodologyWhereUniqueInput
  }

  /**
   * Methodology deleteMany
   */
  export type MethodologyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Methodologies to delete
     */
    where?: MethodologyWhereInput
    /**
     * Limit how many Methodologies to delete.
     */
    limit?: number
  }

  /**
   * Methodology.Standards
   */
  export type Methodology$StandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    cursor?: StandardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * Methodology.batches
   */
  export type Methodology$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Methodology.batchParameterValues
   */
  export type Methodology$batchParameterValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    where?: BatchParameterValueWhereInput
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    cursor?: BatchParameterValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * Methodology.standardDefinitions
   */
  export type Methodology$standardDefinitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    where?: StandardDefinitionWhereInput
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    cursor?: StandardDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * Methodology without action
   */
  export type MethodologyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    batchId: string | null
    message: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    batchId: string | null
    message: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    batchId: number
    message: number
    type: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    batchId?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    batchId?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    batchId?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    batchId: string | null
    message: string
    type: $Enums.NotificationType
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    batchId?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    Batch?: boolean | Notification$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    batchId?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    Batch?: boolean | Notification$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    batchId?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    Batch?: boolean | Notification$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    batchId?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "batchId" | "message" | "type" | "isRead" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | Notification$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | Notification$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | Notification$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      Batch: Prisma.$BatchPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      batchId: string | null
      message: string
      type: $Enums.NotificationType
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Batch<T extends Notification$BatchArgs<ExtArgs> = {}>(args?: Subset<T, Notification$BatchArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly batchId: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.Batch
   */
  export type Notification$BatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    action: string | null
    resource: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    action: string | null
    resource: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    action: number
    resource: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    action?: true
    resource?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    action?: true
    resource?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    action?: true
    resource?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    action: string
    resource: string
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    resource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Role?: boolean | Permission$RoleArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    resource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    resource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    action?: boolean
    resource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "resource" | "createdAt" | "updatedAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | Permission$RoleArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      Role: Prisma.$RolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      resource: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Role<T extends Permission$RoleArgs<ExtArgs> = {}>(args?: Subset<T, Permission$RoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly resource: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.Role
   */
  export type Permission$RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    code: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    code: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Batch?: boolean | Product$BatchArgs<ExtArgs>
    standardCategories?: boolean | Product$standardCategoriesArgs<ExtArgs>
    parameters?: boolean | Product$parametersArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | Product$BatchArgs<ExtArgs>
    standardCategories?: boolean | Product$standardCategoriesArgs<ExtArgs>
    parameters?: boolean | Product$parametersArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      Batch: Prisma.$BatchPayload<ExtArgs>[]
      standardCategories: Prisma.$ProductStandardCategoryPayload<ExtArgs>[]
      parameters: Prisma.$ProductParameterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Batch<T extends Product$BatchArgs<ExtArgs> = {}>(args?: Subset<T, Product$BatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standardCategories<T extends Product$standardCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Product$standardCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStandardCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parameters<T extends Product$parametersArgs<ExtArgs> = {}>(args?: Subset<T, Product$parametersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly code: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.Batch
   */
  export type Product$BatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Product.standardCategories
   */
  export type Product$standardCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryInclude<ExtArgs> | null
    where?: ProductStandardCategoryWhereInput
    orderBy?: ProductStandardCategoryOrderByWithRelationInput | ProductStandardCategoryOrderByWithRelationInput[]
    cursor?: ProductStandardCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductStandardCategoryScalarFieldEnum | ProductStandardCategoryScalarFieldEnum[]
  }

  /**
   * Product.parameters
   */
  export type Product$parametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterInclude<ExtArgs> | null
    where?: ProductParameterWhereInput
    orderBy?: ProductParameterOrderByWithRelationInput | ProductParameterOrderByWithRelationInput[]
    cursor?: ProductParameterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductParameterScalarFieldEnum | ProductParameterScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductParameter
   */

  export type AggregateProductParameter = {
    _count: ProductParameterCountAggregateOutputType | null
    _min: ProductParameterMinAggregateOutputType | null
    _max: ProductParameterMaxAggregateOutputType | null
  }

  export type ProductParameterMinAggregateOutputType = {
    id: string | null
    productId: string | null
    parameterId: string | null
    isRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductParameterMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    parameterId: string | null
    isRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductParameterCountAggregateOutputType = {
    id: number
    productId: number
    parameterId: number
    isRequired: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductParameterMinAggregateInputType = {
    id?: true
    productId?: true
    parameterId?: true
    isRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductParameterMaxAggregateInputType = {
    id?: true
    productId?: true
    parameterId?: true
    isRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductParameterCountAggregateInputType = {
    id?: true
    productId?: true
    parameterId?: true
    isRequired?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductParameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductParameter to aggregate.
     */
    where?: ProductParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductParameters to fetch.
     */
    orderBy?: ProductParameterOrderByWithRelationInput | ProductParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductParameters
    **/
    _count?: true | ProductParameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductParameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductParameterMaxAggregateInputType
  }

  export type GetProductParameterAggregateType<T extends ProductParameterAggregateArgs> = {
        [P in keyof T & keyof AggregateProductParameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductParameter[P]>
      : GetScalarType<T[P], AggregateProductParameter[P]>
  }




  export type ProductParameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductParameterWhereInput
    orderBy?: ProductParameterOrderByWithAggregationInput | ProductParameterOrderByWithAggregationInput[]
    by: ProductParameterScalarFieldEnum[] | ProductParameterScalarFieldEnum
    having?: ProductParameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductParameterCountAggregateInputType | true
    _min?: ProductParameterMinAggregateInputType
    _max?: ProductParameterMaxAggregateInputType
  }

  export type ProductParameterGroupByOutputType = {
    id: string
    productId: string
    parameterId: string
    isRequired: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductParameterCountAggregateOutputType | null
    _min: ProductParameterMinAggregateOutputType | null
    _max: ProductParameterMaxAggregateOutputType | null
  }

  type GetProductParameterGroupByPayload<T extends ProductParameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductParameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductParameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductParameterGroupByOutputType[P]>
            : GetScalarType<T[P], ProductParameterGroupByOutputType[P]>
        }
      >
    >


  export type ProductParameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    parameterId?: boolean
    isRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productParameter"]>

  export type ProductParameterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    parameterId?: boolean
    isRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productParameter"]>

  export type ProductParameterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    parameterId?: boolean
    isRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productParameter"]>

  export type ProductParameterSelectScalar = {
    id?: boolean
    productId?: boolean
    parameterId?: boolean
    isRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductParameterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "parameterId" | "isRequired" | "createdAt" | "updatedAt", ExtArgs["result"]["productParameter"]>
  export type ProductParameterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
  }
  export type ProductParameterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
  }
  export type ProductParameterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
  }

  export type $ProductParameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductParameter"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      parameter: Prisma.$StandardParameterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      parameterId: string
      isRequired: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productParameter"]>
    composites: {}
  }

  type ProductParameterGetPayload<S extends boolean | null | undefined | ProductParameterDefaultArgs> = $Result.GetResult<Prisma.$ProductParameterPayload, S>

  type ProductParameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductParameterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductParameterCountAggregateInputType | true
    }

  export interface ProductParameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductParameter'], meta: { name: 'ProductParameter' } }
    /**
     * Find zero or one ProductParameter that matches the filter.
     * @param {ProductParameterFindUniqueArgs} args - Arguments to find a ProductParameter
     * @example
     * // Get one ProductParameter
     * const productParameter = await prisma.productParameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductParameterFindUniqueArgs>(args: SelectSubset<T, ProductParameterFindUniqueArgs<ExtArgs>>): Prisma__ProductParameterClient<$Result.GetResult<Prisma.$ProductParameterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductParameter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductParameterFindUniqueOrThrowArgs} args - Arguments to find a ProductParameter
     * @example
     * // Get one ProductParameter
     * const productParameter = await prisma.productParameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductParameterFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductParameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductParameterClient<$Result.GetResult<Prisma.$ProductParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductParameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductParameterFindFirstArgs} args - Arguments to find a ProductParameter
     * @example
     * // Get one ProductParameter
     * const productParameter = await prisma.productParameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductParameterFindFirstArgs>(args?: SelectSubset<T, ProductParameterFindFirstArgs<ExtArgs>>): Prisma__ProductParameterClient<$Result.GetResult<Prisma.$ProductParameterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductParameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductParameterFindFirstOrThrowArgs} args - Arguments to find a ProductParameter
     * @example
     * // Get one ProductParameter
     * const productParameter = await prisma.productParameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductParameterFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductParameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductParameterClient<$Result.GetResult<Prisma.$ProductParameterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductParameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductParameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductParameters
     * const productParameters = await prisma.productParameter.findMany()
     * 
     * // Get first 10 ProductParameters
     * const productParameters = await prisma.productParameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productParameterWithIdOnly = await prisma.productParameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductParameterFindManyArgs>(args?: SelectSubset<T, ProductParameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductParameter.
     * @param {ProductParameterCreateArgs} args - Arguments to create a ProductParameter.
     * @example
     * // Create one ProductParameter
     * const ProductParameter = await prisma.productParameter.create({
     *   data: {
     *     // ... data to create a ProductParameter
     *   }
     * })
     * 
     */
    create<T extends ProductParameterCreateArgs>(args: SelectSubset<T, ProductParameterCreateArgs<ExtArgs>>): Prisma__ProductParameterClient<$Result.GetResult<Prisma.$ProductParameterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductParameters.
     * @param {ProductParameterCreateManyArgs} args - Arguments to create many ProductParameters.
     * @example
     * // Create many ProductParameters
     * const productParameter = await prisma.productParameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductParameterCreateManyArgs>(args?: SelectSubset<T, ProductParameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductParameters and returns the data saved in the database.
     * @param {ProductParameterCreateManyAndReturnArgs} args - Arguments to create many ProductParameters.
     * @example
     * // Create many ProductParameters
     * const productParameter = await prisma.productParameter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductParameters and only return the `id`
     * const productParameterWithIdOnly = await prisma.productParameter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductParameterCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductParameterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductParameterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductParameter.
     * @param {ProductParameterDeleteArgs} args - Arguments to delete one ProductParameter.
     * @example
     * // Delete one ProductParameter
     * const ProductParameter = await prisma.productParameter.delete({
     *   where: {
     *     // ... filter to delete one ProductParameter
     *   }
     * })
     * 
     */
    delete<T extends ProductParameterDeleteArgs>(args: SelectSubset<T, ProductParameterDeleteArgs<ExtArgs>>): Prisma__ProductParameterClient<$Result.GetResult<Prisma.$ProductParameterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductParameter.
     * @param {ProductParameterUpdateArgs} args - Arguments to update one ProductParameter.
     * @example
     * // Update one ProductParameter
     * const productParameter = await prisma.productParameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductParameterUpdateArgs>(args: SelectSubset<T, ProductParameterUpdateArgs<ExtArgs>>): Prisma__ProductParameterClient<$Result.GetResult<Prisma.$ProductParameterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductParameters.
     * @param {ProductParameterDeleteManyArgs} args - Arguments to filter ProductParameters to delete.
     * @example
     * // Delete a few ProductParameters
     * const { count } = await prisma.productParameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductParameterDeleteManyArgs>(args?: SelectSubset<T, ProductParameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductParameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductParameters
     * const productParameter = await prisma.productParameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductParameterUpdateManyArgs>(args: SelectSubset<T, ProductParameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductParameters and returns the data updated in the database.
     * @param {ProductParameterUpdateManyAndReturnArgs} args - Arguments to update many ProductParameters.
     * @example
     * // Update many ProductParameters
     * const productParameter = await prisma.productParameter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductParameters and only return the `id`
     * const productParameterWithIdOnly = await prisma.productParameter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductParameterUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductParameterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductParameterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductParameter.
     * @param {ProductParameterUpsertArgs} args - Arguments to update or create a ProductParameter.
     * @example
     * // Update or create a ProductParameter
     * const productParameter = await prisma.productParameter.upsert({
     *   create: {
     *     // ... data to create a ProductParameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductParameter we want to update
     *   }
     * })
     */
    upsert<T extends ProductParameterUpsertArgs>(args: SelectSubset<T, ProductParameterUpsertArgs<ExtArgs>>): Prisma__ProductParameterClient<$Result.GetResult<Prisma.$ProductParameterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductParameterCountArgs} args - Arguments to filter ProductParameters to count.
     * @example
     * // Count the number of ProductParameters
     * const count = await prisma.productParameter.count({
     *   where: {
     *     // ... the filter for the ProductParameters we want to count
     *   }
     * })
    **/
    count<T extends ProductParameterCountArgs>(
      args?: Subset<T, ProductParameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductParameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductParameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductParameterAggregateArgs>(args: Subset<T, ProductParameterAggregateArgs>): Prisma.PrismaPromise<GetProductParameterAggregateType<T>>

    /**
     * Group by ProductParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductParameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductParameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductParameterGroupByArgs['orderBy'] }
        : { orderBy?: ProductParameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductParameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductParameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductParameter model
   */
  readonly fields: ProductParameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductParameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductParameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parameter<T extends StandardParameterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StandardParameterDefaultArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductParameter model
   */
  interface ProductParameterFieldRefs {
    readonly id: FieldRef<"ProductParameter", 'String'>
    readonly productId: FieldRef<"ProductParameter", 'String'>
    readonly parameterId: FieldRef<"ProductParameter", 'String'>
    readonly isRequired: FieldRef<"ProductParameter", 'Boolean'>
    readonly createdAt: FieldRef<"ProductParameter", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductParameter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductParameter findUnique
   */
  export type ProductParameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterInclude<ExtArgs> | null
    /**
     * Filter, which ProductParameter to fetch.
     */
    where: ProductParameterWhereUniqueInput
  }

  /**
   * ProductParameter findUniqueOrThrow
   */
  export type ProductParameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterInclude<ExtArgs> | null
    /**
     * Filter, which ProductParameter to fetch.
     */
    where: ProductParameterWhereUniqueInput
  }

  /**
   * ProductParameter findFirst
   */
  export type ProductParameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterInclude<ExtArgs> | null
    /**
     * Filter, which ProductParameter to fetch.
     */
    where?: ProductParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductParameters to fetch.
     */
    orderBy?: ProductParameterOrderByWithRelationInput | ProductParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductParameters.
     */
    cursor?: ProductParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductParameters.
     */
    distinct?: ProductParameterScalarFieldEnum | ProductParameterScalarFieldEnum[]
  }

  /**
   * ProductParameter findFirstOrThrow
   */
  export type ProductParameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterInclude<ExtArgs> | null
    /**
     * Filter, which ProductParameter to fetch.
     */
    where?: ProductParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductParameters to fetch.
     */
    orderBy?: ProductParameterOrderByWithRelationInput | ProductParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductParameters.
     */
    cursor?: ProductParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductParameters.
     */
    distinct?: ProductParameterScalarFieldEnum | ProductParameterScalarFieldEnum[]
  }

  /**
   * ProductParameter findMany
   */
  export type ProductParameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterInclude<ExtArgs> | null
    /**
     * Filter, which ProductParameters to fetch.
     */
    where?: ProductParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductParameters to fetch.
     */
    orderBy?: ProductParameterOrderByWithRelationInput | ProductParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductParameters.
     */
    cursor?: ProductParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductParameters.
     */
    skip?: number
    distinct?: ProductParameterScalarFieldEnum | ProductParameterScalarFieldEnum[]
  }

  /**
   * ProductParameter create
   */
  export type ProductParameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductParameter.
     */
    data: XOR<ProductParameterCreateInput, ProductParameterUncheckedCreateInput>
  }

  /**
   * ProductParameter createMany
   */
  export type ProductParameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductParameters.
     */
    data: ProductParameterCreateManyInput | ProductParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductParameter createManyAndReturn
   */
  export type ProductParameterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * The data used to create many ProductParameters.
     */
    data: ProductParameterCreateManyInput | ProductParameterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductParameter update
   */
  export type ProductParameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductParameter.
     */
    data: XOR<ProductParameterUpdateInput, ProductParameterUncheckedUpdateInput>
    /**
     * Choose, which ProductParameter to update.
     */
    where: ProductParameterWhereUniqueInput
  }

  /**
   * ProductParameter updateMany
   */
  export type ProductParameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductParameters.
     */
    data: XOR<ProductParameterUpdateManyMutationInput, ProductParameterUncheckedUpdateManyInput>
    /**
     * Filter which ProductParameters to update
     */
    where?: ProductParameterWhereInput
    /**
     * Limit how many ProductParameters to update.
     */
    limit?: number
  }

  /**
   * ProductParameter updateManyAndReturn
   */
  export type ProductParameterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * The data used to update ProductParameters.
     */
    data: XOR<ProductParameterUpdateManyMutationInput, ProductParameterUncheckedUpdateManyInput>
    /**
     * Filter which ProductParameters to update
     */
    where?: ProductParameterWhereInput
    /**
     * Limit how many ProductParameters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductParameter upsert
   */
  export type ProductParameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductParameter to update in case it exists.
     */
    where: ProductParameterWhereUniqueInput
    /**
     * In case the ProductParameter found by the `where` argument doesn't exist, create a new ProductParameter with this data.
     */
    create: XOR<ProductParameterCreateInput, ProductParameterUncheckedCreateInput>
    /**
     * In case the ProductParameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductParameterUpdateInput, ProductParameterUncheckedUpdateInput>
  }

  /**
   * ProductParameter delete
   */
  export type ProductParameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterInclude<ExtArgs> | null
    /**
     * Filter which ProductParameter to delete.
     */
    where: ProductParameterWhereUniqueInput
  }

  /**
   * ProductParameter deleteMany
   */
  export type ProductParameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductParameters to delete
     */
    where?: ProductParameterWhereInput
    /**
     * Limit how many ProductParameters to delete.
     */
    limit?: number
  }

  /**
   * ProductParameter without action
   */
  export type ProductParameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | Role$UserArgs<ExtArgs>
    Permission?: boolean | Role$PermissionArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Role$UserArgs<ExtArgs>
    Permission?: boolean | Role$PermissionArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>[]
      Permission: Prisma.$PermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Role$UserArgs<ExtArgs> = {}>(args?: Subset<T, Role$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Permission<T extends Role$PermissionArgs<ExtArgs> = {}>(args?: Subset<T, Role$PermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.User
   */
  export type Role$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role.Permission
   */
  export type Role$PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UnitOfMeasurement
   */

  export type AggregateUnitOfMeasurement = {
    _count: UnitOfMeasurementCountAggregateOutputType | null
    _min: UnitOfMeasurementMinAggregateOutputType | null
    _max: UnitOfMeasurementMaxAggregateOutputType | null
  }

  export type UnitOfMeasurementMinAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitOfMeasurementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitOfMeasurementCountAggregateOutputType = {
    id: number
    name: number
    symbol: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitOfMeasurementMinAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitOfMeasurementMaxAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitOfMeasurementCountAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitOfMeasurementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitOfMeasurement to aggregate.
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasurements to fetch.
     */
    orderBy?: UnitOfMeasurementOrderByWithRelationInput | UnitOfMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitOfMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitOfMeasurements
    **/
    _count?: true | UnitOfMeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitOfMeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitOfMeasurementMaxAggregateInputType
  }

  export type GetUnitOfMeasurementAggregateType<T extends UnitOfMeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitOfMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitOfMeasurement[P]>
      : GetScalarType<T[P], AggregateUnitOfMeasurement[P]>
  }




  export type UnitOfMeasurementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfMeasurementWhereInput
    orderBy?: UnitOfMeasurementOrderByWithAggregationInput | UnitOfMeasurementOrderByWithAggregationInput[]
    by: UnitOfMeasurementScalarFieldEnum[] | UnitOfMeasurementScalarFieldEnum
    having?: UnitOfMeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitOfMeasurementCountAggregateInputType | true
    _min?: UnitOfMeasurementMinAggregateInputType
    _max?: UnitOfMeasurementMaxAggregateInputType
  }

  export type UnitOfMeasurementGroupByOutputType = {
    id: string
    name: string
    symbol: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: UnitOfMeasurementCountAggregateOutputType | null
    _min: UnitOfMeasurementMinAggregateOutputType | null
    _max: UnitOfMeasurementMaxAggregateOutputType | null
  }

  type GetUnitOfMeasurementGroupByPayload<T extends UnitOfMeasurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitOfMeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitOfMeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitOfMeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], UnitOfMeasurementGroupByOutputType[P]>
        }
      >
    >


  export type UnitOfMeasurementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Standards?: boolean | UnitOfMeasurement$StandardsArgs<ExtArgs>
    batchParameterValues?: boolean | UnitOfMeasurement$batchParameterValuesArgs<ExtArgs>
    standardParameters?: boolean | UnitOfMeasurement$standardParametersArgs<ExtArgs>
    standardDefinitions?: boolean | UnitOfMeasurement$standardDefinitionsArgs<ExtArgs>
    batches?: boolean | UnitOfMeasurement$batchesArgs<ExtArgs>
    _count?: boolean | UnitOfMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitOfMeasurement"]>

  export type UnitOfMeasurementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unitOfMeasurement"]>

  export type UnitOfMeasurementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unitOfMeasurement"]>

  export type UnitOfMeasurementSelectScalar = {
    id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitOfMeasurementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "symbol" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["unitOfMeasurement"]>
  export type UnitOfMeasurementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Standards?: boolean | UnitOfMeasurement$StandardsArgs<ExtArgs>
    batchParameterValues?: boolean | UnitOfMeasurement$batchParameterValuesArgs<ExtArgs>
    standardParameters?: boolean | UnitOfMeasurement$standardParametersArgs<ExtArgs>
    standardDefinitions?: boolean | UnitOfMeasurement$standardDefinitionsArgs<ExtArgs>
    batches?: boolean | UnitOfMeasurement$batchesArgs<ExtArgs>
    _count?: boolean | UnitOfMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitOfMeasurementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UnitOfMeasurementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnitOfMeasurementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitOfMeasurement"
    objects: {
      Standards: Prisma.$StandardPayload<ExtArgs>[]
      batchParameterValues: Prisma.$BatchParameterValuePayload<ExtArgs>[]
      standardParameters: Prisma.$StandardParameterPayload<ExtArgs>[]
      standardDefinitions: Prisma.$StandardDefinitionPayload<ExtArgs>[]
      batches: Prisma.$BatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      symbol: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitOfMeasurement"]>
    composites: {}
  }

  type UnitOfMeasurementGetPayload<S extends boolean | null | undefined | UnitOfMeasurementDefaultArgs> = $Result.GetResult<Prisma.$UnitOfMeasurementPayload, S>

  type UnitOfMeasurementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitOfMeasurementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitOfMeasurementCountAggregateInputType | true
    }

  export interface UnitOfMeasurementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitOfMeasurement'], meta: { name: 'UnitOfMeasurement' } }
    /**
     * Find zero or one UnitOfMeasurement that matches the filter.
     * @param {UnitOfMeasurementFindUniqueArgs} args - Arguments to find a UnitOfMeasurement
     * @example
     * // Get one UnitOfMeasurement
     * const unitOfMeasurement = await prisma.unitOfMeasurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitOfMeasurementFindUniqueArgs>(args: SelectSubset<T, UnitOfMeasurementFindUniqueArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitOfMeasurement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitOfMeasurementFindUniqueOrThrowArgs} args - Arguments to find a UnitOfMeasurement
     * @example
     * // Get one UnitOfMeasurement
     * const unitOfMeasurement = await prisma.unitOfMeasurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitOfMeasurementFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitOfMeasurementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitOfMeasurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementFindFirstArgs} args - Arguments to find a UnitOfMeasurement
     * @example
     * // Get one UnitOfMeasurement
     * const unitOfMeasurement = await prisma.unitOfMeasurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitOfMeasurementFindFirstArgs>(args?: SelectSubset<T, UnitOfMeasurementFindFirstArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitOfMeasurement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementFindFirstOrThrowArgs} args - Arguments to find a UnitOfMeasurement
     * @example
     * // Get one UnitOfMeasurement
     * const unitOfMeasurement = await prisma.unitOfMeasurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitOfMeasurementFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitOfMeasurementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitOfMeasurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitOfMeasurements
     * const unitOfMeasurements = await prisma.unitOfMeasurement.findMany()
     * 
     * // Get first 10 UnitOfMeasurements
     * const unitOfMeasurements = await prisma.unitOfMeasurement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitOfMeasurementWithIdOnly = await prisma.unitOfMeasurement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitOfMeasurementFindManyArgs>(args?: SelectSubset<T, UnitOfMeasurementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitOfMeasurement.
     * @param {UnitOfMeasurementCreateArgs} args - Arguments to create a UnitOfMeasurement.
     * @example
     * // Create one UnitOfMeasurement
     * const UnitOfMeasurement = await prisma.unitOfMeasurement.create({
     *   data: {
     *     // ... data to create a UnitOfMeasurement
     *   }
     * })
     * 
     */
    create<T extends UnitOfMeasurementCreateArgs>(args: SelectSubset<T, UnitOfMeasurementCreateArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitOfMeasurements.
     * @param {UnitOfMeasurementCreateManyArgs} args - Arguments to create many UnitOfMeasurements.
     * @example
     * // Create many UnitOfMeasurements
     * const unitOfMeasurement = await prisma.unitOfMeasurement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitOfMeasurementCreateManyArgs>(args?: SelectSubset<T, UnitOfMeasurementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitOfMeasurements and returns the data saved in the database.
     * @param {UnitOfMeasurementCreateManyAndReturnArgs} args - Arguments to create many UnitOfMeasurements.
     * @example
     * // Create many UnitOfMeasurements
     * const unitOfMeasurement = await prisma.unitOfMeasurement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitOfMeasurements and only return the `id`
     * const unitOfMeasurementWithIdOnly = await prisma.unitOfMeasurement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitOfMeasurementCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitOfMeasurementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitOfMeasurement.
     * @param {UnitOfMeasurementDeleteArgs} args - Arguments to delete one UnitOfMeasurement.
     * @example
     * // Delete one UnitOfMeasurement
     * const UnitOfMeasurement = await prisma.unitOfMeasurement.delete({
     *   where: {
     *     // ... filter to delete one UnitOfMeasurement
     *   }
     * })
     * 
     */
    delete<T extends UnitOfMeasurementDeleteArgs>(args: SelectSubset<T, UnitOfMeasurementDeleteArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitOfMeasurement.
     * @param {UnitOfMeasurementUpdateArgs} args - Arguments to update one UnitOfMeasurement.
     * @example
     * // Update one UnitOfMeasurement
     * const unitOfMeasurement = await prisma.unitOfMeasurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitOfMeasurementUpdateArgs>(args: SelectSubset<T, UnitOfMeasurementUpdateArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitOfMeasurements.
     * @param {UnitOfMeasurementDeleteManyArgs} args - Arguments to filter UnitOfMeasurements to delete.
     * @example
     * // Delete a few UnitOfMeasurements
     * const { count } = await prisma.unitOfMeasurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitOfMeasurementDeleteManyArgs>(args?: SelectSubset<T, UnitOfMeasurementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitOfMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitOfMeasurements
     * const unitOfMeasurement = await prisma.unitOfMeasurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitOfMeasurementUpdateManyArgs>(args: SelectSubset<T, UnitOfMeasurementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitOfMeasurements and returns the data updated in the database.
     * @param {UnitOfMeasurementUpdateManyAndReturnArgs} args - Arguments to update many UnitOfMeasurements.
     * @example
     * // Update many UnitOfMeasurements
     * const unitOfMeasurement = await prisma.unitOfMeasurement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitOfMeasurements and only return the `id`
     * const unitOfMeasurementWithIdOnly = await prisma.unitOfMeasurement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitOfMeasurementUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitOfMeasurementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitOfMeasurement.
     * @param {UnitOfMeasurementUpsertArgs} args - Arguments to update or create a UnitOfMeasurement.
     * @example
     * // Update or create a UnitOfMeasurement
     * const unitOfMeasurement = await prisma.unitOfMeasurement.upsert({
     *   create: {
     *     // ... data to create a UnitOfMeasurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitOfMeasurement we want to update
     *   }
     * })
     */
    upsert<T extends UnitOfMeasurementUpsertArgs>(args: SelectSubset<T, UnitOfMeasurementUpsertArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitOfMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementCountArgs} args - Arguments to filter UnitOfMeasurements to count.
     * @example
     * // Count the number of UnitOfMeasurements
     * const count = await prisma.unitOfMeasurement.count({
     *   where: {
     *     // ... the filter for the UnitOfMeasurements we want to count
     *   }
     * })
    **/
    count<T extends UnitOfMeasurementCountArgs>(
      args?: Subset<T, UnitOfMeasurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitOfMeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitOfMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitOfMeasurementAggregateArgs>(args: Subset<T, UnitOfMeasurementAggregateArgs>): Prisma.PrismaPromise<GetUnitOfMeasurementAggregateType<T>>

    /**
     * Group by UnitOfMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitOfMeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitOfMeasurementGroupByArgs['orderBy'] }
        : { orderBy?: UnitOfMeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitOfMeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitOfMeasurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitOfMeasurement model
   */
  readonly fields: UnitOfMeasurementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitOfMeasurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitOfMeasurementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Standards<T extends UnitOfMeasurement$StandardsArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasurement$StandardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    batchParameterValues<T extends UnitOfMeasurement$batchParameterValuesArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasurement$batchParameterValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standardParameters<T extends UnitOfMeasurement$standardParametersArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasurement$standardParametersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standardDefinitions<T extends UnitOfMeasurement$standardDefinitionsArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasurement$standardDefinitionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    batches<T extends UnitOfMeasurement$batchesArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasurement$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitOfMeasurement model
   */
  interface UnitOfMeasurementFieldRefs {
    readonly id: FieldRef<"UnitOfMeasurement", 'String'>
    readonly name: FieldRef<"UnitOfMeasurement", 'String'>
    readonly symbol: FieldRef<"UnitOfMeasurement", 'String'>
    readonly description: FieldRef<"UnitOfMeasurement", 'String'>
    readonly createdAt: FieldRef<"UnitOfMeasurement", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitOfMeasurement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitOfMeasurement findUnique
   */
  export type UnitOfMeasurementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasurement to fetch.
     */
    where: UnitOfMeasurementWhereUniqueInput
  }

  /**
   * UnitOfMeasurement findUniqueOrThrow
   */
  export type UnitOfMeasurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasurement to fetch.
     */
    where: UnitOfMeasurementWhereUniqueInput
  }

  /**
   * UnitOfMeasurement findFirst
   */
  export type UnitOfMeasurementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasurement to fetch.
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasurements to fetch.
     */
    orderBy?: UnitOfMeasurementOrderByWithRelationInput | UnitOfMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitOfMeasurements.
     */
    cursor?: UnitOfMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitOfMeasurements.
     */
    distinct?: UnitOfMeasurementScalarFieldEnum | UnitOfMeasurementScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement findFirstOrThrow
   */
  export type UnitOfMeasurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasurement to fetch.
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasurements to fetch.
     */
    orderBy?: UnitOfMeasurementOrderByWithRelationInput | UnitOfMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitOfMeasurements.
     */
    cursor?: UnitOfMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitOfMeasurements.
     */
    distinct?: UnitOfMeasurementScalarFieldEnum | UnitOfMeasurementScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement findMany
   */
  export type UnitOfMeasurementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasurements to fetch.
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasurements to fetch.
     */
    orderBy?: UnitOfMeasurementOrderByWithRelationInput | UnitOfMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitOfMeasurements.
     */
    cursor?: UnitOfMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasurements.
     */
    skip?: number
    distinct?: UnitOfMeasurementScalarFieldEnum | UnitOfMeasurementScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement create
   */
  export type UnitOfMeasurementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitOfMeasurement.
     */
    data: XOR<UnitOfMeasurementCreateInput, UnitOfMeasurementUncheckedCreateInput>
  }

  /**
   * UnitOfMeasurement createMany
   */
  export type UnitOfMeasurementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitOfMeasurements.
     */
    data: UnitOfMeasurementCreateManyInput | UnitOfMeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitOfMeasurement createManyAndReturn
   */
  export type UnitOfMeasurementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * The data used to create many UnitOfMeasurements.
     */
    data: UnitOfMeasurementCreateManyInput | UnitOfMeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitOfMeasurement update
   */
  export type UnitOfMeasurementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitOfMeasurement.
     */
    data: XOR<UnitOfMeasurementUpdateInput, UnitOfMeasurementUncheckedUpdateInput>
    /**
     * Choose, which UnitOfMeasurement to update.
     */
    where: UnitOfMeasurementWhereUniqueInput
  }

  /**
   * UnitOfMeasurement updateMany
   */
  export type UnitOfMeasurementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitOfMeasurements.
     */
    data: XOR<UnitOfMeasurementUpdateManyMutationInput, UnitOfMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which UnitOfMeasurements to update
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * Limit how many UnitOfMeasurements to update.
     */
    limit?: number
  }

  /**
   * UnitOfMeasurement updateManyAndReturn
   */
  export type UnitOfMeasurementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * The data used to update UnitOfMeasurements.
     */
    data: XOR<UnitOfMeasurementUpdateManyMutationInput, UnitOfMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which UnitOfMeasurements to update
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * Limit how many UnitOfMeasurements to update.
     */
    limit?: number
  }

  /**
   * UnitOfMeasurement upsert
   */
  export type UnitOfMeasurementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitOfMeasurement to update in case it exists.
     */
    where: UnitOfMeasurementWhereUniqueInput
    /**
     * In case the UnitOfMeasurement found by the `where` argument doesn't exist, create a new UnitOfMeasurement with this data.
     */
    create: XOR<UnitOfMeasurementCreateInput, UnitOfMeasurementUncheckedCreateInput>
    /**
     * In case the UnitOfMeasurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitOfMeasurementUpdateInput, UnitOfMeasurementUncheckedUpdateInput>
  }

  /**
   * UnitOfMeasurement delete
   */
  export type UnitOfMeasurementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * Filter which UnitOfMeasurement to delete.
     */
    where: UnitOfMeasurementWhereUniqueInput
  }

  /**
   * UnitOfMeasurement deleteMany
   */
  export type UnitOfMeasurementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitOfMeasurements to delete
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * Limit how many UnitOfMeasurements to delete.
     */
    limit?: number
  }

  /**
   * UnitOfMeasurement.Standards
   */
  export type UnitOfMeasurement$StandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    cursor?: StandardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement.batchParameterValues
   */
  export type UnitOfMeasurement$batchParameterValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    where?: BatchParameterValueWhereInput
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    cursor?: BatchParameterValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement.standardParameters
   */
  export type UnitOfMeasurement$standardParametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    where?: StandardParameterWhereInput
    orderBy?: StandardParameterOrderByWithRelationInput | StandardParameterOrderByWithRelationInput[]
    cursor?: StandardParameterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardParameterScalarFieldEnum | StandardParameterScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement.standardDefinitions
   */
  export type UnitOfMeasurement$standardDefinitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    where?: StandardDefinitionWhereInput
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    cursor?: StandardDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement.batches
   */
  export type UnitOfMeasurement$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement without action
   */
  export type UnitOfMeasurementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    roleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    roleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    roleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ActivityLog?: boolean | User$ActivityLogArgs<ExtArgs>
    Batch_Batch_checkerIdToUser?: boolean | User$Batch_Batch_checkerIdToUserArgs<ExtArgs>
    Batch_Batch_makerIdToUser?: boolean | User$Batch_Batch_makerIdToUserArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    StandardsCreated?: boolean | User$StandardsCreatedArgs<ExtArgs>
    StandardsModified?: boolean | User$StandardsModifiedArgs<ExtArgs>
    standardDefinitionsCreated?: boolean | User$standardDefinitionsCreatedArgs<ExtArgs>
    standardDefinitionsModified?: boolean | User$standardDefinitionsModifiedArgs<ExtArgs>
    trainerTrainings?: boolean | User$trainerTrainingsArgs<ExtArgs>
    createdTrainings?: boolean | User$createdTrainingsArgs<ExtArgs>
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    uploadedPhotos?: boolean | User$uploadedPhotosArgs<ExtArgs>
    assignedFollowups?: boolean | User$assignedFollowupsArgs<ExtArgs>
    createdFollowups?: boolean | User$createdFollowupsArgs<ExtArgs>
    trainingNotifications?: boolean | User$trainingNotificationsArgs<ExtArgs>
    auditorProfile?: boolean | User$auditorProfileArgs<ExtArgs>
    auditeeAudits?: boolean | User$auditeeAuditsArgs<ExtArgs>
    createdAudits?: boolean | User$createdAuditsArgs<ExtArgs>
    assignedFindings?: boolean | User$assignedFindingsArgs<ExtArgs>
    assignedActions?: boolean | User$assignedActionsArgs<ExtArgs>
    verifiedActions?: boolean | User$verifiedActionsArgs<ExtArgs>
    uploadedAuditDocuments?: boolean | User$uploadedAuditDocumentsArgs<ExtArgs>
    createdReminders?: boolean | User$createdRemindersArgs<ExtArgs>
    receivedReminders?: boolean | User$receivedRemindersArgs<ExtArgs>
    auditNotifications?: boolean | User$auditNotificationsArgs<ExtArgs>
    responsibleForChecklistItems?: boolean | User$responsibleForChecklistItemsArgs<ExtArgs>
    createdChecklistItems?: boolean | User$createdChecklistItemsArgs<ExtArgs>
    inspectedItems?: boolean | User$inspectedItemsArgs<ExtArgs>
    uploadedFeedbackForms?: boolean | User$uploadedFeedbackFormsArgs<ExtArgs>
    uploadedSessionPhotos?: boolean | User$uploadedSessionPhotosArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "roleId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActivityLog?: boolean | User$ActivityLogArgs<ExtArgs>
    Batch_Batch_checkerIdToUser?: boolean | User$Batch_Batch_checkerIdToUserArgs<ExtArgs>
    Batch_Batch_makerIdToUser?: boolean | User$Batch_Batch_makerIdToUserArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    StandardsCreated?: boolean | User$StandardsCreatedArgs<ExtArgs>
    StandardsModified?: boolean | User$StandardsModifiedArgs<ExtArgs>
    standardDefinitionsCreated?: boolean | User$standardDefinitionsCreatedArgs<ExtArgs>
    standardDefinitionsModified?: boolean | User$standardDefinitionsModifiedArgs<ExtArgs>
    trainerTrainings?: boolean | User$trainerTrainingsArgs<ExtArgs>
    createdTrainings?: boolean | User$createdTrainingsArgs<ExtArgs>
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    uploadedPhotos?: boolean | User$uploadedPhotosArgs<ExtArgs>
    assignedFollowups?: boolean | User$assignedFollowupsArgs<ExtArgs>
    createdFollowups?: boolean | User$createdFollowupsArgs<ExtArgs>
    trainingNotifications?: boolean | User$trainingNotificationsArgs<ExtArgs>
    auditorProfile?: boolean | User$auditorProfileArgs<ExtArgs>
    auditeeAudits?: boolean | User$auditeeAuditsArgs<ExtArgs>
    createdAudits?: boolean | User$createdAuditsArgs<ExtArgs>
    assignedFindings?: boolean | User$assignedFindingsArgs<ExtArgs>
    assignedActions?: boolean | User$assignedActionsArgs<ExtArgs>
    verifiedActions?: boolean | User$verifiedActionsArgs<ExtArgs>
    uploadedAuditDocuments?: boolean | User$uploadedAuditDocumentsArgs<ExtArgs>
    createdReminders?: boolean | User$createdRemindersArgs<ExtArgs>
    receivedReminders?: boolean | User$receivedRemindersArgs<ExtArgs>
    auditNotifications?: boolean | User$auditNotificationsArgs<ExtArgs>
    responsibleForChecklistItems?: boolean | User$responsibleForChecklistItemsArgs<ExtArgs>
    createdChecklistItems?: boolean | User$createdChecklistItemsArgs<ExtArgs>
    inspectedItems?: boolean | User$inspectedItemsArgs<ExtArgs>
    uploadedFeedbackForms?: boolean | User$uploadedFeedbackFormsArgs<ExtArgs>
    uploadedSessionPhotos?: boolean | User$uploadedSessionPhotosArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      ActivityLog: Prisma.$ActivityLogPayload<ExtArgs>[]
      Batch_Batch_checkerIdToUser: Prisma.$BatchPayload<ExtArgs>[]
      Batch_Batch_makerIdToUser: Prisma.$BatchPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
      Role: Prisma.$RolePayload<ExtArgs>
      StandardsCreated: Prisma.$StandardPayload<ExtArgs>[]
      StandardsModified: Prisma.$StandardPayload<ExtArgs>[]
      standardDefinitionsCreated: Prisma.$StandardDefinitionPayload<ExtArgs>[]
      standardDefinitionsModified: Prisma.$StandardDefinitionPayload<ExtArgs>[]
      trainerTrainings: Prisma.$TrainingPayload<ExtArgs>[]
      createdTrainings: Prisma.$TrainingPayload<ExtArgs>[]
      uploadedDocuments: Prisma.$TrainingDocumentPayload<ExtArgs>[]
      uploadedPhotos: Prisma.$TrainingPhotoPayload<ExtArgs>[]
      assignedFollowups: Prisma.$TrainingFollowupPayload<ExtArgs>[]
      createdFollowups: Prisma.$TrainingFollowupPayload<ExtArgs>[]
      trainingNotifications: Prisma.$TrainingNotificationPayload<ExtArgs>[]
      auditorProfile: Prisma.$AuditorPayload<ExtArgs> | null
      auditeeAudits: Prisma.$AuditPayload<ExtArgs>[]
      createdAudits: Prisma.$AuditPayload<ExtArgs>[]
      assignedFindings: Prisma.$FindingPayload<ExtArgs>[]
      assignedActions: Prisma.$CorrectiveActionPayload<ExtArgs>[]
      verifiedActions: Prisma.$CorrectiveActionPayload<ExtArgs>[]
      uploadedAuditDocuments: Prisma.$AuditDocumentPayload<ExtArgs>[]
      createdReminders: Prisma.$AuditReminderPayload<ExtArgs>[]
      receivedReminders: Prisma.$AuditReminderPayload<ExtArgs>[]
      auditNotifications: Prisma.$AuditNotificationPayload<ExtArgs>[]
      responsibleForChecklistItems: Prisma.$PreAuditChecklistItemPayload<ExtArgs>[]
      createdChecklistItems: Prisma.$PreAuditChecklistItemPayload<ExtArgs>[]
      inspectedItems: Prisma.$AuditInspectionItemPayload<ExtArgs>[]
      uploadedFeedbackForms: Prisma.$FeedbackFormPayload<ExtArgs>[]
      uploadedSessionPhotos: Prisma.$TrainingSessionPhotoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      roleId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ActivityLog<T extends User$ActivityLogArgs<ExtArgs> = {}>(args?: Subset<T, User$ActivityLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Batch_Batch_checkerIdToUser<T extends User$Batch_Batch_checkerIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Batch_Batch_checkerIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Batch_Batch_makerIdToUser<T extends User$Batch_Batch_makerIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Batch_Batch_makerIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    StandardsCreated<T extends User$StandardsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$StandardsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StandardsModified<T extends User$StandardsModifiedArgs<ExtArgs> = {}>(args?: Subset<T, User$StandardsModifiedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standardDefinitionsCreated<T extends User$standardDefinitionsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$standardDefinitionsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standardDefinitionsModified<T extends User$standardDefinitionsModifiedArgs<ExtArgs> = {}>(args?: Subset<T, User$standardDefinitionsModifiedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainerTrainings<T extends User$trainerTrainingsArgs<ExtArgs> = {}>(args?: Subset<T, User$trainerTrainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdTrainings<T extends User$createdTrainingsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTrainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedDocuments<T extends User$uploadedDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedPhotos<T extends User$uploadedPhotosArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedFollowups<T extends User$assignedFollowupsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedFollowupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdFollowups<T extends User$createdFollowupsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdFollowupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainingNotifications<T extends User$trainingNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$trainingNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditorProfile<T extends User$auditorProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$auditorProfileArgs<ExtArgs>>): Prisma__AuditorClient<$Result.GetResult<Prisma.$AuditorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    auditeeAudits<T extends User$auditeeAuditsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditeeAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdAudits<T extends User$createdAuditsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedFindings<T extends User$assignedFindingsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedFindingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedActions<T extends User$assignedActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verifiedActions<T extends User$verifiedActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$verifiedActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedAuditDocuments<T extends User$uploadedAuditDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedAuditDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdReminders<T extends User$createdRemindersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdRemindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedReminders<T extends User$receivedRemindersArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedRemindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditNotifications<T extends User$auditNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    responsibleForChecklistItems<T extends User$responsibleForChecklistItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$responsibleForChecklistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdChecklistItems<T extends User$createdChecklistItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdChecklistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inspectedItems<T extends User$inspectedItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$inspectedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditInspectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedFeedbackForms<T extends User$uploadedFeedbackFormsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedFeedbackFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedSessionPhotos<T extends User$uploadedSessionPhotosArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedSessionPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.ActivityLog
   */
  export type User$ActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.Batch_Batch_checkerIdToUser
   */
  export type User$Batch_Batch_checkerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * User.Batch_Batch_makerIdToUser
   */
  export type User$Batch_Batch_makerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * User.Notification
   */
  export type User$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.StandardsCreated
   */
  export type User$StandardsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    cursor?: StandardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * User.StandardsModified
   */
  export type User$StandardsModifiedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    cursor?: StandardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * User.standardDefinitionsCreated
   */
  export type User$standardDefinitionsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    where?: StandardDefinitionWhereInput
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    cursor?: StandardDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * User.standardDefinitionsModified
   */
  export type User$standardDefinitionsModifiedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    where?: StandardDefinitionWhereInput
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    cursor?: StandardDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * User.trainerTrainings
   */
  export type User$trainerTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    where?: TrainingWhereInput
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    cursor?: TrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * User.createdTrainings
   */
  export type User$createdTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    where?: TrainingWhereInput
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    cursor?: TrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * User.uploadedDocuments
   */
  export type User$uploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    where?: TrainingDocumentWhereInput
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    cursor?: TrainingDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * User.uploadedPhotos
   */
  export type User$uploadedPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    where?: TrainingPhotoWhereInput
    orderBy?: TrainingPhotoOrderByWithRelationInput | TrainingPhotoOrderByWithRelationInput[]
    cursor?: TrainingPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingPhotoScalarFieldEnum | TrainingPhotoScalarFieldEnum[]
  }

  /**
   * User.assignedFollowups
   */
  export type User$assignedFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    where?: TrainingFollowupWhereInput
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    cursor?: TrainingFollowupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingFollowupScalarFieldEnum | TrainingFollowupScalarFieldEnum[]
  }

  /**
   * User.createdFollowups
   */
  export type User$createdFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    where?: TrainingFollowupWhereInput
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    cursor?: TrainingFollowupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingFollowupScalarFieldEnum | TrainingFollowupScalarFieldEnum[]
  }

  /**
   * User.trainingNotifications
   */
  export type User$trainingNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    where?: TrainingNotificationWhereInput
    orderBy?: TrainingNotificationOrderByWithRelationInput | TrainingNotificationOrderByWithRelationInput[]
    cursor?: TrainingNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingNotificationScalarFieldEnum | TrainingNotificationScalarFieldEnum[]
  }

  /**
   * User.auditorProfile
   */
  export type User$auditorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditor
     */
    select?: AuditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditor
     */
    omit?: AuditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditorInclude<ExtArgs> | null
    where?: AuditorWhereInput
  }

  /**
   * User.auditeeAudits
   */
  export type User$auditeeAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    cursor?: AuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * User.createdAudits
   */
  export type User$createdAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    cursor?: AuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * User.assignedFindings
   */
  export type User$assignedFindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null
    where?: FindingWhereInput
    orderBy?: FindingOrderByWithRelationInput | FindingOrderByWithRelationInput[]
    cursor?: FindingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FindingScalarFieldEnum | FindingScalarFieldEnum[]
  }

  /**
   * User.assignedActions
   */
  export type User$assignedActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
    where?: CorrectiveActionWhereInput
    orderBy?: CorrectiveActionOrderByWithRelationInput | CorrectiveActionOrderByWithRelationInput[]
    cursor?: CorrectiveActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CorrectiveActionScalarFieldEnum | CorrectiveActionScalarFieldEnum[]
  }

  /**
   * User.verifiedActions
   */
  export type User$verifiedActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
    where?: CorrectiveActionWhereInput
    orderBy?: CorrectiveActionOrderByWithRelationInput | CorrectiveActionOrderByWithRelationInput[]
    cursor?: CorrectiveActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CorrectiveActionScalarFieldEnum | CorrectiveActionScalarFieldEnum[]
  }

  /**
   * User.uploadedAuditDocuments
   */
  export type User$uploadedAuditDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentInclude<ExtArgs> | null
    where?: AuditDocumentWhereInput
    orderBy?: AuditDocumentOrderByWithRelationInput | AuditDocumentOrderByWithRelationInput[]
    cursor?: AuditDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditDocumentScalarFieldEnum | AuditDocumentScalarFieldEnum[]
  }

  /**
   * User.createdReminders
   */
  export type User$createdRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderInclude<ExtArgs> | null
    where?: AuditReminderWhereInput
    orderBy?: AuditReminderOrderByWithRelationInput | AuditReminderOrderByWithRelationInput[]
    cursor?: AuditReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditReminderScalarFieldEnum | AuditReminderScalarFieldEnum[]
  }

  /**
   * User.receivedReminders
   */
  export type User$receivedRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderInclude<ExtArgs> | null
    where?: AuditReminderWhereInput
    orderBy?: AuditReminderOrderByWithRelationInput | AuditReminderOrderByWithRelationInput[]
    cursor?: AuditReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditReminderScalarFieldEnum | AuditReminderScalarFieldEnum[]
  }

  /**
   * User.auditNotifications
   */
  export type User$auditNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationInclude<ExtArgs> | null
    where?: AuditNotificationWhereInput
    orderBy?: AuditNotificationOrderByWithRelationInput | AuditNotificationOrderByWithRelationInput[]
    cursor?: AuditNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditNotificationScalarFieldEnum | AuditNotificationScalarFieldEnum[]
  }

  /**
   * User.responsibleForChecklistItems
   */
  export type User$responsibleForChecklistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemInclude<ExtArgs> | null
    where?: PreAuditChecklistItemWhereInput
    orderBy?: PreAuditChecklistItemOrderByWithRelationInput | PreAuditChecklistItemOrderByWithRelationInput[]
    cursor?: PreAuditChecklistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreAuditChecklistItemScalarFieldEnum | PreAuditChecklistItemScalarFieldEnum[]
  }

  /**
   * User.createdChecklistItems
   */
  export type User$createdChecklistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemInclude<ExtArgs> | null
    where?: PreAuditChecklistItemWhereInput
    orderBy?: PreAuditChecklistItemOrderByWithRelationInput | PreAuditChecklistItemOrderByWithRelationInput[]
    cursor?: PreAuditChecklistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreAuditChecklistItemScalarFieldEnum | PreAuditChecklistItemScalarFieldEnum[]
  }

  /**
   * User.inspectedItems
   */
  export type User$inspectedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemInclude<ExtArgs> | null
    where?: AuditInspectionItemWhereInput
    orderBy?: AuditInspectionItemOrderByWithRelationInput | AuditInspectionItemOrderByWithRelationInput[]
    cursor?: AuditInspectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditInspectionItemScalarFieldEnum | AuditInspectionItemScalarFieldEnum[]
  }

  /**
   * User.uploadedFeedbackForms
   */
  export type User$uploadedFeedbackFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
    where?: FeedbackFormWhereInput
    orderBy?: FeedbackFormOrderByWithRelationInput | FeedbackFormOrderByWithRelationInput[]
    cursor?: FeedbackFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackFormScalarFieldEnum | FeedbackFormScalarFieldEnum[]
  }

  /**
   * User.uploadedSessionPhotos
   */
  export type User$uploadedSessionPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoInclude<ExtArgs> | null
    where?: TrainingSessionPhotoWhereInput
    orderBy?: TrainingSessionPhotoOrderByWithRelationInput | TrainingSessionPhotoOrderByWithRelationInput[]
    cursor?: TrainingSessionPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingSessionPhotoScalarFieldEnum | TrainingSessionPhotoScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Standard
   */

  export type AggregateStandard = {
    _count: StandardCountAggregateOutputType | null
    _min: StandardMinAggregateOutputType | null
    _max: StandardMaxAggregateOutputType | null
  }

  export type StandardMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    categoryId: string | null
    createdById: string | null
    modifiedById: string | null
    status: $Enums.StandardStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    categoryId: string | null
    createdById: string | null
    modifiedById: string | null
    status: $Enums.StandardStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    categoryId: number
    createdById: number
    modifiedById: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StandardMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    categoryId?: true
    createdById?: true
    modifiedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    categoryId?: true
    createdById?: true
    modifiedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    categoryId?: true
    createdById?: true
    modifiedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StandardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Standard to aggregate.
     */
    where?: StandardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standards to fetch.
     */
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StandardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Standards
    **/
    _count?: true | StandardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StandardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StandardMaxAggregateInputType
  }

  export type GetStandardAggregateType<T extends StandardAggregateArgs> = {
        [P in keyof T & keyof AggregateStandard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStandard[P]>
      : GetScalarType<T[P], AggregateStandard[P]>
  }




  export type StandardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithAggregationInput | StandardOrderByWithAggregationInput[]
    by: StandardScalarFieldEnum[] | StandardScalarFieldEnum
    having?: StandardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StandardCountAggregateInputType | true
    _min?: StandardMinAggregateInputType
    _max?: StandardMaxAggregateInputType
  }

  export type StandardGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    modifiedById: string | null
    status: $Enums.StandardStatus
    createdAt: Date
    updatedAt: Date
    _count: StandardCountAggregateOutputType | null
    _min: StandardMinAggregateOutputType | null
    _max: StandardMaxAggregateOutputType | null
  }

  type GetStandardGroupByPayload<T extends StandardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StandardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StandardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StandardGroupByOutputType[P]>
            : GetScalarType<T[P], StandardGroupByOutputType[P]>
        }
      >
    >


  export type StandardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | Standard$ModifiedByArgs<ExtArgs>
    batches?: boolean | Standard$batchesArgs<ExtArgs>
    methodologies?: boolean | Standard$methodologiesArgs<ExtArgs>
    units?: boolean | Standard$unitsArgs<ExtArgs>
    _count?: boolean | StandardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["standard"]>

  export type StandardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | Standard$ModifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["standard"]>

  export type StandardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | Standard$ModifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["standard"]>

  export type StandardSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StandardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "categoryId" | "createdById" | "modifiedById" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["standard"]>
  export type StandardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | Standard$ModifiedByArgs<ExtArgs>
    batches?: boolean | Standard$batchesArgs<ExtArgs>
    methodologies?: boolean | Standard$methodologiesArgs<ExtArgs>
    units?: boolean | Standard$unitsArgs<ExtArgs>
    _count?: boolean | StandardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StandardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | Standard$ModifiedByArgs<ExtArgs>
  }
  export type StandardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | Standard$ModifiedByArgs<ExtArgs>
  }

  export type $StandardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Standard"
    objects: {
      Category: Prisma.$StandardCategoryPayload<ExtArgs>
      CreatedBy: Prisma.$UserPayload<ExtArgs>
      ModifiedBy: Prisma.$UserPayload<ExtArgs> | null
      batches: Prisma.$BatchPayload<ExtArgs>[]
      methodologies: Prisma.$MethodologyPayload<ExtArgs>[]
      units: Prisma.$UnitOfMeasurementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string
      categoryId: string
      createdById: string
      modifiedById: string | null
      status: $Enums.StandardStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["standard"]>
    composites: {}
  }

  type StandardGetPayload<S extends boolean | null | undefined | StandardDefaultArgs> = $Result.GetResult<Prisma.$StandardPayload, S>

  type StandardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StandardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StandardCountAggregateInputType | true
    }

  export interface StandardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Standard'], meta: { name: 'Standard' } }
    /**
     * Find zero or one Standard that matches the filter.
     * @param {StandardFindUniqueArgs} args - Arguments to find a Standard
     * @example
     * // Get one Standard
     * const standard = await prisma.standard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StandardFindUniqueArgs>(args: SelectSubset<T, StandardFindUniqueArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Standard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StandardFindUniqueOrThrowArgs} args - Arguments to find a Standard
     * @example
     * // Get one Standard
     * const standard = await prisma.standard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StandardFindUniqueOrThrowArgs>(args: SelectSubset<T, StandardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Standard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardFindFirstArgs} args - Arguments to find a Standard
     * @example
     * // Get one Standard
     * const standard = await prisma.standard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StandardFindFirstArgs>(args?: SelectSubset<T, StandardFindFirstArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Standard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardFindFirstOrThrowArgs} args - Arguments to find a Standard
     * @example
     * // Get one Standard
     * const standard = await prisma.standard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StandardFindFirstOrThrowArgs>(args?: SelectSubset<T, StandardFindFirstOrThrowArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Standards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Standards
     * const standards = await prisma.standard.findMany()
     * 
     * // Get first 10 Standards
     * const standards = await prisma.standard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const standardWithIdOnly = await prisma.standard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StandardFindManyArgs>(args?: SelectSubset<T, StandardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Standard.
     * @param {StandardCreateArgs} args - Arguments to create a Standard.
     * @example
     * // Create one Standard
     * const Standard = await prisma.standard.create({
     *   data: {
     *     // ... data to create a Standard
     *   }
     * })
     * 
     */
    create<T extends StandardCreateArgs>(args: SelectSubset<T, StandardCreateArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Standards.
     * @param {StandardCreateManyArgs} args - Arguments to create many Standards.
     * @example
     * // Create many Standards
     * const standard = await prisma.standard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StandardCreateManyArgs>(args?: SelectSubset<T, StandardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Standards and returns the data saved in the database.
     * @param {StandardCreateManyAndReturnArgs} args - Arguments to create many Standards.
     * @example
     * // Create many Standards
     * const standard = await prisma.standard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Standards and only return the `id`
     * const standardWithIdOnly = await prisma.standard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StandardCreateManyAndReturnArgs>(args?: SelectSubset<T, StandardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Standard.
     * @param {StandardDeleteArgs} args - Arguments to delete one Standard.
     * @example
     * // Delete one Standard
     * const Standard = await prisma.standard.delete({
     *   where: {
     *     // ... filter to delete one Standard
     *   }
     * })
     * 
     */
    delete<T extends StandardDeleteArgs>(args: SelectSubset<T, StandardDeleteArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Standard.
     * @param {StandardUpdateArgs} args - Arguments to update one Standard.
     * @example
     * // Update one Standard
     * const standard = await prisma.standard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StandardUpdateArgs>(args: SelectSubset<T, StandardUpdateArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Standards.
     * @param {StandardDeleteManyArgs} args - Arguments to filter Standards to delete.
     * @example
     * // Delete a few Standards
     * const { count } = await prisma.standard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StandardDeleteManyArgs>(args?: SelectSubset<T, StandardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Standards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Standards
     * const standard = await prisma.standard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StandardUpdateManyArgs>(args: SelectSubset<T, StandardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Standards and returns the data updated in the database.
     * @param {StandardUpdateManyAndReturnArgs} args - Arguments to update many Standards.
     * @example
     * // Update many Standards
     * const standard = await prisma.standard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Standards and only return the `id`
     * const standardWithIdOnly = await prisma.standard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StandardUpdateManyAndReturnArgs>(args: SelectSubset<T, StandardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Standard.
     * @param {StandardUpsertArgs} args - Arguments to update or create a Standard.
     * @example
     * // Update or create a Standard
     * const standard = await prisma.standard.upsert({
     *   create: {
     *     // ... data to create a Standard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Standard we want to update
     *   }
     * })
     */
    upsert<T extends StandardUpsertArgs>(args: SelectSubset<T, StandardUpsertArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Standards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCountArgs} args - Arguments to filter Standards to count.
     * @example
     * // Count the number of Standards
     * const count = await prisma.standard.count({
     *   where: {
     *     // ... the filter for the Standards we want to count
     *   }
     * })
    **/
    count<T extends StandardCountArgs>(
      args?: Subset<T, StandardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StandardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Standard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StandardAggregateArgs>(args: Subset<T, StandardAggregateArgs>): Prisma.PrismaPromise<GetStandardAggregateType<T>>

    /**
     * Group by Standard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StandardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StandardGroupByArgs['orderBy'] }
        : { orderBy?: StandardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StandardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStandardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Standard model
   */
  readonly fields: StandardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Standard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StandardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Category<T extends StandardCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StandardCategoryDefaultArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CreatedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ModifiedBy<T extends Standard$ModifiedByArgs<ExtArgs> = {}>(args?: Subset<T, Standard$ModifiedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    batches<T extends Standard$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Standard$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    methodologies<T extends Standard$methodologiesArgs<ExtArgs> = {}>(args?: Subset<T, Standard$methodologiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    units<T extends Standard$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Standard$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Standard model
   */
  interface StandardFieldRefs {
    readonly id: FieldRef<"Standard", 'String'>
    readonly name: FieldRef<"Standard", 'String'>
    readonly code: FieldRef<"Standard", 'String'>
    readonly description: FieldRef<"Standard", 'String'>
    readonly categoryId: FieldRef<"Standard", 'String'>
    readonly createdById: FieldRef<"Standard", 'String'>
    readonly modifiedById: FieldRef<"Standard", 'String'>
    readonly status: FieldRef<"Standard", 'StandardStatus'>
    readonly createdAt: FieldRef<"Standard", 'DateTime'>
    readonly updatedAt: FieldRef<"Standard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Standard findUnique
   */
  export type StandardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * Filter, which Standard to fetch.
     */
    where: StandardWhereUniqueInput
  }

  /**
   * Standard findUniqueOrThrow
   */
  export type StandardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * Filter, which Standard to fetch.
     */
    where: StandardWhereUniqueInput
  }

  /**
   * Standard findFirst
   */
  export type StandardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * Filter, which Standard to fetch.
     */
    where?: StandardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standards to fetch.
     */
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Standards.
     */
    cursor?: StandardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Standards.
     */
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * Standard findFirstOrThrow
   */
  export type StandardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * Filter, which Standard to fetch.
     */
    where?: StandardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standards to fetch.
     */
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Standards.
     */
    cursor?: StandardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Standards.
     */
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * Standard findMany
   */
  export type StandardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * Filter, which Standards to fetch.
     */
    where?: StandardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standards to fetch.
     */
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Standards.
     */
    cursor?: StandardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standards.
     */
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * Standard create
   */
  export type StandardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * The data needed to create a Standard.
     */
    data: XOR<StandardCreateInput, StandardUncheckedCreateInput>
  }

  /**
   * Standard createMany
   */
  export type StandardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Standards.
     */
    data: StandardCreateManyInput | StandardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Standard createManyAndReturn
   */
  export type StandardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * The data used to create many Standards.
     */
    data: StandardCreateManyInput | StandardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Standard update
   */
  export type StandardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * The data needed to update a Standard.
     */
    data: XOR<StandardUpdateInput, StandardUncheckedUpdateInput>
    /**
     * Choose, which Standard to update.
     */
    where: StandardWhereUniqueInput
  }

  /**
   * Standard updateMany
   */
  export type StandardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Standards.
     */
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyInput>
    /**
     * Filter which Standards to update
     */
    where?: StandardWhereInput
    /**
     * Limit how many Standards to update.
     */
    limit?: number
  }

  /**
   * Standard updateManyAndReturn
   */
  export type StandardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * The data used to update Standards.
     */
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyInput>
    /**
     * Filter which Standards to update
     */
    where?: StandardWhereInput
    /**
     * Limit how many Standards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Standard upsert
   */
  export type StandardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * The filter to search for the Standard to update in case it exists.
     */
    where: StandardWhereUniqueInput
    /**
     * In case the Standard found by the `where` argument doesn't exist, create a new Standard with this data.
     */
    create: XOR<StandardCreateInput, StandardUncheckedCreateInput>
    /**
     * In case the Standard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StandardUpdateInput, StandardUncheckedUpdateInput>
  }

  /**
   * Standard delete
   */
  export type StandardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * Filter which Standard to delete.
     */
    where: StandardWhereUniqueInput
  }

  /**
   * Standard deleteMany
   */
  export type StandardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Standards to delete
     */
    where?: StandardWhereInput
    /**
     * Limit how many Standards to delete.
     */
    limit?: number
  }

  /**
   * Standard.ModifiedBy
   */
  export type Standard$ModifiedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Standard.batches
   */
  export type Standard$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Standard.methodologies
   */
  export type Standard$methodologiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    where?: MethodologyWhereInput
    orderBy?: MethodologyOrderByWithRelationInput | MethodologyOrderByWithRelationInput[]
    cursor?: MethodologyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MethodologyScalarFieldEnum | MethodologyScalarFieldEnum[]
  }

  /**
   * Standard.units
   */
  export type Standard$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    where?: UnitOfMeasurementWhereInput
    orderBy?: UnitOfMeasurementOrderByWithRelationInput | UnitOfMeasurementOrderByWithRelationInput[]
    cursor?: UnitOfMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitOfMeasurementScalarFieldEnum | UnitOfMeasurementScalarFieldEnum[]
  }

  /**
   * Standard without action
   */
  export type StandardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
  }


  /**
   * Model StandardCategory
   */

  export type AggregateStandardCategory = {
    _count: StandardCategoryCountAggregateOutputType | null
    _min: StandardCategoryMinAggregateOutputType | null
    _max: StandardCategoryMaxAggregateOutputType | null
  }

  export type StandardCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StandardCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StandardCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardCategory to aggregate.
     */
    where?: StandardCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardCategories to fetch.
     */
    orderBy?: StandardCategoryOrderByWithRelationInput | StandardCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StandardCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StandardCategories
    **/
    _count?: true | StandardCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StandardCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StandardCategoryMaxAggregateInputType
  }

  export type GetStandardCategoryAggregateType<T extends StandardCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStandardCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStandardCategory[P]>
      : GetScalarType<T[P], AggregateStandardCategory[P]>
  }




  export type StandardCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardCategoryWhereInput
    orderBy?: StandardCategoryOrderByWithAggregationInput | StandardCategoryOrderByWithAggregationInput[]
    by: StandardCategoryScalarFieldEnum[] | StandardCategoryScalarFieldEnum
    having?: StandardCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StandardCategoryCountAggregateInputType | true
    _min?: StandardCategoryMinAggregateInputType
    _max?: StandardCategoryMaxAggregateInputType
  }

  export type StandardCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: StandardCategoryCountAggregateOutputType | null
    _min: StandardCategoryMinAggregateOutputType | null
    _max: StandardCategoryMaxAggregateOutputType | null
  }

  type GetStandardCategoryGroupByPayload<T extends StandardCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StandardCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StandardCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StandardCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], StandardCategoryGroupByOutputType[P]>
        }
      >
    >


  export type StandardCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parameters?: boolean | StandardCategory$parametersArgs<ExtArgs>
    Standards?: boolean | StandardCategory$StandardsArgs<ExtArgs>
    products?: boolean | StandardCategory$productsArgs<ExtArgs>
    _count?: boolean | StandardCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["standardCategory"]>

  export type StandardCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["standardCategory"]>

  export type StandardCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["standardCategory"]>

  export type StandardCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StandardCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["standardCategory"]>
  export type StandardCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameters?: boolean | StandardCategory$parametersArgs<ExtArgs>
    Standards?: boolean | StandardCategory$StandardsArgs<ExtArgs>
    products?: boolean | StandardCategory$productsArgs<ExtArgs>
    _count?: boolean | StandardCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StandardCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StandardCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StandardCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StandardCategory"
    objects: {
      parameters: Prisma.$StandardParameterPayload<ExtArgs>[]
      Standards: Prisma.$StandardPayload<ExtArgs>[]
      products: Prisma.$ProductStandardCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["standardCategory"]>
    composites: {}
  }

  type StandardCategoryGetPayload<S extends boolean | null | undefined | StandardCategoryDefaultArgs> = $Result.GetResult<Prisma.$StandardCategoryPayload, S>

  type StandardCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StandardCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StandardCategoryCountAggregateInputType | true
    }

  export interface StandardCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StandardCategory'], meta: { name: 'StandardCategory' } }
    /**
     * Find zero or one StandardCategory that matches the filter.
     * @param {StandardCategoryFindUniqueArgs} args - Arguments to find a StandardCategory
     * @example
     * // Get one StandardCategory
     * const standardCategory = await prisma.standardCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StandardCategoryFindUniqueArgs>(args: SelectSubset<T, StandardCategoryFindUniqueArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StandardCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StandardCategoryFindUniqueOrThrowArgs} args - Arguments to find a StandardCategory
     * @example
     * // Get one StandardCategory
     * const standardCategory = await prisma.standardCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StandardCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, StandardCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StandardCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryFindFirstArgs} args - Arguments to find a StandardCategory
     * @example
     * // Get one StandardCategory
     * const standardCategory = await prisma.standardCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StandardCategoryFindFirstArgs>(args?: SelectSubset<T, StandardCategoryFindFirstArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StandardCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryFindFirstOrThrowArgs} args - Arguments to find a StandardCategory
     * @example
     * // Get one StandardCategory
     * const standardCategory = await prisma.standardCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StandardCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, StandardCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StandardCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StandardCategories
     * const standardCategories = await prisma.standardCategory.findMany()
     * 
     * // Get first 10 StandardCategories
     * const standardCategories = await prisma.standardCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const standardCategoryWithIdOnly = await prisma.standardCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StandardCategoryFindManyArgs>(args?: SelectSubset<T, StandardCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StandardCategory.
     * @param {StandardCategoryCreateArgs} args - Arguments to create a StandardCategory.
     * @example
     * // Create one StandardCategory
     * const StandardCategory = await prisma.standardCategory.create({
     *   data: {
     *     // ... data to create a StandardCategory
     *   }
     * })
     * 
     */
    create<T extends StandardCategoryCreateArgs>(args: SelectSubset<T, StandardCategoryCreateArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StandardCategories.
     * @param {StandardCategoryCreateManyArgs} args - Arguments to create many StandardCategories.
     * @example
     * // Create many StandardCategories
     * const standardCategory = await prisma.standardCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StandardCategoryCreateManyArgs>(args?: SelectSubset<T, StandardCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StandardCategories and returns the data saved in the database.
     * @param {StandardCategoryCreateManyAndReturnArgs} args - Arguments to create many StandardCategories.
     * @example
     * // Create many StandardCategories
     * const standardCategory = await prisma.standardCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StandardCategories and only return the `id`
     * const standardCategoryWithIdOnly = await prisma.standardCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StandardCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, StandardCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StandardCategory.
     * @param {StandardCategoryDeleteArgs} args - Arguments to delete one StandardCategory.
     * @example
     * // Delete one StandardCategory
     * const StandardCategory = await prisma.standardCategory.delete({
     *   where: {
     *     // ... filter to delete one StandardCategory
     *   }
     * })
     * 
     */
    delete<T extends StandardCategoryDeleteArgs>(args: SelectSubset<T, StandardCategoryDeleteArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StandardCategory.
     * @param {StandardCategoryUpdateArgs} args - Arguments to update one StandardCategory.
     * @example
     * // Update one StandardCategory
     * const standardCategory = await prisma.standardCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StandardCategoryUpdateArgs>(args: SelectSubset<T, StandardCategoryUpdateArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StandardCategories.
     * @param {StandardCategoryDeleteManyArgs} args - Arguments to filter StandardCategories to delete.
     * @example
     * // Delete a few StandardCategories
     * const { count } = await prisma.standardCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StandardCategoryDeleteManyArgs>(args?: SelectSubset<T, StandardCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StandardCategories
     * const standardCategory = await prisma.standardCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StandardCategoryUpdateManyArgs>(args: SelectSubset<T, StandardCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardCategories and returns the data updated in the database.
     * @param {StandardCategoryUpdateManyAndReturnArgs} args - Arguments to update many StandardCategories.
     * @example
     * // Update many StandardCategories
     * const standardCategory = await prisma.standardCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StandardCategories and only return the `id`
     * const standardCategoryWithIdOnly = await prisma.standardCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StandardCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, StandardCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StandardCategory.
     * @param {StandardCategoryUpsertArgs} args - Arguments to update or create a StandardCategory.
     * @example
     * // Update or create a StandardCategory
     * const standardCategory = await prisma.standardCategory.upsert({
     *   create: {
     *     // ... data to create a StandardCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StandardCategory we want to update
     *   }
     * })
     */
    upsert<T extends StandardCategoryUpsertArgs>(args: SelectSubset<T, StandardCategoryUpsertArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StandardCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryCountArgs} args - Arguments to filter StandardCategories to count.
     * @example
     * // Count the number of StandardCategories
     * const count = await prisma.standardCategory.count({
     *   where: {
     *     // ... the filter for the StandardCategories we want to count
     *   }
     * })
    **/
    count<T extends StandardCategoryCountArgs>(
      args?: Subset<T, StandardCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StandardCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StandardCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StandardCategoryAggregateArgs>(args: Subset<T, StandardCategoryAggregateArgs>): Prisma.PrismaPromise<GetStandardCategoryAggregateType<T>>

    /**
     * Group by StandardCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StandardCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StandardCategoryGroupByArgs['orderBy'] }
        : { orderBy?: StandardCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StandardCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStandardCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StandardCategory model
   */
  readonly fields: StandardCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StandardCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StandardCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parameters<T extends StandardCategory$parametersArgs<ExtArgs> = {}>(args?: Subset<T, StandardCategory$parametersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Standards<T extends StandardCategory$StandardsArgs<ExtArgs> = {}>(args?: Subset<T, StandardCategory$StandardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends StandardCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, StandardCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStandardCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StandardCategory model
   */
  interface StandardCategoryFieldRefs {
    readonly id: FieldRef<"StandardCategory", 'String'>
    readonly name: FieldRef<"StandardCategory", 'String'>
    readonly description: FieldRef<"StandardCategory", 'String'>
    readonly createdAt: FieldRef<"StandardCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"StandardCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StandardCategory findUnique
   */
  export type StandardCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which StandardCategory to fetch.
     */
    where: StandardCategoryWhereUniqueInput
  }

  /**
   * StandardCategory findUniqueOrThrow
   */
  export type StandardCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which StandardCategory to fetch.
     */
    where: StandardCategoryWhereUniqueInput
  }

  /**
   * StandardCategory findFirst
   */
  export type StandardCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which StandardCategory to fetch.
     */
    where?: StandardCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardCategories to fetch.
     */
    orderBy?: StandardCategoryOrderByWithRelationInput | StandardCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardCategories.
     */
    cursor?: StandardCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardCategories.
     */
    distinct?: StandardCategoryScalarFieldEnum | StandardCategoryScalarFieldEnum[]
  }

  /**
   * StandardCategory findFirstOrThrow
   */
  export type StandardCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which StandardCategory to fetch.
     */
    where?: StandardCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardCategories to fetch.
     */
    orderBy?: StandardCategoryOrderByWithRelationInput | StandardCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardCategories.
     */
    cursor?: StandardCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardCategories.
     */
    distinct?: StandardCategoryScalarFieldEnum | StandardCategoryScalarFieldEnum[]
  }

  /**
   * StandardCategory findMany
   */
  export type StandardCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which StandardCategories to fetch.
     */
    where?: StandardCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardCategories to fetch.
     */
    orderBy?: StandardCategoryOrderByWithRelationInput | StandardCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StandardCategories.
     */
    cursor?: StandardCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardCategories.
     */
    skip?: number
    distinct?: StandardCategoryScalarFieldEnum | StandardCategoryScalarFieldEnum[]
  }

  /**
   * StandardCategory create
   */
  export type StandardCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a StandardCategory.
     */
    data: XOR<StandardCategoryCreateInput, StandardCategoryUncheckedCreateInput>
  }

  /**
   * StandardCategory createMany
   */
  export type StandardCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StandardCategories.
     */
    data: StandardCategoryCreateManyInput | StandardCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StandardCategory createManyAndReturn
   */
  export type StandardCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many StandardCategories.
     */
    data: StandardCategoryCreateManyInput | StandardCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StandardCategory update
   */
  export type StandardCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a StandardCategory.
     */
    data: XOR<StandardCategoryUpdateInput, StandardCategoryUncheckedUpdateInput>
    /**
     * Choose, which StandardCategory to update.
     */
    where: StandardCategoryWhereUniqueInput
  }

  /**
   * StandardCategory updateMany
   */
  export type StandardCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StandardCategories.
     */
    data: XOR<StandardCategoryUpdateManyMutationInput, StandardCategoryUncheckedUpdateManyInput>
    /**
     * Filter which StandardCategories to update
     */
    where?: StandardCategoryWhereInput
    /**
     * Limit how many StandardCategories to update.
     */
    limit?: number
  }

  /**
   * StandardCategory updateManyAndReturn
   */
  export type StandardCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * The data used to update StandardCategories.
     */
    data: XOR<StandardCategoryUpdateManyMutationInput, StandardCategoryUncheckedUpdateManyInput>
    /**
     * Filter which StandardCategories to update
     */
    where?: StandardCategoryWhereInput
    /**
     * Limit how many StandardCategories to update.
     */
    limit?: number
  }

  /**
   * StandardCategory upsert
   */
  export type StandardCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the StandardCategory to update in case it exists.
     */
    where: StandardCategoryWhereUniqueInput
    /**
     * In case the StandardCategory found by the `where` argument doesn't exist, create a new StandardCategory with this data.
     */
    create: XOR<StandardCategoryCreateInput, StandardCategoryUncheckedCreateInput>
    /**
     * In case the StandardCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StandardCategoryUpdateInput, StandardCategoryUncheckedUpdateInput>
  }

  /**
   * StandardCategory delete
   */
  export type StandardCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * Filter which StandardCategory to delete.
     */
    where: StandardCategoryWhereUniqueInput
  }

  /**
   * StandardCategory deleteMany
   */
  export type StandardCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardCategories to delete
     */
    where?: StandardCategoryWhereInput
    /**
     * Limit how many StandardCategories to delete.
     */
    limit?: number
  }

  /**
   * StandardCategory.parameters
   */
  export type StandardCategory$parametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    where?: StandardParameterWhereInput
    orderBy?: StandardParameterOrderByWithRelationInput | StandardParameterOrderByWithRelationInput[]
    cursor?: StandardParameterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardParameterScalarFieldEnum | StandardParameterScalarFieldEnum[]
  }

  /**
   * StandardCategory.Standards
   */
  export type StandardCategory$StandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    cursor?: StandardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * StandardCategory.products
   */
  export type StandardCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryInclude<ExtArgs> | null
    where?: ProductStandardCategoryWhereInput
    orderBy?: ProductStandardCategoryOrderByWithRelationInput | ProductStandardCategoryOrderByWithRelationInput[]
    cursor?: ProductStandardCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductStandardCategoryScalarFieldEnum | ProductStandardCategoryScalarFieldEnum[]
  }

  /**
   * StandardCategory without action
   */
  export type StandardCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ProductStandardCategory
   */

  export type AggregateProductStandardCategory = {
    _count: ProductStandardCategoryCountAggregateOutputType | null
    _min: ProductStandardCategoryMinAggregateOutputType | null
    _max: ProductStandardCategoryMaxAggregateOutputType | null
  }

  export type ProductStandardCategoryMinAggregateOutputType = {
    id: string | null
    productId: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductStandardCategoryMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductStandardCategoryCountAggregateOutputType = {
    id: number
    productId: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductStandardCategoryMinAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductStandardCategoryMaxAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductStandardCategoryCountAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductStandardCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStandardCategory to aggregate.
     */
    where?: ProductStandardCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStandardCategories to fetch.
     */
    orderBy?: ProductStandardCategoryOrderByWithRelationInput | ProductStandardCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductStandardCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStandardCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStandardCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductStandardCategories
    **/
    _count?: true | ProductStandardCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductStandardCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductStandardCategoryMaxAggregateInputType
  }

  export type GetProductStandardCategoryAggregateType<T extends ProductStandardCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductStandardCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductStandardCategory[P]>
      : GetScalarType<T[P], AggregateProductStandardCategory[P]>
  }




  export type ProductStandardCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStandardCategoryWhereInput
    orderBy?: ProductStandardCategoryOrderByWithAggregationInput | ProductStandardCategoryOrderByWithAggregationInput[]
    by: ProductStandardCategoryScalarFieldEnum[] | ProductStandardCategoryScalarFieldEnum
    having?: ProductStandardCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductStandardCategoryCountAggregateInputType | true
    _min?: ProductStandardCategoryMinAggregateInputType
    _max?: ProductStandardCategoryMaxAggregateInputType
  }

  export type ProductStandardCategoryGroupByOutputType = {
    id: string
    productId: string
    categoryId: string
    createdAt: Date
    updatedAt: Date
    _count: ProductStandardCategoryCountAggregateOutputType | null
    _min: ProductStandardCategoryMinAggregateOutputType | null
    _max: ProductStandardCategoryMaxAggregateOutputType | null
  }

  type GetProductStandardCategoryGroupByPayload<T extends ProductStandardCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductStandardCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductStandardCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductStandardCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductStandardCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductStandardCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStandardCategory"]>

  export type ProductStandardCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStandardCategory"]>

  export type ProductStandardCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStandardCategory"]>

  export type ProductStandardCategorySelectScalar = {
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductStandardCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "categoryId" | "createdAt" | "updatedAt", ExtArgs["result"]["productStandardCategory"]>
  export type ProductStandardCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
  }
  export type ProductStandardCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
  }
  export type ProductStandardCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
  }

  export type $ProductStandardCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductStandardCategory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      category: Prisma.$StandardCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      categoryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productStandardCategory"]>
    composites: {}
  }

  type ProductStandardCategoryGetPayload<S extends boolean | null | undefined | ProductStandardCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductStandardCategoryPayload, S>

  type ProductStandardCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductStandardCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductStandardCategoryCountAggregateInputType | true
    }

  export interface ProductStandardCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductStandardCategory'], meta: { name: 'ProductStandardCategory' } }
    /**
     * Find zero or one ProductStandardCategory that matches the filter.
     * @param {ProductStandardCategoryFindUniqueArgs} args - Arguments to find a ProductStandardCategory
     * @example
     * // Get one ProductStandardCategory
     * const productStandardCategory = await prisma.productStandardCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductStandardCategoryFindUniqueArgs>(args: SelectSubset<T, ProductStandardCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductStandardCategoryClient<$Result.GetResult<Prisma.$ProductStandardCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductStandardCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductStandardCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductStandardCategory
     * @example
     * // Get one ProductStandardCategory
     * const productStandardCategory = await prisma.productStandardCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductStandardCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductStandardCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductStandardCategoryClient<$Result.GetResult<Prisma.$ProductStandardCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductStandardCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStandardCategoryFindFirstArgs} args - Arguments to find a ProductStandardCategory
     * @example
     * // Get one ProductStandardCategory
     * const productStandardCategory = await prisma.productStandardCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductStandardCategoryFindFirstArgs>(args?: SelectSubset<T, ProductStandardCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductStandardCategoryClient<$Result.GetResult<Prisma.$ProductStandardCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductStandardCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStandardCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductStandardCategory
     * @example
     * // Get one ProductStandardCategory
     * const productStandardCategory = await prisma.productStandardCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductStandardCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductStandardCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductStandardCategoryClient<$Result.GetResult<Prisma.$ProductStandardCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductStandardCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStandardCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductStandardCategories
     * const productStandardCategories = await prisma.productStandardCategory.findMany()
     * 
     * // Get first 10 ProductStandardCategories
     * const productStandardCategories = await prisma.productStandardCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productStandardCategoryWithIdOnly = await prisma.productStandardCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductStandardCategoryFindManyArgs>(args?: SelectSubset<T, ProductStandardCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStandardCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductStandardCategory.
     * @param {ProductStandardCategoryCreateArgs} args - Arguments to create a ProductStandardCategory.
     * @example
     * // Create one ProductStandardCategory
     * const ProductStandardCategory = await prisma.productStandardCategory.create({
     *   data: {
     *     // ... data to create a ProductStandardCategory
     *   }
     * })
     * 
     */
    create<T extends ProductStandardCategoryCreateArgs>(args: SelectSubset<T, ProductStandardCategoryCreateArgs<ExtArgs>>): Prisma__ProductStandardCategoryClient<$Result.GetResult<Prisma.$ProductStandardCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductStandardCategories.
     * @param {ProductStandardCategoryCreateManyArgs} args - Arguments to create many ProductStandardCategories.
     * @example
     * // Create many ProductStandardCategories
     * const productStandardCategory = await prisma.productStandardCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductStandardCategoryCreateManyArgs>(args?: SelectSubset<T, ProductStandardCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductStandardCategories and returns the data saved in the database.
     * @param {ProductStandardCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductStandardCategories.
     * @example
     * // Create many ProductStandardCategories
     * const productStandardCategory = await prisma.productStandardCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductStandardCategories and only return the `id`
     * const productStandardCategoryWithIdOnly = await prisma.productStandardCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductStandardCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductStandardCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStandardCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductStandardCategory.
     * @param {ProductStandardCategoryDeleteArgs} args - Arguments to delete one ProductStandardCategory.
     * @example
     * // Delete one ProductStandardCategory
     * const ProductStandardCategory = await prisma.productStandardCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductStandardCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductStandardCategoryDeleteArgs>(args: SelectSubset<T, ProductStandardCategoryDeleteArgs<ExtArgs>>): Prisma__ProductStandardCategoryClient<$Result.GetResult<Prisma.$ProductStandardCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductStandardCategory.
     * @param {ProductStandardCategoryUpdateArgs} args - Arguments to update one ProductStandardCategory.
     * @example
     * // Update one ProductStandardCategory
     * const productStandardCategory = await prisma.productStandardCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductStandardCategoryUpdateArgs>(args: SelectSubset<T, ProductStandardCategoryUpdateArgs<ExtArgs>>): Prisma__ProductStandardCategoryClient<$Result.GetResult<Prisma.$ProductStandardCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductStandardCategories.
     * @param {ProductStandardCategoryDeleteManyArgs} args - Arguments to filter ProductStandardCategories to delete.
     * @example
     * // Delete a few ProductStandardCategories
     * const { count } = await prisma.productStandardCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductStandardCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductStandardCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductStandardCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStandardCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductStandardCategories
     * const productStandardCategory = await prisma.productStandardCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductStandardCategoryUpdateManyArgs>(args: SelectSubset<T, ProductStandardCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductStandardCategories and returns the data updated in the database.
     * @param {ProductStandardCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductStandardCategories.
     * @example
     * // Update many ProductStandardCategories
     * const productStandardCategory = await prisma.productStandardCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductStandardCategories and only return the `id`
     * const productStandardCategoryWithIdOnly = await prisma.productStandardCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductStandardCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductStandardCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStandardCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductStandardCategory.
     * @param {ProductStandardCategoryUpsertArgs} args - Arguments to update or create a ProductStandardCategory.
     * @example
     * // Update or create a ProductStandardCategory
     * const productStandardCategory = await prisma.productStandardCategory.upsert({
     *   create: {
     *     // ... data to create a ProductStandardCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductStandardCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductStandardCategoryUpsertArgs>(args: SelectSubset<T, ProductStandardCategoryUpsertArgs<ExtArgs>>): Prisma__ProductStandardCategoryClient<$Result.GetResult<Prisma.$ProductStandardCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductStandardCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStandardCategoryCountArgs} args - Arguments to filter ProductStandardCategories to count.
     * @example
     * // Count the number of ProductStandardCategories
     * const count = await prisma.productStandardCategory.count({
     *   where: {
     *     // ... the filter for the ProductStandardCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductStandardCategoryCountArgs>(
      args?: Subset<T, ProductStandardCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductStandardCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductStandardCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStandardCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductStandardCategoryAggregateArgs>(args: Subset<T, ProductStandardCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductStandardCategoryAggregateType<T>>

    /**
     * Group by ProductStandardCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStandardCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductStandardCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductStandardCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductStandardCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductStandardCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductStandardCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductStandardCategory model
   */
  readonly fields: ProductStandardCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductStandardCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductStandardCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends StandardCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StandardCategoryDefaultArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductStandardCategory model
   */
  interface ProductStandardCategoryFieldRefs {
    readonly id: FieldRef<"ProductStandardCategory", 'String'>
    readonly productId: FieldRef<"ProductStandardCategory", 'String'>
    readonly categoryId: FieldRef<"ProductStandardCategory", 'String'>
    readonly createdAt: FieldRef<"ProductStandardCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductStandardCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductStandardCategory findUnique
   */
  export type ProductStandardCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductStandardCategory to fetch.
     */
    where: ProductStandardCategoryWhereUniqueInput
  }

  /**
   * ProductStandardCategory findUniqueOrThrow
   */
  export type ProductStandardCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductStandardCategory to fetch.
     */
    where: ProductStandardCategoryWhereUniqueInput
  }

  /**
   * ProductStandardCategory findFirst
   */
  export type ProductStandardCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductStandardCategory to fetch.
     */
    where?: ProductStandardCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStandardCategories to fetch.
     */
    orderBy?: ProductStandardCategoryOrderByWithRelationInput | ProductStandardCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStandardCategories.
     */
    cursor?: ProductStandardCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStandardCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStandardCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStandardCategories.
     */
    distinct?: ProductStandardCategoryScalarFieldEnum | ProductStandardCategoryScalarFieldEnum[]
  }

  /**
   * ProductStandardCategory findFirstOrThrow
   */
  export type ProductStandardCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductStandardCategory to fetch.
     */
    where?: ProductStandardCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStandardCategories to fetch.
     */
    orderBy?: ProductStandardCategoryOrderByWithRelationInput | ProductStandardCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStandardCategories.
     */
    cursor?: ProductStandardCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStandardCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStandardCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStandardCategories.
     */
    distinct?: ProductStandardCategoryScalarFieldEnum | ProductStandardCategoryScalarFieldEnum[]
  }

  /**
   * ProductStandardCategory findMany
   */
  export type ProductStandardCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductStandardCategories to fetch.
     */
    where?: ProductStandardCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStandardCategories to fetch.
     */
    orderBy?: ProductStandardCategoryOrderByWithRelationInput | ProductStandardCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductStandardCategories.
     */
    cursor?: ProductStandardCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStandardCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStandardCategories.
     */
    skip?: number
    distinct?: ProductStandardCategoryScalarFieldEnum | ProductStandardCategoryScalarFieldEnum[]
  }

  /**
   * ProductStandardCategory create
   */
  export type ProductStandardCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductStandardCategory.
     */
    data: XOR<ProductStandardCategoryCreateInput, ProductStandardCategoryUncheckedCreateInput>
  }

  /**
   * ProductStandardCategory createMany
   */
  export type ProductStandardCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductStandardCategories.
     */
    data: ProductStandardCategoryCreateManyInput | ProductStandardCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductStandardCategory createManyAndReturn
   */
  export type ProductStandardCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductStandardCategories.
     */
    data: ProductStandardCategoryCreateManyInput | ProductStandardCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductStandardCategory update
   */
  export type ProductStandardCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductStandardCategory.
     */
    data: XOR<ProductStandardCategoryUpdateInput, ProductStandardCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductStandardCategory to update.
     */
    where: ProductStandardCategoryWhereUniqueInput
  }

  /**
   * ProductStandardCategory updateMany
   */
  export type ProductStandardCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductStandardCategories.
     */
    data: XOR<ProductStandardCategoryUpdateManyMutationInput, ProductStandardCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductStandardCategories to update
     */
    where?: ProductStandardCategoryWhereInput
    /**
     * Limit how many ProductStandardCategories to update.
     */
    limit?: number
  }

  /**
   * ProductStandardCategory updateManyAndReturn
   */
  export type ProductStandardCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductStandardCategories.
     */
    data: XOR<ProductStandardCategoryUpdateManyMutationInput, ProductStandardCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductStandardCategories to update
     */
    where?: ProductStandardCategoryWhereInput
    /**
     * Limit how many ProductStandardCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductStandardCategory upsert
   */
  export type ProductStandardCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductStandardCategory to update in case it exists.
     */
    where: ProductStandardCategoryWhereUniqueInput
    /**
     * In case the ProductStandardCategory found by the `where` argument doesn't exist, create a new ProductStandardCategory with this data.
     */
    create: XOR<ProductStandardCategoryCreateInput, ProductStandardCategoryUncheckedCreateInput>
    /**
     * In case the ProductStandardCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductStandardCategoryUpdateInput, ProductStandardCategoryUncheckedUpdateInput>
  }

  /**
   * ProductStandardCategory delete
   */
  export type ProductStandardCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductStandardCategory to delete.
     */
    where: ProductStandardCategoryWhereUniqueInput
  }

  /**
   * ProductStandardCategory deleteMany
   */
  export type ProductStandardCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStandardCategories to delete
     */
    where?: ProductStandardCategoryWhereInput
    /**
     * Limit how many ProductStandardCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductStandardCategory without action
   */
  export type ProductStandardCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStandardCategory
     */
    select?: ProductStandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStandardCategory
     */
    omit?: ProductStandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStandardCategoryInclude<ExtArgs> | null
  }


  /**
   * Model StandardParameter
   */

  export type AggregateStandardParameter = {
    _count: StandardParameterCountAggregateOutputType | null
    _min: StandardParameterMinAggregateOutputType | null
    _max: StandardParameterMaxAggregateOutputType | null
  }

  export type StandardParameterMinAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    unitId: string | null
    productType: string | null
    description: string | null
    dataType: $Enums.ParameterDataType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardParameterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    unitId: string | null
    productType: string | null
    description: string | null
    dataType: $Enums.ParameterDataType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardParameterCountAggregateOutputType = {
    id: number
    name: number
    categoryId: number
    unitId: number
    productType: number
    description: number
    dataType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StandardParameterMinAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    unitId?: true
    productType?: true
    description?: true
    dataType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardParameterMaxAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    unitId?: true
    productType?: true
    description?: true
    dataType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardParameterCountAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    unitId?: true
    productType?: true
    description?: true
    dataType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StandardParameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardParameter to aggregate.
     */
    where?: StandardParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardParameters to fetch.
     */
    orderBy?: StandardParameterOrderByWithRelationInput | StandardParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StandardParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StandardParameters
    **/
    _count?: true | StandardParameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StandardParameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StandardParameterMaxAggregateInputType
  }

  export type GetStandardParameterAggregateType<T extends StandardParameterAggregateArgs> = {
        [P in keyof T & keyof AggregateStandardParameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStandardParameter[P]>
      : GetScalarType<T[P], AggregateStandardParameter[P]>
  }




  export type StandardParameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardParameterWhereInput
    orderBy?: StandardParameterOrderByWithAggregationInput | StandardParameterOrderByWithAggregationInput[]
    by: StandardParameterScalarFieldEnum[] | StandardParameterScalarFieldEnum
    having?: StandardParameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StandardParameterCountAggregateInputType | true
    _min?: StandardParameterMinAggregateInputType
    _max?: StandardParameterMaxAggregateInputType
  }

  export type StandardParameterGroupByOutputType = {
    id: string
    name: string
    categoryId: string
    unitId: string | null
    productType: string | null
    description: string | null
    dataType: $Enums.ParameterDataType
    createdAt: Date
    updatedAt: Date
    _count: StandardParameterCountAggregateOutputType | null
    _min: StandardParameterMinAggregateOutputType | null
    _max: StandardParameterMaxAggregateOutputType | null
  }

  type GetStandardParameterGroupByPayload<T extends StandardParameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StandardParameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StandardParameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StandardParameterGroupByOutputType[P]>
            : GetScalarType<T[P], StandardParameterGroupByOutputType[P]>
        }
      >
    >


  export type StandardParameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    unitId?: boolean
    productType?: boolean
    description?: boolean
    dataType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    batchValues?: boolean | StandardParameter$batchValuesArgs<ExtArgs>
    unit?: boolean | StandardParameter$unitArgs<ExtArgs>
    standards?: boolean | StandardParameter$standardsArgs<ExtArgs>
    products?: boolean | StandardParameter$productsArgs<ExtArgs>
    _count?: boolean | StandardParameterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["standardParameter"]>

  export type StandardParameterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    unitId?: boolean
    productType?: boolean
    description?: boolean
    dataType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    unit?: boolean | StandardParameter$unitArgs<ExtArgs>
  }, ExtArgs["result"]["standardParameter"]>

  export type StandardParameterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    unitId?: boolean
    productType?: boolean
    description?: boolean
    dataType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    unit?: boolean | StandardParameter$unitArgs<ExtArgs>
  }, ExtArgs["result"]["standardParameter"]>

  export type StandardParameterSelectScalar = {
    id?: boolean
    name?: boolean
    categoryId?: boolean
    unitId?: boolean
    productType?: boolean
    description?: boolean
    dataType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StandardParameterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "categoryId" | "unitId" | "productType" | "description" | "dataType" | "createdAt" | "updatedAt", ExtArgs["result"]["standardParameter"]>
  export type StandardParameterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    batchValues?: boolean | StandardParameter$batchValuesArgs<ExtArgs>
    unit?: boolean | StandardParameter$unitArgs<ExtArgs>
    standards?: boolean | StandardParameter$standardsArgs<ExtArgs>
    products?: boolean | StandardParameter$productsArgs<ExtArgs>
    _count?: boolean | StandardParameterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StandardParameterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    unit?: boolean | StandardParameter$unitArgs<ExtArgs>
  }
  export type StandardParameterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    unit?: boolean | StandardParameter$unitArgs<ExtArgs>
  }

  export type $StandardParameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StandardParameter"
    objects: {
      category: Prisma.$StandardCategoryPayload<ExtArgs>
      batchValues: Prisma.$BatchParameterValuePayload<ExtArgs>[]
      unit: Prisma.$UnitOfMeasurementPayload<ExtArgs> | null
      standards: Prisma.$StandardDefinitionPayload<ExtArgs>[]
      products: Prisma.$ProductParameterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      categoryId: string
      unitId: string | null
      productType: string | null
      description: string | null
      dataType: $Enums.ParameterDataType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["standardParameter"]>
    composites: {}
  }

  type StandardParameterGetPayload<S extends boolean | null | undefined | StandardParameterDefaultArgs> = $Result.GetResult<Prisma.$StandardParameterPayload, S>

  type StandardParameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StandardParameterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StandardParameterCountAggregateInputType | true
    }

  export interface StandardParameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StandardParameter'], meta: { name: 'StandardParameter' } }
    /**
     * Find zero or one StandardParameter that matches the filter.
     * @param {StandardParameterFindUniqueArgs} args - Arguments to find a StandardParameter
     * @example
     * // Get one StandardParameter
     * const standardParameter = await prisma.standardParameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StandardParameterFindUniqueArgs>(args: SelectSubset<T, StandardParameterFindUniqueArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StandardParameter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StandardParameterFindUniqueOrThrowArgs} args - Arguments to find a StandardParameter
     * @example
     * // Get one StandardParameter
     * const standardParameter = await prisma.standardParameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StandardParameterFindUniqueOrThrowArgs>(args: SelectSubset<T, StandardParameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StandardParameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterFindFirstArgs} args - Arguments to find a StandardParameter
     * @example
     * // Get one StandardParameter
     * const standardParameter = await prisma.standardParameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StandardParameterFindFirstArgs>(args?: SelectSubset<T, StandardParameterFindFirstArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StandardParameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterFindFirstOrThrowArgs} args - Arguments to find a StandardParameter
     * @example
     * // Get one StandardParameter
     * const standardParameter = await prisma.standardParameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StandardParameterFindFirstOrThrowArgs>(args?: SelectSubset<T, StandardParameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StandardParameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StandardParameters
     * const standardParameters = await prisma.standardParameter.findMany()
     * 
     * // Get first 10 StandardParameters
     * const standardParameters = await prisma.standardParameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const standardParameterWithIdOnly = await prisma.standardParameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StandardParameterFindManyArgs>(args?: SelectSubset<T, StandardParameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StandardParameter.
     * @param {StandardParameterCreateArgs} args - Arguments to create a StandardParameter.
     * @example
     * // Create one StandardParameter
     * const StandardParameter = await prisma.standardParameter.create({
     *   data: {
     *     // ... data to create a StandardParameter
     *   }
     * })
     * 
     */
    create<T extends StandardParameterCreateArgs>(args: SelectSubset<T, StandardParameterCreateArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StandardParameters.
     * @param {StandardParameterCreateManyArgs} args - Arguments to create many StandardParameters.
     * @example
     * // Create many StandardParameters
     * const standardParameter = await prisma.standardParameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StandardParameterCreateManyArgs>(args?: SelectSubset<T, StandardParameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StandardParameters and returns the data saved in the database.
     * @param {StandardParameterCreateManyAndReturnArgs} args - Arguments to create many StandardParameters.
     * @example
     * // Create many StandardParameters
     * const standardParameter = await prisma.standardParameter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StandardParameters and only return the `id`
     * const standardParameterWithIdOnly = await prisma.standardParameter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StandardParameterCreateManyAndReturnArgs>(args?: SelectSubset<T, StandardParameterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StandardParameter.
     * @param {StandardParameterDeleteArgs} args - Arguments to delete one StandardParameter.
     * @example
     * // Delete one StandardParameter
     * const StandardParameter = await prisma.standardParameter.delete({
     *   where: {
     *     // ... filter to delete one StandardParameter
     *   }
     * })
     * 
     */
    delete<T extends StandardParameterDeleteArgs>(args: SelectSubset<T, StandardParameterDeleteArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StandardParameter.
     * @param {StandardParameterUpdateArgs} args - Arguments to update one StandardParameter.
     * @example
     * // Update one StandardParameter
     * const standardParameter = await prisma.standardParameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StandardParameterUpdateArgs>(args: SelectSubset<T, StandardParameterUpdateArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StandardParameters.
     * @param {StandardParameterDeleteManyArgs} args - Arguments to filter StandardParameters to delete.
     * @example
     * // Delete a few StandardParameters
     * const { count } = await prisma.standardParameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StandardParameterDeleteManyArgs>(args?: SelectSubset<T, StandardParameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StandardParameters
     * const standardParameter = await prisma.standardParameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StandardParameterUpdateManyArgs>(args: SelectSubset<T, StandardParameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardParameters and returns the data updated in the database.
     * @param {StandardParameterUpdateManyAndReturnArgs} args - Arguments to update many StandardParameters.
     * @example
     * // Update many StandardParameters
     * const standardParameter = await prisma.standardParameter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StandardParameters and only return the `id`
     * const standardParameterWithIdOnly = await prisma.standardParameter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StandardParameterUpdateManyAndReturnArgs>(args: SelectSubset<T, StandardParameterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StandardParameter.
     * @param {StandardParameterUpsertArgs} args - Arguments to update or create a StandardParameter.
     * @example
     * // Update or create a StandardParameter
     * const standardParameter = await prisma.standardParameter.upsert({
     *   create: {
     *     // ... data to create a StandardParameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StandardParameter we want to update
     *   }
     * })
     */
    upsert<T extends StandardParameterUpsertArgs>(args: SelectSubset<T, StandardParameterUpsertArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StandardParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterCountArgs} args - Arguments to filter StandardParameters to count.
     * @example
     * // Count the number of StandardParameters
     * const count = await prisma.standardParameter.count({
     *   where: {
     *     // ... the filter for the StandardParameters we want to count
     *   }
     * })
    **/
    count<T extends StandardParameterCountArgs>(
      args?: Subset<T, StandardParameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StandardParameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StandardParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StandardParameterAggregateArgs>(args: Subset<T, StandardParameterAggregateArgs>): Prisma.PrismaPromise<GetStandardParameterAggregateType<T>>

    /**
     * Group by StandardParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StandardParameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StandardParameterGroupByArgs['orderBy'] }
        : { orderBy?: StandardParameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StandardParameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStandardParameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StandardParameter model
   */
  readonly fields: StandardParameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StandardParameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StandardParameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends StandardCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StandardCategoryDefaultArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batchValues<T extends StandardParameter$batchValuesArgs<ExtArgs> = {}>(args?: Subset<T, StandardParameter$batchValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unit<T extends StandardParameter$unitArgs<ExtArgs> = {}>(args?: Subset<T, StandardParameter$unitArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    standards<T extends StandardParameter$standardsArgs<ExtArgs> = {}>(args?: Subset<T, StandardParameter$standardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends StandardParameter$productsArgs<ExtArgs> = {}>(args?: Subset<T, StandardParameter$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StandardParameter model
   */
  interface StandardParameterFieldRefs {
    readonly id: FieldRef<"StandardParameter", 'String'>
    readonly name: FieldRef<"StandardParameter", 'String'>
    readonly categoryId: FieldRef<"StandardParameter", 'String'>
    readonly unitId: FieldRef<"StandardParameter", 'String'>
    readonly productType: FieldRef<"StandardParameter", 'String'>
    readonly description: FieldRef<"StandardParameter", 'String'>
    readonly dataType: FieldRef<"StandardParameter", 'ParameterDataType'>
    readonly createdAt: FieldRef<"StandardParameter", 'DateTime'>
    readonly updatedAt: FieldRef<"StandardParameter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StandardParameter findUnique
   */
  export type StandardParameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * Filter, which StandardParameter to fetch.
     */
    where: StandardParameterWhereUniqueInput
  }

  /**
   * StandardParameter findUniqueOrThrow
   */
  export type StandardParameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * Filter, which StandardParameter to fetch.
     */
    where: StandardParameterWhereUniqueInput
  }

  /**
   * StandardParameter findFirst
   */
  export type StandardParameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * Filter, which StandardParameter to fetch.
     */
    where?: StandardParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardParameters to fetch.
     */
    orderBy?: StandardParameterOrderByWithRelationInput | StandardParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardParameters.
     */
    cursor?: StandardParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardParameters.
     */
    distinct?: StandardParameterScalarFieldEnum | StandardParameterScalarFieldEnum[]
  }

  /**
   * StandardParameter findFirstOrThrow
   */
  export type StandardParameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * Filter, which StandardParameter to fetch.
     */
    where?: StandardParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardParameters to fetch.
     */
    orderBy?: StandardParameterOrderByWithRelationInput | StandardParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardParameters.
     */
    cursor?: StandardParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardParameters.
     */
    distinct?: StandardParameterScalarFieldEnum | StandardParameterScalarFieldEnum[]
  }

  /**
   * StandardParameter findMany
   */
  export type StandardParameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * Filter, which StandardParameters to fetch.
     */
    where?: StandardParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardParameters to fetch.
     */
    orderBy?: StandardParameterOrderByWithRelationInput | StandardParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StandardParameters.
     */
    cursor?: StandardParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardParameters.
     */
    skip?: number
    distinct?: StandardParameterScalarFieldEnum | StandardParameterScalarFieldEnum[]
  }

  /**
   * StandardParameter create
   */
  export type StandardParameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * The data needed to create a StandardParameter.
     */
    data: XOR<StandardParameterCreateInput, StandardParameterUncheckedCreateInput>
  }

  /**
   * StandardParameter createMany
   */
  export type StandardParameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StandardParameters.
     */
    data: StandardParameterCreateManyInput | StandardParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StandardParameter createManyAndReturn
   */
  export type StandardParameterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * The data used to create many StandardParameters.
     */
    data: StandardParameterCreateManyInput | StandardParameterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StandardParameter update
   */
  export type StandardParameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * The data needed to update a StandardParameter.
     */
    data: XOR<StandardParameterUpdateInput, StandardParameterUncheckedUpdateInput>
    /**
     * Choose, which StandardParameter to update.
     */
    where: StandardParameterWhereUniqueInput
  }

  /**
   * StandardParameter updateMany
   */
  export type StandardParameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StandardParameters.
     */
    data: XOR<StandardParameterUpdateManyMutationInput, StandardParameterUncheckedUpdateManyInput>
    /**
     * Filter which StandardParameters to update
     */
    where?: StandardParameterWhereInput
    /**
     * Limit how many StandardParameters to update.
     */
    limit?: number
  }

  /**
   * StandardParameter updateManyAndReturn
   */
  export type StandardParameterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * The data used to update StandardParameters.
     */
    data: XOR<StandardParameterUpdateManyMutationInput, StandardParameterUncheckedUpdateManyInput>
    /**
     * Filter which StandardParameters to update
     */
    where?: StandardParameterWhereInput
    /**
     * Limit how many StandardParameters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StandardParameter upsert
   */
  export type StandardParameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * The filter to search for the StandardParameter to update in case it exists.
     */
    where: StandardParameterWhereUniqueInput
    /**
     * In case the StandardParameter found by the `where` argument doesn't exist, create a new StandardParameter with this data.
     */
    create: XOR<StandardParameterCreateInput, StandardParameterUncheckedCreateInput>
    /**
     * In case the StandardParameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StandardParameterUpdateInput, StandardParameterUncheckedUpdateInput>
  }

  /**
   * StandardParameter delete
   */
  export type StandardParameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * Filter which StandardParameter to delete.
     */
    where: StandardParameterWhereUniqueInput
  }

  /**
   * StandardParameter deleteMany
   */
  export type StandardParameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardParameters to delete
     */
    where?: StandardParameterWhereInput
    /**
     * Limit how many StandardParameters to delete.
     */
    limit?: number
  }

  /**
   * StandardParameter.batchValues
   */
  export type StandardParameter$batchValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    where?: BatchParameterValueWhereInput
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    cursor?: BatchParameterValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * StandardParameter.unit
   */
  export type StandardParameter$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    where?: UnitOfMeasurementWhereInput
  }

  /**
   * StandardParameter.standards
   */
  export type StandardParameter$standardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    where?: StandardDefinitionWhereInput
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    cursor?: StandardDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * StandardParameter.products
   */
  export type StandardParameter$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductParameter
     */
    select?: ProductParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductParameter
     */
    omit?: ProductParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductParameterInclude<ExtArgs> | null
    where?: ProductParameterWhereInput
    orderBy?: ProductParameterOrderByWithRelationInput | ProductParameterOrderByWithRelationInput[]
    cursor?: ProductParameterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductParameterScalarFieldEnum | ProductParameterScalarFieldEnum[]
  }

  /**
   * StandardParameter without action
   */
  export type StandardParameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
  }


  /**
   * Model StandardDefinition
   */

  export type AggregateStandardDefinition = {
    _count: StandardDefinitionCountAggregateOutputType | null
    _min: StandardDefinitionMinAggregateOutputType | null
    _max: StandardDefinitionMaxAggregateOutputType | null
  }

  export type StandardDefinitionMinAggregateOutputType = {
    id: string | null
    parameterId: string | null
    standardValue: string | null
    unitId: string | null
    methodologyId: string | null
    createdById: string | null
    modifiedById: string | null
    status: $Enums.StandardStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardDefinitionMaxAggregateOutputType = {
    id: string | null
    parameterId: string | null
    standardValue: string | null
    unitId: string | null
    methodologyId: string | null
    createdById: string | null
    modifiedById: string | null
    status: $Enums.StandardStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardDefinitionCountAggregateOutputType = {
    id: number
    parameterId: number
    standardValue: number
    unitId: number
    methodologyId: number
    createdById: number
    modifiedById: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StandardDefinitionMinAggregateInputType = {
    id?: true
    parameterId?: true
    standardValue?: true
    unitId?: true
    methodologyId?: true
    createdById?: true
    modifiedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardDefinitionMaxAggregateInputType = {
    id?: true
    parameterId?: true
    standardValue?: true
    unitId?: true
    methodologyId?: true
    createdById?: true
    modifiedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardDefinitionCountAggregateInputType = {
    id?: true
    parameterId?: true
    standardValue?: true
    unitId?: true
    methodologyId?: true
    createdById?: true
    modifiedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StandardDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardDefinition to aggregate.
     */
    where?: StandardDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardDefinitions to fetch.
     */
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StandardDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StandardDefinitions
    **/
    _count?: true | StandardDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StandardDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StandardDefinitionMaxAggregateInputType
  }

  export type GetStandardDefinitionAggregateType<T extends StandardDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateStandardDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStandardDefinition[P]>
      : GetScalarType<T[P], AggregateStandardDefinition[P]>
  }




  export type StandardDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardDefinitionWhereInput
    orderBy?: StandardDefinitionOrderByWithAggregationInput | StandardDefinitionOrderByWithAggregationInput[]
    by: StandardDefinitionScalarFieldEnum[] | StandardDefinitionScalarFieldEnum
    having?: StandardDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StandardDefinitionCountAggregateInputType | true
    _min?: StandardDefinitionMinAggregateInputType
    _max?: StandardDefinitionMaxAggregateInputType
  }

  export type StandardDefinitionGroupByOutputType = {
    id: string
    parameterId: string
    standardValue: string
    unitId: string | null
    methodologyId: string | null
    createdById: string
    modifiedById: string | null
    status: $Enums.StandardStatus
    createdAt: Date
    updatedAt: Date
    _count: StandardDefinitionCountAggregateOutputType | null
    _min: StandardDefinitionMinAggregateOutputType | null
    _max: StandardDefinitionMaxAggregateOutputType | null
  }

  type GetStandardDefinitionGroupByPayload<T extends StandardDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StandardDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StandardDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StandardDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], StandardDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type StandardDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parameterId?: boolean
    standardValue?: boolean
    unitId?: boolean
    methodologyId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | StandardDefinition$unitArgs<ExtArgs>
    methodology?: boolean | StandardDefinition$methodologyArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | StandardDefinition$ModifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["standardDefinition"]>

  export type StandardDefinitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parameterId?: boolean
    standardValue?: boolean
    unitId?: boolean
    methodologyId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | StandardDefinition$unitArgs<ExtArgs>
    methodology?: boolean | StandardDefinition$methodologyArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | StandardDefinition$ModifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["standardDefinition"]>

  export type StandardDefinitionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parameterId?: boolean
    standardValue?: boolean
    unitId?: boolean
    methodologyId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | StandardDefinition$unitArgs<ExtArgs>
    methodology?: boolean | StandardDefinition$methodologyArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | StandardDefinition$ModifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["standardDefinition"]>

  export type StandardDefinitionSelectScalar = {
    id?: boolean
    parameterId?: boolean
    standardValue?: boolean
    unitId?: boolean
    methodologyId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StandardDefinitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "parameterId" | "standardValue" | "unitId" | "methodologyId" | "createdById" | "modifiedById" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["standardDefinition"]>
  export type StandardDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | StandardDefinition$unitArgs<ExtArgs>
    methodology?: boolean | StandardDefinition$methodologyArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | StandardDefinition$ModifiedByArgs<ExtArgs>
  }
  export type StandardDefinitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | StandardDefinition$unitArgs<ExtArgs>
    methodology?: boolean | StandardDefinition$methodologyArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | StandardDefinition$ModifiedByArgs<ExtArgs>
  }
  export type StandardDefinitionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | StandardDefinition$unitArgs<ExtArgs>
    methodology?: boolean | StandardDefinition$methodologyArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | StandardDefinition$ModifiedByArgs<ExtArgs>
  }

  export type $StandardDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StandardDefinition"
    objects: {
      parameter: Prisma.$StandardParameterPayload<ExtArgs>
      unit: Prisma.$UnitOfMeasurementPayload<ExtArgs> | null
      methodology: Prisma.$MethodologyPayload<ExtArgs> | null
      CreatedBy: Prisma.$UserPayload<ExtArgs>
      ModifiedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      parameterId: string
      standardValue: string
      unitId: string | null
      methodologyId: string | null
      createdById: string
      modifiedById: string | null
      status: $Enums.StandardStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["standardDefinition"]>
    composites: {}
  }

  type StandardDefinitionGetPayload<S extends boolean | null | undefined | StandardDefinitionDefaultArgs> = $Result.GetResult<Prisma.$StandardDefinitionPayload, S>

  type StandardDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StandardDefinitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StandardDefinitionCountAggregateInputType | true
    }

  export interface StandardDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StandardDefinition'], meta: { name: 'StandardDefinition' } }
    /**
     * Find zero or one StandardDefinition that matches the filter.
     * @param {StandardDefinitionFindUniqueArgs} args - Arguments to find a StandardDefinition
     * @example
     * // Get one StandardDefinition
     * const standardDefinition = await prisma.standardDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StandardDefinitionFindUniqueArgs>(args: SelectSubset<T, StandardDefinitionFindUniqueArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StandardDefinition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StandardDefinitionFindUniqueOrThrowArgs} args - Arguments to find a StandardDefinition
     * @example
     * // Get one StandardDefinition
     * const standardDefinition = await prisma.standardDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StandardDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, StandardDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StandardDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionFindFirstArgs} args - Arguments to find a StandardDefinition
     * @example
     * // Get one StandardDefinition
     * const standardDefinition = await prisma.standardDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StandardDefinitionFindFirstArgs>(args?: SelectSubset<T, StandardDefinitionFindFirstArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StandardDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionFindFirstOrThrowArgs} args - Arguments to find a StandardDefinition
     * @example
     * // Get one StandardDefinition
     * const standardDefinition = await prisma.standardDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StandardDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, StandardDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StandardDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StandardDefinitions
     * const standardDefinitions = await prisma.standardDefinition.findMany()
     * 
     * // Get first 10 StandardDefinitions
     * const standardDefinitions = await prisma.standardDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const standardDefinitionWithIdOnly = await prisma.standardDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StandardDefinitionFindManyArgs>(args?: SelectSubset<T, StandardDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StandardDefinition.
     * @param {StandardDefinitionCreateArgs} args - Arguments to create a StandardDefinition.
     * @example
     * // Create one StandardDefinition
     * const StandardDefinition = await prisma.standardDefinition.create({
     *   data: {
     *     // ... data to create a StandardDefinition
     *   }
     * })
     * 
     */
    create<T extends StandardDefinitionCreateArgs>(args: SelectSubset<T, StandardDefinitionCreateArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StandardDefinitions.
     * @param {StandardDefinitionCreateManyArgs} args - Arguments to create many StandardDefinitions.
     * @example
     * // Create many StandardDefinitions
     * const standardDefinition = await prisma.standardDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StandardDefinitionCreateManyArgs>(args?: SelectSubset<T, StandardDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StandardDefinitions and returns the data saved in the database.
     * @param {StandardDefinitionCreateManyAndReturnArgs} args - Arguments to create many StandardDefinitions.
     * @example
     * // Create many StandardDefinitions
     * const standardDefinition = await prisma.standardDefinition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StandardDefinitions and only return the `id`
     * const standardDefinitionWithIdOnly = await prisma.standardDefinition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StandardDefinitionCreateManyAndReturnArgs>(args?: SelectSubset<T, StandardDefinitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StandardDefinition.
     * @param {StandardDefinitionDeleteArgs} args - Arguments to delete one StandardDefinition.
     * @example
     * // Delete one StandardDefinition
     * const StandardDefinition = await prisma.standardDefinition.delete({
     *   where: {
     *     // ... filter to delete one StandardDefinition
     *   }
     * })
     * 
     */
    delete<T extends StandardDefinitionDeleteArgs>(args: SelectSubset<T, StandardDefinitionDeleteArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StandardDefinition.
     * @param {StandardDefinitionUpdateArgs} args - Arguments to update one StandardDefinition.
     * @example
     * // Update one StandardDefinition
     * const standardDefinition = await prisma.standardDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StandardDefinitionUpdateArgs>(args: SelectSubset<T, StandardDefinitionUpdateArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StandardDefinitions.
     * @param {StandardDefinitionDeleteManyArgs} args - Arguments to filter StandardDefinitions to delete.
     * @example
     * // Delete a few StandardDefinitions
     * const { count } = await prisma.standardDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StandardDefinitionDeleteManyArgs>(args?: SelectSubset<T, StandardDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StandardDefinitions
     * const standardDefinition = await prisma.standardDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StandardDefinitionUpdateManyArgs>(args: SelectSubset<T, StandardDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardDefinitions and returns the data updated in the database.
     * @param {StandardDefinitionUpdateManyAndReturnArgs} args - Arguments to update many StandardDefinitions.
     * @example
     * // Update many StandardDefinitions
     * const standardDefinition = await prisma.standardDefinition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StandardDefinitions and only return the `id`
     * const standardDefinitionWithIdOnly = await prisma.standardDefinition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StandardDefinitionUpdateManyAndReturnArgs>(args: SelectSubset<T, StandardDefinitionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StandardDefinition.
     * @param {StandardDefinitionUpsertArgs} args - Arguments to update or create a StandardDefinition.
     * @example
     * // Update or create a StandardDefinition
     * const standardDefinition = await prisma.standardDefinition.upsert({
     *   create: {
     *     // ... data to create a StandardDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StandardDefinition we want to update
     *   }
     * })
     */
    upsert<T extends StandardDefinitionUpsertArgs>(args: SelectSubset<T, StandardDefinitionUpsertArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StandardDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionCountArgs} args - Arguments to filter StandardDefinitions to count.
     * @example
     * // Count the number of StandardDefinitions
     * const count = await prisma.standardDefinition.count({
     *   where: {
     *     // ... the filter for the StandardDefinitions we want to count
     *   }
     * })
    **/
    count<T extends StandardDefinitionCountArgs>(
      args?: Subset<T, StandardDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StandardDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StandardDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StandardDefinitionAggregateArgs>(args: Subset<T, StandardDefinitionAggregateArgs>): Prisma.PrismaPromise<GetStandardDefinitionAggregateType<T>>

    /**
     * Group by StandardDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StandardDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StandardDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: StandardDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StandardDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStandardDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StandardDefinition model
   */
  readonly fields: StandardDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StandardDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StandardDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parameter<T extends StandardParameterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StandardParameterDefaultArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends StandardDefinition$unitArgs<ExtArgs> = {}>(args?: Subset<T, StandardDefinition$unitArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    methodology<T extends StandardDefinition$methodologyArgs<ExtArgs> = {}>(args?: Subset<T, StandardDefinition$methodologyArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    CreatedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ModifiedBy<T extends StandardDefinition$ModifiedByArgs<ExtArgs> = {}>(args?: Subset<T, StandardDefinition$ModifiedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StandardDefinition model
   */
  interface StandardDefinitionFieldRefs {
    readonly id: FieldRef<"StandardDefinition", 'String'>
    readonly parameterId: FieldRef<"StandardDefinition", 'String'>
    readonly standardValue: FieldRef<"StandardDefinition", 'String'>
    readonly unitId: FieldRef<"StandardDefinition", 'String'>
    readonly methodologyId: FieldRef<"StandardDefinition", 'String'>
    readonly createdById: FieldRef<"StandardDefinition", 'String'>
    readonly modifiedById: FieldRef<"StandardDefinition", 'String'>
    readonly status: FieldRef<"StandardDefinition", 'StandardStatus'>
    readonly createdAt: FieldRef<"StandardDefinition", 'DateTime'>
    readonly updatedAt: FieldRef<"StandardDefinition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StandardDefinition findUnique
   */
  export type StandardDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which StandardDefinition to fetch.
     */
    where: StandardDefinitionWhereUniqueInput
  }

  /**
   * StandardDefinition findUniqueOrThrow
   */
  export type StandardDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which StandardDefinition to fetch.
     */
    where: StandardDefinitionWhereUniqueInput
  }

  /**
   * StandardDefinition findFirst
   */
  export type StandardDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which StandardDefinition to fetch.
     */
    where?: StandardDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardDefinitions to fetch.
     */
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardDefinitions.
     */
    cursor?: StandardDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardDefinitions.
     */
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * StandardDefinition findFirstOrThrow
   */
  export type StandardDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which StandardDefinition to fetch.
     */
    where?: StandardDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardDefinitions to fetch.
     */
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardDefinitions.
     */
    cursor?: StandardDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardDefinitions.
     */
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * StandardDefinition findMany
   */
  export type StandardDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which StandardDefinitions to fetch.
     */
    where?: StandardDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardDefinitions to fetch.
     */
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StandardDefinitions.
     */
    cursor?: StandardDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardDefinitions.
     */
    skip?: number
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * StandardDefinition create
   */
  export type StandardDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a StandardDefinition.
     */
    data: XOR<StandardDefinitionCreateInput, StandardDefinitionUncheckedCreateInput>
  }

  /**
   * StandardDefinition createMany
   */
  export type StandardDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StandardDefinitions.
     */
    data: StandardDefinitionCreateManyInput | StandardDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StandardDefinition createManyAndReturn
   */
  export type StandardDefinitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * The data used to create many StandardDefinitions.
     */
    data: StandardDefinitionCreateManyInput | StandardDefinitionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StandardDefinition update
   */
  export type StandardDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a StandardDefinition.
     */
    data: XOR<StandardDefinitionUpdateInput, StandardDefinitionUncheckedUpdateInput>
    /**
     * Choose, which StandardDefinition to update.
     */
    where: StandardDefinitionWhereUniqueInput
  }

  /**
   * StandardDefinition updateMany
   */
  export type StandardDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StandardDefinitions.
     */
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which StandardDefinitions to update
     */
    where?: StandardDefinitionWhereInput
    /**
     * Limit how many StandardDefinitions to update.
     */
    limit?: number
  }

  /**
   * StandardDefinition updateManyAndReturn
   */
  export type StandardDefinitionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * The data used to update StandardDefinitions.
     */
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which StandardDefinitions to update
     */
    where?: StandardDefinitionWhereInput
    /**
     * Limit how many StandardDefinitions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StandardDefinition upsert
   */
  export type StandardDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the StandardDefinition to update in case it exists.
     */
    where: StandardDefinitionWhereUniqueInput
    /**
     * In case the StandardDefinition found by the `where` argument doesn't exist, create a new StandardDefinition with this data.
     */
    create: XOR<StandardDefinitionCreateInput, StandardDefinitionUncheckedCreateInput>
    /**
     * In case the StandardDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StandardDefinitionUpdateInput, StandardDefinitionUncheckedUpdateInput>
  }

  /**
   * StandardDefinition delete
   */
  export type StandardDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * Filter which StandardDefinition to delete.
     */
    where: StandardDefinitionWhereUniqueInput
  }

  /**
   * StandardDefinition deleteMany
   */
  export type StandardDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardDefinitions to delete
     */
    where?: StandardDefinitionWhereInput
    /**
     * Limit how many StandardDefinitions to delete.
     */
    limit?: number
  }

  /**
   * StandardDefinition.unit
   */
  export type StandardDefinition$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    where?: UnitOfMeasurementWhereInput
  }

  /**
   * StandardDefinition.methodology
   */
  export type StandardDefinition$methodologyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    where?: MethodologyWhereInput
  }

  /**
   * StandardDefinition.ModifiedBy
   */
  export type StandardDefinition$ModifiedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StandardDefinition without action
   */
  export type StandardDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model BatchParameterValue
   */

  export type AggregateBatchParameterValue = {
    _count: BatchParameterValueCountAggregateOutputType | null
    _min: BatchParameterValueMinAggregateOutputType | null
    _max: BatchParameterValueMaxAggregateOutputType | null
  }

  export type BatchParameterValueMinAggregateOutputType = {
    id: string | null
    batchId: string | null
    parameterId: string | null
    value: string | null
    unitId: string | null
    methodologyId: string | null
    verificationResult: string | null
    verificationRemark: string | null
    verifiedById: string | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchParameterValueMaxAggregateOutputType = {
    id: string | null
    batchId: string | null
    parameterId: string | null
    value: string | null
    unitId: string | null
    methodologyId: string | null
    verificationResult: string | null
    verificationRemark: string | null
    verifiedById: string | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchParameterValueCountAggregateOutputType = {
    id: number
    batchId: number
    parameterId: number
    value: number
    unitId: number
    methodologyId: number
    verificationResult: number
    verificationRemark: number
    verifiedById: number
    verifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BatchParameterValueMinAggregateInputType = {
    id?: true
    batchId?: true
    parameterId?: true
    value?: true
    unitId?: true
    methodologyId?: true
    verificationResult?: true
    verificationRemark?: true
    verifiedById?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchParameterValueMaxAggregateInputType = {
    id?: true
    batchId?: true
    parameterId?: true
    value?: true
    unitId?: true
    methodologyId?: true
    verificationResult?: true
    verificationRemark?: true
    verifiedById?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchParameterValueCountAggregateInputType = {
    id?: true
    batchId?: true
    parameterId?: true
    value?: true
    unitId?: true
    methodologyId?: true
    verificationResult?: true
    verificationRemark?: true
    verifiedById?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BatchParameterValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchParameterValue to aggregate.
     */
    where?: BatchParameterValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchParameterValues to fetch.
     */
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchParameterValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchParameterValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchParameterValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BatchParameterValues
    **/
    _count?: true | BatchParameterValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchParameterValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchParameterValueMaxAggregateInputType
  }

  export type GetBatchParameterValueAggregateType<T extends BatchParameterValueAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchParameterValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchParameterValue[P]>
      : GetScalarType<T[P], AggregateBatchParameterValue[P]>
  }




  export type BatchParameterValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchParameterValueWhereInput
    orderBy?: BatchParameterValueOrderByWithAggregationInput | BatchParameterValueOrderByWithAggregationInput[]
    by: BatchParameterValueScalarFieldEnum[] | BatchParameterValueScalarFieldEnum
    having?: BatchParameterValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchParameterValueCountAggregateInputType | true
    _min?: BatchParameterValueMinAggregateInputType
    _max?: BatchParameterValueMaxAggregateInputType
  }

  export type BatchParameterValueGroupByOutputType = {
    id: string
    batchId: string
    parameterId: string
    value: string
    unitId: string | null
    methodologyId: string | null
    verificationResult: string | null
    verificationRemark: string | null
    verifiedById: string | null
    verifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BatchParameterValueCountAggregateOutputType | null
    _min: BatchParameterValueMinAggregateOutputType | null
    _max: BatchParameterValueMaxAggregateOutputType | null
  }

  type GetBatchParameterValueGroupByPayload<T extends BatchParameterValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchParameterValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchParameterValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchParameterValueGroupByOutputType[P]>
            : GetScalarType<T[P], BatchParameterValueGroupByOutputType[P]>
        }
      >
    >


  export type BatchParameterValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    parameterId?: boolean
    value?: boolean
    unitId?: boolean
    methodologyId?: boolean
    verificationResult?: boolean
    verificationRemark?: boolean
    verifiedById?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | BatchParameterValue$unitArgs<ExtArgs>
    methodology?: boolean | BatchParameterValue$methodologyArgs<ExtArgs>
  }, ExtArgs["result"]["batchParameterValue"]>

  export type BatchParameterValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    parameterId?: boolean
    value?: boolean
    unitId?: boolean
    methodologyId?: boolean
    verificationResult?: boolean
    verificationRemark?: boolean
    verifiedById?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | BatchParameterValue$unitArgs<ExtArgs>
    methodology?: boolean | BatchParameterValue$methodologyArgs<ExtArgs>
  }, ExtArgs["result"]["batchParameterValue"]>

  export type BatchParameterValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    parameterId?: boolean
    value?: boolean
    unitId?: boolean
    methodologyId?: boolean
    verificationResult?: boolean
    verificationRemark?: boolean
    verifiedById?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | BatchParameterValue$unitArgs<ExtArgs>
    methodology?: boolean | BatchParameterValue$methodologyArgs<ExtArgs>
  }, ExtArgs["result"]["batchParameterValue"]>

  export type BatchParameterValueSelectScalar = {
    id?: boolean
    batchId?: boolean
    parameterId?: boolean
    value?: boolean
    unitId?: boolean
    methodologyId?: boolean
    verificationResult?: boolean
    verificationRemark?: boolean
    verifiedById?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BatchParameterValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "batchId" | "parameterId" | "value" | "unitId" | "methodologyId" | "verificationResult" | "verificationRemark" | "verifiedById" | "verifiedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["batchParameterValue"]>
  export type BatchParameterValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | BatchParameterValue$unitArgs<ExtArgs>
    methodology?: boolean | BatchParameterValue$methodologyArgs<ExtArgs>
  }
  export type BatchParameterValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | BatchParameterValue$unitArgs<ExtArgs>
    methodology?: boolean | BatchParameterValue$methodologyArgs<ExtArgs>
  }
  export type BatchParameterValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | BatchParameterValue$unitArgs<ExtArgs>
    methodology?: boolean | BatchParameterValue$methodologyArgs<ExtArgs>
  }

  export type $BatchParameterValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BatchParameterValue"
    objects: {
      batch: Prisma.$BatchPayload<ExtArgs>
      parameter: Prisma.$StandardParameterPayload<ExtArgs>
      unit: Prisma.$UnitOfMeasurementPayload<ExtArgs> | null
      methodology: Prisma.$MethodologyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      batchId: string
      parameterId: string
      value: string
      unitId: string | null
      methodologyId: string | null
      verificationResult: string | null
      verificationRemark: string | null
      verifiedById: string | null
      verifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["batchParameterValue"]>
    composites: {}
  }

  type BatchParameterValueGetPayload<S extends boolean | null | undefined | BatchParameterValueDefaultArgs> = $Result.GetResult<Prisma.$BatchParameterValuePayload, S>

  type BatchParameterValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchParameterValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchParameterValueCountAggregateInputType | true
    }

  export interface BatchParameterValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BatchParameterValue'], meta: { name: 'BatchParameterValue' } }
    /**
     * Find zero or one BatchParameterValue that matches the filter.
     * @param {BatchParameterValueFindUniqueArgs} args - Arguments to find a BatchParameterValue
     * @example
     * // Get one BatchParameterValue
     * const batchParameterValue = await prisma.batchParameterValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchParameterValueFindUniqueArgs>(args: SelectSubset<T, BatchParameterValueFindUniqueArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BatchParameterValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchParameterValueFindUniqueOrThrowArgs} args - Arguments to find a BatchParameterValue
     * @example
     * // Get one BatchParameterValue
     * const batchParameterValue = await prisma.batchParameterValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchParameterValueFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchParameterValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchParameterValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueFindFirstArgs} args - Arguments to find a BatchParameterValue
     * @example
     * // Get one BatchParameterValue
     * const batchParameterValue = await prisma.batchParameterValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchParameterValueFindFirstArgs>(args?: SelectSubset<T, BatchParameterValueFindFirstArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchParameterValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueFindFirstOrThrowArgs} args - Arguments to find a BatchParameterValue
     * @example
     * // Get one BatchParameterValue
     * const batchParameterValue = await prisma.batchParameterValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchParameterValueFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchParameterValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BatchParameterValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BatchParameterValues
     * const batchParameterValues = await prisma.batchParameterValue.findMany()
     * 
     * // Get first 10 BatchParameterValues
     * const batchParameterValues = await prisma.batchParameterValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchParameterValueWithIdOnly = await prisma.batchParameterValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchParameterValueFindManyArgs>(args?: SelectSubset<T, BatchParameterValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BatchParameterValue.
     * @param {BatchParameterValueCreateArgs} args - Arguments to create a BatchParameterValue.
     * @example
     * // Create one BatchParameterValue
     * const BatchParameterValue = await prisma.batchParameterValue.create({
     *   data: {
     *     // ... data to create a BatchParameterValue
     *   }
     * })
     * 
     */
    create<T extends BatchParameterValueCreateArgs>(args: SelectSubset<T, BatchParameterValueCreateArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BatchParameterValues.
     * @param {BatchParameterValueCreateManyArgs} args - Arguments to create many BatchParameterValues.
     * @example
     * // Create many BatchParameterValues
     * const batchParameterValue = await prisma.batchParameterValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchParameterValueCreateManyArgs>(args?: SelectSubset<T, BatchParameterValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BatchParameterValues and returns the data saved in the database.
     * @param {BatchParameterValueCreateManyAndReturnArgs} args - Arguments to create many BatchParameterValues.
     * @example
     * // Create many BatchParameterValues
     * const batchParameterValue = await prisma.batchParameterValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BatchParameterValues and only return the `id`
     * const batchParameterValueWithIdOnly = await prisma.batchParameterValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchParameterValueCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchParameterValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BatchParameterValue.
     * @param {BatchParameterValueDeleteArgs} args - Arguments to delete one BatchParameterValue.
     * @example
     * // Delete one BatchParameterValue
     * const BatchParameterValue = await prisma.batchParameterValue.delete({
     *   where: {
     *     // ... filter to delete one BatchParameterValue
     *   }
     * })
     * 
     */
    delete<T extends BatchParameterValueDeleteArgs>(args: SelectSubset<T, BatchParameterValueDeleteArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BatchParameterValue.
     * @param {BatchParameterValueUpdateArgs} args - Arguments to update one BatchParameterValue.
     * @example
     * // Update one BatchParameterValue
     * const batchParameterValue = await prisma.batchParameterValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchParameterValueUpdateArgs>(args: SelectSubset<T, BatchParameterValueUpdateArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BatchParameterValues.
     * @param {BatchParameterValueDeleteManyArgs} args - Arguments to filter BatchParameterValues to delete.
     * @example
     * // Delete a few BatchParameterValues
     * const { count } = await prisma.batchParameterValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchParameterValueDeleteManyArgs>(args?: SelectSubset<T, BatchParameterValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchParameterValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BatchParameterValues
     * const batchParameterValue = await prisma.batchParameterValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchParameterValueUpdateManyArgs>(args: SelectSubset<T, BatchParameterValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchParameterValues and returns the data updated in the database.
     * @param {BatchParameterValueUpdateManyAndReturnArgs} args - Arguments to update many BatchParameterValues.
     * @example
     * // Update many BatchParameterValues
     * const batchParameterValue = await prisma.batchParameterValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BatchParameterValues and only return the `id`
     * const batchParameterValueWithIdOnly = await prisma.batchParameterValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchParameterValueUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchParameterValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BatchParameterValue.
     * @param {BatchParameterValueUpsertArgs} args - Arguments to update or create a BatchParameterValue.
     * @example
     * // Update or create a BatchParameterValue
     * const batchParameterValue = await prisma.batchParameterValue.upsert({
     *   create: {
     *     // ... data to create a BatchParameterValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BatchParameterValue we want to update
     *   }
     * })
     */
    upsert<T extends BatchParameterValueUpsertArgs>(args: SelectSubset<T, BatchParameterValueUpsertArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BatchParameterValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueCountArgs} args - Arguments to filter BatchParameterValues to count.
     * @example
     * // Count the number of BatchParameterValues
     * const count = await prisma.batchParameterValue.count({
     *   where: {
     *     // ... the filter for the BatchParameterValues we want to count
     *   }
     * })
    **/
    count<T extends BatchParameterValueCountArgs>(
      args?: Subset<T, BatchParameterValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchParameterValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BatchParameterValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchParameterValueAggregateArgs>(args: Subset<T, BatchParameterValueAggregateArgs>): Prisma.PrismaPromise<GetBatchParameterValueAggregateType<T>>

    /**
     * Group by BatchParameterValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchParameterValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchParameterValueGroupByArgs['orderBy'] }
        : { orderBy?: BatchParameterValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchParameterValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchParameterValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BatchParameterValue model
   */
  readonly fields: BatchParameterValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BatchParameterValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchParameterValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends BatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatchDefaultArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parameter<T extends StandardParameterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StandardParameterDefaultArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends BatchParameterValue$unitArgs<ExtArgs> = {}>(args?: Subset<T, BatchParameterValue$unitArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    methodology<T extends BatchParameterValue$methodologyArgs<ExtArgs> = {}>(args?: Subset<T, BatchParameterValue$methodologyArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BatchParameterValue model
   */
  interface BatchParameterValueFieldRefs {
    readonly id: FieldRef<"BatchParameterValue", 'String'>
    readonly batchId: FieldRef<"BatchParameterValue", 'String'>
    readonly parameterId: FieldRef<"BatchParameterValue", 'String'>
    readonly value: FieldRef<"BatchParameterValue", 'String'>
    readonly unitId: FieldRef<"BatchParameterValue", 'String'>
    readonly methodologyId: FieldRef<"BatchParameterValue", 'String'>
    readonly verificationResult: FieldRef<"BatchParameterValue", 'String'>
    readonly verificationRemark: FieldRef<"BatchParameterValue", 'String'>
    readonly verifiedById: FieldRef<"BatchParameterValue", 'String'>
    readonly verifiedAt: FieldRef<"BatchParameterValue", 'DateTime'>
    readonly createdAt: FieldRef<"BatchParameterValue", 'DateTime'>
    readonly updatedAt: FieldRef<"BatchParameterValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BatchParameterValue findUnique
   */
  export type BatchParameterValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * Filter, which BatchParameterValue to fetch.
     */
    where: BatchParameterValueWhereUniqueInput
  }

  /**
   * BatchParameterValue findUniqueOrThrow
   */
  export type BatchParameterValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * Filter, which BatchParameterValue to fetch.
     */
    where: BatchParameterValueWhereUniqueInput
  }

  /**
   * BatchParameterValue findFirst
   */
  export type BatchParameterValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * Filter, which BatchParameterValue to fetch.
     */
    where?: BatchParameterValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchParameterValues to fetch.
     */
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchParameterValues.
     */
    cursor?: BatchParameterValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchParameterValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchParameterValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchParameterValues.
     */
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * BatchParameterValue findFirstOrThrow
   */
  export type BatchParameterValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * Filter, which BatchParameterValue to fetch.
     */
    where?: BatchParameterValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchParameterValues to fetch.
     */
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchParameterValues.
     */
    cursor?: BatchParameterValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchParameterValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchParameterValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchParameterValues.
     */
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * BatchParameterValue findMany
   */
  export type BatchParameterValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * Filter, which BatchParameterValues to fetch.
     */
    where?: BatchParameterValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchParameterValues to fetch.
     */
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BatchParameterValues.
     */
    cursor?: BatchParameterValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchParameterValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchParameterValues.
     */
    skip?: number
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * BatchParameterValue create
   */
  export type BatchParameterValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * The data needed to create a BatchParameterValue.
     */
    data: XOR<BatchParameterValueCreateInput, BatchParameterValueUncheckedCreateInput>
  }

  /**
   * BatchParameterValue createMany
   */
  export type BatchParameterValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BatchParameterValues.
     */
    data: BatchParameterValueCreateManyInput | BatchParameterValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BatchParameterValue createManyAndReturn
   */
  export type BatchParameterValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * The data used to create many BatchParameterValues.
     */
    data: BatchParameterValueCreateManyInput | BatchParameterValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchParameterValue update
   */
  export type BatchParameterValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * The data needed to update a BatchParameterValue.
     */
    data: XOR<BatchParameterValueUpdateInput, BatchParameterValueUncheckedUpdateInput>
    /**
     * Choose, which BatchParameterValue to update.
     */
    where: BatchParameterValueWhereUniqueInput
  }

  /**
   * BatchParameterValue updateMany
   */
  export type BatchParameterValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BatchParameterValues.
     */
    data: XOR<BatchParameterValueUpdateManyMutationInput, BatchParameterValueUncheckedUpdateManyInput>
    /**
     * Filter which BatchParameterValues to update
     */
    where?: BatchParameterValueWhereInput
    /**
     * Limit how many BatchParameterValues to update.
     */
    limit?: number
  }

  /**
   * BatchParameterValue updateManyAndReturn
   */
  export type BatchParameterValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * The data used to update BatchParameterValues.
     */
    data: XOR<BatchParameterValueUpdateManyMutationInput, BatchParameterValueUncheckedUpdateManyInput>
    /**
     * Filter which BatchParameterValues to update
     */
    where?: BatchParameterValueWhereInput
    /**
     * Limit how many BatchParameterValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchParameterValue upsert
   */
  export type BatchParameterValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * The filter to search for the BatchParameterValue to update in case it exists.
     */
    where: BatchParameterValueWhereUniqueInput
    /**
     * In case the BatchParameterValue found by the `where` argument doesn't exist, create a new BatchParameterValue with this data.
     */
    create: XOR<BatchParameterValueCreateInput, BatchParameterValueUncheckedCreateInput>
    /**
     * In case the BatchParameterValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchParameterValueUpdateInput, BatchParameterValueUncheckedUpdateInput>
  }

  /**
   * BatchParameterValue delete
   */
  export type BatchParameterValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * Filter which BatchParameterValue to delete.
     */
    where: BatchParameterValueWhereUniqueInput
  }

  /**
   * BatchParameterValue deleteMany
   */
  export type BatchParameterValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchParameterValues to delete
     */
    where?: BatchParameterValueWhereInput
    /**
     * Limit how many BatchParameterValues to delete.
     */
    limit?: number
  }

  /**
   * BatchParameterValue.unit
   */
  export type BatchParameterValue$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    where?: UnitOfMeasurementWhereInput
  }

  /**
   * BatchParameterValue.methodology
   */
  export type BatchParameterValue$methodologyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    where?: MethodologyWhereInput
  }

  /**
   * BatchParameterValue without action
   */
  export type BatchParameterValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
  }


  /**
   * Model TrainingCalendar
   */

  export type AggregateTrainingCalendar = {
    _count: TrainingCalendarCountAggregateOutputType | null
    _avg: TrainingCalendarAvgAggregateOutputType | null
    _sum: TrainingCalendarSumAggregateOutputType | null
    _min: TrainingCalendarMinAggregateOutputType | null
    _max: TrainingCalendarMaxAggregateOutputType | null
  }

  export type TrainingCalendarAvgAggregateOutputType = {
    month: number | null
    year: number | null
  }

  export type TrainingCalendarSumAggregateOutputType = {
    month: number | null
    year: number | null
  }

  export type TrainingCalendarMinAggregateOutputType = {
    id: string | null
    month: number | null
    year: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingCalendarMaxAggregateOutputType = {
    id: string | null
    month: number | null
    year: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingCalendarCountAggregateOutputType = {
    id: number
    month: number
    year: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingCalendarAvgAggregateInputType = {
    month?: true
    year?: true
  }

  export type TrainingCalendarSumAggregateInputType = {
    month?: true
    year?: true
  }

  export type TrainingCalendarMinAggregateInputType = {
    id?: true
    month?: true
    year?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingCalendarMaxAggregateInputType = {
    id?: true
    month?: true
    year?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingCalendarCountAggregateInputType = {
    id?: true
    month?: true
    year?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingCalendarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingCalendar to aggregate.
     */
    where?: TrainingCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingCalendars to fetch.
     */
    orderBy?: TrainingCalendarOrderByWithRelationInput | TrainingCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingCalendars
    **/
    _count?: true | TrainingCalendarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingCalendarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingCalendarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingCalendarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingCalendarMaxAggregateInputType
  }

  export type GetTrainingCalendarAggregateType<T extends TrainingCalendarAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingCalendar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingCalendar[P]>
      : GetScalarType<T[P], AggregateTrainingCalendar[P]>
  }




  export type TrainingCalendarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingCalendarWhereInput
    orderBy?: TrainingCalendarOrderByWithAggregationInput | TrainingCalendarOrderByWithAggregationInput[]
    by: TrainingCalendarScalarFieldEnum[] | TrainingCalendarScalarFieldEnum
    having?: TrainingCalendarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingCalendarCountAggregateInputType | true
    _avg?: TrainingCalendarAvgAggregateInputType
    _sum?: TrainingCalendarSumAggregateInputType
    _min?: TrainingCalendarMinAggregateInputType
    _max?: TrainingCalendarMaxAggregateInputType
  }

  export type TrainingCalendarGroupByOutputType = {
    id: string
    month: number
    year: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TrainingCalendarCountAggregateOutputType | null
    _avg: TrainingCalendarAvgAggregateOutputType | null
    _sum: TrainingCalendarSumAggregateOutputType | null
    _min: TrainingCalendarMinAggregateOutputType | null
    _max: TrainingCalendarMaxAggregateOutputType | null
  }

  type GetTrainingCalendarGroupByPayload<T extends TrainingCalendarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingCalendarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingCalendarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingCalendarGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingCalendarGroupByOutputType[P]>
        }
      >
    >


  export type TrainingCalendarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    year?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainings?: boolean | TrainingCalendar$trainingsArgs<ExtArgs>
    _count?: boolean | TrainingCalendarCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingCalendar"]>

  export type TrainingCalendarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    year?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingCalendar"]>

  export type TrainingCalendarSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    year?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingCalendar"]>

  export type TrainingCalendarSelectScalar = {
    id?: boolean
    month?: boolean
    year?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingCalendarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "year" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingCalendar"]>
  export type TrainingCalendarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | TrainingCalendar$trainingsArgs<ExtArgs>
    _count?: boolean | TrainingCalendarCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingCalendarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TrainingCalendarIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TrainingCalendarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingCalendar"
    objects: {
      trainings: Prisma.$TrainingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      month: number
      year: number
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingCalendar"]>
    composites: {}
  }

  type TrainingCalendarGetPayload<S extends boolean | null | undefined | TrainingCalendarDefaultArgs> = $Result.GetResult<Prisma.$TrainingCalendarPayload, S>

  type TrainingCalendarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingCalendarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingCalendarCountAggregateInputType | true
    }

  export interface TrainingCalendarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingCalendar'], meta: { name: 'TrainingCalendar' } }
    /**
     * Find zero or one TrainingCalendar that matches the filter.
     * @param {TrainingCalendarFindUniqueArgs} args - Arguments to find a TrainingCalendar
     * @example
     * // Get one TrainingCalendar
     * const trainingCalendar = await prisma.trainingCalendar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingCalendarFindUniqueArgs>(args: SelectSubset<T, TrainingCalendarFindUniqueArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingCalendar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingCalendarFindUniqueOrThrowArgs} args - Arguments to find a TrainingCalendar
     * @example
     * // Get one TrainingCalendar
     * const trainingCalendar = await prisma.trainingCalendar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingCalendarFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingCalendarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingCalendar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarFindFirstArgs} args - Arguments to find a TrainingCalendar
     * @example
     * // Get one TrainingCalendar
     * const trainingCalendar = await prisma.trainingCalendar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingCalendarFindFirstArgs>(args?: SelectSubset<T, TrainingCalendarFindFirstArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingCalendar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarFindFirstOrThrowArgs} args - Arguments to find a TrainingCalendar
     * @example
     * // Get one TrainingCalendar
     * const trainingCalendar = await prisma.trainingCalendar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingCalendarFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingCalendarFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingCalendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingCalendars
     * const trainingCalendars = await prisma.trainingCalendar.findMany()
     * 
     * // Get first 10 TrainingCalendars
     * const trainingCalendars = await prisma.trainingCalendar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingCalendarWithIdOnly = await prisma.trainingCalendar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingCalendarFindManyArgs>(args?: SelectSubset<T, TrainingCalendarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingCalendar.
     * @param {TrainingCalendarCreateArgs} args - Arguments to create a TrainingCalendar.
     * @example
     * // Create one TrainingCalendar
     * const TrainingCalendar = await prisma.trainingCalendar.create({
     *   data: {
     *     // ... data to create a TrainingCalendar
     *   }
     * })
     * 
     */
    create<T extends TrainingCalendarCreateArgs>(args: SelectSubset<T, TrainingCalendarCreateArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingCalendars.
     * @param {TrainingCalendarCreateManyArgs} args - Arguments to create many TrainingCalendars.
     * @example
     * // Create many TrainingCalendars
     * const trainingCalendar = await prisma.trainingCalendar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingCalendarCreateManyArgs>(args?: SelectSubset<T, TrainingCalendarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingCalendars and returns the data saved in the database.
     * @param {TrainingCalendarCreateManyAndReturnArgs} args - Arguments to create many TrainingCalendars.
     * @example
     * // Create many TrainingCalendars
     * const trainingCalendar = await prisma.trainingCalendar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingCalendars and only return the `id`
     * const trainingCalendarWithIdOnly = await prisma.trainingCalendar.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingCalendarCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingCalendarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingCalendar.
     * @param {TrainingCalendarDeleteArgs} args - Arguments to delete one TrainingCalendar.
     * @example
     * // Delete one TrainingCalendar
     * const TrainingCalendar = await prisma.trainingCalendar.delete({
     *   where: {
     *     // ... filter to delete one TrainingCalendar
     *   }
     * })
     * 
     */
    delete<T extends TrainingCalendarDeleteArgs>(args: SelectSubset<T, TrainingCalendarDeleteArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingCalendar.
     * @param {TrainingCalendarUpdateArgs} args - Arguments to update one TrainingCalendar.
     * @example
     * // Update one TrainingCalendar
     * const trainingCalendar = await prisma.trainingCalendar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingCalendarUpdateArgs>(args: SelectSubset<T, TrainingCalendarUpdateArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingCalendars.
     * @param {TrainingCalendarDeleteManyArgs} args - Arguments to filter TrainingCalendars to delete.
     * @example
     * // Delete a few TrainingCalendars
     * const { count } = await prisma.trainingCalendar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingCalendarDeleteManyArgs>(args?: SelectSubset<T, TrainingCalendarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingCalendars
     * const trainingCalendar = await prisma.trainingCalendar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingCalendarUpdateManyArgs>(args: SelectSubset<T, TrainingCalendarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingCalendars and returns the data updated in the database.
     * @param {TrainingCalendarUpdateManyAndReturnArgs} args - Arguments to update many TrainingCalendars.
     * @example
     * // Update many TrainingCalendars
     * const trainingCalendar = await prisma.trainingCalendar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingCalendars and only return the `id`
     * const trainingCalendarWithIdOnly = await prisma.trainingCalendar.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingCalendarUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingCalendarUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingCalendar.
     * @param {TrainingCalendarUpsertArgs} args - Arguments to update or create a TrainingCalendar.
     * @example
     * // Update or create a TrainingCalendar
     * const trainingCalendar = await prisma.trainingCalendar.upsert({
     *   create: {
     *     // ... data to create a TrainingCalendar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingCalendar we want to update
     *   }
     * })
     */
    upsert<T extends TrainingCalendarUpsertArgs>(args: SelectSubset<T, TrainingCalendarUpsertArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarCountArgs} args - Arguments to filter TrainingCalendars to count.
     * @example
     * // Count the number of TrainingCalendars
     * const count = await prisma.trainingCalendar.count({
     *   where: {
     *     // ... the filter for the TrainingCalendars we want to count
     *   }
     * })
    **/
    count<T extends TrainingCalendarCountArgs>(
      args?: Subset<T, TrainingCalendarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingCalendarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingCalendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingCalendarAggregateArgs>(args: Subset<T, TrainingCalendarAggregateArgs>): Prisma.PrismaPromise<GetTrainingCalendarAggregateType<T>>

    /**
     * Group by TrainingCalendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingCalendarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingCalendarGroupByArgs['orderBy'] }
        : { orderBy?: TrainingCalendarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingCalendarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingCalendarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingCalendar model
   */
  readonly fields: TrainingCalendarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingCalendar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingCalendarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainings<T extends TrainingCalendar$trainingsArgs<ExtArgs> = {}>(args?: Subset<T, TrainingCalendar$trainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingCalendar model
   */
  interface TrainingCalendarFieldRefs {
    readonly id: FieldRef<"TrainingCalendar", 'String'>
    readonly month: FieldRef<"TrainingCalendar", 'Int'>
    readonly year: FieldRef<"TrainingCalendar", 'Int'>
    readonly description: FieldRef<"TrainingCalendar", 'String'>
    readonly createdAt: FieldRef<"TrainingCalendar", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingCalendar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingCalendar findUnique
   */
  export type TrainingCalendarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * Filter, which TrainingCalendar to fetch.
     */
    where: TrainingCalendarWhereUniqueInput
  }

  /**
   * TrainingCalendar findUniqueOrThrow
   */
  export type TrainingCalendarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * Filter, which TrainingCalendar to fetch.
     */
    where: TrainingCalendarWhereUniqueInput
  }

  /**
   * TrainingCalendar findFirst
   */
  export type TrainingCalendarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * Filter, which TrainingCalendar to fetch.
     */
    where?: TrainingCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingCalendars to fetch.
     */
    orderBy?: TrainingCalendarOrderByWithRelationInput | TrainingCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingCalendars.
     */
    cursor?: TrainingCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingCalendars.
     */
    distinct?: TrainingCalendarScalarFieldEnum | TrainingCalendarScalarFieldEnum[]
  }

  /**
   * TrainingCalendar findFirstOrThrow
   */
  export type TrainingCalendarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * Filter, which TrainingCalendar to fetch.
     */
    where?: TrainingCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingCalendars to fetch.
     */
    orderBy?: TrainingCalendarOrderByWithRelationInput | TrainingCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingCalendars.
     */
    cursor?: TrainingCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingCalendars.
     */
    distinct?: TrainingCalendarScalarFieldEnum | TrainingCalendarScalarFieldEnum[]
  }

  /**
   * TrainingCalendar findMany
   */
  export type TrainingCalendarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * Filter, which TrainingCalendars to fetch.
     */
    where?: TrainingCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingCalendars to fetch.
     */
    orderBy?: TrainingCalendarOrderByWithRelationInput | TrainingCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingCalendars.
     */
    cursor?: TrainingCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingCalendars.
     */
    skip?: number
    distinct?: TrainingCalendarScalarFieldEnum | TrainingCalendarScalarFieldEnum[]
  }

  /**
   * TrainingCalendar create
   */
  export type TrainingCalendarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingCalendar.
     */
    data: XOR<TrainingCalendarCreateInput, TrainingCalendarUncheckedCreateInput>
  }

  /**
   * TrainingCalendar createMany
   */
  export type TrainingCalendarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingCalendars.
     */
    data: TrainingCalendarCreateManyInput | TrainingCalendarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingCalendar createManyAndReturn
   */
  export type TrainingCalendarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingCalendars.
     */
    data: TrainingCalendarCreateManyInput | TrainingCalendarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingCalendar update
   */
  export type TrainingCalendarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingCalendar.
     */
    data: XOR<TrainingCalendarUpdateInput, TrainingCalendarUncheckedUpdateInput>
    /**
     * Choose, which TrainingCalendar to update.
     */
    where: TrainingCalendarWhereUniqueInput
  }

  /**
   * TrainingCalendar updateMany
   */
  export type TrainingCalendarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingCalendars.
     */
    data: XOR<TrainingCalendarUpdateManyMutationInput, TrainingCalendarUncheckedUpdateManyInput>
    /**
     * Filter which TrainingCalendars to update
     */
    where?: TrainingCalendarWhereInput
    /**
     * Limit how many TrainingCalendars to update.
     */
    limit?: number
  }

  /**
   * TrainingCalendar updateManyAndReturn
   */
  export type TrainingCalendarUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * The data used to update TrainingCalendars.
     */
    data: XOR<TrainingCalendarUpdateManyMutationInput, TrainingCalendarUncheckedUpdateManyInput>
    /**
     * Filter which TrainingCalendars to update
     */
    where?: TrainingCalendarWhereInput
    /**
     * Limit how many TrainingCalendars to update.
     */
    limit?: number
  }

  /**
   * TrainingCalendar upsert
   */
  export type TrainingCalendarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingCalendar to update in case it exists.
     */
    where: TrainingCalendarWhereUniqueInput
    /**
     * In case the TrainingCalendar found by the `where` argument doesn't exist, create a new TrainingCalendar with this data.
     */
    create: XOR<TrainingCalendarCreateInput, TrainingCalendarUncheckedCreateInput>
    /**
     * In case the TrainingCalendar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingCalendarUpdateInput, TrainingCalendarUncheckedUpdateInput>
  }

  /**
   * TrainingCalendar delete
   */
  export type TrainingCalendarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * Filter which TrainingCalendar to delete.
     */
    where: TrainingCalendarWhereUniqueInput
  }

  /**
   * TrainingCalendar deleteMany
   */
  export type TrainingCalendarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingCalendars to delete
     */
    where?: TrainingCalendarWhereInput
    /**
     * Limit how many TrainingCalendars to delete.
     */
    limit?: number
  }

  /**
   * TrainingCalendar.trainings
   */
  export type TrainingCalendar$trainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    where?: TrainingWhereInput
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    cursor?: TrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * TrainingCalendar without action
   */
  export type TrainingCalendarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
  }


  /**
   * Model Training
   */

  export type AggregateTraining = {
    _count: TrainingCountAggregateOutputType | null
    _avg: TrainingAvgAggregateOutputType | null
    _sum: TrainingSumAggregateOutputType | null
    _min: TrainingMinAggregateOutputType | null
    _max: TrainingMaxAggregateOutputType | null
  }

  export type TrainingAvgAggregateOutputType = {
    maxParticipants: number | null
  }

  export type TrainingSumAggregateOutputType = {
    maxParticipants: number | null
  }

  export type TrainingMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    trainingType: $Enums.TrainingType | null
    status: $Enums.TrainingStatus | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    maxParticipants: number | null
    trainerId: string | null
    calendarId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    trainingType: $Enums.TrainingType | null
    status: $Enums.TrainingStatus | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    maxParticipants: number | null
    trainerId: string | null
    calendarId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingCountAggregateOutputType = {
    id: number
    title: number
    description: number
    trainingType: number
    status: number
    startDate: number
    endDate: number
    location: number
    maxParticipants: number
    trainerId: number
    calendarId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingAvgAggregateInputType = {
    maxParticipants?: true
  }

  export type TrainingSumAggregateInputType = {
    maxParticipants?: true
  }

  export type TrainingMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    trainingType?: true
    status?: true
    startDate?: true
    endDate?: true
    location?: true
    maxParticipants?: true
    trainerId?: true
    calendarId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    trainingType?: true
    status?: true
    startDate?: true
    endDate?: true
    location?: true
    maxParticipants?: true
    trainerId?: true
    calendarId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    trainingType?: true
    status?: true
    startDate?: true
    endDate?: true
    location?: true
    maxParticipants?: true
    trainerId?: true
    calendarId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Training to aggregate.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trainings
    **/
    _count?: true | TrainingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingMaxAggregateInputType
  }

  export type GetTrainingAggregateType<T extends TrainingAggregateArgs> = {
        [P in keyof T & keyof AggregateTraining]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraining[P]>
      : GetScalarType<T[P], AggregateTraining[P]>
  }




  export type TrainingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWhereInput
    orderBy?: TrainingOrderByWithAggregationInput | TrainingOrderByWithAggregationInput[]
    by: TrainingScalarFieldEnum[] | TrainingScalarFieldEnum
    having?: TrainingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingCountAggregateInputType | true
    _avg?: TrainingAvgAggregateInputType
    _sum?: TrainingSumAggregateInputType
    _min?: TrainingMinAggregateInputType
    _max?: TrainingMaxAggregateInputType
  }

  export type TrainingGroupByOutputType = {
    id: string
    title: string
    description: string | null
    trainingType: $Enums.TrainingType
    status: $Enums.TrainingStatus
    startDate: Date
    endDate: Date
    location: string
    maxParticipants: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: TrainingCountAggregateOutputType | null
    _avg: TrainingAvgAggregateOutputType | null
    _sum: TrainingSumAggregateOutputType | null
    _min: TrainingMinAggregateOutputType | null
    _max: TrainingMaxAggregateOutputType | null
  }

  type GetTrainingGroupByPayload<T extends TrainingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingGroupByOutputType[P]>
        }
      >
    >


  export type TrainingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    trainingType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    maxParticipants?: boolean
    trainerId?: boolean
    calendarId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    calendar?: boolean | TrainingCalendarDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    sessions?: boolean | Training$sessionsArgs<ExtArgs>
    documents?: boolean | Training$documentsArgs<ExtArgs>
    attendance?: boolean | Training$attendanceArgs<ExtArgs>
    participants?: boolean | Training$participantsArgs<ExtArgs>
    photos?: boolean | Training$photosArgs<ExtArgs>
    feedback?: boolean | Training$feedbackArgs<ExtArgs>
    followups?: boolean | Training$followupsArgs<ExtArgs>
    notifications?: boolean | Training$notificationsArgs<ExtArgs>
    inviteTokens?: boolean | Training$inviteTokensArgs<ExtArgs>
    feedbackForms?: boolean | Training$feedbackFormsArgs<ExtArgs>
    _count?: boolean | TrainingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["training"]>

  export type TrainingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    trainingType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    maxParticipants?: boolean
    trainerId?: boolean
    calendarId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    calendar?: boolean | TrainingCalendarDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["training"]>

  export type TrainingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    trainingType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    maxParticipants?: boolean
    trainerId?: boolean
    calendarId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    calendar?: boolean | TrainingCalendarDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["training"]>

  export type TrainingSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    trainingType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    maxParticipants?: boolean
    trainerId?: boolean
    calendarId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "trainingType" | "status" | "startDate" | "endDate" | "location" | "maxParticipants" | "trainerId" | "calendarId" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["training"]>
  export type TrainingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    calendar?: boolean | TrainingCalendarDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    sessions?: boolean | Training$sessionsArgs<ExtArgs>
    documents?: boolean | Training$documentsArgs<ExtArgs>
    attendance?: boolean | Training$attendanceArgs<ExtArgs>
    participants?: boolean | Training$participantsArgs<ExtArgs>
    photos?: boolean | Training$photosArgs<ExtArgs>
    feedback?: boolean | Training$feedbackArgs<ExtArgs>
    followups?: boolean | Training$followupsArgs<ExtArgs>
    notifications?: boolean | Training$notificationsArgs<ExtArgs>
    inviteTokens?: boolean | Training$inviteTokensArgs<ExtArgs>
    feedbackForms?: boolean | Training$feedbackFormsArgs<ExtArgs>
    _count?: boolean | TrainingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    calendar?: boolean | TrainingCalendarDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    calendar?: boolean | TrainingCalendarDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Training"
    objects: {
      trainer: Prisma.$UserPayload<ExtArgs>
      calendar: Prisma.$TrainingCalendarPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      sessions: Prisma.$TrainingSessionPayload<ExtArgs>[]
      documents: Prisma.$TrainingDocumentPayload<ExtArgs>[]
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
      participants: Prisma.$TrainingParticipantPayload<ExtArgs>[]
      photos: Prisma.$TrainingPhotoPayload<ExtArgs>[]
      feedback: Prisma.$TrainingFeedbackPayload<ExtArgs>[]
      followups: Prisma.$TrainingFollowupPayload<ExtArgs>[]
      notifications: Prisma.$TrainingNotificationPayload<ExtArgs>[]
      inviteTokens: Prisma.$TrainingInviteTokenPayload<ExtArgs>[]
      feedbackForms: Prisma.$FeedbackFormPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      trainingType: $Enums.TrainingType
      status: $Enums.TrainingStatus
      startDate: Date
      endDate: Date
      location: string
      maxParticipants: number | null
      trainerId: string
      calendarId: string
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["training"]>
    composites: {}
  }

  type TrainingGetPayload<S extends boolean | null | undefined | TrainingDefaultArgs> = $Result.GetResult<Prisma.$TrainingPayload, S>

  type TrainingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingCountAggregateInputType | true
    }

  export interface TrainingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Training'], meta: { name: 'Training' } }
    /**
     * Find zero or one Training that matches the filter.
     * @param {TrainingFindUniqueArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingFindUniqueArgs>(args: SelectSubset<T, TrainingFindUniqueArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Training that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingFindUniqueOrThrowArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Training that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindFirstArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingFindFirstArgs>(args?: SelectSubset<T, TrainingFindFirstArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Training that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindFirstOrThrowArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trainings
     * const trainings = await prisma.training.findMany()
     * 
     * // Get first 10 Trainings
     * const trainings = await prisma.training.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingWithIdOnly = await prisma.training.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingFindManyArgs>(args?: SelectSubset<T, TrainingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Training.
     * @param {TrainingCreateArgs} args - Arguments to create a Training.
     * @example
     * // Create one Training
     * const Training = await prisma.training.create({
     *   data: {
     *     // ... data to create a Training
     *   }
     * })
     * 
     */
    create<T extends TrainingCreateArgs>(args: SelectSubset<T, TrainingCreateArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trainings.
     * @param {TrainingCreateManyArgs} args - Arguments to create many Trainings.
     * @example
     * // Create many Trainings
     * const training = await prisma.training.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingCreateManyArgs>(args?: SelectSubset<T, TrainingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trainings and returns the data saved in the database.
     * @param {TrainingCreateManyAndReturnArgs} args - Arguments to create many Trainings.
     * @example
     * // Create many Trainings
     * const training = await prisma.training.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trainings and only return the `id`
     * const trainingWithIdOnly = await prisma.training.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Training.
     * @param {TrainingDeleteArgs} args - Arguments to delete one Training.
     * @example
     * // Delete one Training
     * const Training = await prisma.training.delete({
     *   where: {
     *     // ... filter to delete one Training
     *   }
     * })
     * 
     */
    delete<T extends TrainingDeleteArgs>(args: SelectSubset<T, TrainingDeleteArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Training.
     * @param {TrainingUpdateArgs} args - Arguments to update one Training.
     * @example
     * // Update one Training
     * const training = await prisma.training.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingUpdateArgs>(args: SelectSubset<T, TrainingUpdateArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trainings.
     * @param {TrainingDeleteManyArgs} args - Arguments to filter Trainings to delete.
     * @example
     * // Delete a few Trainings
     * const { count } = await prisma.training.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingDeleteManyArgs>(args?: SelectSubset<T, TrainingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trainings
     * const training = await prisma.training.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingUpdateManyArgs>(args: SelectSubset<T, TrainingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings and returns the data updated in the database.
     * @param {TrainingUpdateManyAndReturnArgs} args - Arguments to update many Trainings.
     * @example
     * // Update many Trainings
     * const training = await prisma.training.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trainings and only return the `id`
     * const trainingWithIdOnly = await prisma.training.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Training.
     * @param {TrainingUpsertArgs} args - Arguments to update or create a Training.
     * @example
     * // Update or create a Training
     * const training = await prisma.training.upsert({
     *   create: {
     *     // ... data to create a Training
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Training we want to update
     *   }
     * })
     */
    upsert<T extends TrainingUpsertArgs>(args: SelectSubset<T, TrainingUpsertArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCountArgs} args - Arguments to filter Trainings to count.
     * @example
     * // Count the number of Trainings
     * const count = await prisma.training.count({
     *   where: {
     *     // ... the filter for the Trainings we want to count
     *   }
     * })
    **/
    count<T extends TrainingCountArgs>(
      args?: Subset<T, TrainingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingAggregateArgs>(args: Subset<T, TrainingAggregateArgs>): Prisma.PrismaPromise<GetTrainingAggregateType<T>>

    /**
     * Group by Training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingGroupByArgs['orderBy'] }
        : { orderBy?: TrainingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Training model
   */
  readonly fields: TrainingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Training.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    calendar<T extends TrainingCalendarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingCalendarDefaultArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessions<T extends Training$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Training$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Training$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Training$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends Training$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Training$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    participants<T extends Training$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Training$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos<T extends Training$photosArgs<ExtArgs> = {}>(args?: Subset<T, Training$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedback<T extends Training$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, Training$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followups<T extends Training$followupsArgs<ExtArgs> = {}>(args?: Subset<T, Training$followupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Training$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Training$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inviteTokens<T extends Training$inviteTokensArgs<ExtArgs> = {}>(args?: Subset<T, Training$inviteTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingInviteTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbackForms<T extends Training$feedbackFormsArgs<ExtArgs> = {}>(args?: Subset<T, Training$feedbackFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Training model
   */
  interface TrainingFieldRefs {
    readonly id: FieldRef<"Training", 'String'>
    readonly title: FieldRef<"Training", 'String'>
    readonly description: FieldRef<"Training", 'String'>
    readonly trainingType: FieldRef<"Training", 'TrainingType'>
    readonly status: FieldRef<"Training", 'TrainingStatus'>
    readonly startDate: FieldRef<"Training", 'DateTime'>
    readonly endDate: FieldRef<"Training", 'DateTime'>
    readonly location: FieldRef<"Training", 'String'>
    readonly maxParticipants: FieldRef<"Training", 'Int'>
    readonly trainerId: FieldRef<"Training", 'String'>
    readonly calendarId: FieldRef<"Training", 'String'>
    readonly createdById: FieldRef<"Training", 'String'>
    readonly createdAt: FieldRef<"Training", 'DateTime'>
    readonly updatedAt: FieldRef<"Training", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Training findUnique
   */
  export type TrainingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training findUniqueOrThrow
   */
  export type TrainingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training findFirst
   */
  export type TrainingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainings.
     */
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * Training findFirstOrThrow
   */
  export type TrainingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainings.
     */
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * Training findMany
   */
  export type TrainingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Trainings to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * Training create
   */
  export type TrainingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The data needed to create a Training.
     */
    data: XOR<TrainingCreateInput, TrainingUncheckedCreateInput>
  }

  /**
   * Training createMany
   */
  export type TrainingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trainings.
     */
    data: TrainingCreateManyInput | TrainingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Training createManyAndReturn
   */
  export type TrainingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * The data used to create many Trainings.
     */
    data: TrainingCreateManyInput | TrainingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Training update
   */
  export type TrainingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The data needed to update a Training.
     */
    data: XOR<TrainingUpdateInput, TrainingUncheckedUpdateInput>
    /**
     * Choose, which Training to update.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training updateMany
   */
  export type TrainingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trainings.
     */
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyInput>
    /**
     * Filter which Trainings to update
     */
    where?: TrainingWhereInput
    /**
     * Limit how many Trainings to update.
     */
    limit?: number
  }

  /**
   * Training updateManyAndReturn
   */
  export type TrainingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * The data used to update Trainings.
     */
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyInput>
    /**
     * Filter which Trainings to update
     */
    where?: TrainingWhereInput
    /**
     * Limit how many Trainings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Training upsert
   */
  export type TrainingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The filter to search for the Training to update in case it exists.
     */
    where: TrainingWhereUniqueInput
    /**
     * In case the Training found by the `where` argument doesn't exist, create a new Training with this data.
     */
    create: XOR<TrainingCreateInput, TrainingUncheckedCreateInput>
    /**
     * In case the Training was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingUpdateInput, TrainingUncheckedUpdateInput>
  }

  /**
   * Training delete
   */
  export type TrainingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter which Training to delete.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training deleteMany
   */
  export type TrainingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trainings to delete
     */
    where?: TrainingWhereInput
    /**
     * Limit how many Trainings to delete.
     */
    limit?: number
  }

  /**
   * Training.sessions
   */
  export type Training$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    where?: TrainingSessionWhereInput
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    cursor?: TrainingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingSessionScalarFieldEnum | TrainingSessionScalarFieldEnum[]
  }

  /**
   * Training.documents
   */
  export type Training$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    where?: TrainingDocumentWhereInput
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    cursor?: TrainingDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * Training.attendance
   */
  export type Training$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Training.participants
   */
  export type Training$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    where?: TrainingParticipantWhereInput
    orderBy?: TrainingParticipantOrderByWithRelationInput | TrainingParticipantOrderByWithRelationInput[]
    cursor?: TrainingParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingParticipantScalarFieldEnum | TrainingParticipantScalarFieldEnum[]
  }

  /**
   * Training.photos
   */
  export type Training$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    where?: TrainingPhotoWhereInput
    orderBy?: TrainingPhotoOrderByWithRelationInput | TrainingPhotoOrderByWithRelationInput[]
    cursor?: TrainingPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingPhotoScalarFieldEnum | TrainingPhotoScalarFieldEnum[]
  }

  /**
   * Training.feedback
   */
  export type Training$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    where?: TrainingFeedbackWhereInput
    orderBy?: TrainingFeedbackOrderByWithRelationInput | TrainingFeedbackOrderByWithRelationInput[]
    cursor?: TrainingFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingFeedbackScalarFieldEnum | TrainingFeedbackScalarFieldEnum[]
  }

  /**
   * Training.followups
   */
  export type Training$followupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    where?: TrainingFollowupWhereInput
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    cursor?: TrainingFollowupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingFollowupScalarFieldEnum | TrainingFollowupScalarFieldEnum[]
  }

  /**
   * Training.notifications
   */
  export type Training$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    where?: TrainingNotificationWhereInput
    orderBy?: TrainingNotificationOrderByWithRelationInput | TrainingNotificationOrderByWithRelationInput[]
    cursor?: TrainingNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingNotificationScalarFieldEnum | TrainingNotificationScalarFieldEnum[]
  }

  /**
   * Training.inviteTokens
   */
  export type Training$inviteTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenInclude<ExtArgs> | null
    where?: TrainingInviteTokenWhereInput
    orderBy?: TrainingInviteTokenOrderByWithRelationInput | TrainingInviteTokenOrderByWithRelationInput[]
    cursor?: TrainingInviteTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingInviteTokenScalarFieldEnum | TrainingInviteTokenScalarFieldEnum[]
  }

  /**
   * Training.feedbackForms
   */
  export type Training$feedbackFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
    where?: FeedbackFormWhereInput
    orderBy?: FeedbackFormOrderByWithRelationInput | FeedbackFormOrderByWithRelationInput[]
    cursor?: FeedbackFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackFormScalarFieldEnum | FeedbackFormScalarFieldEnum[]
  }

  /**
   * Training without action
   */
  export type TrainingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
  }


  /**
   * Model TrainingSession
   */

  export type AggregateTrainingSession = {
    _count: TrainingSessionCountAggregateOutputType | null
    _min: TrainingSessionMinAggregateOutputType | null
    _max: TrainingSessionMaxAggregateOutputType | null
  }

  export type TrainingSessionMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    venue: string | null
    status: $Enums.TrainingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingSessionMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    venue: string | null
    status: $Enums.TrainingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingSessionCountAggregateOutputType = {
    id: number
    trainingId: number
    title: number
    description: number
    startTime: number
    endTime: number
    venue: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingSessionMinAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    venue?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingSessionMaxAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    venue?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingSessionCountAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    venue?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingSession to aggregate.
     */
    where?: TrainingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessions to fetch.
     */
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingSessions
    **/
    _count?: true | TrainingSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingSessionMaxAggregateInputType
  }

  export type GetTrainingSessionAggregateType<T extends TrainingSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingSession[P]>
      : GetScalarType<T[P], AggregateTrainingSession[P]>
  }




  export type TrainingSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingSessionWhereInput
    orderBy?: TrainingSessionOrderByWithAggregationInput | TrainingSessionOrderByWithAggregationInput[]
    by: TrainingSessionScalarFieldEnum[] | TrainingSessionScalarFieldEnum
    having?: TrainingSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingSessionCountAggregateInputType | true
    _min?: TrainingSessionMinAggregateInputType
    _max?: TrainingSessionMaxAggregateInputType
  }

  export type TrainingSessionGroupByOutputType = {
    id: string
    trainingId: string
    title: string
    description: string | null
    startTime: Date
    endTime: Date
    venue: string
    status: $Enums.TrainingStatus
    createdAt: Date
    updatedAt: Date
    _count: TrainingSessionCountAggregateOutputType | null
    _min: TrainingSessionMinAggregateOutputType | null
    _max: TrainingSessionMaxAggregateOutputType | null
  }

  type GetTrainingSessionGroupByPayload<T extends TrainingSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingSessionGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingSessionGroupByOutputType[P]>
        }
      >
    >


  export type TrainingSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    venue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    attendance?: boolean | TrainingSession$attendanceArgs<ExtArgs>
    feedbackForms?: boolean | TrainingSession$feedbackFormsArgs<ExtArgs>
    photos?: boolean | TrainingSession$photosArgs<ExtArgs>
    _count?: boolean | TrainingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingSession"]>

  export type TrainingSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    venue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingSession"]>

  export type TrainingSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    venue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingSession"]>

  export type TrainingSessionSelectScalar = {
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    venue?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "title" | "description" | "startTime" | "endTime" | "venue" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingSession"]>
  export type TrainingSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    attendance?: boolean | TrainingSession$attendanceArgs<ExtArgs>
    feedbackForms?: boolean | TrainingSession$feedbackFormsArgs<ExtArgs>
    photos?: boolean | TrainingSession$photosArgs<ExtArgs>
    _count?: boolean | TrainingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
  }
  export type TrainingSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
  }

  export type $TrainingSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingSession"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
      feedbackForms: Prisma.$FeedbackFormPayload<ExtArgs>[]
      photos: Prisma.$TrainingSessionPhotoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      title: string
      description: string | null
      startTime: Date
      endTime: Date
      venue: string
      status: $Enums.TrainingStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingSession"]>
    composites: {}
  }

  type TrainingSessionGetPayload<S extends boolean | null | undefined | TrainingSessionDefaultArgs> = $Result.GetResult<Prisma.$TrainingSessionPayload, S>

  type TrainingSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingSessionCountAggregateInputType | true
    }

  export interface TrainingSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingSession'], meta: { name: 'TrainingSession' } }
    /**
     * Find zero or one TrainingSession that matches the filter.
     * @param {TrainingSessionFindUniqueArgs} args - Arguments to find a TrainingSession
     * @example
     * // Get one TrainingSession
     * const trainingSession = await prisma.trainingSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingSessionFindUniqueArgs>(args: SelectSubset<T, TrainingSessionFindUniqueArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingSessionFindUniqueOrThrowArgs} args - Arguments to find a TrainingSession
     * @example
     * // Get one TrainingSession
     * const trainingSession = await prisma.trainingSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionFindFirstArgs} args - Arguments to find a TrainingSession
     * @example
     * // Get one TrainingSession
     * const trainingSession = await prisma.trainingSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingSessionFindFirstArgs>(args?: SelectSubset<T, TrainingSessionFindFirstArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionFindFirstOrThrowArgs} args - Arguments to find a TrainingSession
     * @example
     * // Get one TrainingSession
     * const trainingSession = await prisma.trainingSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingSessions
     * const trainingSessions = await prisma.trainingSession.findMany()
     * 
     * // Get first 10 TrainingSessions
     * const trainingSessions = await prisma.trainingSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingSessionWithIdOnly = await prisma.trainingSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingSessionFindManyArgs>(args?: SelectSubset<T, TrainingSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingSession.
     * @param {TrainingSessionCreateArgs} args - Arguments to create a TrainingSession.
     * @example
     * // Create one TrainingSession
     * const TrainingSession = await prisma.trainingSession.create({
     *   data: {
     *     // ... data to create a TrainingSession
     *   }
     * })
     * 
     */
    create<T extends TrainingSessionCreateArgs>(args: SelectSubset<T, TrainingSessionCreateArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingSessions.
     * @param {TrainingSessionCreateManyArgs} args - Arguments to create many TrainingSessions.
     * @example
     * // Create many TrainingSessions
     * const trainingSession = await prisma.trainingSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingSessionCreateManyArgs>(args?: SelectSubset<T, TrainingSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingSessions and returns the data saved in the database.
     * @param {TrainingSessionCreateManyAndReturnArgs} args - Arguments to create many TrainingSessions.
     * @example
     * // Create many TrainingSessions
     * const trainingSession = await prisma.trainingSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingSessions and only return the `id`
     * const trainingSessionWithIdOnly = await prisma.trainingSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingSession.
     * @param {TrainingSessionDeleteArgs} args - Arguments to delete one TrainingSession.
     * @example
     * // Delete one TrainingSession
     * const TrainingSession = await prisma.trainingSession.delete({
     *   where: {
     *     // ... filter to delete one TrainingSession
     *   }
     * })
     * 
     */
    delete<T extends TrainingSessionDeleteArgs>(args: SelectSubset<T, TrainingSessionDeleteArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingSession.
     * @param {TrainingSessionUpdateArgs} args - Arguments to update one TrainingSession.
     * @example
     * // Update one TrainingSession
     * const trainingSession = await prisma.trainingSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingSessionUpdateArgs>(args: SelectSubset<T, TrainingSessionUpdateArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingSessions.
     * @param {TrainingSessionDeleteManyArgs} args - Arguments to filter TrainingSessions to delete.
     * @example
     * // Delete a few TrainingSessions
     * const { count } = await prisma.trainingSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingSessionDeleteManyArgs>(args?: SelectSubset<T, TrainingSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingSessions
     * const trainingSession = await prisma.trainingSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingSessionUpdateManyArgs>(args: SelectSubset<T, TrainingSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingSessions and returns the data updated in the database.
     * @param {TrainingSessionUpdateManyAndReturnArgs} args - Arguments to update many TrainingSessions.
     * @example
     * // Update many TrainingSessions
     * const trainingSession = await prisma.trainingSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingSessions and only return the `id`
     * const trainingSessionWithIdOnly = await prisma.trainingSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingSession.
     * @param {TrainingSessionUpsertArgs} args - Arguments to update or create a TrainingSession.
     * @example
     * // Update or create a TrainingSession
     * const trainingSession = await prisma.trainingSession.upsert({
     *   create: {
     *     // ... data to create a TrainingSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingSession we want to update
     *   }
     * })
     */
    upsert<T extends TrainingSessionUpsertArgs>(args: SelectSubset<T, TrainingSessionUpsertArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionCountArgs} args - Arguments to filter TrainingSessions to count.
     * @example
     * // Count the number of TrainingSessions
     * const count = await prisma.trainingSession.count({
     *   where: {
     *     // ... the filter for the TrainingSessions we want to count
     *   }
     * })
    **/
    count<T extends TrainingSessionCountArgs>(
      args?: Subset<T, TrainingSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingSessionAggregateArgs>(args: Subset<T, TrainingSessionAggregateArgs>): Prisma.PrismaPromise<GetTrainingSessionAggregateType<T>>

    /**
     * Group by TrainingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingSessionGroupByArgs['orderBy'] }
        : { orderBy?: TrainingSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingSession model
   */
  readonly fields: TrainingSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendance<T extends TrainingSession$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, TrainingSession$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbackForms<T extends TrainingSession$feedbackFormsArgs<ExtArgs> = {}>(args?: Subset<T, TrainingSession$feedbackFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos<T extends TrainingSession$photosArgs<ExtArgs> = {}>(args?: Subset<T, TrainingSession$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingSession model
   */
  interface TrainingSessionFieldRefs {
    readonly id: FieldRef<"TrainingSession", 'String'>
    readonly trainingId: FieldRef<"TrainingSession", 'String'>
    readonly title: FieldRef<"TrainingSession", 'String'>
    readonly description: FieldRef<"TrainingSession", 'String'>
    readonly startTime: FieldRef<"TrainingSession", 'DateTime'>
    readonly endTime: FieldRef<"TrainingSession", 'DateTime'>
    readonly venue: FieldRef<"TrainingSession", 'String'>
    readonly status: FieldRef<"TrainingSession", 'TrainingStatus'>
    readonly createdAt: FieldRef<"TrainingSession", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingSession findUnique
   */
  export type TrainingSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSession to fetch.
     */
    where: TrainingSessionWhereUniqueInput
  }

  /**
   * TrainingSession findUniqueOrThrow
   */
  export type TrainingSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSession to fetch.
     */
    where: TrainingSessionWhereUniqueInput
  }

  /**
   * TrainingSession findFirst
   */
  export type TrainingSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSession to fetch.
     */
    where?: TrainingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessions to fetch.
     */
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingSessions.
     */
    cursor?: TrainingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingSessions.
     */
    distinct?: TrainingSessionScalarFieldEnum | TrainingSessionScalarFieldEnum[]
  }

  /**
   * TrainingSession findFirstOrThrow
   */
  export type TrainingSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSession to fetch.
     */
    where?: TrainingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessions to fetch.
     */
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingSessions.
     */
    cursor?: TrainingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingSessions.
     */
    distinct?: TrainingSessionScalarFieldEnum | TrainingSessionScalarFieldEnum[]
  }

  /**
   * TrainingSession findMany
   */
  export type TrainingSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSessions to fetch.
     */
    where?: TrainingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessions to fetch.
     */
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingSessions.
     */
    cursor?: TrainingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessions.
     */
    skip?: number
    distinct?: TrainingSessionScalarFieldEnum | TrainingSessionScalarFieldEnum[]
  }

  /**
   * TrainingSession create
   */
  export type TrainingSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingSession.
     */
    data: XOR<TrainingSessionCreateInput, TrainingSessionUncheckedCreateInput>
  }

  /**
   * TrainingSession createMany
   */
  export type TrainingSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingSessions.
     */
    data: TrainingSessionCreateManyInput | TrainingSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingSession createManyAndReturn
   */
  export type TrainingSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingSessions.
     */
    data: TrainingSessionCreateManyInput | TrainingSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingSession update
   */
  export type TrainingSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingSession.
     */
    data: XOR<TrainingSessionUpdateInput, TrainingSessionUncheckedUpdateInput>
    /**
     * Choose, which TrainingSession to update.
     */
    where: TrainingSessionWhereUniqueInput
  }

  /**
   * TrainingSession updateMany
   */
  export type TrainingSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingSessions.
     */
    data: XOR<TrainingSessionUpdateManyMutationInput, TrainingSessionUncheckedUpdateManyInput>
    /**
     * Filter which TrainingSessions to update
     */
    where?: TrainingSessionWhereInput
    /**
     * Limit how many TrainingSessions to update.
     */
    limit?: number
  }

  /**
   * TrainingSession updateManyAndReturn
   */
  export type TrainingSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * The data used to update TrainingSessions.
     */
    data: XOR<TrainingSessionUpdateManyMutationInput, TrainingSessionUncheckedUpdateManyInput>
    /**
     * Filter which TrainingSessions to update
     */
    where?: TrainingSessionWhereInput
    /**
     * Limit how many TrainingSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingSession upsert
   */
  export type TrainingSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingSession to update in case it exists.
     */
    where: TrainingSessionWhereUniqueInput
    /**
     * In case the TrainingSession found by the `where` argument doesn't exist, create a new TrainingSession with this data.
     */
    create: XOR<TrainingSessionCreateInput, TrainingSessionUncheckedCreateInput>
    /**
     * In case the TrainingSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingSessionUpdateInput, TrainingSessionUncheckedUpdateInput>
  }

  /**
   * TrainingSession delete
   */
  export type TrainingSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter which TrainingSession to delete.
     */
    where: TrainingSessionWhereUniqueInput
  }

  /**
   * TrainingSession deleteMany
   */
  export type TrainingSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingSessions to delete
     */
    where?: TrainingSessionWhereInput
    /**
     * Limit how many TrainingSessions to delete.
     */
    limit?: number
  }

  /**
   * TrainingSession.attendance
   */
  export type TrainingSession$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * TrainingSession.feedbackForms
   */
  export type TrainingSession$feedbackFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
    where?: FeedbackFormWhereInput
    orderBy?: FeedbackFormOrderByWithRelationInput | FeedbackFormOrderByWithRelationInput[]
    cursor?: FeedbackFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackFormScalarFieldEnum | FeedbackFormScalarFieldEnum[]
  }

  /**
   * TrainingSession.photos
   */
  export type TrainingSession$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoInclude<ExtArgs> | null
    where?: TrainingSessionPhotoWhereInput
    orderBy?: TrainingSessionPhotoOrderByWithRelationInput | TrainingSessionPhotoOrderByWithRelationInput[]
    cursor?: TrainingSessionPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingSessionPhotoScalarFieldEnum | TrainingSessionPhotoScalarFieldEnum[]
  }

  /**
   * TrainingSession without action
   */
  export type TrainingSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
  }


  /**
   * Model TrainingDocument
   */

  export type AggregateTrainingDocument = {
    _count: TrainingDocumentCountAggregateOutputType | null
    _min: TrainingDocumentMinAggregateOutputType | null
    _max: TrainingDocumentMaxAggregateOutputType | null
  }

  export type TrainingDocumentMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    sessionId: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    filePath: string | null
    documentType: $Enums.DocumentType | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingDocumentMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    sessionId: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    filePath: string | null
    documentType: $Enums.DocumentType | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingDocumentCountAggregateOutputType = {
    id: number
    trainingId: number
    sessionId: number
    title: number
    description: number
    fileUrl: number
    filePath: number
    documentType: number
    uploadedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingDocumentMinAggregateInputType = {
    id?: true
    trainingId?: true
    sessionId?: true
    title?: true
    description?: true
    fileUrl?: true
    filePath?: true
    documentType?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingDocumentMaxAggregateInputType = {
    id?: true
    trainingId?: true
    sessionId?: true
    title?: true
    description?: true
    fileUrl?: true
    filePath?: true
    documentType?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingDocumentCountAggregateInputType = {
    id?: true
    trainingId?: true
    sessionId?: true
    title?: true
    description?: true
    fileUrl?: true
    filePath?: true
    documentType?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDocument to aggregate.
     */
    where?: TrainingDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDocuments to fetch.
     */
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingDocuments
    **/
    _count?: true | TrainingDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingDocumentMaxAggregateInputType
  }

  export type GetTrainingDocumentAggregateType<T extends TrainingDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingDocument[P]>
      : GetScalarType<T[P], AggregateTrainingDocument[P]>
  }




  export type TrainingDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDocumentWhereInput
    orderBy?: TrainingDocumentOrderByWithAggregationInput | TrainingDocumentOrderByWithAggregationInput[]
    by: TrainingDocumentScalarFieldEnum[] | TrainingDocumentScalarFieldEnum
    having?: TrainingDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingDocumentCountAggregateInputType | true
    _min?: TrainingDocumentMinAggregateInputType
    _max?: TrainingDocumentMaxAggregateInputType
  }

  export type TrainingDocumentGroupByOutputType = {
    id: string
    trainingId: string
    sessionId: string | null
    title: string
    description: string | null
    fileUrl: string
    filePath: string | null
    documentType: $Enums.DocumentType
    uploadedById: string
    createdAt: Date
    updatedAt: Date
    _count: TrainingDocumentCountAggregateOutputType | null
    _min: TrainingDocumentMinAggregateOutputType | null
    _max: TrainingDocumentMaxAggregateOutputType | null
  }

  type GetTrainingDocumentGroupByPayload<T extends TrainingDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingDocumentGroupByOutputType[P]>
        }
      >
    >


  export type TrainingDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    filePath?: boolean
    documentType?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDocument"]>

  export type TrainingDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    filePath?: boolean
    documentType?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDocument"]>

  export type TrainingDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    filePath?: boolean
    documentType?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDocument"]>

  export type TrainingDocumentSelectScalar = {
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    filePath?: boolean
    documentType?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "sessionId" | "title" | "description" | "fileUrl" | "filePath" | "documentType" | "uploadedById" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingDocument"]>
  export type TrainingDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingDocument"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      sessionId: string | null
      title: string
      description: string | null
      fileUrl: string
      filePath: string | null
      documentType: $Enums.DocumentType
      uploadedById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingDocument"]>
    composites: {}
  }

  type TrainingDocumentGetPayload<S extends boolean | null | undefined | TrainingDocumentDefaultArgs> = $Result.GetResult<Prisma.$TrainingDocumentPayload, S>

  type TrainingDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingDocumentCountAggregateInputType | true
    }

  export interface TrainingDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingDocument'], meta: { name: 'TrainingDocument' } }
    /**
     * Find zero or one TrainingDocument that matches the filter.
     * @param {TrainingDocumentFindUniqueArgs} args - Arguments to find a TrainingDocument
     * @example
     * // Get one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingDocumentFindUniqueArgs>(args: SelectSubset<T, TrainingDocumentFindUniqueArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingDocumentFindUniqueOrThrowArgs} args - Arguments to find a TrainingDocument
     * @example
     * // Get one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentFindFirstArgs} args - Arguments to find a TrainingDocument
     * @example
     * // Get one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingDocumentFindFirstArgs>(args?: SelectSubset<T, TrainingDocumentFindFirstArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentFindFirstOrThrowArgs} args - Arguments to find a TrainingDocument
     * @example
     * // Get one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingDocuments
     * const trainingDocuments = await prisma.trainingDocument.findMany()
     * 
     * // Get first 10 TrainingDocuments
     * const trainingDocuments = await prisma.trainingDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingDocumentWithIdOnly = await prisma.trainingDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingDocumentFindManyArgs>(args?: SelectSubset<T, TrainingDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingDocument.
     * @param {TrainingDocumentCreateArgs} args - Arguments to create a TrainingDocument.
     * @example
     * // Create one TrainingDocument
     * const TrainingDocument = await prisma.trainingDocument.create({
     *   data: {
     *     // ... data to create a TrainingDocument
     *   }
     * })
     * 
     */
    create<T extends TrainingDocumentCreateArgs>(args: SelectSubset<T, TrainingDocumentCreateArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingDocuments.
     * @param {TrainingDocumentCreateManyArgs} args - Arguments to create many TrainingDocuments.
     * @example
     * // Create many TrainingDocuments
     * const trainingDocument = await prisma.trainingDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingDocumentCreateManyArgs>(args?: SelectSubset<T, TrainingDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingDocuments and returns the data saved in the database.
     * @param {TrainingDocumentCreateManyAndReturnArgs} args - Arguments to create many TrainingDocuments.
     * @example
     * // Create many TrainingDocuments
     * const trainingDocument = await prisma.trainingDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingDocuments and only return the `id`
     * const trainingDocumentWithIdOnly = await prisma.trainingDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingDocument.
     * @param {TrainingDocumentDeleteArgs} args - Arguments to delete one TrainingDocument.
     * @example
     * // Delete one TrainingDocument
     * const TrainingDocument = await prisma.trainingDocument.delete({
     *   where: {
     *     // ... filter to delete one TrainingDocument
     *   }
     * })
     * 
     */
    delete<T extends TrainingDocumentDeleteArgs>(args: SelectSubset<T, TrainingDocumentDeleteArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingDocument.
     * @param {TrainingDocumentUpdateArgs} args - Arguments to update one TrainingDocument.
     * @example
     * // Update one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingDocumentUpdateArgs>(args: SelectSubset<T, TrainingDocumentUpdateArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingDocuments.
     * @param {TrainingDocumentDeleteManyArgs} args - Arguments to filter TrainingDocuments to delete.
     * @example
     * // Delete a few TrainingDocuments
     * const { count } = await prisma.trainingDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingDocumentDeleteManyArgs>(args?: SelectSubset<T, TrainingDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingDocuments
     * const trainingDocument = await prisma.trainingDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingDocumentUpdateManyArgs>(args: SelectSubset<T, TrainingDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingDocuments and returns the data updated in the database.
     * @param {TrainingDocumentUpdateManyAndReturnArgs} args - Arguments to update many TrainingDocuments.
     * @example
     * // Update many TrainingDocuments
     * const trainingDocument = await prisma.trainingDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingDocuments and only return the `id`
     * const trainingDocumentWithIdOnly = await prisma.trainingDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingDocument.
     * @param {TrainingDocumentUpsertArgs} args - Arguments to update or create a TrainingDocument.
     * @example
     * // Update or create a TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.upsert({
     *   create: {
     *     // ... data to create a TrainingDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingDocument we want to update
     *   }
     * })
     */
    upsert<T extends TrainingDocumentUpsertArgs>(args: SelectSubset<T, TrainingDocumentUpsertArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentCountArgs} args - Arguments to filter TrainingDocuments to count.
     * @example
     * // Count the number of TrainingDocuments
     * const count = await prisma.trainingDocument.count({
     *   where: {
     *     // ... the filter for the TrainingDocuments we want to count
     *   }
     * })
    **/
    count<T extends TrainingDocumentCountArgs>(
      args?: Subset<T, TrainingDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingDocumentAggregateArgs>(args: Subset<T, TrainingDocumentAggregateArgs>): Prisma.PrismaPromise<GetTrainingDocumentAggregateType<T>>

    /**
     * Group by TrainingDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingDocumentGroupByArgs['orderBy'] }
        : { orderBy?: TrainingDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingDocument model
   */
  readonly fields: TrainingDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingDocument model
   */
  interface TrainingDocumentFieldRefs {
    readonly id: FieldRef<"TrainingDocument", 'String'>
    readonly trainingId: FieldRef<"TrainingDocument", 'String'>
    readonly sessionId: FieldRef<"TrainingDocument", 'String'>
    readonly title: FieldRef<"TrainingDocument", 'String'>
    readonly description: FieldRef<"TrainingDocument", 'String'>
    readonly fileUrl: FieldRef<"TrainingDocument", 'String'>
    readonly filePath: FieldRef<"TrainingDocument", 'String'>
    readonly documentType: FieldRef<"TrainingDocument", 'DocumentType'>
    readonly uploadedById: FieldRef<"TrainingDocument", 'String'>
    readonly createdAt: FieldRef<"TrainingDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingDocument findUnique
   */
  export type TrainingDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocument to fetch.
     */
    where: TrainingDocumentWhereUniqueInput
  }

  /**
   * TrainingDocument findUniqueOrThrow
   */
  export type TrainingDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocument to fetch.
     */
    where: TrainingDocumentWhereUniqueInput
  }

  /**
   * TrainingDocument findFirst
   */
  export type TrainingDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocument to fetch.
     */
    where?: TrainingDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDocuments to fetch.
     */
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDocuments.
     */
    cursor?: TrainingDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDocuments.
     */
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * TrainingDocument findFirstOrThrow
   */
  export type TrainingDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocument to fetch.
     */
    where?: TrainingDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDocuments to fetch.
     */
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDocuments.
     */
    cursor?: TrainingDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDocuments.
     */
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * TrainingDocument findMany
   */
  export type TrainingDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocuments to fetch.
     */
    where?: TrainingDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDocuments to fetch.
     */
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingDocuments.
     */
    cursor?: TrainingDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDocuments.
     */
    skip?: number
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * TrainingDocument create
   */
  export type TrainingDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingDocument.
     */
    data: XOR<TrainingDocumentCreateInput, TrainingDocumentUncheckedCreateInput>
  }

  /**
   * TrainingDocument createMany
   */
  export type TrainingDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingDocuments.
     */
    data: TrainingDocumentCreateManyInput | TrainingDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingDocument createManyAndReturn
   */
  export type TrainingDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingDocuments.
     */
    data: TrainingDocumentCreateManyInput | TrainingDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingDocument update
   */
  export type TrainingDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingDocument.
     */
    data: XOR<TrainingDocumentUpdateInput, TrainingDocumentUncheckedUpdateInput>
    /**
     * Choose, which TrainingDocument to update.
     */
    where: TrainingDocumentWhereUniqueInput
  }

  /**
   * TrainingDocument updateMany
   */
  export type TrainingDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingDocuments.
     */
    data: XOR<TrainingDocumentUpdateManyMutationInput, TrainingDocumentUncheckedUpdateManyInput>
    /**
     * Filter which TrainingDocuments to update
     */
    where?: TrainingDocumentWhereInput
    /**
     * Limit how many TrainingDocuments to update.
     */
    limit?: number
  }

  /**
   * TrainingDocument updateManyAndReturn
   */
  export type TrainingDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * The data used to update TrainingDocuments.
     */
    data: XOR<TrainingDocumentUpdateManyMutationInput, TrainingDocumentUncheckedUpdateManyInput>
    /**
     * Filter which TrainingDocuments to update
     */
    where?: TrainingDocumentWhereInput
    /**
     * Limit how many TrainingDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingDocument upsert
   */
  export type TrainingDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingDocument to update in case it exists.
     */
    where: TrainingDocumentWhereUniqueInput
    /**
     * In case the TrainingDocument found by the `where` argument doesn't exist, create a new TrainingDocument with this data.
     */
    create: XOR<TrainingDocumentCreateInput, TrainingDocumentUncheckedCreateInput>
    /**
     * In case the TrainingDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingDocumentUpdateInput, TrainingDocumentUncheckedUpdateInput>
  }

  /**
   * TrainingDocument delete
   */
  export type TrainingDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter which TrainingDocument to delete.
     */
    where: TrainingDocumentWhereUniqueInput
  }

  /**
   * TrainingDocument deleteMany
   */
  export type TrainingDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDocuments to delete
     */
    where?: TrainingDocumentWhereInput
    /**
     * Limit how many TrainingDocuments to delete.
     */
    limit?: number
  }

  /**
   * TrainingDocument without action
   */
  export type TrainingDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Participant
   */

  export type AggregateParticipant = {
    _count: ParticipantCountAggregateOutputType | null
    _min: ParticipantMinAggregateOutputType | null
    _max: ParticipantMaxAggregateOutputType | null
  }

  export type ParticipantMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    organization: string | null
    position: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParticipantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    organization: string | null
    position: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParticipantCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    organization: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParticipantMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    organization?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParticipantMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    organization?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParticipantCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    organization?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Participant to aggregate.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Participants
    **/
    _count?: true | ParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParticipantMaxAggregateInputType
  }

  export type GetParticipantAggregateType<T extends ParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParticipant[P]>
      : GetScalarType<T[P], AggregateParticipant[P]>
  }




  export type ParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipantWhereInput
    orderBy?: ParticipantOrderByWithAggregationInput | ParticipantOrderByWithAggregationInput[]
    by: ParticipantScalarFieldEnum[] | ParticipantScalarFieldEnum
    having?: ParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParticipantCountAggregateInputType | true
    _min?: ParticipantMinAggregateInputType
    _max?: ParticipantMaxAggregateInputType
  }

  export type ParticipantGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    organization: string | null
    position: string | null
    createdAt: Date
    updatedAt: Date
    _count: ParticipantCountAggregateOutputType | null
    _min: ParticipantMinAggregateOutputType | null
    _max: ParticipantMaxAggregateOutputType | null
  }

  type GetParticipantGroupByPayload<T extends ParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    organization?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainings?: boolean | Participant$trainingsArgs<ExtArgs>
    attendances?: boolean | Participant$attendancesArgs<ExtArgs>
    feedbacks?: boolean | Participant$feedbacksArgs<ExtArgs>
    inviteTokens?: boolean | Participant$inviteTokensArgs<ExtArgs>
    feedbackForms?: boolean | Participant$feedbackFormsArgs<ExtArgs>
    _count?: boolean | ParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participant"]>

  export type ParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    organization?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["participant"]>

  export type ParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    organization?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["participant"]>

  export type ParticipantSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    organization?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "organization" | "position" | "createdAt" | "updatedAt", ExtArgs["result"]["participant"]>
  export type ParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | Participant$trainingsArgs<ExtArgs>
    attendances?: boolean | Participant$attendancesArgs<ExtArgs>
    feedbacks?: boolean | Participant$feedbacksArgs<ExtArgs>
    inviteTokens?: boolean | Participant$inviteTokensArgs<ExtArgs>
    feedbackForms?: boolean | Participant$feedbackFormsArgs<ExtArgs>
    _count?: boolean | ParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Participant"
    objects: {
      trainings: Prisma.$TrainingParticipantPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      feedbacks: Prisma.$TrainingFeedbackPayload<ExtArgs>[]
      inviteTokens: Prisma.$TrainingInviteTokenPayload<ExtArgs>[]
      feedbackForms: Prisma.$FeedbackFormPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      organization: string | null
      position: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["participant"]>
    composites: {}
  }

  type ParticipantGetPayload<S extends boolean | null | undefined | ParticipantDefaultArgs> = $Result.GetResult<Prisma.$ParticipantPayload, S>

  type ParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParticipantCountAggregateInputType | true
    }

  export interface ParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Participant'], meta: { name: 'Participant' } }
    /**
     * Find zero or one Participant that matches the filter.
     * @param {ParticipantFindUniqueArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParticipantFindUniqueArgs>(args: SelectSubset<T, ParticipantFindUniqueArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Participant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParticipantFindUniqueOrThrowArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Participant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindFirstArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParticipantFindFirstArgs>(args?: SelectSubset<T, ParticipantFindFirstArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Participant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindFirstOrThrowArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Participants
     * const participants = await prisma.participant.findMany()
     * 
     * // Get first 10 Participants
     * const participants = await prisma.participant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const participantWithIdOnly = await prisma.participant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParticipantFindManyArgs>(args?: SelectSubset<T, ParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Participant.
     * @param {ParticipantCreateArgs} args - Arguments to create a Participant.
     * @example
     * // Create one Participant
     * const Participant = await prisma.participant.create({
     *   data: {
     *     // ... data to create a Participant
     *   }
     * })
     * 
     */
    create<T extends ParticipantCreateArgs>(args: SelectSubset<T, ParticipantCreateArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Participants.
     * @param {ParticipantCreateManyArgs} args - Arguments to create many Participants.
     * @example
     * // Create many Participants
     * const participant = await prisma.participant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParticipantCreateManyArgs>(args?: SelectSubset<T, ParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Participants and returns the data saved in the database.
     * @param {ParticipantCreateManyAndReturnArgs} args - Arguments to create many Participants.
     * @example
     * // Create many Participants
     * const participant = await prisma.participant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Participants and only return the `id`
     * const participantWithIdOnly = await prisma.participant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Participant.
     * @param {ParticipantDeleteArgs} args - Arguments to delete one Participant.
     * @example
     * // Delete one Participant
     * const Participant = await prisma.participant.delete({
     *   where: {
     *     // ... filter to delete one Participant
     *   }
     * })
     * 
     */
    delete<T extends ParticipantDeleteArgs>(args: SelectSubset<T, ParticipantDeleteArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Participant.
     * @param {ParticipantUpdateArgs} args - Arguments to update one Participant.
     * @example
     * // Update one Participant
     * const participant = await prisma.participant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParticipantUpdateArgs>(args: SelectSubset<T, ParticipantUpdateArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Participants.
     * @param {ParticipantDeleteManyArgs} args - Arguments to filter Participants to delete.
     * @example
     * // Delete a few Participants
     * const { count } = await prisma.participant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParticipantDeleteManyArgs>(args?: SelectSubset<T, ParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Participants
     * const participant = await prisma.participant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParticipantUpdateManyArgs>(args: SelectSubset<T, ParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Participants and returns the data updated in the database.
     * @param {ParticipantUpdateManyAndReturnArgs} args - Arguments to update many Participants.
     * @example
     * // Update many Participants
     * const participant = await prisma.participant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Participants and only return the `id`
     * const participantWithIdOnly = await prisma.participant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Participant.
     * @param {ParticipantUpsertArgs} args - Arguments to update or create a Participant.
     * @example
     * // Update or create a Participant
     * const participant = await prisma.participant.upsert({
     *   create: {
     *     // ... data to create a Participant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Participant we want to update
     *   }
     * })
     */
    upsert<T extends ParticipantUpsertArgs>(args: SelectSubset<T, ParticipantUpsertArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantCountArgs} args - Arguments to filter Participants to count.
     * @example
     * // Count the number of Participants
     * const count = await prisma.participant.count({
     *   where: {
     *     // ... the filter for the Participants we want to count
     *   }
     * })
    **/
    count<T extends ParticipantCountArgs>(
      args?: Subset<T, ParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Participant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParticipantAggregateArgs>(args: Subset<T, ParticipantAggregateArgs>): Prisma.PrismaPromise<GetParticipantAggregateType<T>>

    /**
     * Group by Participant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Participant model
   */
  readonly fields: ParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Participant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainings<T extends Participant$trainingsArgs<ExtArgs> = {}>(args?: Subset<T, Participant$trainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Participant$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Participant$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends Participant$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Participant$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inviteTokens<T extends Participant$inviteTokensArgs<ExtArgs> = {}>(args?: Subset<T, Participant$inviteTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingInviteTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbackForms<T extends Participant$feedbackFormsArgs<ExtArgs> = {}>(args?: Subset<T, Participant$feedbackFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Participant model
   */
  interface ParticipantFieldRefs {
    readonly id: FieldRef<"Participant", 'String'>
    readonly name: FieldRef<"Participant", 'String'>
    readonly email: FieldRef<"Participant", 'String'>
    readonly phone: FieldRef<"Participant", 'String'>
    readonly organization: FieldRef<"Participant", 'String'>
    readonly position: FieldRef<"Participant", 'String'>
    readonly createdAt: FieldRef<"Participant", 'DateTime'>
    readonly updatedAt: FieldRef<"Participant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Participant findUnique
   */
  export type ParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where: ParticipantWhereUniqueInput
  }

  /**
   * Participant findUniqueOrThrow
   */
  export type ParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where: ParticipantWhereUniqueInput
  }

  /**
   * Participant findFirst
   */
  export type ParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Participants.
     */
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }

  /**
   * Participant findFirstOrThrow
   */
  export type ParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Participants.
     */
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }

  /**
   * Participant findMany
   */
  export type ParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participants to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }

  /**
   * Participant create
   */
  export type ParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a Participant.
     */
    data: XOR<ParticipantCreateInput, ParticipantUncheckedCreateInput>
  }

  /**
   * Participant createMany
   */
  export type ParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Participants.
     */
    data: ParticipantCreateManyInput | ParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Participant createManyAndReturn
   */
  export type ParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many Participants.
     */
    data: ParticipantCreateManyInput | ParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Participant update
   */
  export type ParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a Participant.
     */
    data: XOR<ParticipantUpdateInput, ParticipantUncheckedUpdateInput>
    /**
     * Choose, which Participant to update.
     */
    where: ParticipantWhereUniqueInput
  }

  /**
   * Participant updateMany
   */
  export type ParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Participants.
     */
    data: XOR<ParticipantUpdateManyMutationInput, ParticipantUncheckedUpdateManyInput>
    /**
     * Filter which Participants to update
     */
    where?: ParticipantWhereInput
    /**
     * Limit how many Participants to update.
     */
    limit?: number
  }

  /**
   * Participant updateManyAndReturn
   */
  export type ParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * The data used to update Participants.
     */
    data: XOR<ParticipantUpdateManyMutationInput, ParticipantUncheckedUpdateManyInput>
    /**
     * Filter which Participants to update
     */
    where?: ParticipantWhereInput
    /**
     * Limit how many Participants to update.
     */
    limit?: number
  }

  /**
   * Participant upsert
   */
  export type ParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the Participant to update in case it exists.
     */
    where: ParticipantWhereUniqueInput
    /**
     * In case the Participant found by the `where` argument doesn't exist, create a new Participant with this data.
     */
    create: XOR<ParticipantCreateInput, ParticipantUncheckedCreateInput>
    /**
     * In case the Participant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParticipantUpdateInput, ParticipantUncheckedUpdateInput>
  }

  /**
   * Participant delete
   */
  export type ParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter which Participant to delete.
     */
    where: ParticipantWhereUniqueInput
  }

  /**
   * Participant deleteMany
   */
  export type ParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Participants to delete
     */
    where?: ParticipantWhereInput
    /**
     * Limit how many Participants to delete.
     */
    limit?: number
  }

  /**
   * Participant.trainings
   */
  export type Participant$trainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    where?: TrainingParticipantWhereInput
    orderBy?: TrainingParticipantOrderByWithRelationInput | TrainingParticipantOrderByWithRelationInput[]
    cursor?: TrainingParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingParticipantScalarFieldEnum | TrainingParticipantScalarFieldEnum[]
  }

  /**
   * Participant.attendances
   */
  export type Participant$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Participant.feedbacks
   */
  export type Participant$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    where?: TrainingFeedbackWhereInput
    orderBy?: TrainingFeedbackOrderByWithRelationInput | TrainingFeedbackOrderByWithRelationInput[]
    cursor?: TrainingFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingFeedbackScalarFieldEnum | TrainingFeedbackScalarFieldEnum[]
  }

  /**
   * Participant.inviteTokens
   */
  export type Participant$inviteTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenInclude<ExtArgs> | null
    where?: TrainingInviteTokenWhereInput
    orderBy?: TrainingInviteTokenOrderByWithRelationInput | TrainingInviteTokenOrderByWithRelationInput[]
    cursor?: TrainingInviteTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingInviteTokenScalarFieldEnum | TrainingInviteTokenScalarFieldEnum[]
  }

  /**
   * Participant.feedbackForms
   */
  export type Participant$feedbackFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
    where?: FeedbackFormWhereInput
    orderBy?: FeedbackFormOrderByWithRelationInput | FeedbackFormOrderByWithRelationInput[]
    cursor?: FeedbackFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackFormScalarFieldEnum | FeedbackFormScalarFieldEnum[]
  }

  /**
   * Participant without action
   */
  export type ParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
  }


  /**
   * Model TrainingParticipant
   */

  export type AggregateTrainingParticipant = {
    _count: TrainingParticipantCountAggregateOutputType | null
    _min: TrainingParticipantMinAggregateOutputType | null
    _max: TrainingParticipantMaxAggregateOutputType | null
  }

  export type TrainingParticipantMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    participantId: string | null
    inviteSent: boolean | null
    inviteSentAt: Date | null
    inviteAccepted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingParticipantMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    participantId: string | null
    inviteSent: boolean | null
    inviteSentAt: Date | null
    inviteAccepted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingParticipantCountAggregateOutputType = {
    id: number
    trainingId: number
    participantId: number
    inviteSent: number
    inviteSentAt: number
    inviteAccepted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingParticipantMinAggregateInputType = {
    id?: true
    trainingId?: true
    participantId?: true
    inviteSent?: true
    inviteSentAt?: true
    inviteAccepted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingParticipantMaxAggregateInputType = {
    id?: true
    trainingId?: true
    participantId?: true
    inviteSent?: true
    inviteSentAt?: true
    inviteAccepted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingParticipantCountAggregateInputType = {
    id?: true
    trainingId?: true
    participantId?: true
    inviteSent?: true
    inviteSentAt?: true
    inviteAccepted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingParticipant to aggregate.
     */
    where?: TrainingParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingParticipants to fetch.
     */
    orderBy?: TrainingParticipantOrderByWithRelationInput | TrainingParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingParticipants
    **/
    _count?: true | TrainingParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingParticipantMaxAggregateInputType
  }

  export type GetTrainingParticipantAggregateType<T extends TrainingParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingParticipant[P]>
      : GetScalarType<T[P], AggregateTrainingParticipant[P]>
  }




  export type TrainingParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingParticipantWhereInput
    orderBy?: TrainingParticipantOrderByWithAggregationInput | TrainingParticipantOrderByWithAggregationInput[]
    by: TrainingParticipantScalarFieldEnum[] | TrainingParticipantScalarFieldEnum
    having?: TrainingParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingParticipantCountAggregateInputType | true
    _min?: TrainingParticipantMinAggregateInputType
    _max?: TrainingParticipantMaxAggregateInputType
  }

  export type TrainingParticipantGroupByOutputType = {
    id: string
    trainingId: string
    participantId: string
    inviteSent: boolean
    inviteSentAt: Date | null
    inviteAccepted: boolean
    createdAt: Date
    updatedAt: Date
    _count: TrainingParticipantCountAggregateOutputType | null
    _min: TrainingParticipantMinAggregateOutputType | null
    _max: TrainingParticipantMaxAggregateOutputType | null
  }

  type GetTrainingParticipantGroupByPayload<T extends TrainingParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingParticipantGroupByOutputType[P]>
        }
      >
    >


  export type TrainingParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    participantId?: boolean
    inviteSent?: boolean
    inviteSentAt?: boolean
    inviteAccepted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingParticipant"]>

  export type TrainingParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    participantId?: boolean
    inviteSent?: boolean
    inviteSentAt?: boolean
    inviteAccepted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingParticipant"]>

  export type TrainingParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    participantId?: boolean
    inviteSent?: boolean
    inviteSentAt?: boolean
    inviteAccepted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingParticipant"]>

  export type TrainingParticipantSelectScalar = {
    id?: boolean
    trainingId?: boolean
    participantId?: boolean
    inviteSent?: boolean
    inviteSentAt?: boolean
    inviteAccepted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "participantId" | "inviteSent" | "inviteSentAt" | "inviteAccepted" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingParticipant"]>
  export type TrainingParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }
  export type TrainingParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }
  export type TrainingParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }

  export type $TrainingParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingParticipant"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      participant: Prisma.$ParticipantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      participantId: string
      inviteSent: boolean
      inviteSentAt: Date | null
      inviteAccepted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingParticipant"]>
    composites: {}
  }

  type TrainingParticipantGetPayload<S extends boolean | null | undefined | TrainingParticipantDefaultArgs> = $Result.GetResult<Prisma.$TrainingParticipantPayload, S>

  type TrainingParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingParticipantCountAggregateInputType | true
    }

  export interface TrainingParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingParticipant'], meta: { name: 'TrainingParticipant' } }
    /**
     * Find zero or one TrainingParticipant that matches the filter.
     * @param {TrainingParticipantFindUniqueArgs} args - Arguments to find a TrainingParticipant
     * @example
     * // Get one TrainingParticipant
     * const trainingParticipant = await prisma.trainingParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingParticipantFindUniqueArgs>(args: SelectSubset<T, TrainingParticipantFindUniqueArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingParticipantFindUniqueOrThrowArgs} args - Arguments to find a TrainingParticipant
     * @example
     * // Get one TrainingParticipant
     * const trainingParticipant = await prisma.trainingParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantFindFirstArgs} args - Arguments to find a TrainingParticipant
     * @example
     * // Get one TrainingParticipant
     * const trainingParticipant = await prisma.trainingParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingParticipantFindFirstArgs>(args?: SelectSubset<T, TrainingParticipantFindFirstArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantFindFirstOrThrowArgs} args - Arguments to find a TrainingParticipant
     * @example
     * // Get one TrainingParticipant
     * const trainingParticipant = await prisma.trainingParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingParticipants
     * const trainingParticipants = await prisma.trainingParticipant.findMany()
     * 
     * // Get first 10 TrainingParticipants
     * const trainingParticipants = await prisma.trainingParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingParticipantWithIdOnly = await prisma.trainingParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingParticipantFindManyArgs>(args?: SelectSubset<T, TrainingParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingParticipant.
     * @param {TrainingParticipantCreateArgs} args - Arguments to create a TrainingParticipant.
     * @example
     * // Create one TrainingParticipant
     * const TrainingParticipant = await prisma.trainingParticipant.create({
     *   data: {
     *     // ... data to create a TrainingParticipant
     *   }
     * })
     * 
     */
    create<T extends TrainingParticipantCreateArgs>(args: SelectSubset<T, TrainingParticipantCreateArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingParticipants.
     * @param {TrainingParticipantCreateManyArgs} args - Arguments to create many TrainingParticipants.
     * @example
     * // Create many TrainingParticipants
     * const trainingParticipant = await prisma.trainingParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingParticipantCreateManyArgs>(args?: SelectSubset<T, TrainingParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingParticipants and returns the data saved in the database.
     * @param {TrainingParticipantCreateManyAndReturnArgs} args - Arguments to create many TrainingParticipants.
     * @example
     * // Create many TrainingParticipants
     * const trainingParticipant = await prisma.trainingParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingParticipants and only return the `id`
     * const trainingParticipantWithIdOnly = await prisma.trainingParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingParticipant.
     * @param {TrainingParticipantDeleteArgs} args - Arguments to delete one TrainingParticipant.
     * @example
     * // Delete one TrainingParticipant
     * const TrainingParticipant = await prisma.trainingParticipant.delete({
     *   where: {
     *     // ... filter to delete one TrainingParticipant
     *   }
     * })
     * 
     */
    delete<T extends TrainingParticipantDeleteArgs>(args: SelectSubset<T, TrainingParticipantDeleteArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingParticipant.
     * @param {TrainingParticipantUpdateArgs} args - Arguments to update one TrainingParticipant.
     * @example
     * // Update one TrainingParticipant
     * const trainingParticipant = await prisma.trainingParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingParticipantUpdateArgs>(args: SelectSubset<T, TrainingParticipantUpdateArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingParticipants.
     * @param {TrainingParticipantDeleteManyArgs} args - Arguments to filter TrainingParticipants to delete.
     * @example
     * // Delete a few TrainingParticipants
     * const { count } = await prisma.trainingParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingParticipantDeleteManyArgs>(args?: SelectSubset<T, TrainingParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingParticipants
     * const trainingParticipant = await prisma.trainingParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingParticipantUpdateManyArgs>(args: SelectSubset<T, TrainingParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingParticipants and returns the data updated in the database.
     * @param {TrainingParticipantUpdateManyAndReturnArgs} args - Arguments to update many TrainingParticipants.
     * @example
     * // Update many TrainingParticipants
     * const trainingParticipant = await prisma.trainingParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingParticipants and only return the `id`
     * const trainingParticipantWithIdOnly = await prisma.trainingParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingParticipant.
     * @param {TrainingParticipantUpsertArgs} args - Arguments to update or create a TrainingParticipant.
     * @example
     * // Update or create a TrainingParticipant
     * const trainingParticipant = await prisma.trainingParticipant.upsert({
     *   create: {
     *     // ... data to create a TrainingParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingParticipant we want to update
     *   }
     * })
     */
    upsert<T extends TrainingParticipantUpsertArgs>(args: SelectSubset<T, TrainingParticipantUpsertArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantCountArgs} args - Arguments to filter TrainingParticipants to count.
     * @example
     * // Count the number of TrainingParticipants
     * const count = await prisma.trainingParticipant.count({
     *   where: {
     *     // ... the filter for the TrainingParticipants we want to count
     *   }
     * })
    **/
    count<T extends TrainingParticipantCountArgs>(
      args?: Subset<T, TrainingParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingParticipantAggregateArgs>(args: Subset<T, TrainingParticipantAggregateArgs>): Prisma.PrismaPromise<GetTrainingParticipantAggregateType<T>>

    /**
     * Group by TrainingParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingParticipantGroupByArgs['orderBy'] }
        : { orderBy?: TrainingParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingParticipant model
   */
  readonly fields: TrainingParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participant<T extends ParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParticipantDefaultArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingParticipant model
   */
  interface TrainingParticipantFieldRefs {
    readonly id: FieldRef<"TrainingParticipant", 'String'>
    readonly trainingId: FieldRef<"TrainingParticipant", 'String'>
    readonly participantId: FieldRef<"TrainingParticipant", 'String'>
    readonly inviteSent: FieldRef<"TrainingParticipant", 'Boolean'>
    readonly inviteSentAt: FieldRef<"TrainingParticipant", 'DateTime'>
    readonly inviteAccepted: FieldRef<"TrainingParticipant", 'Boolean'>
    readonly createdAt: FieldRef<"TrainingParticipant", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingParticipant findUnique
   */
  export type TrainingParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TrainingParticipant to fetch.
     */
    where: TrainingParticipantWhereUniqueInput
  }

  /**
   * TrainingParticipant findUniqueOrThrow
   */
  export type TrainingParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TrainingParticipant to fetch.
     */
    where: TrainingParticipantWhereUniqueInput
  }

  /**
   * TrainingParticipant findFirst
   */
  export type TrainingParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TrainingParticipant to fetch.
     */
    where?: TrainingParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingParticipants to fetch.
     */
    orderBy?: TrainingParticipantOrderByWithRelationInput | TrainingParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingParticipants.
     */
    cursor?: TrainingParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingParticipants.
     */
    distinct?: TrainingParticipantScalarFieldEnum | TrainingParticipantScalarFieldEnum[]
  }

  /**
   * TrainingParticipant findFirstOrThrow
   */
  export type TrainingParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TrainingParticipant to fetch.
     */
    where?: TrainingParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingParticipants to fetch.
     */
    orderBy?: TrainingParticipantOrderByWithRelationInput | TrainingParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingParticipants.
     */
    cursor?: TrainingParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingParticipants.
     */
    distinct?: TrainingParticipantScalarFieldEnum | TrainingParticipantScalarFieldEnum[]
  }

  /**
   * TrainingParticipant findMany
   */
  export type TrainingParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TrainingParticipants to fetch.
     */
    where?: TrainingParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingParticipants to fetch.
     */
    orderBy?: TrainingParticipantOrderByWithRelationInput | TrainingParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingParticipants.
     */
    cursor?: TrainingParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingParticipants.
     */
    skip?: number
    distinct?: TrainingParticipantScalarFieldEnum | TrainingParticipantScalarFieldEnum[]
  }

  /**
   * TrainingParticipant create
   */
  export type TrainingParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingParticipant.
     */
    data: XOR<TrainingParticipantCreateInput, TrainingParticipantUncheckedCreateInput>
  }

  /**
   * TrainingParticipant createMany
   */
  export type TrainingParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingParticipants.
     */
    data: TrainingParticipantCreateManyInput | TrainingParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingParticipant createManyAndReturn
   */
  export type TrainingParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingParticipants.
     */
    data: TrainingParticipantCreateManyInput | TrainingParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingParticipant update
   */
  export type TrainingParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingParticipant.
     */
    data: XOR<TrainingParticipantUpdateInput, TrainingParticipantUncheckedUpdateInput>
    /**
     * Choose, which TrainingParticipant to update.
     */
    where: TrainingParticipantWhereUniqueInput
  }

  /**
   * TrainingParticipant updateMany
   */
  export type TrainingParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingParticipants.
     */
    data: XOR<TrainingParticipantUpdateManyMutationInput, TrainingParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TrainingParticipants to update
     */
    where?: TrainingParticipantWhereInput
    /**
     * Limit how many TrainingParticipants to update.
     */
    limit?: number
  }

  /**
   * TrainingParticipant updateManyAndReturn
   */
  export type TrainingParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * The data used to update TrainingParticipants.
     */
    data: XOR<TrainingParticipantUpdateManyMutationInput, TrainingParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TrainingParticipants to update
     */
    where?: TrainingParticipantWhereInput
    /**
     * Limit how many TrainingParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingParticipant upsert
   */
  export type TrainingParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingParticipant to update in case it exists.
     */
    where: TrainingParticipantWhereUniqueInput
    /**
     * In case the TrainingParticipant found by the `where` argument doesn't exist, create a new TrainingParticipant with this data.
     */
    create: XOR<TrainingParticipantCreateInput, TrainingParticipantUncheckedCreateInput>
    /**
     * In case the TrainingParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingParticipantUpdateInput, TrainingParticipantUncheckedUpdateInput>
  }

  /**
   * TrainingParticipant delete
   */
  export type TrainingParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * Filter which TrainingParticipant to delete.
     */
    where: TrainingParticipantWhereUniqueInput
  }

  /**
   * TrainingParticipant deleteMany
   */
  export type TrainingParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingParticipants to delete
     */
    where?: TrainingParticipantWhereInput
    /**
     * Limit how many TrainingParticipants to delete.
     */
    limit?: number
  }

  /**
   * TrainingParticipant without action
   */
  export type TrainingParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    sessionId: string | null
    participantId: string | null
    status: $Enums.AttendanceStatus | null
    remarks: string | null
    signatureUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    sessionId: string | null
    participantId: string | null
    status: $Enums.AttendanceStatus | null
    remarks: string | null
    signatureUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    trainingId: number
    sessionId: number
    participantId: number
    status: number
    remarks: number
    signatureUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    trainingId?: true
    sessionId?: true
    participantId?: true
    status?: true
    remarks?: true
    signatureUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    trainingId?: true
    sessionId?: true
    participantId?: true
    status?: true
    remarks?: true
    signatureUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    trainingId?: true
    sessionId?: true
    participantId?: true
    status?: true
    remarks?: true
    signatureUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    trainingId: string
    sessionId: string
    participantId: string
    status: $Enums.AttendanceStatus
    remarks: string | null
    signatureUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    participantId?: boolean
    status?: boolean
    remarks?: boolean
    signatureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    participantId?: boolean
    status?: boolean
    remarks?: boolean
    signatureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    participantId?: boolean
    status?: boolean
    remarks?: boolean
    signatureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    participantId?: boolean
    status?: boolean
    remarks?: boolean
    signatureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "sessionId" | "participantId" | "status" | "remarks" | "signatureUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      session: Prisma.$TrainingSessionPayload<ExtArgs>
      participant: Prisma.$ParticipantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      sessionId: string
      participantId: string
      status: $Enums.AttendanceStatus
      remarks: string | null
      signatureUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session<T extends TrainingSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingSessionDefaultArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participant<T extends ParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParticipantDefaultArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly trainingId: FieldRef<"Attendance", 'String'>
    readonly sessionId: FieldRef<"Attendance", 'String'>
    readonly participantId: FieldRef<"Attendance", 'String'>
    readonly status: FieldRef<"Attendance", 'AttendanceStatus'>
    readonly remarks: FieldRef<"Attendance", 'String'>
    readonly signatureUrl: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model TrainingPhoto
   */

  export type AggregateTrainingPhoto = {
    _count: TrainingPhotoCountAggregateOutputType | null
    _min: TrainingPhotoMinAggregateOutputType | null
    _max: TrainingPhotoMaxAggregateOutputType | null
  }

  export type TrainingPhotoMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    photoUrl: string | null
    caption: string | null
    uploadedById: string | null
    createdAt: Date | null
  }

  export type TrainingPhotoMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    photoUrl: string | null
    caption: string | null
    uploadedById: string | null
    createdAt: Date | null
  }

  export type TrainingPhotoCountAggregateOutputType = {
    id: number
    trainingId: number
    photoUrl: number
    caption: number
    uploadedById: number
    createdAt: number
    _all: number
  }


  export type TrainingPhotoMinAggregateInputType = {
    id?: true
    trainingId?: true
    photoUrl?: true
    caption?: true
    uploadedById?: true
    createdAt?: true
  }

  export type TrainingPhotoMaxAggregateInputType = {
    id?: true
    trainingId?: true
    photoUrl?: true
    caption?: true
    uploadedById?: true
    createdAt?: true
  }

  export type TrainingPhotoCountAggregateInputType = {
    id?: true
    trainingId?: true
    photoUrl?: true
    caption?: true
    uploadedById?: true
    createdAt?: true
    _all?: true
  }

  export type TrainingPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingPhoto to aggregate.
     */
    where?: TrainingPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPhotos to fetch.
     */
    orderBy?: TrainingPhotoOrderByWithRelationInput | TrainingPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingPhotos
    **/
    _count?: true | TrainingPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingPhotoMaxAggregateInputType
  }

  export type GetTrainingPhotoAggregateType<T extends TrainingPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingPhoto[P]>
      : GetScalarType<T[P], AggregateTrainingPhoto[P]>
  }




  export type TrainingPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPhotoWhereInput
    orderBy?: TrainingPhotoOrderByWithAggregationInput | TrainingPhotoOrderByWithAggregationInput[]
    by: TrainingPhotoScalarFieldEnum[] | TrainingPhotoScalarFieldEnum
    having?: TrainingPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingPhotoCountAggregateInputType | true
    _min?: TrainingPhotoMinAggregateInputType
    _max?: TrainingPhotoMaxAggregateInputType
  }

  export type TrainingPhotoGroupByOutputType = {
    id: string
    trainingId: string
    photoUrl: string
    caption: string | null
    uploadedById: string
    createdAt: Date
    _count: TrainingPhotoCountAggregateOutputType | null
    _min: TrainingPhotoMinAggregateOutputType | null
    _max: TrainingPhotoMaxAggregateOutputType | null
  }

  type GetTrainingPhotoGroupByPayload<T extends TrainingPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingPhotoGroupByOutputType[P]>
        }
      >
    >


  export type TrainingPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    photoUrl?: boolean
    caption?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPhoto"]>

  export type TrainingPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    photoUrl?: boolean
    caption?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPhoto"]>

  export type TrainingPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    photoUrl?: boolean
    caption?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPhoto"]>

  export type TrainingPhotoSelectScalar = {
    id?: boolean
    trainingId?: boolean
    photoUrl?: boolean
    caption?: boolean
    uploadedById?: boolean
    createdAt?: boolean
  }

  export type TrainingPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "photoUrl" | "caption" | "uploadedById" | "createdAt", ExtArgs["result"]["trainingPhoto"]>
  export type TrainingPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingPhoto"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      photoUrl: string
      caption: string | null
      uploadedById: string
      createdAt: Date
    }, ExtArgs["result"]["trainingPhoto"]>
    composites: {}
  }

  type TrainingPhotoGetPayload<S extends boolean | null | undefined | TrainingPhotoDefaultArgs> = $Result.GetResult<Prisma.$TrainingPhotoPayload, S>

  type TrainingPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingPhotoCountAggregateInputType | true
    }

  export interface TrainingPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingPhoto'], meta: { name: 'TrainingPhoto' } }
    /**
     * Find zero or one TrainingPhoto that matches the filter.
     * @param {TrainingPhotoFindUniqueArgs} args - Arguments to find a TrainingPhoto
     * @example
     * // Get one TrainingPhoto
     * const trainingPhoto = await prisma.trainingPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingPhotoFindUniqueArgs>(args: SelectSubset<T, TrainingPhotoFindUniqueArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingPhotoFindUniqueOrThrowArgs} args - Arguments to find a TrainingPhoto
     * @example
     * // Get one TrainingPhoto
     * const trainingPhoto = await prisma.trainingPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoFindFirstArgs} args - Arguments to find a TrainingPhoto
     * @example
     * // Get one TrainingPhoto
     * const trainingPhoto = await prisma.trainingPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingPhotoFindFirstArgs>(args?: SelectSubset<T, TrainingPhotoFindFirstArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoFindFirstOrThrowArgs} args - Arguments to find a TrainingPhoto
     * @example
     * // Get one TrainingPhoto
     * const trainingPhoto = await prisma.trainingPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingPhotos
     * const trainingPhotos = await prisma.trainingPhoto.findMany()
     * 
     * // Get first 10 TrainingPhotos
     * const trainingPhotos = await prisma.trainingPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingPhotoWithIdOnly = await prisma.trainingPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingPhotoFindManyArgs>(args?: SelectSubset<T, TrainingPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingPhoto.
     * @param {TrainingPhotoCreateArgs} args - Arguments to create a TrainingPhoto.
     * @example
     * // Create one TrainingPhoto
     * const TrainingPhoto = await prisma.trainingPhoto.create({
     *   data: {
     *     // ... data to create a TrainingPhoto
     *   }
     * })
     * 
     */
    create<T extends TrainingPhotoCreateArgs>(args: SelectSubset<T, TrainingPhotoCreateArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingPhotos.
     * @param {TrainingPhotoCreateManyArgs} args - Arguments to create many TrainingPhotos.
     * @example
     * // Create many TrainingPhotos
     * const trainingPhoto = await prisma.trainingPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingPhotoCreateManyArgs>(args?: SelectSubset<T, TrainingPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingPhotos and returns the data saved in the database.
     * @param {TrainingPhotoCreateManyAndReturnArgs} args - Arguments to create many TrainingPhotos.
     * @example
     * // Create many TrainingPhotos
     * const trainingPhoto = await prisma.trainingPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingPhotos and only return the `id`
     * const trainingPhotoWithIdOnly = await prisma.trainingPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingPhoto.
     * @param {TrainingPhotoDeleteArgs} args - Arguments to delete one TrainingPhoto.
     * @example
     * // Delete one TrainingPhoto
     * const TrainingPhoto = await prisma.trainingPhoto.delete({
     *   where: {
     *     // ... filter to delete one TrainingPhoto
     *   }
     * })
     * 
     */
    delete<T extends TrainingPhotoDeleteArgs>(args: SelectSubset<T, TrainingPhotoDeleteArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingPhoto.
     * @param {TrainingPhotoUpdateArgs} args - Arguments to update one TrainingPhoto.
     * @example
     * // Update one TrainingPhoto
     * const trainingPhoto = await prisma.trainingPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingPhotoUpdateArgs>(args: SelectSubset<T, TrainingPhotoUpdateArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingPhotos.
     * @param {TrainingPhotoDeleteManyArgs} args - Arguments to filter TrainingPhotos to delete.
     * @example
     * // Delete a few TrainingPhotos
     * const { count } = await prisma.trainingPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingPhotoDeleteManyArgs>(args?: SelectSubset<T, TrainingPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingPhotos
     * const trainingPhoto = await prisma.trainingPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingPhotoUpdateManyArgs>(args: SelectSubset<T, TrainingPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingPhotos and returns the data updated in the database.
     * @param {TrainingPhotoUpdateManyAndReturnArgs} args - Arguments to update many TrainingPhotos.
     * @example
     * // Update many TrainingPhotos
     * const trainingPhoto = await prisma.trainingPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingPhotos and only return the `id`
     * const trainingPhotoWithIdOnly = await prisma.trainingPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingPhoto.
     * @param {TrainingPhotoUpsertArgs} args - Arguments to update or create a TrainingPhoto.
     * @example
     * // Update or create a TrainingPhoto
     * const trainingPhoto = await prisma.trainingPhoto.upsert({
     *   create: {
     *     // ... data to create a TrainingPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingPhoto we want to update
     *   }
     * })
     */
    upsert<T extends TrainingPhotoUpsertArgs>(args: SelectSubset<T, TrainingPhotoUpsertArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoCountArgs} args - Arguments to filter TrainingPhotos to count.
     * @example
     * // Count the number of TrainingPhotos
     * const count = await prisma.trainingPhoto.count({
     *   where: {
     *     // ... the filter for the TrainingPhotos we want to count
     *   }
     * })
    **/
    count<T extends TrainingPhotoCountArgs>(
      args?: Subset<T, TrainingPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingPhotoAggregateArgs>(args: Subset<T, TrainingPhotoAggregateArgs>): Prisma.PrismaPromise<GetTrainingPhotoAggregateType<T>>

    /**
     * Group by TrainingPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingPhotoGroupByArgs['orderBy'] }
        : { orderBy?: TrainingPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingPhoto model
   */
  readonly fields: TrainingPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingPhoto model
   */
  interface TrainingPhotoFieldRefs {
    readonly id: FieldRef<"TrainingPhoto", 'String'>
    readonly trainingId: FieldRef<"TrainingPhoto", 'String'>
    readonly photoUrl: FieldRef<"TrainingPhoto", 'String'>
    readonly caption: FieldRef<"TrainingPhoto", 'String'>
    readonly uploadedById: FieldRef<"TrainingPhoto", 'String'>
    readonly createdAt: FieldRef<"TrainingPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingPhoto findUnique
   */
  export type TrainingPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPhoto to fetch.
     */
    where: TrainingPhotoWhereUniqueInput
  }

  /**
   * TrainingPhoto findUniqueOrThrow
   */
  export type TrainingPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPhoto to fetch.
     */
    where: TrainingPhotoWhereUniqueInput
  }

  /**
   * TrainingPhoto findFirst
   */
  export type TrainingPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPhoto to fetch.
     */
    where?: TrainingPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPhotos to fetch.
     */
    orderBy?: TrainingPhotoOrderByWithRelationInput | TrainingPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPhotos.
     */
    cursor?: TrainingPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPhotos.
     */
    distinct?: TrainingPhotoScalarFieldEnum | TrainingPhotoScalarFieldEnum[]
  }

  /**
   * TrainingPhoto findFirstOrThrow
   */
  export type TrainingPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPhoto to fetch.
     */
    where?: TrainingPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPhotos to fetch.
     */
    orderBy?: TrainingPhotoOrderByWithRelationInput | TrainingPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPhotos.
     */
    cursor?: TrainingPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPhotos.
     */
    distinct?: TrainingPhotoScalarFieldEnum | TrainingPhotoScalarFieldEnum[]
  }

  /**
   * TrainingPhoto findMany
   */
  export type TrainingPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPhotos to fetch.
     */
    where?: TrainingPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPhotos to fetch.
     */
    orderBy?: TrainingPhotoOrderByWithRelationInput | TrainingPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingPhotos.
     */
    cursor?: TrainingPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPhotos.
     */
    skip?: number
    distinct?: TrainingPhotoScalarFieldEnum | TrainingPhotoScalarFieldEnum[]
  }

  /**
   * TrainingPhoto create
   */
  export type TrainingPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingPhoto.
     */
    data: XOR<TrainingPhotoCreateInput, TrainingPhotoUncheckedCreateInput>
  }

  /**
   * TrainingPhoto createMany
   */
  export type TrainingPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingPhotos.
     */
    data: TrainingPhotoCreateManyInput | TrainingPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingPhoto createManyAndReturn
   */
  export type TrainingPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingPhotos.
     */
    data: TrainingPhotoCreateManyInput | TrainingPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingPhoto update
   */
  export type TrainingPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingPhoto.
     */
    data: XOR<TrainingPhotoUpdateInput, TrainingPhotoUncheckedUpdateInput>
    /**
     * Choose, which TrainingPhoto to update.
     */
    where: TrainingPhotoWhereUniqueInput
  }

  /**
   * TrainingPhoto updateMany
   */
  export type TrainingPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingPhotos.
     */
    data: XOR<TrainingPhotoUpdateManyMutationInput, TrainingPhotoUncheckedUpdateManyInput>
    /**
     * Filter which TrainingPhotos to update
     */
    where?: TrainingPhotoWhereInput
    /**
     * Limit how many TrainingPhotos to update.
     */
    limit?: number
  }

  /**
   * TrainingPhoto updateManyAndReturn
   */
  export type TrainingPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * The data used to update TrainingPhotos.
     */
    data: XOR<TrainingPhotoUpdateManyMutationInput, TrainingPhotoUncheckedUpdateManyInput>
    /**
     * Filter which TrainingPhotos to update
     */
    where?: TrainingPhotoWhereInput
    /**
     * Limit how many TrainingPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingPhoto upsert
   */
  export type TrainingPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingPhoto to update in case it exists.
     */
    where: TrainingPhotoWhereUniqueInput
    /**
     * In case the TrainingPhoto found by the `where` argument doesn't exist, create a new TrainingPhoto with this data.
     */
    create: XOR<TrainingPhotoCreateInput, TrainingPhotoUncheckedCreateInput>
    /**
     * In case the TrainingPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingPhotoUpdateInput, TrainingPhotoUncheckedUpdateInput>
  }

  /**
   * TrainingPhoto delete
   */
  export type TrainingPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * Filter which TrainingPhoto to delete.
     */
    where: TrainingPhotoWhereUniqueInput
  }

  /**
   * TrainingPhoto deleteMany
   */
  export type TrainingPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingPhotos to delete
     */
    where?: TrainingPhotoWhereInput
    /**
     * Limit how many TrainingPhotos to delete.
     */
    limit?: number
  }

  /**
   * TrainingPhoto without action
   */
  export type TrainingPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
  }


  /**
   * Model TrainingFeedback
   */

  export type AggregateTrainingFeedback = {
    _count: TrainingFeedbackCountAggregateOutputType | null
    _avg: TrainingFeedbackAvgAggregateOutputType | null
    _sum: TrainingFeedbackSumAggregateOutputType | null
    _min: TrainingFeedbackMinAggregateOutputType | null
    _max: TrainingFeedbackMaxAggregateOutputType | null
  }

  export type TrainingFeedbackAvgAggregateOutputType = {
    contentRating: number | null
    trainerRating: number | null
    materialRating: number | null
    venueRating: number | null
    overallRating: number | null
  }

  export type TrainingFeedbackSumAggregateOutputType = {
    contentRating: number | null
    trainerRating: number | null
    materialRating: number | null
    venueRating: number | null
    overallRating: number | null
  }

  export type TrainingFeedbackMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    participantId: string | null
    contentRating: number | null
    trainerRating: number | null
    materialRating: number | null
    venueRating: number | null
    overallRating: number | null
    comments: string | null
    suggestedImprovements: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingFeedbackMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    participantId: string | null
    contentRating: number | null
    trainerRating: number | null
    materialRating: number | null
    venueRating: number | null
    overallRating: number | null
    comments: string | null
    suggestedImprovements: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingFeedbackCountAggregateOutputType = {
    id: number
    trainingId: number
    participantId: number
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments: number
    suggestedImprovements: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingFeedbackAvgAggregateInputType = {
    contentRating?: true
    trainerRating?: true
    materialRating?: true
    venueRating?: true
    overallRating?: true
  }

  export type TrainingFeedbackSumAggregateInputType = {
    contentRating?: true
    trainerRating?: true
    materialRating?: true
    venueRating?: true
    overallRating?: true
  }

  export type TrainingFeedbackMinAggregateInputType = {
    id?: true
    trainingId?: true
    participantId?: true
    contentRating?: true
    trainerRating?: true
    materialRating?: true
    venueRating?: true
    overallRating?: true
    comments?: true
    suggestedImprovements?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingFeedbackMaxAggregateInputType = {
    id?: true
    trainingId?: true
    participantId?: true
    contentRating?: true
    trainerRating?: true
    materialRating?: true
    venueRating?: true
    overallRating?: true
    comments?: true
    suggestedImprovements?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingFeedbackCountAggregateInputType = {
    id?: true
    trainingId?: true
    participantId?: true
    contentRating?: true
    trainerRating?: true
    materialRating?: true
    venueRating?: true
    overallRating?: true
    comments?: true
    suggestedImprovements?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingFeedback to aggregate.
     */
    where?: TrainingFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFeedbacks to fetch.
     */
    orderBy?: TrainingFeedbackOrderByWithRelationInput | TrainingFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingFeedbacks
    **/
    _count?: true | TrainingFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingFeedbackMaxAggregateInputType
  }

  export type GetTrainingFeedbackAggregateType<T extends TrainingFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingFeedback[P]>
      : GetScalarType<T[P], AggregateTrainingFeedback[P]>
  }




  export type TrainingFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFeedbackWhereInput
    orderBy?: TrainingFeedbackOrderByWithAggregationInput | TrainingFeedbackOrderByWithAggregationInput[]
    by: TrainingFeedbackScalarFieldEnum[] | TrainingFeedbackScalarFieldEnum
    having?: TrainingFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingFeedbackCountAggregateInputType | true
    _avg?: TrainingFeedbackAvgAggregateInputType
    _sum?: TrainingFeedbackSumAggregateInputType
    _min?: TrainingFeedbackMinAggregateInputType
    _max?: TrainingFeedbackMaxAggregateInputType
  }

  export type TrainingFeedbackGroupByOutputType = {
    id: string
    trainingId: string
    participantId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments: string | null
    suggestedImprovements: string | null
    createdAt: Date
    updatedAt: Date
    _count: TrainingFeedbackCountAggregateOutputType | null
    _avg: TrainingFeedbackAvgAggregateOutputType | null
    _sum: TrainingFeedbackSumAggregateOutputType | null
    _min: TrainingFeedbackMinAggregateOutputType | null
    _max: TrainingFeedbackMaxAggregateOutputType | null
  }

  type GetTrainingFeedbackGroupByPayload<T extends TrainingFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type TrainingFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    participantId?: boolean
    contentRating?: boolean
    trainerRating?: boolean
    materialRating?: boolean
    venueRating?: boolean
    overallRating?: boolean
    comments?: boolean
    suggestedImprovements?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingFeedback"]>

  export type TrainingFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    participantId?: boolean
    contentRating?: boolean
    trainerRating?: boolean
    materialRating?: boolean
    venueRating?: boolean
    overallRating?: boolean
    comments?: boolean
    suggestedImprovements?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingFeedback"]>

  export type TrainingFeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    participantId?: boolean
    contentRating?: boolean
    trainerRating?: boolean
    materialRating?: boolean
    venueRating?: boolean
    overallRating?: boolean
    comments?: boolean
    suggestedImprovements?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingFeedback"]>

  export type TrainingFeedbackSelectScalar = {
    id?: boolean
    trainingId?: boolean
    participantId?: boolean
    contentRating?: boolean
    trainerRating?: boolean
    materialRating?: boolean
    venueRating?: boolean
    overallRating?: boolean
    comments?: boolean
    suggestedImprovements?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "participantId" | "contentRating" | "trainerRating" | "materialRating" | "venueRating" | "overallRating" | "comments" | "suggestedImprovements" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingFeedback"]>
  export type TrainingFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }
  export type TrainingFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }
  export type TrainingFeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }

  export type $TrainingFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingFeedback"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      participant: Prisma.$ParticipantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      participantId: string
      contentRating: number
      trainerRating: number
      materialRating: number
      venueRating: number
      overallRating: number
      comments: string | null
      suggestedImprovements: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingFeedback"]>
    composites: {}
  }

  type TrainingFeedbackGetPayload<S extends boolean | null | undefined | TrainingFeedbackDefaultArgs> = $Result.GetResult<Prisma.$TrainingFeedbackPayload, S>

  type TrainingFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingFeedbackCountAggregateInputType | true
    }

  export interface TrainingFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingFeedback'], meta: { name: 'TrainingFeedback' } }
    /**
     * Find zero or one TrainingFeedback that matches the filter.
     * @param {TrainingFeedbackFindUniqueArgs} args - Arguments to find a TrainingFeedback
     * @example
     * // Get one TrainingFeedback
     * const trainingFeedback = await prisma.trainingFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingFeedbackFindUniqueArgs>(args: SelectSubset<T, TrainingFeedbackFindUniqueArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingFeedbackFindUniqueOrThrowArgs} args - Arguments to find a TrainingFeedback
     * @example
     * // Get one TrainingFeedback
     * const trainingFeedback = await prisma.trainingFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackFindFirstArgs} args - Arguments to find a TrainingFeedback
     * @example
     * // Get one TrainingFeedback
     * const trainingFeedback = await prisma.trainingFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingFeedbackFindFirstArgs>(args?: SelectSubset<T, TrainingFeedbackFindFirstArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackFindFirstOrThrowArgs} args - Arguments to find a TrainingFeedback
     * @example
     * // Get one TrainingFeedback
     * const trainingFeedback = await prisma.trainingFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingFeedbacks
     * const trainingFeedbacks = await prisma.trainingFeedback.findMany()
     * 
     * // Get first 10 TrainingFeedbacks
     * const trainingFeedbacks = await prisma.trainingFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingFeedbackWithIdOnly = await prisma.trainingFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingFeedbackFindManyArgs>(args?: SelectSubset<T, TrainingFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingFeedback.
     * @param {TrainingFeedbackCreateArgs} args - Arguments to create a TrainingFeedback.
     * @example
     * // Create one TrainingFeedback
     * const TrainingFeedback = await prisma.trainingFeedback.create({
     *   data: {
     *     // ... data to create a TrainingFeedback
     *   }
     * })
     * 
     */
    create<T extends TrainingFeedbackCreateArgs>(args: SelectSubset<T, TrainingFeedbackCreateArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingFeedbacks.
     * @param {TrainingFeedbackCreateManyArgs} args - Arguments to create many TrainingFeedbacks.
     * @example
     * // Create many TrainingFeedbacks
     * const trainingFeedback = await prisma.trainingFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingFeedbackCreateManyArgs>(args?: SelectSubset<T, TrainingFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingFeedbacks and returns the data saved in the database.
     * @param {TrainingFeedbackCreateManyAndReturnArgs} args - Arguments to create many TrainingFeedbacks.
     * @example
     * // Create many TrainingFeedbacks
     * const trainingFeedback = await prisma.trainingFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingFeedbacks and only return the `id`
     * const trainingFeedbackWithIdOnly = await prisma.trainingFeedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingFeedback.
     * @param {TrainingFeedbackDeleteArgs} args - Arguments to delete one TrainingFeedback.
     * @example
     * // Delete one TrainingFeedback
     * const TrainingFeedback = await prisma.trainingFeedback.delete({
     *   where: {
     *     // ... filter to delete one TrainingFeedback
     *   }
     * })
     * 
     */
    delete<T extends TrainingFeedbackDeleteArgs>(args: SelectSubset<T, TrainingFeedbackDeleteArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingFeedback.
     * @param {TrainingFeedbackUpdateArgs} args - Arguments to update one TrainingFeedback.
     * @example
     * // Update one TrainingFeedback
     * const trainingFeedback = await prisma.trainingFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingFeedbackUpdateArgs>(args: SelectSubset<T, TrainingFeedbackUpdateArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingFeedbacks.
     * @param {TrainingFeedbackDeleteManyArgs} args - Arguments to filter TrainingFeedbacks to delete.
     * @example
     * // Delete a few TrainingFeedbacks
     * const { count } = await prisma.trainingFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingFeedbackDeleteManyArgs>(args?: SelectSubset<T, TrainingFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingFeedbacks
     * const trainingFeedback = await prisma.trainingFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingFeedbackUpdateManyArgs>(args: SelectSubset<T, TrainingFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingFeedbacks and returns the data updated in the database.
     * @param {TrainingFeedbackUpdateManyAndReturnArgs} args - Arguments to update many TrainingFeedbacks.
     * @example
     * // Update many TrainingFeedbacks
     * const trainingFeedback = await prisma.trainingFeedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingFeedbacks and only return the `id`
     * const trainingFeedbackWithIdOnly = await prisma.trainingFeedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingFeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingFeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingFeedback.
     * @param {TrainingFeedbackUpsertArgs} args - Arguments to update or create a TrainingFeedback.
     * @example
     * // Update or create a TrainingFeedback
     * const trainingFeedback = await prisma.trainingFeedback.upsert({
     *   create: {
     *     // ... data to create a TrainingFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingFeedback we want to update
     *   }
     * })
     */
    upsert<T extends TrainingFeedbackUpsertArgs>(args: SelectSubset<T, TrainingFeedbackUpsertArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackCountArgs} args - Arguments to filter TrainingFeedbacks to count.
     * @example
     * // Count the number of TrainingFeedbacks
     * const count = await prisma.trainingFeedback.count({
     *   where: {
     *     // ... the filter for the TrainingFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends TrainingFeedbackCountArgs>(
      args?: Subset<T, TrainingFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingFeedbackAggregateArgs>(args: Subset<T, TrainingFeedbackAggregateArgs>): Prisma.PrismaPromise<GetTrainingFeedbackAggregateType<T>>

    /**
     * Group by TrainingFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: TrainingFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingFeedback model
   */
  readonly fields: TrainingFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participant<T extends ParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParticipantDefaultArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingFeedback model
   */
  interface TrainingFeedbackFieldRefs {
    readonly id: FieldRef<"TrainingFeedback", 'String'>
    readonly trainingId: FieldRef<"TrainingFeedback", 'String'>
    readonly participantId: FieldRef<"TrainingFeedback", 'String'>
    readonly contentRating: FieldRef<"TrainingFeedback", 'Int'>
    readonly trainerRating: FieldRef<"TrainingFeedback", 'Int'>
    readonly materialRating: FieldRef<"TrainingFeedback", 'Int'>
    readonly venueRating: FieldRef<"TrainingFeedback", 'Int'>
    readonly overallRating: FieldRef<"TrainingFeedback", 'Int'>
    readonly comments: FieldRef<"TrainingFeedback", 'String'>
    readonly suggestedImprovements: FieldRef<"TrainingFeedback", 'String'>
    readonly createdAt: FieldRef<"TrainingFeedback", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingFeedback findUnique
   */
  export type TrainingFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFeedback to fetch.
     */
    where: TrainingFeedbackWhereUniqueInput
  }

  /**
   * TrainingFeedback findUniqueOrThrow
   */
  export type TrainingFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFeedback to fetch.
     */
    where: TrainingFeedbackWhereUniqueInput
  }

  /**
   * TrainingFeedback findFirst
   */
  export type TrainingFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFeedback to fetch.
     */
    where?: TrainingFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFeedbacks to fetch.
     */
    orderBy?: TrainingFeedbackOrderByWithRelationInput | TrainingFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingFeedbacks.
     */
    cursor?: TrainingFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingFeedbacks.
     */
    distinct?: TrainingFeedbackScalarFieldEnum | TrainingFeedbackScalarFieldEnum[]
  }

  /**
   * TrainingFeedback findFirstOrThrow
   */
  export type TrainingFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFeedback to fetch.
     */
    where?: TrainingFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFeedbacks to fetch.
     */
    orderBy?: TrainingFeedbackOrderByWithRelationInput | TrainingFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingFeedbacks.
     */
    cursor?: TrainingFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingFeedbacks.
     */
    distinct?: TrainingFeedbackScalarFieldEnum | TrainingFeedbackScalarFieldEnum[]
  }

  /**
   * TrainingFeedback findMany
   */
  export type TrainingFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFeedbacks to fetch.
     */
    where?: TrainingFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFeedbacks to fetch.
     */
    orderBy?: TrainingFeedbackOrderByWithRelationInput | TrainingFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingFeedbacks.
     */
    cursor?: TrainingFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFeedbacks.
     */
    skip?: number
    distinct?: TrainingFeedbackScalarFieldEnum | TrainingFeedbackScalarFieldEnum[]
  }

  /**
   * TrainingFeedback create
   */
  export type TrainingFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingFeedback.
     */
    data: XOR<TrainingFeedbackCreateInput, TrainingFeedbackUncheckedCreateInput>
  }

  /**
   * TrainingFeedback createMany
   */
  export type TrainingFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingFeedbacks.
     */
    data: TrainingFeedbackCreateManyInput | TrainingFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingFeedback createManyAndReturn
   */
  export type TrainingFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingFeedbacks.
     */
    data: TrainingFeedbackCreateManyInput | TrainingFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingFeedback update
   */
  export type TrainingFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingFeedback.
     */
    data: XOR<TrainingFeedbackUpdateInput, TrainingFeedbackUncheckedUpdateInput>
    /**
     * Choose, which TrainingFeedback to update.
     */
    where: TrainingFeedbackWhereUniqueInput
  }

  /**
   * TrainingFeedback updateMany
   */
  export type TrainingFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingFeedbacks.
     */
    data: XOR<TrainingFeedbackUpdateManyMutationInput, TrainingFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which TrainingFeedbacks to update
     */
    where?: TrainingFeedbackWhereInput
    /**
     * Limit how many TrainingFeedbacks to update.
     */
    limit?: number
  }

  /**
   * TrainingFeedback updateManyAndReturn
   */
  export type TrainingFeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * The data used to update TrainingFeedbacks.
     */
    data: XOR<TrainingFeedbackUpdateManyMutationInput, TrainingFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which TrainingFeedbacks to update
     */
    where?: TrainingFeedbackWhereInput
    /**
     * Limit how many TrainingFeedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingFeedback upsert
   */
  export type TrainingFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingFeedback to update in case it exists.
     */
    where: TrainingFeedbackWhereUniqueInput
    /**
     * In case the TrainingFeedback found by the `where` argument doesn't exist, create a new TrainingFeedback with this data.
     */
    create: XOR<TrainingFeedbackCreateInput, TrainingFeedbackUncheckedCreateInput>
    /**
     * In case the TrainingFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingFeedbackUpdateInput, TrainingFeedbackUncheckedUpdateInput>
  }

  /**
   * TrainingFeedback delete
   */
  export type TrainingFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * Filter which TrainingFeedback to delete.
     */
    where: TrainingFeedbackWhereUniqueInput
  }

  /**
   * TrainingFeedback deleteMany
   */
  export type TrainingFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingFeedbacks to delete
     */
    where?: TrainingFeedbackWhereInput
    /**
     * Limit how many TrainingFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * TrainingFeedback without action
   */
  export type TrainingFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model FeedbackForm
   */

  export type AggregateFeedbackForm = {
    _count: FeedbackFormCountAggregateOutputType | null
    _min: FeedbackFormMinAggregateOutputType | null
    _max: FeedbackFormMaxAggregateOutputType | null
  }

  export type FeedbackFormMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    sessionId: string | null
    participantId: string | null
    fileUrl: string | null
    filePath: string | null
    submittedAt: Date | null
    uploadedById: string | null
  }

  export type FeedbackFormMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    sessionId: string | null
    participantId: string | null
    fileUrl: string | null
    filePath: string | null
    submittedAt: Date | null
    uploadedById: string | null
  }

  export type FeedbackFormCountAggregateOutputType = {
    id: number
    trainingId: number
    sessionId: number
    participantId: number
    fileUrl: number
    filePath: number
    submittedAt: number
    uploadedById: number
    _all: number
  }


  export type FeedbackFormMinAggregateInputType = {
    id?: true
    trainingId?: true
    sessionId?: true
    participantId?: true
    fileUrl?: true
    filePath?: true
    submittedAt?: true
    uploadedById?: true
  }

  export type FeedbackFormMaxAggregateInputType = {
    id?: true
    trainingId?: true
    sessionId?: true
    participantId?: true
    fileUrl?: true
    filePath?: true
    submittedAt?: true
    uploadedById?: true
  }

  export type FeedbackFormCountAggregateInputType = {
    id?: true
    trainingId?: true
    sessionId?: true
    participantId?: true
    fileUrl?: true
    filePath?: true
    submittedAt?: true
    uploadedById?: true
    _all?: true
  }

  export type FeedbackFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackForm to aggregate.
     */
    where?: FeedbackFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackForms to fetch.
     */
    orderBy?: FeedbackFormOrderByWithRelationInput | FeedbackFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedbackForms
    **/
    _count?: true | FeedbackFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackFormMaxAggregateInputType
  }

  export type GetFeedbackFormAggregateType<T extends FeedbackFormAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbackForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbackForm[P]>
      : GetScalarType<T[P], AggregateFeedbackForm[P]>
  }




  export type FeedbackFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackFormWhereInput
    orderBy?: FeedbackFormOrderByWithAggregationInput | FeedbackFormOrderByWithAggregationInput[]
    by: FeedbackFormScalarFieldEnum[] | FeedbackFormScalarFieldEnum
    having?: FeedbackFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackFormCountAggregateInputType | true
    _min?: FeedbackFormMinAggregateInputType
    _max?: FeedbackFormMaxAggregateInputType
  }

  export type FeedbackFormGroupByOutputType = {
    id: string
    trainingId: string
    sessionId: string
    participantId: string
    fileUrl: string
    filePath: string | null
    submittedAt: Date
    uploadedById: string
    _count: FeedbackFormCountAggregateOutputType | null
    _min: FeedbackFormMinAggregateOutputType | null
    _max: FeedbackFormMaxAggregateOutputType | null
  }

  type GetFeedbackFormGroupByPayload<T extends FeedbackFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackFormGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackFormGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    participantId?: boolean
    fileUrl?: boolean
    filePath?: boolean
    submittedAt?: boolean
    uploadedById?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackForm"]>

  export type FeedbackFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    participantId?: boolean
    fileUrl?: boolean
    filePath?: boolean
    submittedAt?: boolean
    uploadedById?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackForm"]>

  export type FeedbackFormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    participantId?: boolean
    fileUrl?: boolean
    filePath?: boolean
    submittedAt?: boolean
    uploadedById?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackForm"]>

  export type FeedbackFormSelectScalar = {
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    participantId?: boolean
    fileUrl?: boolean
    filePath?: boolean
    submittedAt?: boolean
    uploadedById?: boolean
  }

  export type FeedbackFormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "sessionId" | "participantId" | "fileUrl" | "filePath" | "submittedAt" | "uploadedById", ExtArgs["result"]["feedbackForm"]>
  export type FeedbackFormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedbackFormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FeedbackFormIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedbackFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedbackForm"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      session: Prisma.$TrainingSessionPayload<ExtArgs>
      participant: Prisma.$ParticipantPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      sessionId: string
      participantId: string
      fileUrl: string
      filePath: string | null
      submittedAt: Date
      uploadedById: string
    }, ExtArgs["result"]["feedbackForm"]>
    composites: {}
  }

  type FeedbackFormGetPayload<S extends boolean | null | undefined | FeedbackFormDefaultArgs> = $Result.GetResult<Prisma.$FeedbackFormPayload, S>

  type FeedbackFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedbackFormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbackFormCountAggregateInputType | true
    }

  export interface FeedbackFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedbackForm'], meta: { name: 'FeedbackForm' } }
    /**
     * Find zero or one FeedbackForm that matches the filter.
     * @param {FeedbackFormFindUniqueArgs} args - Arguments to find a FeedbackForm
     * @example
     * // Get one FeedbackForm
     * const feedbackForm = await prisma.feedbackForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFormFindUniqueArgs>(args: SelectSubset<T, FeedbackFormFindUniqueArgs<ExtArgs>>): Prisma__FeedbackFormClient<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeedbackForm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedbackFormFindUniqueOrThrowArgs} args - Arguments to find a FeedbackForm
     * @example
     * // Get one FeedbackForm
     * const feedbackForm = await prisma.feedbackForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFormFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackFormClient<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedbackForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFormFindFirstArgs} args - Arguments to find a FeedbackForm
     * @example
     * // Get one FeedbackForm
     * const feedbackForm = await prisma.feedbackForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFormFindFirstArgs>(args?: SelectSubset<T, FeedbackFormFindFirstArgs<ExtArgs>>): Prisma__FeedbackFormClient<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedbackForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFormFindFirstOrThrowArgs} args - Arguments to find a FeedbackForm
     * @example
     * // Get one FeedbackForm
     * const feedbackForm = await prisma.feedbackForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFormFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackFormClient<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeedbackForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedbackForms
     * const feedbackForms = await prisma.feedbackForm.findMany()
     * 
     * // Get first 10 FeedbackForms
     * const feedbackForms = await prisma.feedbackForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackFormWithIdOnly = await prisma.feedbackForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFormFindManyArgs>(args?: SelectSubset<T, FeedbackFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeedbackForm.
     * @param {FeedbackFormCreateArgs} args - Arguments to create a FeedbackForm.
     * @example
     * // Create one FeedbackForm
     * const FeedbackForm = await prisma.feedbackForm.create({
     *   data: {
     *     // ... data to create a FeedbackForm
     *   }
     * })
     * 
     */
    create<T extends FeedbackFormCreateArgs>(args: SelectSubset<T, FeedbackFormCreateArgs<ExtArgs>>): Prisma__FeedbackFormClient<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeedbackForms.
     * @param {FeedbackFormCreateManyArgs} args - Arguments to create many FeedbackForms.
     * @example
     * // Create many FeedbackForms
     * const feedbackForm = await prisma.feedbackForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackFormCreateManyArgs>(args?: SelectSubset<T, FeedbackFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeedbackForms and returns the data saved in the database.
     * @param {FeedbackFormCreateManyAndReturnArgs} args - Arguments to create many FeedbackForms.
     * @example
     * // Create many FeedbackForms
     * const feedbackForm = await prisma.feedbackForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeedbackForms and only return the `id`
     * const feedbackFormWithIdOnly = await prisma.feedbackForm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackFormCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeedbackForm.
     * @param {FeedbackFormDeleteArgs} args - Arguments to delete one FeedbackForm.
     * @example
     * // Delete one FeedbackForm
     * const FeedbackForm = await prisma.feedbackForm.delete({
     *   where: {
     *     // ... filter to delete one FeedbackForm
     *   }
     * })
     * 
     */
    delete<T extends FeedbackFormDeleteArgs>(args: SelectSubset<T, FeedbackFormDeleteArgs<ExtArgs>>): Prisma__FeedbackFormClient<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeedbackForm.
     * @param {FeedbackFormUpdateArgs} args - Arguments to update one FeedbackForm.
     * @example
     * // Update one FeedbackForm
     * const feedbackForm = await prisma.feedbackForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackFormUpdateArgs>(args: SelectSubset<T, FeedbackFormUpdateArgs<ExtArgs>>): Prisma__FeedbackFormClient<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeedbackForms.
     * @param {FeedbackFormDeleteManyArgs} args - Arguments to filter FeedbackForms to delete.
     * @example
     * // Delete a few FeedbackForms
     * const { count } = await prisma.feedbackForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackFormDeleteManyArgs>(args?: SelectSubset<T, FeedbackFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedbackForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedbackForms
     * const feedbackForm = await prisma.feedbackForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackFormUpdateManyArgs>(args: SelectSubset<T, FeedbackFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedbackForms and returns the data updated in the database.
     * @param {FeedbackFormUpdateManyAndReturnArgs} args - Arguments to update many FeedbackForms.
     * @example
     * // Update many FeedbackForms
     * const feedbackForm = await prisma.feedbackForm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeedbackForms and only return the `id`
     * const feedbackFormWithIdOnly = await prisma.feedbackForm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedbackFormUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedbackFormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeedbackForm.
     * @param {FeedbackFormUpsertArgs} args - Arguments to update or create a FeedbackForm.
     * @example
     * // Update or create a FeedbackForm
     * const feedbackForm = await prisma.feedbackForm.upsert({
     *   create: {
     *     // ... data to create a FeedbackForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedbackForm we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackFormUpsertArgs>(args: SelectSubset<T, FeedbackFormUpsertArgs<ExtArgs>>): Prisma__FeedbackFormClient<$Result.GetResult<Prisma.$FeedbackFormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeedbackForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFormCountArgs} args - Arguments to filter FeedbackForms to count.
     * @example
     * // Count the number of FeedbackForms
     * const count = await prisma.feedbackForm.count({
     *   where: {
     *     // ... the filter for the FeedbackForms we want to count
     *   }
     * })
    **/
    count<T extends FeedbackFormCountArgs>(
      args?: Subset<T, FeedbackFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedbackForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackFormAggregateArgs>(args: Subset<T, FeedbackFormAggregateArgs>): Prisma.PrismaPromise<GetFeedbackFormAggregateType<T>>

    /**
     * Group by FeedbackForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackFormGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedbackForm model
   */
  readonly fields: FeedbackFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedbackForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session<T extends TrainingSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingSessionDefaultArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participant<T extends ParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParticipantDefaultArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedbackForm model
   */
  interface FeedbackFormFieldRefs {
    readonly id: FieldRef<"FeedbackForm", 'String'>
    readonly trainingId: FieldRef<"FeedbackForm", 'String'>
    readonly sessionId: FieldRef<"FeedbackForm", 'String'>
    readonly participantId: FieldRef<"FeedbackForm", 'String'>
    readonly fileUrl: FieldRef<"FeedbackForm", 'String'>
    readonly filePath: FieldRef<"FeedbackForm", 'String'>
    readonly submittedAt: FieldRef<"FeedbackForm", 'DateTime'>
    readonly uploadedById: FieldRef<"FeedbackForm", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FeedbackForm findUnique
   */
  export type FeedbackFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackForm to fetch.
     */
    where: FeedbackFormWhereUniqueInput
  }

  /**
   * FeedbackForm findUniqueOrThrow
   */
  export type FeedbackFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackForm to fetch.
     */
    where: FeedbackFormWhereUniqueInput
  }

  /**
   * FeedbackForm findFirst
   */
  export type FeedbackFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackForm to fetch.
     */
    where?: FeedbackFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackForms to fetch.
     */
    orderBy?: FeedbackFormOrderByWithRelationInput | FeedbackFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackForms.
     */
    cursor?: FeedbackFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackForms.
     */
    distinct?: FeedbackFormScalarFieldEnum | FeedbackFormScalarFieldEnum[]
  }

  /**
   * FeedbackForm findFirstOrThrow
   */
  export type FeedbackFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackForm to fetch.
     */
    where?: FeedbackFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackForms to fetch.
     */
    orderBy?: FeedbackFormOrderByWithRelationInput | FeedbackFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackForms.
     */
    cursor?: FeedbackFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackForms.
     */
    distinct?: FeedbackFormScalarFieldEnum | FeedbackFormScalarFieldEnum[]
  }

  /**
   * FeedbackForm findMany
   */
  export type FeedbackFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackForms to fetch.
     */
    where?: FeedbackFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackForms to fetch.
     */
    orderBy?: FeedbackFormOrderByWithRelationInput | FeedbackFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedbackForms.
     */
    cursor?: FeedbackFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackForms.
     */
    skip?: number
    distinct?: FeedbackFormScalarFieldEnum | FeedbackFormScalarFieldEnum[]
  }

  /**
   * FeedbackForm create
   */
  export type FeedbackFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedbackForm.
     */
    data: XOR<FeedbackFormCreateInput, FeedbackFormUncheckedCreateInput>
  }

  /**
   * FeedbackForm createMany
   */
  export type FeedbackFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedbackForms.
     */
    data: FeedbackFormCreateManyInput | FeedbackFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedbackForm createManyAndReturn
   */
  export type FeedbackFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * The data used to create many FeedbackForms.
     */
    data: FeedbackFormCreateManyInput | FeedbackFormCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedbackForm update
   */
  export type FeedbackFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedbackForm.
     */
    data: XOR<FeedbackFormUpdateInput, FeedbackFormUncheckedUpdateInput>
    /**
     * Choose, which FeedbackForm to update.
     */
    where: FeedbackFormWhereUniqueInput
  }

  /**
   * FeedbackForm updateMany
   */
  export type FeedbackFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedbackForms.
     */
    data: XOR<FeedbackFormUpdateManyMutationInput, FeedbackFormUncheckedUpdateManyInput>
    /**
     * Filter which FeedbackForms to update
     */
    where?: FeedbackFormWhereInput
    /**
     * Limit how many FeedbackForms to update.
     */
    limit?: number
  }

  /**
   * FeedbackForm updateManyAndReturn
   */
  export type FeedbackFormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * The data used to update FeedbackForms.
     */
    data: XOR<FeedbackFormUpdateManyMutationInput, FeedbackFormUncheckedUpdateManyInput>
    /**
     * Filter which FeedbackForms to update
     */
    where?: FeedbackFormWhereInput
    /**
     * Limit how many FeedbackForms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedbackForm upsert
   */
  export type FeedbackFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedbackForm to update in case it exists.
     */
    where: FeedbackFormWhereUniqueInput
    /**
     * In case the FeedbackForm found by the `where` argument doesn't exist, create a new FeedbackForm with this data.
     */
    create: XOR<FeedbackFormCreateInput, FeedbackFormUncheckedCreateInput>
    /**
     * In case the FeedbackForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackFormUpdateInput, FeedbackFormUncheckedUpdateInput>
  }

  /**
   * FeedbackForm delete
   */
  export type FeedbackFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
    /**
     * Filter which FeedbackForm to delete.
     */
    where: FeedbackFormWhereUniqueInput
  }

  /**
   * FeedbackForm deleteMany
   */
  export type FeedbackFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackForms to delete
     */
    where?: FeedbackFormWhereInput
    /**
     * Limit how many FeedbackForms to delete.
     */
    limit?: number
  }

  /**
   * FeedbackForm without action
   */
  export type FeedbackFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackForm
     */
    select?: FeedbackFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackForm
     */
    omit?: FeedbackFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackFormInclude<ExtArgs> | null
  }


  /**
   * Model TrainingFollowup
   */

  export type AggregateTrainingFollowup = {
    _count: TrainingFollowupCountAggregateOutputType | null
    _min: TrainingFollowupMinAggregateOutputType | null
    _max: TrainingFollowupMaxAggregateOutputType | null
  }

  export type TrainingFollowupMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    title: string | null
    description: string | null
    dueDate: Date | null
    isCompleted: boolean | null
    assignedToId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type TrainingFollowupMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    title: string | null
    description: string | null
    dueDate: Date | null
    isCompleted: boolean | null
    assignedToId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type TrainingFollowupCountAggregateOutputType = {
    id: number
    trainingId: number
    title: number
    description: number
    dueDate: number
    isCompleted: number
    assignedToId: number
    createdById: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type TrainingFollowupMinAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    dueDate?: true
    isCompleted?: true
    assignedToId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type TrainingFollowupMaxAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    dueDate?: true
    isCompleted?: true
    assignedToId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type TrainingFollowupCountAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    dueDate?: true
    isCompleted?: true
    assignedToId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type TrainingFollowupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingFollowup to aggregate.
     */
    where?: TrainingFollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFollowups to fetch.
     */
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingFollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFollowups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFollowups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingFollowups
    **/
    _count?: true | TrainingFollowupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingFollowupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingFollowupMaxAggregateInputType
  }

  export type GetTrainingFollowupAggregateType<T extends TrainingFollowupAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingFollowup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingFollowup[P]>
      : GetScalarType<T[P], AggregateTrainingFollowup[P]>
  }




  export type TrainingFollowupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFollowupWhereInput
    orderBy?: TrainingFollowupOrderByWithAggregationInput | TrainingFollowupOrderByWithAggregationInput[]
    by: TrainingFollowupScalarFieldEnum[] | TrainingFollowupScalarFieldEnum
    having?: TrainingFollowupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingFollowupCountAggregateInputType | true
    _min?: TrainingFollowupMinAggregateInputType
    _max?: TrainingFollowupMaxAggregateInputType
  }

  export type TrainingFollowupGroupByOutputType = {
    id: string
    trainingId: string
    title: string
    description: string
    dueDate: Date | null
    isCompleted: boolean
    assignedToId: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: TrainingFollowupCountAggregateOutputType | null
    _min: TrainingFollowupMinAggregateOutputType | null
    _max: TrainingFollowupMaxAggregateOutputType | null
  }

  type GetTrainingFollowupGroupByPayload<T extends TrainingFollowupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingFollowupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingFollowupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingFollowupGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingFollowupGroupByOutputType[P]>
        }
      >
    >


  export type TrainingFollowupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    isCompleted?: boolean
    assignedToId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingFollowup"]>

  export type TrainingFollowupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    isCompleted?: boolean
    assignedToId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingFollowup"]>

  export type TrainingFollowupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    isCompleted?: boolean
    assignedToId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingFollowup"]>

  export type TrainingFollowupSelectScalar = {
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    isCompleted?: boolean
    assignedToId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type TrainingFollowupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "title" | "description" | "dueDate" | "isCompleted" | "assignedToId" | "createdById" | "createdAt" | "updatedAt" | "completedAt", ExtArgs["result"]["trainingFollowup"]>
  export type TrainingFollowupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingFollowupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingFollowupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingFollowupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingFollowup"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      title: string
      description: string
      dueDate: Date | null
      isCompleted: boolean
      assignedToId: string
      createdById: string
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["trainingFollowup"]>
    composites: {}
  }

  type TrainingFollowupGetPayload<S extends boolean | null | undefined | TrainingFollowupDefaultArgs> = $Result.GetResult<Prisma.$TrainingFollowupPayload, S>

  type TrainingFollowupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingFollowupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingFollowupCountAggregateInputType | true
    }

  export interface TrainingFollowupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingFollowup'], meta: { name: 'TrainingFollowup' } }
    /**
     * Find zero or one TrainingFollowup that matches the filter.
     * @param {TrainingFollowupFindUniqueArgs} args - Arguments to find a TrainingFollowup
     * @example
     * // Get one TrainingFollowup
     * const trainingFollowup = await prisma.trainingFollowup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingFollowupFindUniqueArgs>(args: SelectSubset<T, TrainingFollowupFindUniqueArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingFollowup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingFollowupFindUniqueOrThrowArgs} args - Arguments to find a TrainingFollowup
     * @example
     * // Get one TrainingFollowup
     * const trainingFollowup = await prisma.trainingFollowup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingFollowupFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingFollowupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingFollowup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupFindFirstArgs} args - Arguments to find a TrainingFollowup
     * @example
     * // Get one TrainingFollowup
     * const trainingFollowup = await prisma.trainingFollowup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingFollowupFindFirstArgs>(args?: SelectSubset<T, TrainingFollowupFindFirstArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingFollowup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupFindFirstOrThrowArgs} args - Arguments to find a TrainingFollowup
     * @example
     * // Get one TrainingFollowup
     * const trainingFollowup = await prisma.trainingFollowup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingFollowupFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingFollowupFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingFollowups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingFollowups
     * const trainingFollowups = await prisma.trainingFollowup.findMany()
     * 
     * // Get first 10 TrainingFollowups
     * const trainingFollowups = await prisma.trainingFollowup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingFollowupWithIdOnly = await prisma.trainingFollowup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingFollowupFindManyArgs>(args?: SelectSubset<T, TrainingFollowupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingFollowup.
     * @param {TrainingFollowupCreateArgs} args - Arguments to create a TrainingFollowup.
     * @example
     * // Create one TrainingFollowup
     * const TrainingFollowup = await prisma.trainingFollowup.create({
     *   data: {
     *     // ... data to create a TrainingFollowup
     *   }
     * })
     * 
     */
    create<T extends TrainingFollowupCreateArgs>(args: SelectSubset<T, TrainingFollowupCreateArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingFollowups.
     * @param {TrainingFollowupCreateManyArgs} args - Arguments to create many TrainingFollowups.
     * @example
     * // Create many TrainingFollowups
     * const trainingFollowup = await prisma.trainingFollowup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingFollowupCreateManyArgs>(args?: SelectSubset<T, TrainingFollowupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingFollowups and returns the data saved in the database.
     * @param {TrainingFollowupCreateManyAndReturnArgs} args - Arguments to create many TrainingFollowups.
     * @example
     * // Create many TrainingFollowups
     * const trainingFollowup = await prisma.trainingFollowup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingFollowups and only return the `id`
     * const trainingFollowupWithIdOnly = await prisma.trainingFollowup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingFollowupCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingFollowupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingFollowup.
     * @param {TrainingFollowupDeleteArgs} args - Arguments to delete one TrainingFollowup.
     * @example
     * // Delete one TrainingFollowup
     * const TrainingFollowup = await prisma.trainingFollowup.delete({
     *   where: {
     *     // ... filter to delete one TrainingFollowup
     *   }
     * })
     * 
     */
    delete<T extends TrainingFollowupDeleteArgs>(args: SelectSubset<T, TrainingFollowupDeleteArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingFollowup.
     * @param {TrainingFollowupUpdateArgs} args - Arguments to update one TrainingFollowup.
     * @example
     * // Update one TrainingFollowup
     * const trainingFollowup = await prisma.trainingFollowup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingFollowupUpdateArgs>(args: SelectSubset<T, TrainingFollowupUpdateArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingFollowups.
     * @param {TrainingFollowupDeleteManyArgs} args - Arguments to filter TrainingFollowups to delete.
     * @example
     * // Delete a few TrainingFollowups
     * const { count } = await prisma.trainingFollowup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingFollowupDeleteManyArgs>(args?: SelectSubset<T, TrainingFollowupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingFollowups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingFollowups
     * const trainingFollowup = await prisma.trainingFollowup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingFollowupUpdateManyArgs>(args: SelectSubset<T, TrainingFollowupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingFollowups and returns the data updated in the database.
     * @param {TrainingFollowupUpdateManyAndReturnArgs} args - Arguments to update many TrainingFollowups.
     * @example
     * // Update many TrainingFollowups
     * const trainingFollowup = await prisma.trainingFollowup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingFollowups and only return the `id`
     * const trainingFollowupWithIdOnly = await prisma.trainingFollowup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingFollowupUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingFollowupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingFollowup.
     * @param {TrainingFollowupUpsertArgs} args - Arguments to update or create a TrainingFollowup.
     * @example
     * // Update or create a TrainingFollowup
     * const trainingFollowup = await prisma.trainingFollowup.upsert({
     *   create: {
     *     // ... data to create a TrainingFollowup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingFollowup we want to update
     *   }
     * })
     */
    upsert<T extends TrainingFollowupUpsertArgs>(args: SelectSubset<T, TrainingFollowupUpsertArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingFollowups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupCountArgs} args - Arguments to filter TrainingFollowups to count.
     * @example
     * // Count the number of TrainingFollowups
     * const count = await prisma.trainingFollowup.count({
     *   where: {
     *     // ... the filter for the TrainingFollowups we want to count
     *   }
     * })
    **/
    count<T extends TrainingFollowupCountArgs>(
      args?: Subset<T, TrainingFollowupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingFollowupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingFollowup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingFollowupAggregateArgs>(args: Subset<T, TrainingFollowupAggregateArgs>): Prisma.PrismaPromise<GetTrainingFollowupAggregateType<T>>

    /**
     * Group by TrainingFollowup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingFollowupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingFollowupGroupByArgs['orderBy'] }
        : { orderBy?: TrainingFollowupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingFollowupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingFollowupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingFollowup model
   */
  readonly fields: TrainingFollowupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingFollowup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingFollowupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingFollowup model
   */
  interface TrainingFollowupFieldRefs {
    readonly id: FieldRef<"TrainingFollowup", 'String'>
    readonly trainingId: FieldRef<"TrainingFollowup", 'String'>
    readonly title: FieldRef<"TrainingFollowup", 'String'>
    readonly description: FieldRef<"TrainingFollowup", 'String'>
    readonly dueDate: FieldRef<"TrainingFollowup", 'DateTime'>
    readonly isCompleted: FieldRef<"TrainingFollowup", 'Boolean'>
    readonly assignedToId: FieldRef<"TrainingFollowup", 'String'>
    readonly createdById: FieldRef<"TrainingFollowup", 'String'>
    readonly createdAt: FieldRef<"TrainingFollowup", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingFollowup", 'DateTime'>
    readonly completedAt: FieldRef<"TrainingFollowup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingFollowup findUnique
   */
  export type TrainingFollowupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFollowup to fetch.
     */
    where: TrainingFollowupWhereUniqueInput
  }

  /**
   * TrainingFollowup findUniqueOrThrow
   */
  export type TrainingFollowupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFollowup to fetch.
     */
    where: TrainingFollowupWhereUniqueInput
  }

  /**
   * TrainingFollowup findFirst
   */
  export type TrainingFollowupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFollowup to fetch.
     */
    where?: TrainingFollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFollowups to fetch.
     */
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingFollowups.
     */
    cursor?: TrainingFollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFollowups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFollowups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingFollowups.
     */
    distinct?: TrainingFollowupScalarFieldEnum | TrainingFollowupScalarFieldEnum[]
  }

  /**
   * TrainingFollowup findFirstOrThrow
   */
  export type TrainingFollowupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFollowup to fetch.
     */
    where?: TrainingFollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFollowups to fetch.
     */
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingFollowups.
     */
    cursor?: TrainingFollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFollowups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFollowups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingFollowups.
     */
    distinct?: TrainingFollowupScalarFieldEnum | TrainingFollowupScalarFieldEnum[]
  }

  /**
   * TrainingFollowup findMany
   */
  export type TrainingFollowupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFollowups to fetch.
     */
    where?: TrainingFollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFollowups to fetch.
     */
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingFollowups.
     */
    cursor?: TrainingFollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFollowups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFollowups.
     */
    skip?: number
    distinct?: TrainingFollowupScalarFieldEnum | TrainingFollowupScalarFieldEnum[]
  }

  /**
   * TrainingFollowup create
   */
  export type TrainingFollowupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingFollowup.
     */
    data: XOR<TrainingFollowupCreateInput, TrainingFollowupUncheckedCreateInput>
  }

  /**
   * TrainingFollowup createMany
   */
  export type TrainingFollowupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingFollowups.
     */
    data: TrainingFollowupCreateManyInput | TrainingFollowupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingFollowup createManyAndReturn
   */
  export type TrainingFollowupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingFollowups.
     */
    data: TrainingFollowupCreateManyInput | TrainingFollowupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingFollowup update
   */
  export type TrainingFollowupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingFollowup.
     */
    data: XOR<TrainingFollowupUpdateInput, TrainingFollowupUncheckedUpdateInput>
    /**
     * Choose, which TrainingFollowup to update.
     */
    where: TrainingFollowupWhereUniqueInput
  }

  /**
   * TrainingFollowup updateMany
   */
  export type TrainingFollowupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingFollowups.
     */
    data: XOR<TrainingFollowupUpdateManyMutationInput, TrainingFollowupUncheckedUpdateManyInput>
    /**
     * Filter which TrainingFollowups to update
     */
    where?: TrainingFollowupWhereInput
    /**
     * Limit how many TrainingFollowups to update.
     */
    limit?: number
  }

  /**
   * TrainingFollowup updateManyAndReturn
   */
  export type TrainingFollowupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * The data used to update TrainingFollowups.
     */
    data: XOR<TrainingFollowupUpdateManyMutationInput, TrainingFollowupUncheckedUpdateManyInput>
    /**
     * Filter which TrainingFollowups to update
     */
    where?: TrainingFollowupWhereInput
    /**
     * Limit how many TrainingFollowups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingFollowup upsert
   */
  export type TrainingFollowupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingFollowup to update in case it exists.
     */
    where: TrainingFollowupWhereUniqueInput
    /**
     * In case the TrainingFollowup found by the `where` argument doesn't exist, create a new TrainingFollowup with this data.
     */
    create: XOR<TrainingFollowupCreateInput, TrainingFollowupUncheckedCreateInput>
    /**
     * In case the TrainingFollowup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingFollowupUpdateInput, TrainingFollowupUncheckedUpdateInput>
  }

  /**
   * TrainingFollowup delete
   */
  export type TrainingFollowupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * Filter which TrainingFollowup to delete.
     */
    where: TrainingFollowupWhereUniqueInput
  }

  /**
   * TrainingFollowup deleteMany
   */
  export type TrainingFollowupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingFollowups to delete
     */
    where?: TrainingFollowupWhereInput
    /**
     * Limit how many TrainingFollowups to delete.
     */
    limit?: number
  }

  /**
   * TrainingFollowup without action
   */
  export type TrainingFollowupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
  }


  /**
   * Model TrainingNotification
   */

  export type AggregateTrainingNotification = {
    _count: TrainingNotificationCountAggregateOutputType | null
    _min: TrainingNotificationMinAggregateOutputType | null
    _max: TrainingNotificationMaxAggregateOutputType | null
  }

  export type TrainingNotificationMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    userId: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    sentAt: Date | null
    readAt: Date | null
  }

  export type TrainingNotificationMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    userId: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    sentAt: Date | null
    readAt: Date | null
  }

  export type TrainingNotificationCountAggregateOutputType = {
    id: number
    trainingId: number
    userId: number
    title: number
    message: number
    isRead: number
    sentAt: number
    readAt: number
    _all: number
  }


  export type TrainingNotificationMinAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    sentAt?: true
    readAt?: true
  }

  export type TrainingNotificationMaxAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    sentAt?: true
    readAt?: true
  }

  export type TrainingNotificationCountAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    sentAt?: true
    readAt?: true
    _all?: true
  }

  export type TrainingNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingNotification to aggregate.
     */
    where?: TrainingNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingNotifications to fetch.
     */
    orderBy?: TrainingNotificationOrderByWithRelationInput | TrainingNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingNotifications
    **/
    _count?: true | TrainingNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingNotificationMaxAggregateInputType
  }

  export type GetTrainingNotificationAggregateType<T extends TrainingNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingNotification[P]>
      : GetScalarType<T[P], AggregateTrainingNotification[P]>
  }




  export type TrainingNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingNotificationWhereInput
    orderBy?: TrainingNotificationOrderByWithAggregationInput | TrainingNotificationOrderByWithAggregationInput[]
    by: TrainingNotificationScalarFieldEnum[] | TrainingNotificationScalarFieldEnum
    having?: TrainingNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingNotificationCountAggregateInputType | true
    _min?: TrainingNotificationMinAggregateInputType
    _max?: TrainingNotificationMaxAggregateInputType
  }

  export type TrainingNotificationGroupByOutputType = {
    id: string
    trainingId: string
    userId: string
    title: string
    message: string
    isRead: boolean
    sentAt: Date
    readAt: Date | null
    _count: TrainingNotificationCountAggregateOutputType | null
    _min: TrainingNotificationMinAggregateOutputType | null
    _max: TrainingNotificationMaxAggregateOutputType | null
  }

  type GetTrainingNotificationGroupByPayload<T extends TrainingNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingNotificationGroupByOutputType[P]>
        }
      >
    >


  export type TrainingNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    sentAt?: boolean
    readAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingNotification"]>

  export type TrainingNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    sentAt?: boolean
    readAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingNotification"]>

  export type TrainingNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    sentAt?: boolean
    readAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingNotification"]>

  export type TrainingNotificationSelectScalar = {
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    sentAt?: boolean
    readAt?: boolean
  }

  export type TrainingNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "userId" | "title" | "message" | "isRead" | "sentAt" | "readAt", ExtArgs["result"]["trainingNotification"]>
  export type TrainingNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingNotification"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      userId: string
      title: string
      message: string
      isRead: boolean
      sentAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["trainingNotification"]>
    composites: {}
  }

  type TrainingNotificationGetPayload<S extends boolean | null | undefined | TrainingNotificationDefaultArgs> = $Result.GetResult<Prisma.$TrainingNotificationPayload, S>

  type TrainingNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingNotificationCountAggregateInputType | true
    }

  export interface TrainingNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingNotification'], meta: { name: 'TrainingNotification' } }
    /**
     * Find zero or one TrainingNotification that matches the filter.
     * @param {TrainingNotificationFindUniqueArgs} args - Arguments to find a TrainingNotification
     * @example
     * // Get one TrainingNotification
     * const trainingNotification = await prisma.trainingNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingNotificationFindUniqueArgs>(args: SelectSubset<T, TrainingNotificationFindUniqueArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingNotificationFindUniqueOrThrowArgs} args - Arguments to find a TrainingNotification
     * @example
     * // Get one TrainingNotification
     * const trainingNotification = await prisma.trainingNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationFindFirstArgs} args - Arguments to find a TrainingNotification
     * @example
     * // Get one TrainingNotification
     * const trainingNotification = await prisma.trainingNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingNotificationFindFirstArgs>(args?: SelectSubset<T, TrainingNotificationFindFirstArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationFindFirstOrThrowArgs} args - Arguments to find a TrainingNotification
     * @example
     * // Get one TrainingNotification
     * const trainingNotification = await prisma.trainingNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingNotifications
     * const trainingNotifications = await prisma.trainingNotification.findMany()
     * 
     * // Get first 10 TrainingNotifications
     * const trainingNotifications = await prisma.trainingNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingNotificationWithIdOnly = await prisma.trainingNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingNotificationFindManyArgs>(args?: SelectSubset<T, TrainingNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingNotification.
     * @param {TrainingNotificationCreateArgs} args - Arguments to create a TrainingNotification.
     * @example
     * // Create one TrainingNotification
     * const TrainingNotification = await prisma.trainingNotification.create({
     *   data: {
     *     // ... data to create a TrainingNotification
     *   }
     * })
     * 
     */
    create<T extends TrainingNotificationCreateArgs>(args: SelectSubset<T, TrainingNotificationCreateArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingNotifications.
     * @param {TrainingNotificationCreateManyArgs} args - Arguments to create many TrainingNotifications.
     * @example
     * // Create many TrainingNotifications
     * const trainingNotification = await prisma.trainingNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingNotificationCreateManyArgs>(args?: SelectSubset<T, TrainingNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingNotifications and returns the data saved in the database.
     * @param {TrainingNotificationCreateManyAndReturnArgs} args - Arguments to create many TrainingNotifications.
     * @example
     * // Create many TrainingNotifications
     * const trainingNotification = await prisma.trainingNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingNotifications and only return the `id`
     * const trainingNotificationWithIdOnly = await prisma.trainingNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingNotification.
     * @param {TrainingNotificationDeleteArgs} args - Arguments to delete one TrainingNotification.
     * @example
     * // Delete one TrainingNotification
     * const TrainingNotification = await prisma.trainingNotification.delete({
     *   where: {
     *     // ... filter to delete one TrainingNotification
     *   }
     * })
     * 
     */
    delete<T extends TrainingNotificationDeleteArgs>(args: SelectSubset<T, TrainingNotificationDeleteArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingNotification.
     * @param {TrainingNotificationUpdateArgs} args - Arguments to update one TrainingNotification.
     * @example
     * // Update one TrainingNotification
     * const trainingNotification = await prisma.trainingNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingNotificationUpdateArgs>(args: SelectSubset<T, TrainingNotificationUpdateArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingNotifications.
     * @param {TrainingNotificationDeleteManyArgs} args - Arguments to filter TrainingNotifications to delete.
     * @example
     * // Delete a few TrainingNotifications
     * const { count } = await prisma.trainingNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingNotificationDeleteManyArgs>(args?: SelectSubset<T, TrainingNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingNotifications
     * const trainingNotification = await prisma.trainingNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingNotificationUpdateManyArgs>(args: SelectSubset<T, TrainingNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingNotifications and returns the data updated in the database.
     * @param {TrainingNotificationUpdateManyAndReturnArgs} args - Arguments to update many TrainingNotifications.
     * @example
     * // Update many TrainingNotifications
     * const trainingNotification = await prisma.trainingNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingNotifications and only return the `id`
     * const trainingNotificationWithIdOnly = await prisma.trainingNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingNotification.
     * @param {TrainingNotificationUpsertArgs} args - Arguments to update or create a TrainingNotification.
     * @example
     * // Update or create a TrainingNotification
     * const trainingNotification = await prisma.trainingNotification.upsert({
     *   create: {
     *     // ... data to create a TrainingNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingNotification we want to update
     *   }
     * })
     */
    upsert<T extends TrainingNotificationUpsertArgs>(args: SelectSubset<T, TrainingNotificationUpsertArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationCountArgs} args - Arguments to filter TrainingNotifications to count.
     * @example
     * // Count the number of TrainingNotifications
     * const count = await prisma.trainingNotification.count({
     *   where: {
     *     // ... the filter for the TrainingNotifications we want to count
     *   }
     * })
    **/
    count<T extends TrainingNotificationCountArgs>(
      args?: Subset<T, TrainingNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingNotificationAggregateArgs>(args: Subset<T, TrainingNotificationAggregateArgs>): Prisma.PrismaPromise<GetTrainingNotificationAggregateType<T>>

    /**
     * Group by TrainingNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingNotificationGroupByArgs['orderBy'] }
        : { orderBy?: TrainingNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingNotification model
   */
  readonly fields: TrainingNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingNotification model
   */
  interface TrainingNotificationFieldRefs {
    readonly id: FieldRef<"TrainingNotification", 'String'>
    readonly trainingId: FieldRef<"TrainingNotification", 'String'>
    readonly userId: FieldRef<"TrainingNotification", 'String'>
    readonly title: FieldRef<"TrainingNotification", 'String'>
    readonly message: FieldRef<"TrainingNotification", 'String'>
    readonly isRead: FieldRef<"TrainingNotification", 'Boolean'>
    readonly sentAt: FieldRef<"TrainingNotification", 'DateTime'>
    readonly readAt: FieldRef<"TrainingNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingNotification findUnique
   */
  export type TrainingNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TrainingNotification to fetch.
     */
    where: TrainingNotificationWhereUniqueInput
  }

  /**
   * TrainingNotification findUniqueOrThrow
   */
  export type TrainingNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TrainingNotification to fetch.
     */
    where: TrainingNotificationWhereUniqueInput
  }

  /**
   * TrainingNotification findFirst
   */
  export type TrainingNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TrainingNotification to fetch.
     */
    where?: TrainingNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingNotifications to fetch.
     */
    orderBy?: TrainingNotificationOrderByWithRelationInput | TrainingNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingNotifications.
     */
    cursor?: TrainingNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingNotifications.
     */
    distinct?: TrainingNotificationScalarFieldEnum | TrainingNotificationScalarFieldEnum[]
  }

  /**
   * TrainingNotification findFirstOrThrow
   */
  export type TrainingNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TrainingNotification to fetch.
     */
    where?: TrainingNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingNotifications to fetch.
     */
    orderBy?: TrainingNotificationOrderByWithRelationInput | TrainingNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingNotifications.
     */
    cursor?: TrainingNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingNotifications.
     */
    distinct?: TrainingNotificationScalarFieldEnum | TrainingNotificationScalarFieldEnum[]
  }

  /**
   * TrainingNotification findMany
   */
  export type TrainingNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TrainingNotifications to fetch.
     */
    where?: TrainingNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingNotifications to fetch.
     */
    orderBy?: TrainingNotificationOrderByWithRelationInput | TrainingNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingNotifications.
     */
    cursor?: TrainingNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingNotifications.
     */
    skip?: number
    distinct?: TrainingNotificationScalarFieldEnum | TrainingNotificationScalarFieldEnum[]
  }

  /**
   * TrainingNotification create
   */
  export type TrainingNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingNotification.
     */
    data: XOR<TrainingNotificationCreateInput, TrainingNotificationUncheckedCreateInput>
  }

  /**
   * TrainingNotification createMany
   */
  export type TrainingNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingNotifications.
     */
    data: TrainingNotificationCreateManyInput | TrainingNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingNotification createManyAndReturn
   */
  export type TrainingNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingNotifications.
     */
    data: TrainingNotificationCreateManyInput | TrainingNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingNotification update
   */
  export type TrainingNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingNotification.
     */
    data: XOR<TrainingNotificationUpdateInput, TrainingNotificationUncheckedUpdateInput>
    /**
     * Choose, which TrainingNotification to update.
     */
    where: TrainingNotificationWhereUniqueInput
  }

  /**
   * TrainingNotification updateMany
   */
  export type TrainingNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingNotifications.
     */
    data: XOR<TrainingNotificationUpdateManyMutationInput, TrainingNotificationUncheckedUpdateManyInput>
    /**
     * Filter which TrainingNotifications to update
     */
    where?: TrainingNotificationWhereInput
    /**
     * Limit how many TrainingNotifications to update.
     */
    limit?: number
  }

  /**
   * TrainingNotification updateManyAndReturn
   */
  export type TrainingNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * The data used to update TrainingNotifications.
     */
    data: XOR<TrainingNotificationUpdateManyMutationInput, TrainingNotificationUncheckedUpdateManyInput>
    /**
     * Filter which TrainingNotifications to update
     */
    where?: TrainingNotificationWhereInput
    /**
     * Limit how many TrainingNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingNotification upsert
   */
  export type TrainingNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingNotification to update in case it exists.
     */
    where: TrainingNotificationWhereUniqueInput
    /**
     * In case the TrainingNotification found by the `where` argument doesn't exist, create a new TrainingNotification with this data.
     */
    create: XOR<TrainingNotificationCreateInput, TrainingNotificationUncheckedCreateInput>
    /**
     * In case the TrainingNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingNotificationUpdateInput, TrainingNotificationUncheckedUpdateInput>
  }

  /**
   * TrainingNotification delete
   */
  export type TrainingNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * Filter which TrainingNotification to delete.
     */
    where: TrainingNotificationWhereUniqueInput
  }

  /**
   * TrainingNotification deleteMany
   */
  export type TrainingNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingNotifications to delete
     */
    where?: TrainingNotificationWhereInput
    /**
     * Limit how many TrainingNotifications to delete.
     */
    limit?: number
  }

  /**
   * TrainingNotification without action
   */
  export type TrainingNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
  }


  /**
   * Model TrainingInviteToken
   */

  export type AggregateTrainingInviteToken = {
    _count: TrainingInviteTokenCountAggregateOutputType | null
    _min: TrainingInviteTokenMinAggregateOutputType | null
    _max: TrainingInviteTokenMaxAggregateOutputType | null
  }

  export type TrainingInviteTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    action: string | null
    trainingId: string | null
    participantId: string | null
    email: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type TrainingInviteTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    action: string | null
    trainingId: string | null
    participantId: string | null
    email: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type TrainingInviteTokenCountAggregateOutputType = {
    id: number
    token: number
    action: number
    trainingId: number
    participantId: number
    email: number
    expiresAt: number
    used: number
    createdAt: number
    _all: number
  }


  export type TrainingInviteTokenMinAggregateInputType = {
    id?: true
    token?: true
    action?: true
    trainingId?: true
    participantId?: true
    email?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type TrainingInviteTokenMaxAggregateInputType = {
    id?: true
    token?: true
    action?: true
    trainingId?: true
    participantId?: true
    email?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type TrainingInviteTokenCountAggregateInputType = {
    id?: true
    token?: true
    action?: true
    trainingId?: true
    participantId?: true
    email?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    _all?: true
  }

  export type TrainingInviteTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingInviteToken to aggregate.
     */
    where?: TrainingInviteTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingInviteTokens to fetch.
     */
    orderBy?: TrainingInviteTokenOrderByWithRelationInput | TrainingInviteTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingInviteTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingInviteTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingInviteTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingInviteTokens
    **/
    _count?: true | TrainingInviteTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingInviteTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingInviteTokenMaxAggregateInputType
  }

  export type GetTrainingInviteTokenAggregateType<T extends TrainingInviteTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingInviteToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingInviteToken[P]>
      : GetScalarType<T[P], AggregateTrainingInviteToken[P]>
  }




  export type TrainingInviteTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingInviteTokenWhereInput
    orderBy?: TrainingInviteTokenOrderByWithAggregationInput | TrainingInviteTokenOrderByWithAggregationInput[]
    by: TrainingInviteTokenScalarFieldEnum[] | TrainingInviteTokenScalarFieldEnum
    having?: TrainingInviteTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingInviteTokenCountAggregateInputType | true
    _min?: TrainingInviteTokenMinAggregateInputType
    _max?: TrainingInviteTokenMaxAggregateInputType
  }

  export type TrainingInviteTokenGroupByOutputType = {
    id: string
    token: string
    action: string
    trainingId: string
    participantId: string | null
    email: string
    expiresAt: Date
    used: boolean
    createdAt: Date
    _count: TrainingInviteTokenCountAggregateOutputType | null
    _min: TrainingInviteTokenMinAggregateOutputType | null
    _max: TrainingInviteTokenMaxAggregateOutputType | null
  }

  type GetTrainingInviteTokenGroupByPayload<T extends TrainingInviteTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingInviteTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingInviteTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingInviteTokenGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingInviteTokenGroupByOutputType[P]>
        }
      >
    >


  export type TrainingInviteTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    action?: boolean
    trainingId?: boolean
    participantId?: boolean
    email?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | TrainingInviteToken$participantArgs<ExtArgs>
  }, ExtArgs["result"]["trainingInviteToken"]>

  export type TrainingInviteTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    action?: boolean
    trainingId?: boolean
    participantId?: boolean
    email?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | TrainingInviteToken$participantArgs<ExtArgs>
  }, ExtArgs["result"]["trainingInviteToken"]>

  export type TrainingInviteTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    action?: boolean
    trainingId?: boolean
    participantId?: boolean
    email?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | TrainingInviteToken$participantArgs<ExtArgs>
  }, ExtArgs["result"]["trainingInviteToken"]>

  export type TrainingInviteTokenSelectScalar = {
    id?: boolean
    token?: boolean
    action?: boolean
    trainingId?: boolean
    participantId?: boolean
    email?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }

  export type TrainingInviteTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "action" | "trainingId" | "participantId" | "email" | "expiresAt" | "used" | "createdAt", ExtArgs["result"]["trainingInviteToken"]>
  export type TrainingInviteTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | TrainingInviteToken$participantArgs<ExtArgs>
  }
  export type TrainingInviteTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | TrainingInviteToken$participantArgs<ExtArgs>
  }
  export type TrainingInviteTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    participant?: boolean | TrainingInviteToken$participantArgs<ExtArgs>
  }

  export type $TrainingInviteTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingInviteToken"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      participant: Prisma.$ParticipantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      action: string
      trainingId: string
      participantId: string | null
      email: string
      expiresAt: Date
      used: boolean
      createdAt: Date
    }, ExtArgs["result"]["trainingInviteToken"]>
    composites: {}
  }

  type TrainingInviteTokenGetPayload<S extends boolean | null | undefined | TrainingInviteTokenDefaultArgs> = $Result.GetResult<Prisma.$TrainingInviteTokenPayload, S>

  type TrainingInviteTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingInviteTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingInviteTokenCountAggregateInputType | true
    }

  export interface TrainingInviteTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingInviteToken'], meta: { name: 'TrainingInviteToken' } }
    /**
     * Find zero or one TrainingInviteToken that matches the filter.
     * @param {TrainingInviteTokenFindUniqueArgs} args - Arguments to find a TrainingInviteToken
     * @example
     * // Get one TrainingInviteToken
     * const trainingInviteToken = await prisma.trainingInviteToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingInviteTokenFindUniqueArgs>(args: SelectSubset<T, TrainingInviteTokenFindUniqueArgs<ExtArgs>>): Prisma__TrainingInviteTokenClient<$Result.GetResult<Prisma.$TrainingInviteTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingInviteToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingInviteTokenFindUniqueOrThrowArgs} args - Arguments to find a TrainingInviteToken
     * @example
     * // Get one TrainingInviteToken
     * const trainingInviteToken = await prisma.trainingInviteToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingInviteTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingInviteTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingInviteTokenClient<$Result.GetResult<Prisma.$TrainingInviteTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingInviteToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingInviteTokenFindFirstArgs} args - Arguments to find a TrainingInviteToken
     * @example
     * // Get one TrainingInviteToken
     * const trainingInviteToken = await prisma.trainingInviteToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingInviteTokenFindFirstArgs>(args?: SelectSubset<T, TrainingInviteTokenFindFirstArgs<ExtArgs>>): Prisma__TrainingInviteTokenClient<$Result.GetResult<Prisma.$TrainingInviteTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingInviteToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingInviteTokenFindFirstOrThrowArgs} args - Arguments to find a TrainingInviteToken
     * @example
     * // Get one TrainingInviteToken
     * const trainingInviteToken = await prisma.trainingInviteToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingInviteTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingInviteTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingInviteTokenClient<$Result.GetResult<Prisma.$TrainingInviteTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingInviteTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingInviteTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingInviteTokens
     * const trainingInviteTokens = await prisma.trainingInviteToken.findMany()
     * 
     * // Get first 10 TrainingInviteTokens
     * const trainingInviteTokens = await prisma.trainingInviteToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingInviteTokenWithIdOnly = await prisma.trainingInviteToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingInviteTokenFindManyArgs>(args?: SelectSubset<T, TrainingInviteTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingInviteTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingInviteToken.
     * @param {TrainingInviteTokenCreateArgs} args - Arguments to create a TrainingInviteToken.
     * @example
     * // Create one TrainingInviteToken
     * const TrainingInviteToken = await prisma.trainingInviteToken.create({
     *   data: {
     *     // ... data to create a TrainingInviteToken
     *   }
     * })
     * 
     */
    create<T extends TrainingInviteTokenCreateArgs>(args: SelectSubset<T, TrainingInviteTokenCreateArgs<ExtArgs>>): Prisma__TrainingInviteTokenClient<$Result.GetResult<Prisma.$TrainingInviteTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingInviteTokens.
     * @param {TrainingInviteTokenCreateManyArgs} args - Arguments to create many TrainingInviteTokens.
     * @example
     * // Create many TrainingInviteTokens
     * const trainingInviteToken = await prisma.trainingInviteToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingInviteTokenCreateManyArgs>(args?: SelectSubset<T, TrainingInviteTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingInviteTokens and returns the data saved in the database.
     * @param {TrainingInviteTokenCreateManyAndReturnArgs} args - Arguments to create many TrainingInviteTokens.
     * @example
     * // Create many TrainingInviteTokens
     * const trainingInviteToken = await prisma.trainingInviteToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingInviteTokens and only return the `id`
     * const trainingInviteTokenWithIdOnly = await prisma.trainingInviteToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingInviteTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingInviteTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingInviteTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingInviteToken.
     * @param {TrainingInviteTokenDeleteArgs} args - Arguments to delete one TrainingInviteToken.
     * @example
     * // Delete one TrainingInviteToken
     * const TrainingInviteToken = await prisma.trainingInviteToken.delete({
     *   where: {
     *     // ... filter to delete one TrainingInviteToken
     *   }
     * })
     * 
     */
    delete<T extends TrainingInviteTokenDeleteArgs>(args: SelectSubset<T, TrainingInviteTokenDeleteArgs<ExtArgs>>): Prisma__TrainingInviteTokenClient<$Result.GetResult<Prisma.$TrainingInviteTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingInviteToken.
     * @param {TrainingInviteTokenUpdateArgs} args - Arguments to update one TrainingInviteToken.
     * @example
     * // Update one TrainingInviteToken
     * const trainingInviteToken = await prisma.trainingInviteToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingInviteTokenUpdateArgs>(args: SelectSubset<T, TrainingInviteTokenUpdateArgs<ExtArgs>>): Prisma__TrainingInviteTokenClient<$Result.GetResult<Prisma.$TrainingInviteTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingInviteTokens.
     * @param {TrainingInviteTokenDeleteManyArgs} args - Arguments to filter TrainingInviteTokens to delete.
     * @example
     * // Delete a few TrainingInviteTokens
     * const { count } = await prisma.trainingInviteToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingInviteTokenDeleteManyArgs>(args?: SelectSubset<T, TrainingInviteTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingInviteTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingInviteTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingInviteTokens
     * const trainingInviteToken = await prisma.trainingInviteToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingInviteTokenUpdateManyArgs>(args: SelectSubset<T, TrainingInviteTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingInviteTokens and returns the data updated in the database.
     * @param {TrainingInviteTokenUpdateManyAndReturnArgs} args - Arguments to update many TrainingInviteTokens.
     * @example
     * // Update many TrainingInviteTokens
     * const trainingInviteToken = await prisma.trainingInviteToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingInviteTokens and only return the `id`
     * const trainingInviteTokenWithIdOnly = await prisma.trainingInviteToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingInviteTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingInviteTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingInviteTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingInviteToken.
     * @param {TrainingInviteTokenUpsertArgs} args - Arguments to update or create a TrainingInviteToken.
     * @example
     * // Update or create a TrainingInviteToken
     * const trainingInviteToken = await prisma.trainingInviteToken.upsert({
     *   create: {
     *     // ... data to create a TrainingInviteToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingInviteToken we want to update
     *   }
     * })
     */
    upsert<T extends TrainingInviteTokenUpsertArgs>(args: SelectSubset<T, TrainingInviteTokenUpsertArgs<ExtArgs>>): Prisma__TrainingInviteTokenClient<$Result.GetResult<Prisma.$TrainingInviteTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingInviteTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingInviteTokenCountArgs} args - Arguments to filter TrainingInviteTokens to count.
     * @example
     * // Count the number of TrainingInviteTokens
     * const count = await prisma.trainingInviteToken.count({
     *   where: {
     *     // ... the filter for the TrainingInviteTokens we want to count
     *   }
     * })
    **/
    count<T extends TrainingInviteTokenCountArgs>(
      args?: Subset<T, TrainingInviteTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingInviteTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingInviteToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingInviteTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingInviteTokenAggregateArgs>(args: Subset<T, TrainingInviteTokenAggregateArgs>): Prisma.PrismaPromise<GetTrainingInviteTokenAggregateType<T>>

    /**
     * Group by TrainingInviteToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingInviteTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingInviteTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingInviteTokenGroupByArgs['orderBy'] }
        : { orderBy?: TrainingInviteTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingInviteTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingInviteTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingInviteToken model
   */
  readonly fields: TrainingInviteTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingInviteToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingInviteTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participant<T extends TrainingInviteToken$participantArgs<ExtArgs> = {}>(args?: Subset<T, TrainingInviteToken$participantArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingInviteToken model
   */
  interface TrainingInviteTokenFieldRefs {
    readonly id: FieldRef<"TrainingInviteToken", 'String'>
    readonly token: FieldRef<"TrainingInviteToken", 'String'>
    readonly action: FieldRef<"TrainingInviteToken", 'String'>
    readonly trainingId: FieldRef<"TrainingInviteToken", 'String'>
    readonly participantId: FieldRef<"TrainingInviteToken", 'String'>
    readonly email: FieldRef<"TrainingInviteToken", 'String'>
    readonly expiresAt: FieldRef<"TrainingInviteToken", 'DateTime'>
    readonly used: FieldRef<"TrainingInviteToken", 'Boolean'>
    readonly createdAt: FieldRef<"TrainingInviteToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingInviteToken findUnique
   */
  export type TrainingInviteTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenInclude<ExtArgs> | null
    /**
     * Filter, which TrainingInviteToken to fetch.
     */
    where: TrainingInviteTokenWhereUniqueInput
  }

  /**
   * TrainingInviteToken findUniqueOrThrow
   */
  export type TrainingInviteTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenInclude<ExtArgs> | null
    /**
     * Filter, which TrainingInviteToken to fetch.
     */
    where: TrainingInviteTokenWhereUniqueInput
  }

  /**
   * TrainingInviteToken findFirst
   */
  export type TrainingInviteTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenInclude<ExtArgs> | null
    /**
     * Filter, which TrainingInviteToken to fetch.
     */
    where?: TrainingInviteTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingInviteTokens to fetch.
     */
    orderBy?: TrainingInviteTokenOrderByWithRelationInput | TrainingInviteTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingInviteTokens.
     */
    cursor?: TrainingInviteTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingInviteTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingInviteTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingInviteTokens.
     */
    distinct?: TrainingInviteTokenScalarFieldEnum | TrainingInviteTokenScalarFieldEnum[]
  }

  /**
   * TrainingInviteToken findFirstOrThrow
   */
  export type TrainingInviteTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenInclude<ExtArgs> | null
    /**
     * Filter, which TrainingInviteToken to fetch.
     */
    where?: TrainingInviteTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingInviteTokens to fetch.
     */
    orderBy?: TrainingInviteTokenOrderByWithRelationInput | TrainingInviteTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingInviteTokens.
     */
    cursor?: TrainingInviteTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingInviteTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingInviteTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingInviteTokens.
     */
    distinct?: TrainingInviteTokenScalarFieldEnum | TrainingInviteTokenScalarFieldEnum[]
  }

  /**
   * TrainingInviteToken findMany
   */
  export type TrainingInviteTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenInclude<ExtArgs> | null
    /**
     * Filter, which TrainingInviteTokens to fetch.
     */
    where?: TrainingInviteTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingInviteTokens to fetch.
     */
    orderBy?: TrainingInviteTokenOrderByWithRelationInput | TrainingInviteTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingInviteTokens.
     */
    cursor?: TrainingInviteTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingInviteTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingInviteTokens.
     */
    skip?: number
    distinct?: TrainingInviteTokenScalarFieldEnum | TrainingInviteTokenScalarFieldEnum[]
  }

  /**
   * TrainingInviteToken create
   */
  export type TrainingInviteTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingInviteToken.
     */
    data: XOR<TrainingInviteTokenCreateInput, TrainingInviteTokenUncheckedCreateInput>
  }

  /**
   * TrainingInviteToken createMany
   */
  export type TrainingInviteTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingInviteTokens.
     */
    data: TrainingInviteTokenCreateManyInput | TrainingInviteTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingInviteToken createManyAndReturn
   */
  export type TrainingInviteTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingInviteTokens.
     */
    data: TrainingInviteTokenCreateManyInput | TrainingInviteTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingInviteToken update
   */
  export type TrainingInviteTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingInviteToken.
     */
    data: XOR<TrainingInviteTokenUpdateInput, TrainingInviteTokenUncheckedUpdateInput>
    /**
     * Choose, which TrainingInviteToken to update.
     */
    where: TrainingInviteTokenWhereUniqueInput
  }

  /**
   * TrainingInviteToken updateMany
   */
  export type TrainingInviteTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingInviteTokens.
     */
    data: XOR<TrainingInviteTokenUpdateManyMutationInput, TrainingInviteTokenUncheckedUpdateManyInput>
    /**
     * Filter which TrainingInviteTokens to update
     */
    where?: TrainingInviteTokenWhereInput
    /**
     * Limit how many TrainingInviteTokens to update.
     */
    limit?: number
  }

  /**
   * TrainingInviteToken updateManyAndReturn
   */
  export type TrainingInviteTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * The data used to update TrainingInviteTokens.
     */
    data: XOR<TrainingInviteTokenUpdateManyMutationInput, TrainingInviteTokenUncheckedUpdateManyInput>
    /**
     * Filter which TrainingInviteTokens to update
     */
    where?: TrainingInviteTokenWhereInput
    /**
     * Limit how many TrainingInviteTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingInviteToken upsert
   */
  export type TrainingInviteTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingInviteToken to update in case it exists.
     */
    where: TrainingInviteTokenWhereUniqueInput
    /**
     * In case the TrainingInviteToken found by the `where` argument doesn't exist, create a new TrainingInviteToken with this data.
     */
    create: XOR<TrainingInviteTokenCreateInput, TrainingInviteTokenUncheckedCreateInput>
    /**
     * In case the TrainingInviteToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingInviteTokenUpdateInput, TrainingInviteTokenUncheckedUpdateInput>
  }

  /**
   * TrainingInviteToken delete
   */
  export type TrainingInviteTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenInclude<ExtArgs> | null
    /**
     * Filter which TrainingInviteToken to delete.
     */
    where: TrainingInviteTokenWhereUniqueInput
  }

  /**
   * TrainingInviteToken deleteMany
   */
  export type TrainingInviteTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingInviteTokens to delete
     */
    where?: TrainingInviteTokenWhereInput
    /**
     * Limit how many TrainingInviteTokens to delete.
     */
    limit?: number
  }

  /**
   * TrainingInviteToken.participant
   */
  export type TrainingInviteToken$participantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
  }

  /**
   * TrainingInviteToken without action
   */
  export type TrainingInviteTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingInviteToken
     */
    select?: TrainingInviteTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingInviteToken
     */
    omit?: TrainingInviteTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInviteTokenInclude<ExtArgs> | null
  }


  /**
   * Model TrainingSessionPhoto
   */

  export type AggregateTrainingSessionPhoto = {
    _count: TrainingSessionPhotoCountAggregateOutputType | null
    _min: TrainingSessionPhotoMinAggregateOutputType | null
    _max: TrainingSessionPhotoMaxAggregateOutputType | null
  }

  export type TrainingSessionPhotoMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    photoUrl: string | null
    caption: string | null
    uploadedById: string | null
    createdAt: Date | null
  }

  export type TrainingSessionPhotoMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    photoUrl: string | null
    caption: string | null
    uploadedById: string | null
    createdAt: Date | null
  }

  export type TrainingSessionPhotoCountAggregateOutputType = {
    id: number
    sessionId: number
    photoUrl: number
    caption: number
    uploadedById: number
    createdAt: number
    _all: number
  }


  export type TrainingSessionPhotoMinAggregateInputType = {
    id?: true
    sessionId?: true
    photoUrl?: true
    caption?: true
    uploadedById?: true
    createdAt?: true
  }

  export type TrainingSessionPhotoMaxAggregateInputType = {
    id?: true
    sessionId?: true
    photoUrl?: true
    caption?: true
    uploadedById?: true
    createdAt?: true
  }

  export type TrainingSessionPhotoCountAggregateInputType = {
    id?: true
    sessionId?: true
    photoUrl?: true
    caption?: true
    uploadedById?: true
    createdAt?: true
    _all?: true
  }

  export type TrainingSessionPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingSessionPhoto to aggregate.
     */
    where?: TrainingSessionPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessionPhotos to fetch.
     */
    orderBy?: TrainingSessionPhotoOrderByWithRelationInput | TrainingSessionPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingSessionPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessionPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessionPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingSessionPhotos
    **/
    _count?: true | TrainingSessionPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingSessionPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingSessionPhotoMaxAggregateInputType
  }

  export type GetTrainingSessionPhotoAggregateType<T extends TrainingSessionPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingSessionPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingSessionPhoto[P]>
      : GetScalarType<T[P], AggregateTrainingSessionPhoto[P]>
  }




  export type TrainingSessionPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingSessionPhotoWhereInput
    orderBy?: TrainingSessionPhotoOrderByWithAggregationInput | TrainingSessionPhotoOrderByWithAggregationInput[]
    by: TrainingSessionPhotoScalarFieldEnum[] | TrainingSessionPhotoScalarFieldEnum
    having?: TrainingSessionPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingSessionPhotoCountAggregateInputType | true
    _min?: TrainingSessionPhotoMinAggregateInputType
    _max?: TrainingSessionPhotoMaxAggregateInputType
  }

  export type TrainingSessionPhotoGroupByOutputType = {
    id: string
    sessionId: string
    photoUrl: string
    caption: string | null
    uploadedById: string
    createdAt: Date
    _count: TrainingSessionPhotoCountAggregateOutputType | null
    _min: TrainingSessionPhotoMinAggregateOutputType | null
    _max: TrainingSessionPhotoMaxAggregateOutputType | null
  }

  type GetTrainingSessionPhotoGroupByPayload<T extends TrainingSessionPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingSessionPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingSessionPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingSessionPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingSessionPhotoGroupByOutputType[P]>
        }
      >
    >


  export type TrainingSessionPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    photoUrl?: boolean
    caption?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingSessionPhoto"]>

  export type TrainingSessionPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    photoUrl?: boolean
    caption?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingSessionPhoto"]>

  export type TrainingSessionPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    photoUrl?: boolean
    caption?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingSessionPhoto"]>

  export type TrainingSessionPhotoSelectScalar = {
    id?: boolean
    sessionId?: boolean
    photoUrl?: boolean
    caption?: boolean
    uploadedById?: boolean
    createdAt?: boolean
  }

  export type TrainingSessionPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "photoUrl" | "caption" | "uploadedById" | "createdAt", ExtArgs["result"]["trainingSessionPhoto"]>
  export type TrainingSessionPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingSessionPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingSessionPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingSessionPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingSessionPhoto"
    objects: {
      session: Prisma.$TrainingSessionPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      photoUrl: string
      caption: string | null
      uploadedById: string
      createdAt: Date
    }, ExtArgs["result"]["trainingSessionPhoto"]>
    composites: {}
  }

  type TrainingSessionPhotoGetPayload<S extends boolean | null | undefined | TrainingSessionPhotoDefaultArgs> = $Result.GetResult<Prisma.$TrainingSessionPhotoPayload, S>

  type TrainingSessionPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingSessionPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingSessionPhotoCountAggregateInputType | true
    }

  export interface TrainingSessionPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingSessionPhoto'], meta: { name: 'TrainingSessionPhoto' } }
    /**
     * Find zero or one TrainingSessionPhoto that matches the filter.
     * @param {TrainingSessionPhotoFindUniqueArgs} args - Arguments to find a TrainingSessionPhoto
     * @example
     * // Get one TrainingSessionPhoto
     * const trainingSessionPhoto = await prisma.trainingSessionPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingSessionPhotoFindUniqueArgs>(args: SelectSubset<T, TrainingSessionPhotoFindUniqueArgs<ExtArgs>>): Prisma__TrainingSessionPhotoClient<$Result.GetResult<Prisma.$TrainingSessionPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingSessionPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingSessionPhotoFindUniqueOrThrowArgs} args - Arguments to find a TrainingSessionPhoto
     * @example
     * // Get one TrainingSessionPhoto
     * const trainingSessionPhoto = await prisma.trainingSessionPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingSessionPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingSessionPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingSessionPhotoClient<$Result.GetResult<Prisma.$TrainingSessionPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingSessionPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionPhotoFindFirstArgs} args - Arguments to find a TrainingSessionPhoto
     * @example
     * // Get one TrainingSessionPhoto
     * const trainingSessionPhoto = await prisma.trainingSessionPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingSessionPhotoFindFirstArgs>(args?: SelectSubset<T, TrainingSessionPhotoFindFirstArgs<ExtArgs>>): Prisma__TrainingSessionPhotoClient<$Result.GetResult<Prisma.$TrainingSessionPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingSessionPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionPhotoFindFirstOrThrowArgs} args - Arguments to find a TrainingSessionPhoto
     * @example
     * // Get one TrainingSessionPhoto
     * const trainingSessionPhoto = await prisma.trainingSessionPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingSessionPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingSessionPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingSessionPhotoClient<$Result.GetResult<Prisma.$TrainingSessionPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingSessionPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingSessionPhotos
     * const trainingSessionPhotos = await prisma.trainingSessionPhoto.findMany()
     * 
     * // Get first 10 TrainingSessionPhotos
     * const trainingSessionPhotos = await prisma.trainingSessionPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingSessionPhotoWithIdOnly = await prisma.trainingSessionPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingSessionPhotoFindManyArgs>(args?: SelectSubset<T, TrainingSessionPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingSessionPhoto.
     * @param {TrainingSessionPhotoCreateArgs} args - Arguments to create a TrainingSessionPhoto.
     * @example
     * // Create one TrainingSessionPhoto
     * const TrainingSessionPhoto = await prisma.trainingSessionPhoto.create({
     *   data: {
     *     // ... data to create a TrainingSessionPhoto
     *   }
     * })
     * 
     */
    create<T extends TrainingSessionPhotoCreateArgs>(args: SelectSubset<T, TrainingSessionPhotoCreateArgs<ExtArgs>>): Prisma__TrainingSessionPhotoClient<$Result.GetResult<Prisma.$TrainingSessionPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingSessionPhotos.
     * @param {TrainingSessionPhotoCreateManyArgs} args - Arguments to create many TrainingSessionPhotos.
     * @example
     * // Create many TrainingSessionPhotos
     * const trainingSessionPhoto = await prisma.trainingSessionPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingSessionPhotoCreateManyArgs>(args?: SelectSubset<T, TrainingSessionPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingSessionPhotos and returns the data saved in the database.
     * @param {TrainingSessionPhotoCreateManyAndReturnArgs} args - Arguments to create many TrainingSessionPhotos.
     * @example
     * // Create many TrainingSessionPhotos
     * const trainingSessionPhoto = await prisma.trainingSessionPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingSessionPhotos and only return the `id`
     * const trainingSessionPhotoWithIdOnly = await prisma.trainingSessionPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingSessionPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingSessionPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingSessionPhoto.
     * @param {TrainingSessionPhotoDeleteArgs} args - Arguments to delete one TrainingSessionPhoto.
     * @example
     * // Delete one TrainingSessionPhoto
     * const TrainingSessionPhoto = await prisma.trainingSessionPhoto.delete({
     *   where: {
     *     // ... filter to delete one TrainingSessionPhoto
     *   }
     * })
     * 
     */
    delete<T extends TrainingSessionPhotoDeleteArgs>(args: SelectSubset<T, TrainingSessionPhotoDeleteArgs<ExtArgs>>): Prisma__TrainingSessionPhotoClient<$Result.GetResult<Prisma.$TrainingSessionPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingSessionPhoto.
     * @param {TrainingSessionPhotoUpdateArgs} args - Arguments to update one TrainingSessionPhoto.
     * @example
     * // Update one TrainingSessionPhoto
     * const trainingSessionPhoto = await prisma.trainingSessionPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingSessionPhotoUpdateArgs>(args: SelectSubset<T, TrainingSessionPhotoUpdateArgs<ExtArgs>>): Prisma__TrainingSessionPhotoClient<$Result.GetResult<Prisma.$TrainingSessionPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingSessionPhotos.
     * @param {TrainingSessionPhotoDeleteManyArgs} args - Arguments to filter TrainingSessionPhotos to delete.
     * @example
     * // Delete a few TrainingSessionPhotos
     * const { count } = await prisma.trainingSessionPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingSessionPhotoDeleteManyArgs>(args?: SelectSubset<T, TrainingSessionPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingSessionPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingSessionPhotos
     * const trainingSessionPhoto = await prisma.trainingSessionPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingSessionPhotoUpdateManyArgs>(args: SelectSubset<T, TrainingSessionPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingSessionPhotos and returns the data updated in the database.
     * @param {TrainingSessionPhotoUpdateManyAndReturnArgs} args - Arguments to update many TrainingSessionPhotos.
     * @example
     * // Update many TrainingSessionPhotos
     * const trainingSessionPhoto = await prisma.trainingSessionPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingSessionPhotos and only return the `id`
     * const trainingSessionPhotoWithIdOnly = await prisma.trainingSessionPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingSessionPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingSessionPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingSessionPhoto.
     * @param {TrainingSessionPhotoUpsertArgs} args - Arguments to update or create a TrainingSessionPhoto.
     * @example
     * // Update or create a TrainingSessionPhoto
     * const trainingSessionPhoto = await prisma.trainingSessionPhoto.upsert({
     *   create: {
     *     // ... data to create a TrainingSessionPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingSessionPhoto we want to update
     *   }
     * })
     */
    upsert<T extends TrainingSessionPhotoUpsertArgs>(args: SelectSubset<T, TrainingSessionPhotoUpsertArgs<ExtArgs>>): Prisma__TrainingSessionPhotoClient<$Result.GetResult<Prisma.$TrainingSessionPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingSessionPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionPhotoCountArgs} args - Arguments to filter TrainingSessionPhotos to count.
     * @example
     * // Count the number of TrainingSessionPhotos
     * const count = await prisma.trainingSessionPhoto.count({
     *   where: {
     *     // ... the filter for the TrainingSessionPhotos we want to count
     *   }
     * })
    **/
    count<T extends TrainingSessionPhotoCountArgs>(
      args?: Subset<T, TrainingSessionPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingSessionPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingSessionPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingSessionPhotoAggregateArgs>(args: Subset<T, TrainingSessionPhotoAggregateArgs>): Prisma.PrismaPromise<GetTrainingSessionPhotoAggregateType<T>>

    /**
     * Group by TrainingSessionPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingSessionPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingSessionPhotoGroupByArgs['orderBy'] }
        : { orderBy?: TrainingSessionPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingSessionPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingSessionPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingSessionPhoto model
   */
  readonly fields: TrainingSessionPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingSessionPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingSessionPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends TrainingSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingSessionDefaultArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingSessionPhoto model
   */
  interface TrainingSessionPhotoFieldRefs {
    readonly id: FieldRef<"TrainingSessionPhoto", 'String'>
    readonly sessionId: FieldRef<"TrainingSessionPhoto", 'String'>
    readonly photoUrl: FieldRef<"TrainingSessionPhoto", 'String'>
    readonly caption: FieldRef<"TrainingSessionPhoto", 'String'>
    readonly uploadedById: FieldRef<"TrainingSessionPhoto", 'String'>
    readonly createdAt: FieldRef<"TrainingSessionPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingSessionPhoto findUnique
   */
  export type TrainingSessionPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSessionPhoto to fetch.
     */
    where: TrainingSessionPhotoWhereUniqueInput
  }

  /**
   * TrainingSessionPhoto findUniqueOrThrow
   */
  export type TrainingSessionPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSessionPhoto to fetch.
     */
    where: TrainingSessionPhotoWhereUniqueInput
  }

  /**
   * TrainingSessionPhoto findFirst
   */
  export type TrainingSessionPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSessionPhoto to fetch.
     */
    where?: TrainingSessionPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessionPhotos to fetch.
     */
    orderBy?: TrainingSessionPhotoOrderByWithRelationInput | TrainingSessionPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingSessionPhotos.
     */
    cursor?: TrainingSessionPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessionPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessionPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingSessionPhotos.
     */
    distinct?: TrainingSessionPhotoScalarFieldEnum | TrainingSessionPhotoScalarFieldEnum[]
  }

  /**
   * TrainingSessionPhoto findFirstOrThrow
   */
  export type TrainingSessionPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSessionPhoto to fetch.
     */
    where?: TrainingSessionPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessionPhotos to fetch.
     */
    orderBy?: TrainingSessionPhotoOrderByWithRelationInput | TrainingSessionPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingSessionPhotos.
     */
    cursor?: TrainingSessionPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessionPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessionPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingSessionPhotos.
     */
    distinct?: TrainingSessionPhotoScalarFieldEnum | TrainingSessionPhotoScalarFieldEnum[]
  }

  /**
   * TrainingSessionPhoto findMany
   */
  export type TrainingSessionPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSessionPhotos to fetch.
     */
    where?: TrainingSessionPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessionPhotos to fetch.
     */
    orderBy?: TrainingSessionPhotoOrderByWithRelationInput | TrainingSessionPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingSessionPhotos.
     */
    cursor?: TrainingSessionPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessionPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessionPhotos.
     */
    skip?: number
    distinct?: TrainingSessionPhotoScalarFieldEnum | TrainingSessionPhotoScalarFieldEnum[]
  }

  /**
   * TrainingSessionPhoto create
   */
  export type TrainingSessionPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingSessionPhoto.
     */
    data: XOR<TrainingSessionPhotoCreateInput, TrainingSessionPhotoUncheckedCreateInput>
  }

  /**
   * TrainingSessionPhoto createMany
   */
  export type TrainingSessionPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingSessionPhotos.
     */
    data: TrainingSessionPhotoCreateManyInput | TrainingSessionPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingSessionPhoto createManyAndReturn
   */
  export type TrainingSessionPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingSessionPhotos.
     */
    data: TrainingSessionPhotoCreateManyInput | TrainingSessionPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingSessionPhoto update
   */
  export type TrainingSessionPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingSessionPhoto.
     */
    data: XOR<TrainingSessionPhotoUpdateInput, TrainingSessionPhotoUncheckedUpdateInput>
    /**
     * Choose, which TrainingSessionPhoto to update.
     */
    where: TrainingSessionPhotoWhereUniqueInput
  }

  /**
   * TrainingSessionPhoto updateMany
   */
  export type TrainingSessionPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingSessionPhotos.
     */
    data: XOR<TrainingSessionPhotoUpdateManyMutationInput, TrainingSessionPhotoUncheckedUpdateManyInput>
    /**
     * Filter which TrainingSessionPhotos to update
     */
    where?: TrainingSessionPhotoWhereInput
    /**
     * Limit how many TrainingSessionPhotos to update.
     */
    limit?: number
  }

  /**
   * TrainingSessionPhoto updateManyAndReturn
   */
  export type TrainingSessionPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * The data used to update TrainingSessionPhotos.
     */
    data: XOR<TrainingSessionPhotoUpdateManyMutationInput, TrainingSessionPhotoUncheckedUpdateManyInput>
    /**
     * Filter which TrainingSessionPhotos to update
     */
    where?: TrainingSessionPhotoWhereInput
    /**
     * Limit how many TrainingSessionPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingSessionPhoto upsert
   */
  export type TrainingSessionPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingSessionPhoto to update in case it exists.
     */
    where: TrainingSessionPhotoWhereUniqueInput
    /**
     * In case the TrainingSessionPhoto found by the `where` argument doesn't exist, create a new TrainingSessionPhoto with this data.
     */
    create: XOR<TrainingSessionPhotoCreateInput, TrainingSessionPhotoUncheckedCreateInput>
    /**
     * In case the TrainingSessionPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingSessionPhotoUpdateInput, TrainingSessionPhotoUncheckedUpdateInput>
  }

  /**
   * TrainingSessionPhoto delete
   */
  export type TrainingSessionPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoInclude<ExtArgs> | null
    /**
     * Filter which TrainingSessionPhoto to delete.
     */
    where: TrainingSessionPhotoWhereUniqueInput
  }

  /**
   * TrainingSessionPhoto deleteMany
   */
  export type TrainingSessionPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingSessionPhotos to delete
     */
    where?: TrainingSessionPhotoWhereInput
    /**
     * Limit how many TrainingSessionPhotos to delete.
     */
    limit?: number
  }

  /**
   * TrainingSessionPhoto without action
   */
  export type TrainingSessionPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionPhoto
     */
    select?: TrainingSessionPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSessionPhoto
     */
    omit?: TrainingSessionPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionPhotoInclude<ExtArgs> | null
  }


  /**
   * Model Auditor
   */

  export type AggregateAuditor = {
    _count: AuditorCountAggregateOutputType | null
    _min: AuditorMinAggregateOutputType | null
    _max: AuditorMaxAggregateOutputType | null
  }

  export type AuditorMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    userId: string | null
    isExternal: boolean | null
    firmName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    userId: string | null
    isExternal: boolean | null
    firmName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditorCountAggregateOutputType = {
    id: number
    name: number
    email: number
    userId: number
    isExternal: number
    firmName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditorMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    userId?: true
    isExternal?: true
    firmName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditorMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    userId?: true
    isExternal?: true
    firmName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditorCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    userId?: true
    isExternal?: true
    firmName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auditor to aggregate.
     */
    where?: AuditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditors to fetch.
     */
    orderBy?: AuditorOrderByWithRelationInput | AuditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Auditors
    **/
    _count?: true | AuditorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditorMaxAggregateInputType
  }

  export type GetAuditorAggregateType<T extends AuditorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditor[P]>
      : GetScalarType<T[P], AggregateAuditor[P]>
  }




  export type AuditorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditorWhereInput
    orderBy?: AuditorOrderByWithAggregationInput | AuditorOrderByWithAggregationInput[]
    by: AuditorScalarFieldEnum[] | AuditorScalarFieldEnum
    having?: AuditorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditorCountAggregateInputType | true
    _min?: AuditorMinAggregateInputType
    _max?: AuditorMaxAggregateInputType
  }

  export type AuditorGroupByOutputType = {
    id: string
    name: string
    email: string
    userId: string | null
    isExternal: boolean
    firmName: string | null
    createdAt: Date
    updatedAt: Date
    _count: AuditorCountAggregateOutputType | null
    _min: AuditorMinAggregateOutputType | null
    _max: AuditorMaxAggregateOutputType | null
  }

  type GetAuditorGroupByPayload<T extends AuditorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditorGroupByOutputType[P]>
            : GetScalarType<T[P], AuditorGroupByOutputType[P]>
        }
      >
    >


  export type AuditorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    userId?: boolean
    isExternal?: boolean
    firmName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Auditor$userArgs<ExtArgs>
    audits?: boolean | Auditor$auditsArgs<ExtArgs>
    _count?: boolean | AuditorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditor"]>

  export type AuditorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    userId?: boolean
    isExternal?: boolean
    firmName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Auditor$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditor"]>

  export type AuditorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    userId?: boolean
    isExternal?: boolean
    firmName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Auditor$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditor"]>

  export type AuditorSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    userId?: boolean
    isExternal?: boolean
    firmName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "userId" | "isExternal" | "firmName" | "createdAt" | "updatedAt", ExtArgs["result"]["auditor"]>
  export type AuditorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Auditor$userArgs<ExtArgs>
    audits?: boolean | Auditor$auditsArgs<ExtArgs>
    _count?: boolean | AuditorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuditorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Auditor$userArgs<ExtArgs>
  }
  export type AuditorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Auditor$userArgs<ExtArgs>
  }

  export type $AuditorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Auditor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      audits: Prisma.$AuditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      userId: string | null
      isExternal: boolean
      firmName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auditor"]>
    composites: {}
  }

  type AuditorGetPayload<S extends boolean | null | undefined | AuditorDefaultArgs> = $Result.GetResult<Prisma.$AuditorPayload, S>

  type AuditorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditorCountAggregateInputType | true
    }

  export interface AuditorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Auditor'], meta: { name: 'Auditor' } }
    /**
     * Find zero or one Auditor that matches the filter.
     * @param {AuditorFindUniqueArgs} args - Arguments to find a Auditor
     * @example
     * // Get one Auditor
     * const auditor = await prisma.auditor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditorFindUniqueArgs>(args: SelectSubset<T, AuditorFindUniqueArgs<ExtArgs>>): Prisma__AuditorClient<$Result.GetResult<Prisma.$AuditorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auditor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditorFindUniqueOrThrowArgs} args - Arguments to find a Auditor
     * @example
     * // Get one Auditor
     * const auditor = await prisma.auditor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditorFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditorClient<$Result.GetResult<Prisma.$AuditorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditorFindFirstArgs} args - Arguments to find a Auditor
     * @example
     * // Get one Auditor
     * const auditor = await prisma.auditor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditorFindFirstArgs>(args?: SelectSubset<T, AuditorFindFirstArgs<ExtArgs>>): Prisma__AuditorClient<$Result.GetResult<Prisma.$AuditorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditorFindFirstOrThrowArgs} args - Arguments to find a Auditor
     * @example
     * // Get one Auditor
     * const auditor = await prisma.auditor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditorFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditorClient<$Result.GetResult<Prisma.$AuditorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auditors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditors
     * const auditors = await prisma.auditor.findMany()
     * 
     * // Get first 10 Auditors
     * const auditors = await prisma.auditor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditorWithIdOnly = await prisma.auditor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditorFindManyArgs>(args?: SelectSubset<T, AuditorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auditor.
     * @param {AuditorCreateArgs} args - Arguments to create a Auditor.
     * @example
     * // Create one Auditor
     * const Auditor = await prisma.auditor.create({
     *   data: {
     *     // ... data to create a Auditor
     *   }
     * })
     * 
     */
    create<T extends AuditorCreateArgs>(args: SelectSubset<T, AuditorCreateArgs<ExtArgs>>): Prisma__AuditorClient<$Result.GetResult<Prisma.$AuditorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auditors.
     * @param {AuditorCreateManyArgs} args - Arguments to create many Auditors.
     * @example
     * // Create many Auditors
     * const auditor = await prisma.auditor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditorCreateManyArgs>(args?: SelectSubset<T, AuditorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auditors and returns the data saved in the database.
     * @param {AuditorCreateManyAndReturnArgs} args - Arguments to create many Auditors.
     * @example
     * // Create many Auditors
     * const auditor = await prisma.auditor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auditors and only return the `id`
     * const auditorWithIdOnly = await prisma.auditor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditorCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auditor.
     * @param {AuditorDeleteArgs} args - Arguments to delete one Auditor.
     * @example
     * // Delete one Auditor
     * const Auditor = await prisma.auditor.delete({
     *   where: {
     *     // ... filter to delete one Auditor
     *   }
     * })
     * 
     */
    delete<T extends AuditorDeleteArgs>(args: SelectSubset<T, AuditorDeleteArgs<ExtArgs>>): Prisma__AuditorClient<$Result.GetResult<Prisma.$AuditorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auditor.
     * @param {AuditorUpdateArgs} args - Arguments to update one Auditor.
     * @example
     * // Update one Auditor
     * const auditor = await prisma.auditor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditorUpdateArgs>(args: SelectSubset<T, AuditorUpdateArgs<ExtArgs>>): Prisma__AuditorClient<$Result.GetResult<Prisma.$AuditorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auditors.
     * @param {AuditorDeleteManyArgs} args - Arguments to filter Auditors to delete.
     * @example
     * // Delete a few Auditors
     * const { count } = await prisma.auditor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditorDeleteManyArgs>(args?: SelectSubset<T, AuditorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditors
     * const auditor = await prisma.auditor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditorUpdateManyArgs>(args: SelectSubset<T, AuditorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditors and returns the data updated in the database.
     * @param {AuditorUpdateManyAndReturnArgs} args - Arguments to update many Auditors.
     * @example
     * // Update many Auditors
     * const auditor = await prisma.auditor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auditors and only return the `id`
     * const auditorWithIdOnly = await prisma.auditor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditorUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auditor.
     * @param {AuditorUpsertArgs} args - Arguments to update or create a Auditor.
     * @example
     * // Update or create a Auditor
     * const auditor = await prisma.auditor.upsert({
     *   create: {
     *     // ... data to create a Auditor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditor we want to update
     *   }
     * })
     */
    upsert<T extends AuditorUpsertArgs>(args: SelectSubset<T, AuditorUpsertArgs<ExtArgs>>): Prisma__AuditorClient<$Result.GetResult<Prisma.$AuditorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auditors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditorCountArgs} args - Arguments to filter Auditors to count.
     * @example
     * // Count the number of Auditors
     * const count = await prisma.auditor.count({
     *   where: {
     *     // ... the filter for the Auditors we want to count
     *   }
     * })
    **/
    count<T extends AuditorCountArgs>(
      args?: Subset<T, AuditorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditorAggregateArgs>(args: Subset<T, AuditorAggregateArgs>): Prisma.PrismaPromise<GetAuditorAggregateType<T>>

    /**
     * Group by Auditor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditorGroupByArgs['orderBy'] }
        : { orderBy?: AuditorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Auditor model
   */
  readonly fields: AuditorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Auditor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Auditor$userArgs<ExtArgs> = {}>(args?: Subset<T, Auditor$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    audits<T extends Auditor$auditsArgs<ExtArgs> = {}>(args?: Subset<T, Auditor$auditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Auditor model
   */
  interface AuditorFieldRefs {
    readonly id: FieldRef<"Auditor", 'String'>
    readonly name: FieldRef<"Auditor", 'String'>
    readonly email: FieldRef<"Auditor", 'String'>
    readonly userId: FieldRef<"Auditor", 'String'>
    readonly isExternal: FieldRef<"Auditor", 'Boolean'>
    readonly firmName: FieldRef<"Auditor", 'String'>
    readonly createdAt: FieldRef<"Auditor", 'DateTime'>
    readonly updatedAt: FieldRef<"Auditor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Auditor findUnique
   */
  export type AuditorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditor
     */
    select?: AuditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditor
     */
    omit?: AuditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditorInclude<ExtArgs> | null
    /**
     * Filter, which Auditor to fetch.
     */
    where: AuditorWhereUniqueInput
  }

  /**
   * Auditor findUniqueOrThrow
   */
  export type AuditorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditor
     */
    select?: AuditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditor
     */
    omit?: AuditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditorInclude<ExtArgs> | null
    /**
     * Filter, which Auditor to fetch.
     */
    where: AuditorWhereUniqueInput
  }

  /**
   * Auditor findFirst
   */
  export type AuditorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditor
     */
    select?: AuditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditor
     */
    omit?: AuditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditorInclude<ExtArgs> | null
    /**
     * Filter, which Auditor to fetch.
     */
    where?: AuditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditors to fetch.
     */
    orderBy?: AuditorOrderByWithRelationInput | AuditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auditors.
     */
    cursor?: AuditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auditors.
     */
    distinct?: AuditorScalarFieldEnum | AuditorScalarFieldEnum[]
  }

  /**
   * Auditor findFirstOrThrow
   */
  export type AuditorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditor
     */
    select?: AuditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditor
     */
    omit?: AuditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditorInclude<ExtArgs> | null
    /**
     * Filter, which Auditor to fetch.
     */
    where?: AuditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditors to fetch.
     */
    orderBy?: AuditorOrderByWithRelationInput | AuditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auditors.
     */
    cursor?: AuditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auditors.
     */
    distinct?: AuditorScalarFieldEnum | AuditorScalarFieldEnum[]
  }

  /**
   * Auditor findMany
   */
  export type AuditorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditor
     */
    select?: AuditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditor
     */
    omit?: AuditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditorInclude<ExtArgs> | null
    /**
     * Filter, which Auditors to fetch.
     */
    where?: AuditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditors to fetch.
     */
    orderBy?: AuditorOrderByWithRelationInput | AuditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Auditors.
     */
    cursor?: AuditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditors.
     */
    skip?: number
    distinct?: AuditorScalarFieldEnum | AuditorScalarFieldEnum[]
  }

  /**
   * Auditor create
   */
  export type AuditorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditor
     */
    select?: AuditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditor
     */
    omit?: AuditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditorInclude<ExtArgs> | null
    /**
     * The data needed to create a Auditor.
     */
    data: XOR<AuditorCreateInput, AuditorUncheckedCreateInput>
  }

  /**
   * Auditor createMany
   */
  export type AuditorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Auditors.
     */
    data: AuditorCreateManyInput | AuditorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Auditor createManyAndReturn
   */
  export type AuditorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditor
     */
    select?: AuditorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Auditor
     */
    omit?: AuditorOmit<ExtArgs> | null
    /**
     * The data used to create many Auditors.
     */
    data: AuditorCreateManyInput | AuditorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Auditor update
   */
  export type AuditorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditor
     */
    select?: AuditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditor
     */
    omit?: AuditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditorInclude<ExtArgs> | null
    /**
     * The data needed to update a Auditor.
     */
    data: XOR<AuditorUpdateInput, AuditorUncheckedUpdateInput>
    /**
     * Choose, which Auditor to update.
     */
    where: AuditorWhereUniqueInput
  }

  /**
   * Auditor updateMany
   */
  export type AuditorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Auditors.
     */
    data: XOR<AuditorUpdateManyMutationInput, AuditorUncheckedUpdateManyInput>
    /**
     * Filter which Auditors to update
     */
    where?: AuditorWhereInput
    /**
     * Limit how many Auditors to update.
     */
    limit?: number
  }

  /**
   * Auditor updateManyAndReturn
   */
  export type AuditorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditor
     */
    select?: AuditorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Auditor
     */
    omit?: AuditorOmit<ExtArgs> | null
    /**
     * The data used to update Auditors.
     */
    data: XOR<AuditorUpdateManyMutationInput, AuditorUncheckedUpdateManyInput>
    /**
     * Filter which Auditors to update
     */
    where?: AuditorWhereInput
    /**
     * Limit how many Auditors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Auditor upsert
   */
  export type AuditorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditor
     */
    select?: AuditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditor
     */
    omit?: AuditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditorInclude<ExtArgs> | null
    /**
     * The filter to search for the Auditor to update in case it exists.
     */
    where: AuditorWhereUniqueInput
    /**
     * In case the Auditor found by the `where` argument doesn't exist, create a new Auditor with this data.
     */
    create: XOR<AuditorCreateInput, AuditorUncheckedCreateInput>
    /**
     * In case the Auditor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditorUpdateInput, AuditorUncheckedUpdateInput>
  }

  /**
   * Auditor delete
   */
  export type AuditorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditor
     */
    select?: AuditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditor
     */
    omit?: AuditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditorInclude<ExtArgs> | null
    /**
     * Filter which Auditor to delete.
     */
    where: AuditorWhereUniqueInput
  }

  /**
   * Auditor deleteMany
   */
  export type AuditorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auditors to delete
     */
    where?: AuditorWhereInput
    /**
     * Limit how many Auditors to delete.
     */
    limit?: number
  }

  /**
   * Auditor.user
   */
  export type Auditor$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Auditor.audits
   */
  export type Auditor$auditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    cursor?: AuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Auditor without action
   */
  export type AuditorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditor
     */
    select?: AuditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditor
     */
    omit?: AuditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditorInclude<ExtArgs> | null
  }


  /**
   * Model Audit
   */

  export type AggregateAudit = {
    _count: AuditCountAggregateOutputType | null
    _min: AuditMinAggregateOutputType | null
    _max: AuditMaxAggregateOutputType | null
  }

  export type AuditMinAggregateOutputType = {
    id: string | null
    name: string | null
    auditType: $Enums.AuditType | null
    status: $Enums.AuditStatus | null
    startDate: Date | null
    endDate: Date | null
    auditorId: string | null
    auditeeId: string | null
    firmName: string | null
    departmentId: string | null
    objectives: string | null
    scope: string | null
    summary: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditMaxAggregateOutputType = {
    id: string | null
    name: string | null
    auditType: $Enums.AuditType | null
    status: $Enums.AuditStatus | null
    startDate: Date | null
    endDate: Date | null
    auditorId: string | null
    auditeeId: string | null
    firmName: string | null
    departmentId: string | null
    objectives: string | null
    scope: string | null
    summary: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditCountAggregateOutputType = {
    id: number
    name: number
    auditType: number
    status: number
    startDate: number
    endDate: number
    auditorId: number
    auditeeId: number
    firmName: number
    departmentId: number
    objectives: number
    scope: number
    summary: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditMinAggregateInputType = {
    id?: true
    name?: true
    auditType?: true
    status?: true
    startDate?: true
    endDate?: true
    auditorId?: true
    auditeeId?: true
    firmName?: true
    departmentId?: true
    objectives?: true
    scope?: true
    summary?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditMaxAggregateInputType = {
    id?: true
    name?: true
    auditType?: true
    status?: true
    startDate?: true
    endDate?: true
    auditorId?: true
    auditeeId?: true
    firmName?: true
    departmentId?: true
    objectives?: true
    scope?: true
    summary?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditCountAggregateInputType = {
    id?: true
    name?: true
    auditType?: true
    status?: true
    startDate?: true
    endDate?: true
    auditorId?: true
    auditeeId?: true
    firmName?: true
    departmentId?: true
    objectives?: true
    scope?: true
    summary?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Audit to aggregate.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Audits
    **/
    _count?: true | AuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditMaxAggregateInputType
  }

  export type GetAuditAggregateType<T extends AuditAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit[P]>
      : GetScalarType<T[P], AggregateAudit[P]>
  }




  export type AuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithAggregationInput | AuditOrderByWithAggregationInput[]
    by: AuditScalarFieldEnum[] | AuditScalarFieldEnum
    having?: AuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditCountAggregateInputType | true
    _min?: AuditMinAggregateInputType
    _max?: AuditMaxAggregateInputType
  }

  export type AuditGroupByOutputType = {
    id: string
    name: string
    auditType: $Enums.AuditType
    status: $Enums.AuditStatus
    startDate: Date
    endDate: Date | null
    auditorId: string
    auditeeId: string | null
    firmName: string | null
    departmentId: string | null
    objectives: string | null
    scope: string | null
    summary: string | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: AuditCountAggregateOutputType | null
    _min: AuditMinAggregateOutputType | null
    _max: AuditMaxAggregateOutputType | null
  }

  type GetAuditGroupByPayload<T extends AuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditGroupByOutputType[P]>
            : GetScalarType<T[P], AuditGroupByOutputType[P]>
        }
      >
    >


  export type AuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    auditType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    auditorId?: boolean
    auditeeId?: boolean
    firmName?: boolean
    departmentId?: boolean
    objectives?: boolean
    scope?: boolean
    summary?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auditor?: boolean | AuditorDefaultArgs<ExtArgs>
    auditee?: boolean | Audit$auditeeArgs<ExtArgs>
    department?: boolean | Audit$departmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    findings?: boolean | Audit$findingsArgs<ExtArgs>
    documents?: boolean | Audit$documentsArgs<ExtArgs>
    actions?: boolean | Audit$actionsArgs<ExtArgs>
    reminders?: boolean | Audit$remindersArgs<ExtArgs>
    notifications?: boolean | Audit$notificationsArgs<ExtArgs>
    checklistItems?: boolean | Audit$checklistItemsArgs<ExtArgs>
    inspectionItems?: boolean | Audit$inspectionItemsArgs<ExtArgs>
    _count?: boolean | AuditCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit"]>

  export type AuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    auditType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    auditorId?: boolean
    auditeeId?: boolean
    firmName?: boolean
    departmentId?: boolean
    objectives?: boolean
    scope?: boolean
    summary?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auditor?: boolean | AuditorDefaultArgs<ExtArgs>
    auditee?: boolean | Audit$auditeeArgs<ExtArgs>
    department?: boolean | Audit$departmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit"]>

  export type AuditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    auditType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    auditorId?: boolean
    auditeeId?: boolean
    firmName?: boolean
    departmentId?: boolean
    objectives?: boolean
    scope?: boolean
    summary?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auditor?: boolean | AuditorDefaultArgs<ExtArgs>
    auditee?: boolean | Audit$auditeeArgs<ExtArgs>
    department?: boolean | Audit$departmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit"]>

  export type AuditSelectScalar = {
    id?: boolean
    name?: boolean
    auditType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    auditorId?: boolean
    auditeeId?: boolean
    firmName?: boolean
    departmentId?: boolean
    objectives?: boolean
    scope?: boolean
    summary?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "auditType" | "status" | "startDate" | "endDate" | "auditorId" | "auditeeId" | "firmName" | "departmentId" | "objectives" | "scope" | "summary" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["audit"]>
  export type AuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditor?: boolean | AuditorDefaultArgs<ExtArgs>
    auditee?: boolean | Audit$auditeeArgs<ExtArgs>
    department?: boolean | Audit$departmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    findings?: boolean | Audit$findingsArgs<ExtArgs>
    documents?: boolean | Audit$documentsArgs<ExtArgs>
    actions?: boolean | Audit$actionsArgs<ExtArgs>
    reminders?: boolean | Audit$remindersArgs<ExtArgs>
    notifications?: boolean | Audit$notificationsArgs<ExtArgs>
    checklistItems?: boolean | Audit$checklistItemsArgs<ExtArgs>
    inspectionItems?: boolean | Audit$inspectionItemsArgs<ExtArgs>
    _count?: boolean | AuditCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditor?: boolean | AuditorDefaultArgs<ExtArgs>
    auditee?: boolean | Audit$auditeeArgs<ExtArgs>
    department?: boolean | Audit$departmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditor?: boolean | AuditorDefaultArgs<ExtArgs>
    auditee?: boolean | Audit$auditeeArgs<ExtArgs>
    department?: boolean | Audit$departmentArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Audit"
    objects: {
      auditor: Prisma.$AuditorPayload<ExtArgs>
      auditee: Prisma.$UserPayload<ExtArgs> | null
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      findings: Prisma.$FindingPayload<ExtArgs>[]
      documents: Prisma.$AuditDocumentPayload<ExtArgs>[]
      actions: Prisma.$CorrectiveActionPayload<ExtArgs>[]
      reminders: Prisma.$AuditReminderPayload<ExtArgs>[]
      notifications: Prisma.$AuditNotificationPayload<ExtArgs>[]
      checklistItems: Prisma.$PreAuditChecklistItemPayload<ExtArgs>[]
      inspectionItems: Prisma.$AuditInspectionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      auditType: $Enums.AuditType
      status: $Enums.AuditStatus
      startDate: Date
      endDate: Date | null
      auditorId: string
      auditeeId: string | null
      firmName: string | null
      departmentId: string | null
      objectives: string | null
      scope: string | null
      summary: string | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["audit"]>
    composites: {}
  }

  type AuditGetPayload<S extends boolean | null | undefined | AuditDefaultArgs> = $Result.GetResult<Prisma.$AuditPayload, S>

  type AuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditCountAggregateInputType | true
    }

  export interface AuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Audit'], meta: { name: 'Audit' } }
    /**
     * Find zero or one Audit that matches the filter.
     * @param {AuditFindUniqueArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditFindUniqueArgs>(args: SelectSubset<T, AuditFindUniqueArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditFindUniqueOrThrowArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindFirstArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditFindFirstArgs>(args?: SelectSubset<T, AuditFindFirstArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindFirstOrThrowArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audits
     * const audits = await prisma.audit.findMany()
     * 
     * // Get first 10 Audits
     * const audits = await prisma.audit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditWithIdOnly = await prisma.audit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditFindManyArgs>(args?: SelectSubset<T, AuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit.
     * @param {AuditCreateArgs} args - Arguments to create a Audit.
     * @example
     * // Create one Audit
     * const Audit = await prisma.audit.create({
     *   data: {
     *     // ... data to create a Audit
     *   }
     * })
     * 
     */
    create<T extends AuditCreateArgs>(args: SelectSubset<T, AuditCreateArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audits.
     * @param {AuditCreateManyArgs} args - Arguments to create many Audits.
     * @example
     * // Create many Audits
     * const audit = await prisma.audit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditCreateManyArgs>(args?: SelectSubset<T, AuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Audits and returns the data saved in the database.
     * @param {AuditCreateManyAndReturnArgs} args - Arguments to create many Audits.
     * @example
     * // Create many Audits
     * const audit = await prisma.audit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Audits and only return the `id`
     * const auditWithIdOnly = await prisma.audit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Audit.
     * @param {AuditDeleteArgs} args - Arguments to delete one Audit.
     * @example
     * // Delete one Audit
     * const Audit = await prisma.audit.delete({
     *   where: {
     *     // ... filter to delete one Audit
     *   }
     * })
     * 
     */
    delete<T extends AuditDeleteArgs>(args: SelectSubset<T, AuditDeleteArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit.
     * @param {AuditUpdateArgs} args - Arguments to update one Audit.
     * @example
     * // Update one Audit
     * const audit = await prisma.audit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditUpdateArgs>(args: SelectSubset<T, AuditUpdateArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audits.
     * @param {AuditDeleteManyArgs} args - Arguments to filter Audits to delete.
     * @example
     * // Delete a few Audits
     * const { count } = await prisma.audit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditDeleteManyArgs>(args?: SelectSubset<T, AuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audits
     * const audit = await prisma.audit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditUpdateManyArgs>(args: SelectSubset<T, AuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audits and returns the data updated in the database.
     * @param {AuditUpdateManyAndReturnArgs} args - Arguments to update many Audits.
     * @example
     * // Update many Audits
     * const audit = await prisma.audit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Audits and only return the `id`
     * const auditWithIdOnly = await prisma.audit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Audit.
     * @param {AuditUpsertArgs} args - Arguments to update or create a Audit.
     * @example
     * // Update or create a Audit
     * const audit = await prisma.audit.upsert({
     *   create: {
     *     // ... data to create a Audit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit we want to update
     *   }
     * })
     */
    upsert<T extends AuditUpsertArgs>(args: SelectSubset<T, AuditUpsertArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditCountArgs} args - Arguments to filter Audits to count.
     * @example
     * // Count the number of Audits
     * const count = await prisma.audit.count({
     *   where: {
     *     // ... the filter for the Audits we want to count
     *   }
     * })
    **/
    count<T extends AuditCountArgs>(
      args?: Subset<T, AuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditAggregateArgs>(args: Subset<T, AuditAggregateArgs>): Prisma.PrismaPromise<GetAuditAggregateType<T>>

    /**
     * Group by Audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditGroupByArgs['orderBy'] }
        : { orderBy?: AuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Audit model
   */
  readonly fields: AuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Audit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditor<T extends AuditorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditorDefaultArgs<ExtArgs>>): Prisma__AuditorClient<$Result.GetResult<Prisma.$AuditorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    auditee<T extends Audit$auditeeArgs<ExtArgs> = {}>(args?: Subset<T, Audit$auditeeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    department<T extends Audit$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Audit$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    findings<T extends Audit$findingsArgs<ExtArgs> = {}>(args?: Subset<T, Audit$findingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Audit$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Audit$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    actions<T extends Audit$actionsArgs<ExtArgs> = {}>(args?: Subset<T, Audit$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reminders<T extends Audit$remindersArgs<ExtArgs> = {}>(args?: Subset<T, Audit$remindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Audit$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Audit$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checklistItems<T extends Audit$checklistItemsArgs<ExtArgs> = {}>(args?: Subset<T, Audit$checklistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inspectionItems<T extends Audit$inspectionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Audit$inspectionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditInspectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Audit model
   */
  interface AuditFieldRefs {
    readonly id: FieldRef<"Audit", 'String'>
    readonly name: FieldRef<"Audit", 'String'>
    readonly auditType: FieldRef<"Audit", 'AuditType'>
    readonly status: FieldRef<"Audit", 'AuditStatus'>
    readonly startDate: FieldRef<"Audit", 'DateTime'>
    readonly endDate: FieldRef<"Audit", 'DateTime'>
    readonly auditorId: FieldRef<"Audit", 'String'>
    readonly auditeeId: FieldRef<"Audit", 'String'>
    readonly firmName: FieldRef<"Audit", 'String'>
    readonly departmentId: FieldRef<"Audit", 'String'>
    readonly objectives: FieldRef<"Audit", 'String'>
    readonly scope: FieldRef<"Audit", 'String'>
    readonly summary: FieldRef<"Audit", 'String'>
    readonly createdById: FieldRef<"Audit", 'String'>
    readonly createdAt: FieldRef<"Audit", 'DateTime'>
    readonly updatedAt: FieldRef<"Audit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Audit findUnique
   */
  export type AuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit findUniqueOrThrow
   */
  export type AuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit findFirst
   */
  export type AuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audits.
     */
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit findFirstOrThrow
   */
  export type AuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audits.
     */
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit findMany
   */
  export type AuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audits to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit create
   */
  export type AuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * The data needed to create a Audit.
     */
    data: XOR<AuditCreateInput, AuditUncheckedCreateInput>
  }

  /**
   * Audit createMany
   */
  export type AuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Audits.
     */
    data: AuditCreateManyInput | AuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Audit createManyAndReturn
   */
  export type AuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * The data used to create many Audits.
     */
    data: AuditCreateManyInput | AuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Audit update
   */
  export type AuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * The data needed to update a Audit.
     */
    data: XOR<AuditUpdateInput, AuditUncheckedUpdateInput>
    /**
     * Choose, which Audit to update.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit updateMany
   */
  export type AuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Audits.
     */
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyInput>
    /**
     * Filter which Audits to update
     */
    where?: AuditWhereInput
    /**
     * Limit how many Audits to update.
     */
    limit?: number
  }

  /**
   * Audit updateManyAndReturn
   */
  export type AuditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * The data used to update Audits.
     */
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyInput>
    /**
     * Filter which Audits to update
     */
    where?: AuditWhereInput
    /**
     * Limit how many Audits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Audit upsert
   */
  export type AuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * The filter to search for the Audit to update in case it exists.
     */
    where: AuditWhereUniqueInput
    /**
     * In case the Audit found by the `where` argument doesn't exist, create a new Audit with this data.
     */
    create: XOR<AuditCreateInput, AuditUncheckedCreateInput>
    /**
     * In case the Audit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditUpdateInput, AuditUncheckedUpdateInput>
  }

  /**
   * Audit delete
   */
  export type AuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter which Audit to delete.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit deleteMany
   */
  export type AuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Audits to delete
     */
    where?: AuditWhereInput
    /**
     * Limit how many Audits to delete.
     */
    limit?: number
  }

  /**
   * Audit.auditee
   */
  export type Audit$auditeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Audit.department
   */
  export type Audit$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Audit.findings
   */
  export type Audit$findingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null
    where?: FindingWhereInput
    orderBy?: FindingOrderByWithRelationInput | FindingOrderByWithRelationInput[]
    cursor?: FindingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FindingScalarFieldEnum | FindingScalarFieldEnum[]
  }

  /**
   * Audit.documents
   */
  export type Audit$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentInclude<ExtArgs> | null
    where?: AuditDocumentWhereInput
    orderBy?: AuditDocumentOrderByWithRelationInput | AuditDocumentOrderByWithRelationInput[]
    cursor?: AuditDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditDocumentScalarFieldEnum | AuditDocumentScalarFieldEnum[]
  }

  /**
   * Audit.actions
   */
  export type Audit$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
    where?: CorrectiveActionWhereInput
    orderBy?: CorrectiveActionOrderByWithRelationInput | CorrectiveActionOrderByWithRelationInput[]
    cursor?: CorrectiveActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CorrectiveActionScalarFieldEnum | CorrectiveActionScalarFieldEnum[]
  }

  /**
   * Audit.reminders
   */
  export type Audit$remindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderInclude<ExtArgs> | null
    where?: AuditReminderWhereInput
    orderBy?: AuditReminderOrderByWithRelationInput | AuditReminderOrderByWithRelationInput[]
    cursor?: AuditReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditReminderScalarFieldEnum | AuditReminderScalarFieldEnum[]
  }

  /**
   * Audit.notifications
   */
  export type Audit$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationInclude<ExtArgs> | null
    where?: AuditNotificationWhereInput
    orderBy?: AuditNotificationOrderByWithRelationInput | AuditNotificationOrderByWithRelationInput[]
    cursor?: AuditNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditNotificationScalarFieldEnum | AuditNotificationScalarFieldEnum[]
  }

  /**
   * Audit.checklistItems
   */
  export type Audit$checklistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemInclude<ExtArgs> | null
    where?: PreAuditChecklistItemWhereInput
    orderBy?: PreAuditChecklistItemOrderByWithRelationInput | PreAuditChecklistItemOrderByWithRelationInput[]
    cursor?: PreAuditChecklistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreAuditChecklistItemScalarFieldEnum | PreAuditChecklistItemScalarFieldEnum[]
  }

  /**
   * Audit.inspectionItems
   */
  export type Audit$inspectionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemInclude<ExtArgs> | null
    where?: AuditInspectionItemWhereInput
    orderBy?: AuditInspectionItemOrderByWithRelationInput | AuditInspectionItemOrderByWithRelationInput[]
    cursor?: AuditInspectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditInspectionItemScalarFieldEnum | AuditInspectionItemScalarFieldEnum[]
  }

  /**
   * Audit without action
   */
  export type AuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
  }


  /**
   * Model AuditInspectionItem
   */

  export type AggregateAuditInspectionItem = {
    _count: AuditInspectionItemCountAggregateOutputType | null
    _min: AuditInspectionItemMinAggregateOutputType | null
    _max: AuditInspectionItemMaxAggregateOutputType | null
  }

  export type AuditInspectionItemMinAggregateOutputType = {
    id: string | null
    auditId: string | null
    areaName: string | null
    itemName: string | null
    description: string | null
    standardReference: string | null
    isCompliant: boolean | null
    comments: string | null
    evidence: string | null
    inspectedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditInspectionItemMaxAggregateOutputType = {
    id: string | null
    auditId: string | null
    areaName: string | null
    itemName: string | null
    description: string | null
    standardReference: string | null
    isCompliant: boolean | null
    comments: string | null
    evidence: string | null
    inspectedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditInspectionItemCountAggregateOutputType = {
    id: number
    auditId: number
    areaName: number
    itemName: number
    description: number
    standardReference: number
    isCompliant: number
    comments: number
    evidence: number
    inspectedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditInspectionItemMinAggregateInputType = {
    id?: true
    auditId?: true
    areaName?: true
    itemName?: true
    description?: true
    standardReference?: true
    isCompliant?: true
    comments?: true
    evidence?: true
    inspectedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditInspectionItemMaxAggregateInputType = {
    id?: true
    auditId?: true
    areaName?: true
    itemName?: true
    description?: true
    standardReference?: true
    isCompliant?: true
    comments?: true
    evidence?: true
    inspectedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditInspectionItemCountAggregateInputType = {
    id?: true
    auditId?: true
    areaName?: true
    itemName?: true
    description?: true
    standardReference?: true
    isCompliant?: true
    comments?: true
    evidence?: true
    inspectedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditInspectionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditInspectionItem to aggregate.
     */
    where?: AuditInspectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditInspectionItems to fetch.
     */
    orderBy?: AuditInspectionItemOrderByWithRelationInput | AuditInspectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditInspectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditInspectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditInspectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditInspectionItems
    **/
    _count?: true | AuditInspectionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditInspectionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditInspectionItemMaxAggregateInputType
  }

  export type GetAuditInspectionItemAggregateType<T extends AuditInspectionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditInspectionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditInspectionItem[P]>
      : GetScalarType<T[P], AggregateAuditInspectionItem[P]>
  }




  export type AuditInspectionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditInspectionItemWhereInput
    orderBy?: AuditInspectionItemOrderByWithAggregationInput | AuditInspectionItemOrderByWithAggregationInput[]
    by: AuditInspectionItemScalarFieldEnum[] | AuditInspectionItemScalarFieldEnum
    having?: AuditInspectionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditInspectionItemCountAggregateInputType | true
    _min?: AuditInspectionItemMinAggregateInputType
    _max?: AuditInspectionItemMaxAggregateInputType
  }

  export type AuditInspectionItemGroupByOutputType = {
    id: string
    auditId: string
    areaName: string
    itemName: string
    description: string | null
    standardReference: string | null
    isCompliant: boolean | null
    comments: string | null
    evidence: string | null
    inspectedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: AuditInspectionItemCountAggregateOutputType | null
    _min: AuditInspectionItemMinAggregateOutputType | null
    _max: AuditInspectionItemMaxAggregateOutputType | null
  }

  type GetAuditInspectionItemGroupByPayload<T extends AuditInspectionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditInspectionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditInspectionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditInspectionItemGroupByOutputType[P]>
            : GetScalarType<T[P], AuditInspectionItemGroupByOutputType[P]>
        }
      >
    >


  export type AuditInspectionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    areaName?: boolean
    itemName?: boolean
    description?: boolean
    standardReference?: boolean
    isCompliant?: boolean
    comments?: boolean
    evidence?: boolean
    inspectedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    inspectedBy?: boolean | AuditInspectionItem$inspectedByArgs<ExtArgs>
  }, ExtArgs["result"]["auditInspectionItem"]>

  export type AuditInspectionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    areaName?: boolean
    itemName?: boolean
    description?: boolean
    standardReference?: boolean
    isCompliant?: boolean
    comments?: boolean
    evidence?: boolean
    inspectedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    inspectedBy?: boolean | AuditInspectionItem$inspectedByArgs<ExtArgs>
  }, ExtArgs["result"]["auditInspectionItem"]>

  export type AuditInspectionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    areaName?: boolean
    itemName?: boolean
    description?: boolean
    standardReference?: boolean
    isCompliant?: boolean
    comments?: boolean
    evidence?: boolean
    inspectedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    inspectedBy?: boolean | AuditInspectionItem$inspectedByArgs<ExtArgs>
  }, ExtArgs["result"]["auditInspectionItem"]>

  export type AuditInspectionItemSelectScalar = {
    id?: boolean
    auditId?: boolean
    areaName?: boolean
    itemName?: boolean
    description?: boolean
    standardReference?: boolean
    isCompliant?: boolean
    comments?: boolean
    evidence?: boolean
    inspectedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditInspectionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auditId" | "areaName" | "itemName" | "description" | "standardReference" | "isCompliant" | "comments" | "evidence" | "inspectedById" | "createdAt" | "updatedAt", ExtArgs["result"]["auditInspectionItem"]>
  export type AuditInspectionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    inspectedBy?: boolean | AuditInspectionItem$inspectedByArgs<ExtArgs>
  }
  export type AuditInspectionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    inspectedBy?: boolean | AuditInspectionItem$inspectedByArgs<ExtArgs>
  }
  export type AuditInspectionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    inspectedBy?: boolean | AuditInspectionItem$inspectedByArgs<ExtArgs>
  }

  export type $AuditInspectionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditInspectionItem"
    objects: {
      audit: Prisma.$AuditPayload<ExtArgs>
      inspectedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auditId: string
      areaName: string
      itemName: string
      description: string | null
      standardReference: string | null
      isCompliant: boolean | null
      comments: string | null
      evidence: string | null
      inspectedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auditInspectionItem"]>
    composites: {}
  }

  type AuditInspectionItemGetPayload<S extends boolean | null | undefined | AuditInspectionItemDefaultArgs> = $Result.GetResult<Prisma.$AuditInspectionItemPayload, S>

  type AuditInspectionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditInspectionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditInspectionItemCountAggregateInputType | true
    }

  export interface AuditInspectionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditInspectionItem'], meta: { name: 'AuditInspectionItem' } }
    /**
     * Find zero or one AuditInspectionItem that matches the filter.
     * @param {AuditInspectionItemFindUniqueArgs} args - Arguments to find a AuditInspectionItem
     * @example
     * // Get one AuditInspectionItem
     * const auditInspectionItem = await prisma.auditInspectionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditInspectionItemFindUniqueArgs>(args: SelectSubset<T, AuditInspectionItemFindUniqueArgs<ExtArgs>>): Prisma__AuditInspectionItemClient<$Result.GetResult<Prisma.$AuditInspectionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditInspectionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditInspectionItemFindUniqueOrThrowArgs} args - Arguments to find a AuditInspectionItem
     * @example
     * // Get one AuditInspectionItem
     * const auditInspectionItem = await prisma.auditInspectionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditInspectionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditInspectionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditInspectionItemClient<$Result.GetResult<Prisma.$AuditInspectionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditInspectionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditInspectionItemFindFirstArgs} args - Arguments to find a AuditInspectionItem
     * @example
     * // Get one AuditInspectionItem
     * const auditInspectionItem = await prisma.auditInspectionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditInspectionItemFindFirstArgs>(args?: SelectSubset<T, AuditInspectionItemFindFirstArgs<ExtArgs>>): Prisma__AuditInspectionItemClient<$Result.GetResult<Prisma.$AuditInspectionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditInspectionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditInspectionItemFindFirstOrThrowArgs} args - Arguments to find a AuditInspectionItem
     * @example
     * // Get one AuditInspectionItem
     * const auditInspectionItem = await prisma.auditInspectionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditInspectionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditInspectionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditInspectionItemClient<$Result.GetResult<Prisma.$AuditInspectionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditInspectionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditInspectionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditInspectionItems
     * const auditInspectionItems = await prisma.auditInspectionItem.findMany()
     * 
     * // Get first 10 AuditInspectionItems
     * const auditInspectionItems = await prisma.auditInspectionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditInspectionItemWithIdOnly = await prisma.auditInspectionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditInspectionItemFindManyArgs>(args?: SelectSubset<T, AuditInspectionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditInspectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditInspectionItem.
     * @param {AuditInspectionItemCreateArgs} args - Arguments to create a AuditInspectionItem.
     * @example
     * // Create one AuditInspectionItem
     * const AuditInspectionItem = await prisma.auditInspectionItem.create({
     *   data: {
     *     // ... data to create a AuditInspectionItem
     *   }
     * })
     * 
     */
    create<T extends AuditInspectionItemCreateArgs>(args: SelectSubset<T, AuditInspectionItemCreateArgs<ExtArgs>>): Prisma__AuditInspectionItemClient<$Result.GetResult<Prisma.$AuditInspectionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditInspectionItems.
     * @param {AuditInspectionItemCreateManyArgs} args - Arguments to create many AuditInspectionItems.
     * @example
     * // Create many AuditInspectionItems
     * const auditInspectionItem = await prisma.auditInspectionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditInspectionItemCreateManyArgs>(args?: SelectSubset<T, AuditInspectionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditInspectionItems and returns the data saved in the database.
     * @param {AuditInspectionItemCreateManyAndReturnArgs} args - Arguments to create many AuditInspectionItems.
     * @example
     * // Create many AuditInspectionItems
     * const auditInspectionItem = await prisma.auditInspectionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditInspectionItems and only return the `id`
     * const auditInspectionItemWithIdOnly = await prisma.auditInspectionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditInspectionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditInspectionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditInspectionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditInspectionItem.
     * @param {AuditInspectionItemDeleteArgs} args - Arguments to delete one AuditInspectionItem.
     * @example
     * // Delete one AuditInspectionItem
     * const AuditInspectionItem = await prisma.auditInspectionItem.delete({
     *   where: {
     *     // ... filter to delete one AuditInspectionItem
     *   }
     * })
     * 
     */
    delete<T extends AuditInspectionItemDeleteArgs>(args: SelectSubset<T, AuditInspectionItemDeleteArgs<ExtArgs>>): Prisma__AuditInspectionItemClient<$Result.GetResult<Prisma.$AuditInspectionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditInspectionItem.
     * @param {AuditInspectionItemUpdateArgs} args - Arguments to update one AuditInspectionItem.
     * @example
     * // Update one AuditInspectionItem
     * const auditInspectionItem = await prisma.auditInspectionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditInspectionItemUpdateArgs>(args: SelectSubset<T, AuditInspectionItemUpdateArgs<ExtArgs>>): Prisma__AuditInspectionItemClient<$Result.GetResult<Prisma.$AuditInspectionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditInspectionItems.
     * @param {AuditInspectionItemDeleteManyArgs} args - Arguments to filter AuditInspectionItems to delete.
     * @example
     * // Delete a few AuditInspectionItems
     * const { count } = await prisma.auditInspectionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditInspectionItemDeleteManyArgs>(args?: SelectSubset<T, AuditInspectionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditInspectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditInspectionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditInspectionItems
     * const auditInspectionItem = await prisma.auditInspectionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditInspectionItemUpdateManyArgs>(args: SelectSubset<T, AuditInspectionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditInspectionItems and returns the data updated in the database.
     * @param {AuditInspectionItemUpdateManyAndReturnArgs} args - Arguments to update many AuditInspectionItems.
     * @example
     * // Update many AuditInspectionItems
     * const auditInspectionItem = await prisma.auditInspectionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditInspectionItems and only return the `id`
     * const auditInspectionItemWithIdOnly = await prisma.auditInspectionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditInspectionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditInspectionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditInspectionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditInspectionItem.
     * @param {AuditInspectionItemUpsertArgs} args - Arguments to update or create a AuditInspectionItem.
     * @example
     * // Update or create a AuditInspectionItem
     * const auditInspectionItem = await prisma.auditInspectionItem.upsert({
     *   create: {
     *     // ... data to create a AuditInspectionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditInspectionItem we want to update
     *   }
     * })
     */
    upsert<T extends AuditInspectionItemUpsertArgs>(args: SelectSubset<T, AuditInspectionItemUpsertArgs<ExtArgs>>): Prisma__AuditInspectionItemClient<$Result.GetResult<Prisma.$AuditInspectionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditInspectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditInspectionItemCountArgs} args - Arguments to filter AuditInspectionItems to count.
     * @example
     * // Count the number of AuditInspectionItems
     * const count = await prisma.auditInspectionItem.count({
     *   where: {
     *     // ... the filter for the AuditInspectionItems we want to count
     *   }
     * })
    **/
    count<T extends AuditInspectionItemCountArgs>(
      args?: Subset<T, AuditInspectionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditInspectionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditInspectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditInspectionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditInspectionItemAggregateArgs>(args: Subset<T, AuditInspectionItemAggregateArgs>): Prisma.PrismaPromise<GetAuditInspectionItemAggregateType<T>>

    /**
     * Group by AuditInspectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditInspectionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditInspectionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditInspectionItemGroupByArgs['orderBy'] }
        : { orderBy?: AuditInspectionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditInspectionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditInspectionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditInspectionItem model
   */
  readonly fields: AuditInspectionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditInspectionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditInspectionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audit<T extends AuditDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditDefaultArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inspectedBy<T extends AuditInspectionItem$inspectedByArgs<ExtArgs> = {}>(args?: Subset<T, AuditInspectionItem$inspectedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditInspectionItem model
   */
  interface AuditInspectionItemFieldRefs {
    readonly id: FieldRef<"AuditInspectionItem", 'String'>
    readonly auditId: FieldRef<"AuditInspectionItem", 'String'>
    readonly areaName: FieldRef<"AuditInspectionItem", 'String'>
    readonly itemName: FieldRef<"AuditInspectionItem", 'String'>
    readonly description: FieldRef<"AuditInspectionItem", 'String'>
    readonly standardReference: FieldRef<"AuditInspectionItem", 'String'>
    readonly isCompliant: FieldRef<"AuditInspectionItem", 'Boolean'>
    readonly comments: FieldRef<"AuditInspectionItem", 'String'>
    readonly evidence: FieldRef<"AuditInspectionItem", 'String'>
    readonly inspectedById: FieldRef<"AuditInspectionItem", 'String'>
    readonly createdAt: FieldRef<"AuditInspectionItem", 'DateTime'>
    readonly updatedAt: FieldRef<"AuditInspectionItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditInspectionItem findUnique
   */
  export type AuditInspectionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditInspectionItem to fetch.
     */
    where: AuditInspectionItemWhereUniqueInput
  }

  /**
   * AuditInspectionItem findUniqueOrThrow
   */
  export type AuditInspectionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditInspectionItem to fetch.
     */
    where: AuditInspectionItemWhereUniqueInput
  }

  /**
   * AuditInspectionItem findFirst
   */
  export type AuditInspectionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditInspectionItem to fetch.
     */
    where?: AuditInspectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditInspectionItems to fetch.
     */
    orderBy?: AuditInspectionItemOrderByWithRelationInput | AuditInspectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditInspectionItems.
     */
    cursor?: AuditInspectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditInspectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditInspectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditInspectionItems.
     */
    distinct?: AuditInspectionItemScalarFieldEnum | AuditInspectionItemScalarFieldEnum[]
  }

  /**
   * AuditInspectionItem findFirstOrThrow
   */
  export type AuditInspectionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditInspectionItem to fetch.
     */
    where?: AuditInspectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditInspectionItems to fetch.
     */
    orderBy?: AuditInspectionItemOrderByWithRelationInput | AuditInspectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditInspectionItems.
     */
    cursor?: AuditInspectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditInspectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditInspectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditInspectionItems.
     */
    distinct?: AuditInspectionItemScalarFieldEnum | AuditInspectionItemScalarFieldEnum[]
  }

  /**
   * AuditInspectionItem findMany
   */
  export type AuditInspectionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditInspectionItems to fetch.
     */
    where?: AuditInspectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditInspectionItems to fetch.
     */
    orderBy?: AuditInspectionItemOrderByWithRelationInput | AuditInspectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditInspectionItems.
     */
    cursor?: AuditInspectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditInspectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditInspectionItems.
     */
    skip?: number
    distinct?: AuditInspectionItemScalarFieldEnum | AuditInspectionItemScalarFieldEnum[]
  }

  /**
   * AuditInspectionItem create
   */
  export type AuditInspectionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditInspectionItem.
     */
    data: XOR<AuditInspectionItemCreateInput, AuditInspectionItemUncheckedCreateInput>
  }

  /**
   * AuditInspectionItem createMany
   */
  export type AuditInspectionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditInspectionItems.
     */
    data: AuditInspectionItemCreateManyInput | AuditInspectionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditInspectionItem createManyAndReturn
   */
  export type AuditInspectionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * The data used to create many AuditInspectionItems.
     */
    data: AuditInspectionItemCreateManyInput | AuditInspectionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditInspectionItem update
   */
  export type AuditInspectionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditInspectionItem.
     */
    data: XOR<AuditInspectionItemUpdateInput, AuditInspectionItemUncheckedUpdateInput>
    /**
     * Choose, which AuditInspectionItem to update.
     */
    where: AuditInspectionItemWhereUniqueInput
  }

  /**
   * AuditInspectionItem updateMany
   */
  export type AuditInspectionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditInspectionItems.
     */
    data: XOR<AuditInspectionItemUpdateManyMutationInput, AuditInspectionItemUncheckedUpdateManyInput>
    /**
     * Filter which AuditInspectionItems to update
     */
    where?: AuditInspectionItemWhereInput
    /**
     * Limit how many AuditInspectionItems to update.
     */
    limit?: number
  }

  /**
   * AuditInspectionItem updateManyAndReturn
   */
  export type AuditInspectionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * The data used to update AuditInspectionItems.
     */
    data: XOR<AuditInspectionItemUpdateManyMutationInput, AuditInspectionItemUncheckedUpdateManyInput>
    /**
     * Filter which AuditInspectionItems to update
     */
    where?: AuditInspectionItemWhereInput
    /**
     * Limit how many AuditInspectionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditInspectionItem upsert
   */
  export type AuditInspectionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditInspectionItem to update in case it exists.
     */
    where: AuditInspectionItemWhereUniqueInput
    /**
     * In case the AuditInspectionItem found by the `where` argument doesn't exist, create a new AuditInspectionItem with this data.
     */
    create: XOR<AuditInspectionItemCreateInput, AuditInspectionItemUncheckedCreateInput>
    /**
     * In case the AuditInspectionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditInspectionItemUpdateInput, AuditInspectionItemUncheckedUpdateInput>
  }

  /**
   * AuditInspectionItem delete
   */
  export type AuditInspectionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemInclude<ExtArgs> | null
    /**
     * Filter which AuditInspectionItem to delete.
     */
    where: AuditInspectionItemWhereUniqueInput
  }

  /**
   * AuditInspectionItem deleteMany
   */
  export type AuditInspectionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditInspectionItems to delete
     */
    where?: AuditInspectionItemWhereInput
    /**
     * Limit how many AuditInspectionItems to delete.
     */
    limit?: number
  }

  /**
   * AuditInspectionItem.inspectedBy
   */
  export type AuditInspectionItem$inspectedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditInspectionItem without action
   */
  export type AuditInspectionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditInspectionItem
     */
    select?: AuditInspectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditInspectionItem
     */
    omit?: AuditInspectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInspectionItemInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audits?: boolean | Department$auditsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audits?: boolean | Department$auditsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      audits: Prisma.$AuditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audits<T extends Department$auditsArgs<ExtArgs> = {}>(args?: Subset<T, Department$auditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.audits
   */
  export type Department$auditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    cursor?: AuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Finding
   */

  export type AggregateFinding = {
    _count: FindingCountAggregateOutputType | null
    _min: FindingMinAggregateOutputType | null
    _max: FindingMaxAggregateOutputType | null
  }

  export type FindingMinAggregateOutputType = {
    id: string | null
    auditId: string | null
    title: string | null
    description: string | null
    findingType: $Enums.FindingType | null
    status: $Enums.FindingStatus | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    assignedToId: string | null
    evidence: string | null
    createdAt: Date | null
    updatedAt: Date | null
    closedAt: Date | null
  }

  export type FindingMaxAggregateOutputType = {
    id: string | null
    auditId: string | null
    title: string | null
    description: string | null
    findingType: $Enums.FindingType | null
    status: $Enums.FindingStatus | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    assignedToId: string | null
    evidence: string | null
    createdAt: Date | null
    updatedAt: Date | null
    closedAt: Date | null
  }

  export type FindingCountAggregateOutputType = {
    id: number
    auditId: number
    title: number
    description: number
    findingType: number
    status: number
    priority: number
    dueDate: number
    assignedToId: number
    evidence: number
    createdAt: number
    updatedAt: number
    closedAt: number
    _all: number
  }


  export type FindingMinAggregateInputType = {
    id?: true
    auditId?: true
    title?: true
    description?: true
    findingType?: true
    status?: true
    priority?: true
    dueDate?: true
    assignedToId?: true
    evidence?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
  }

  export type FindingMaxAggregateInputType = {
    id?: true
    auditId?: true
    title?: true
    description?: true
    findingType?: true
    status?: true
    priority?: true
    dueDate?: true
    assignedToId?: true
    evidence?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
  }

  export type FindingCountAggregateInputType = {
    id?: true
    auditId?: true
    title?: true
    description?: true
    findingType?: true
    status?: true
    priority?: true
    dueDate?: true
    assignedToId?: true
    evidence?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
    _all?: true
  }

  export type FindingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Finding to aggregate.
     */
    where?: FindingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Findings to fetch.
     */
    orderBy?: FindingOrderByWithRelationInput | FindingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FindingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Findings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Findings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Findings
    **/
    _count?: true | FindingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FindingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FindingMaxAggregateInputType
  }

  export type GetFindingAggregateType<T extends FindingAggregateArgs> = {
        [P in keyof T & keyof AggregateFinding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinding[P]>
      : GetScalarType<T[P], AggregateFinding[P]>
  }




  export type FindingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FindingWhereInput
    orderBy?: FindingOrderByWithAggregationInput | FindingOrderByWithAggregationInput[]
    by: FindingScalarFieldEnum[] | FindingScalarFieldEnum
    having?: FindingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FindingCountAggregateInputType | true
    _min?: FindingMinAggregateInputType
    _max?: FindingMaxAggregateInputType
  }

  export type FindingGroupByOutputType = {
    id: string
    auditId: string
    title: string
    description: string
    findingType: $Enums.FindingType
    status: $Enums.FindingStatus
    priority: $Enums.Priority | null
    dueDate: Date | null
    assignedToId: string | null
    evidence: string | null
    createdAt: Date
    updatedAt: Date
    closedAt: Date | null
    _count: FindingCountAggregateOutputType | null
    _min: FindingMinAggregateOutputType | null
    _max: FindingMaxAggregateOutputType | null
  }

  type GetFindingGroupByPayload<T extends FindingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FindingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FindingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FindingGroupByOutputType[P]>
            : GetScalarType<T[P], FindingGroupByOutputType[P]>
        }
      >
    >


  export type FindingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    title?: boolean
    description?: boolean
    findingType?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    assignedToId?: boolean
    evidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    assignedTo?: boolean | Finding$assignedToArgs<ExtArgs>
    actions?: boolean | Finding$actionsArgs<ExtArgs>
    _count?: boolean | FindingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finding"]>

  export type FindingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    title?: boolean
    description?: boolean
    findingType?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    assignedToId?: boolean
    evidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    assignedTo?: boolean | Finding$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["finding"]>

  export type FindingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    title?: boolean
    description?: boolean
    findingType?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    assignedToId?: boolean
    evidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    assignedTo?: boolean | Finding$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["finding"]>

  export type FindingSelectScalar = {
    id?: boolean
    auditId?: boolean
    title?: boolean
    description?: boolean
    findingType?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    assignedToId?: boolean
    evidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
  }

  export type FindingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auditId" | "title" | "description" | "findingType" | "status" | "priority" | "dueDate" | "assignedToId" | "evidence" | "createdAt" | "updatedAt" | "closedAt", ExtArgs["result"]["finding"]>
  export type FindingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    assignedTo?: boolean | Finding$assignedToArgs<ExtArgs>
    actions?: boolean | Finding$actionsArgs<ExtArgs>
    _count?: boolean | FindingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FindingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    assignedTo?: boolean | Finding$assignedToArgs<ExtArgs>
  }
  export type FindingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    assignedTo?: boolean | Finding$assignedToArgs<ExtArgs>
  }

  export type $FindingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Finding"
    objects: {
      audit: Prisma.$AuditPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      actions: Prisma.$CorrectiveActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auditId: string
      title: string
      description: string
      findingType: $Enums.FindingType
      status: $Enums.FindingStatus
      priority: $Enums.Priority | null
      dueDate: Date | null
      assignedToId: string | null
      evidence: string | null
      createdAt: Date
      updatedAt: Date
      closedAt: Date | null
    }, ExtArgs["result"]["finding"]>
    composites: {}
  }

  type FindingGetPayload<S extends boolean | null | undefined | FindingDefaultArgs> = $Result.GetResult<Prisma.$FindingPayload, S>

  type FindingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FindingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FindingCountAggregateInputType | true
    }

  export interface FindingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Finding'], meta: { name: 'Finding' } }
    /**
     * Find zero or one Finding that matches the filter.
     * @param {FindingFindUniqueArgs} args - Arguments to find a Finding
     * @example
     * // Get one Finding
     * const finding = await prisma.finding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FindingFindUniqueArgs>(args: SelectSubset<T, FindingFindUniqueArgs<ExtArgs>>): Prisma__FindingClient<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Finding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FindingFindUniqueOrThrowArgs} args - Arguments to find a Finding
     * @example
     * // Get one Finding
     * const finding = await prisma.finding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FindingFindUniqueOrThrowArgs>(args: SelectSubset<T, FindingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FindingClient<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Finding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingFindFirstArgs} args - Arguments to find a Finding
     * @example
     * // Get one Finding
     * const finding = await prisma.finding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FindingFindFirstArgs>(args?: SelectSubset<T, FindingFindFirstArgs<ExtArgs>>): Prisma__FindingClient<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Finding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingFindFirstOrThrowArgs} args - Arguments to find a Finding
     * @example
     * // Get one Finding
     * const finding = await prisma.finding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FindingFindFirstOrThrowArgs>(args?: SelectSubset<T, FindingFindFirstOrThrowArgs<ExtArgs>>): Prisma__FindingClient<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Findings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Findings
     * const findings = await prisma.finding.findMany()
     * 
     * // Get first 10 Findings
     * const findings = await prisma.finding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const findingWithIdOnly = await prisma.finding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FindingFindManyArgs>(args?: SelectSubset<T, FindingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Finding.
     * @param {FindingCreateArgs} args - Arguments to create a Finding.
     * @example
     * // Create one Finding
     * const Finding = await prisma.finding.create({
     *   data: {
     *     // ... data to create a Finding
     *   }
     * })
     * 
     */
    create<T extends FindingCreateArgs>(args: SelectSubset<T, FindingCreateArgs<ExtArgs>>): Prisma__FindingClient<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Findings.
     * @param {FindingCreateManyArgs} args - Arguments to create many Findings.
     * @example
     * // Create many Findings
     * const finding = await prisma.finding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FindingCreateManyArgs>(args?: SelectSubset<T, FindingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Findings and returns the data saved in the database.
     * @param {FindingCreateManyAndReturnArgs} args - Arguments to create many Findings.
     * @example
     * // Create many Findings
     * const finding = await prisma.finding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Findings and only return the `id`
     * const findingWithIdOnly = await prisma.finding.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FindingCreateManyAndReturnArgs>(args?: SelectSubset<T, FindingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Finding.
     * @param {FindingDeleteArgs} args - Arguments to delete one Finding.
     * @example
     * // Delete one Finding
     * const Finding = await prisma.finding.delete({
     *   where: {
     *     // ... filter to delete one Finding
     *   }
     * })
     * 
     */
    delete<T extends FindingDeleteArgs>(args: SelectSubset<T, FindingDeleteArgs<ExtArgs>>): Prisma__FindingClient<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Finding.
     * @param {FindingUpdateArgs} args - Arguments to update one Finding.
     * @example
     * // Update one Finding
     * const finding = await prisma.finding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FindingUpdateArgs>(args: SelectSubset<T, FindingUpdateArgs<ExtArgs>>): Prisma__FindingClient<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Findings.
     * @param {FindingDeleteManyArgs} args - Arguments to filter Findings to delete.
     * @example
     * // Delete a few Findings
     * const { count } = await prisma.finding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FindingDeleteManyArgs>(args?: SelectSubset<T, FindingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Findings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Findings
     * const finding = await prisma.finding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FindingUpdateManyArgs>(args: SelectSubset<T, FindingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Findings and returns the data updated in the database.
     * @param {FindingUpdateManyAndReturnArgs} args - Arguments to update many Findings.
     * @example
     * // Update many Findings
     * const finding = await prisma.finding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Findings and only return the `id`
     * const findingWithIdOnly = await prisma.finding.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FindingUpdateManyAndReturnArgs>(args: SelectSubset<T, FindingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Finding.
     * @param {FindingUpsertArgs} args - Arguments to update or create a Finding.
     * @example
     * // Update or create a Finding
     * const finding = await prisma.finding.upsert({
     *   create: {
     *     // ... data to create a Finding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Finding we want to update
     *   }
     * })
     */
    upsert<T extends FindingUpsertArgs>(args: SelectSubset<T, FindingUpsertArgs<ExtArgs>>): Prisma__FindingClient<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Findings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingCountArgs} args - Arguments to filter Findings to count.
     * @example
     * // Count the number of Findings
     * const count = await prisma.finding.count({
     *   where: {
     *     // ... the filter for the Findings we want to count
     *   }
     * })
    **/
    count<T extends FindingCountArgs>(
      args?: Subset<T, FindingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FindingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Finding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FindingAggregateArgs>(args: Subset<T, FindingAggregateArgs>): Prisma.PrismaPromise<GetFindingAggregateType<T>>

    /**
     * Group by Finding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FindingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FindingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FindingGroupByArgs['orderBy'] }
        : { orderBy?: FindingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FindingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFindingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Finding model
   */
  readonly fields: FindingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Finding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FindingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audit<T extends AuditDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditDefaultArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends Finding$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Finding$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    actions<T extends Finding$actionsArgs<ExtArgs> = {}>(args?: Subset<T, Finding$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Finding model
   */
  interface FindingFieldRefs {
    readonly id: FieldRef<"Finding", 'String'>
    readonly auditId: FieldRef<"Finding", 'String'>
    readonly title: FieldRef<"Finding", 'String'>
    readonly description: FieldRef<"Finding", 'String'>
    readonly findingType: FieldRef<"Finding", 'FindingType'>
    readonly status: FieldRef<"Finding", 'FindingStatus'>
    readonly priority: FieldRef<"Finding", 'Priority'>
    readonly dueDate: FieldRef<"Finding", 'DateTime'>
    readonly assignedToId: FieldRef<"Finding", 'String'>
    readonly evidence: FieldRef<"Finding", 'String'>
    readonly createdAt: FieldRef<"Finding", 'DateTime'>
    readonly updatedAt: FieldRef<"Finding", 'DateTime'>
    readonly closedAt: FieldRef<"Finding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Finding findUnique
   */
  export type FindingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null
    /**
     * Filter, which Finding to fetch.
     */
    where: FindingWhereUniqueInput
  }

  /**
   * Finding findUniqueOrThrow
   */
  export type FindingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null
    /**
     * Filter, which Finding to fetch.
     */
    where: FindingWhereUniqueInput
  }

  /**
   * Finding findFirst
   */
  export type FindingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null
    /**
     * Filter, which Finding to fetch.
     */
    where?: FindingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Findings to fetch.
     */
    orderBy?: FindingOrderByWithRelationInput | FindingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Findings.
     */
    cursor?: FindingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Findings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Findings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Findings.
     */
    distinct?: FindingScalarFieldEnum | FindingScalarFieldEnum[]
  }

  /**
   * Finding findFirstOrThrow
   */
  export type FindingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null
    /**
     * Filter, which Finding to fetch.
     */
    where?: FindingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Findings to fetch.
     */
    orderBy?: FindingOrderByWithRelationInput | FindingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Findings.
     */
    cursor?: FindingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Findings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Findings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Findings.
     */
    distinct?: FindingScalarFieldEnum | FindingScalarFieldEnum[]
  }

  /**
   * Finding findMany
   */
  export type FindingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null
    /**
     * Filter, which Findings to fetch.
     */
    where?: FindingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Findings to fetch.
     */
    orderBy?: FindingOrderByWithRelationInput | FindingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Findings.
     */
    cursor?: FindingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Findings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Findings.
     */
    skip?: number
    distinct?: FindingScalarFieldEnum | FindingScalarFieldEnum[]
  }

  /**
   * Finding create
   */
  export type FindingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null
    /**
     * The data needed to create a Finding.
     */
    data: XOR<FindingCreateInput, FindingUncheckedCreateInput>
  }

  /**
   * Finding createMany
   */
  export type FindingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Findings.
     */
    data: FindingCreateManyInput | FindingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Finding createManyAndReturn
   */
  export type FindingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * The data used to create many Findings.
     */
    data: FindingCreateManyInput | FindingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Finding update
   */
  export type FindingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null
    /**
     * The data needed to update a Finding.
     */
    data: XOR<FindingUpdateInput, FindingUncheckedUpdateInput>
    /**
     * Choose, which Finding to update.
     */
    where: FindingWhereUniqueInput
  }

  /**
   * Finding updateMany
   */
  export type FindingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Findings.
     */
    data: XOR<FindingUpdateManyMutationInput, FindingUncheckedUpdateManyInput>
    /**
     * Filter which Findings to update
     */
    where?: FindingWhereInput
    /**
     * Limit how many Findings to update.
     */
    limit?: number
  }

  /**
   * Finding updateManyAndReturn
   */
  export type FindingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * The data used to update Findings.
     */
    data: XOR<FindingUpdateManyMutationInput, FindingUncheckedUpdateManyInput>
    /**
     * Filter which Findings to update
     */
    where?: FindingWhereInput
    /**
     * Limit how many Findings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Finding upsert
   */
  export type FindingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null
    /**
     * The filter to search for the Finding to update in case it exists.
     */
    where: FindingWhereUniqueInput
    /**
     * In case the Finding found by the `where` argument doesn't exist, create a new Finding with this data.
     */
    create: XOR<FindingCreateInput, FindingUncheckedCreateInput>
    /**
     * In case the Finding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FindingUpdateInput, FindingUncheckedUpdateInput>
  }

  /**
   * Finding delete
   */
  export type FindingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null
    /**
     * Filter which Finding to delete.
     */
    where: FindingWhereUniqueInput
  }

  /**
   * Finding deleteMany
   */
  export type FindingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Findings to delete
     */
    where?: FindingWhereInput
    /**
     * Limit how many Findings to delete.
     */
    limit?: number
  }

  /**
   * Finding.assignedTo
   */
  export type Finding$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Finding.actions
   */
  export type Finding$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
    where?: CorrectiveActionWhereInput
    orderBy?: CorrectiveActionOrderByWithRelationInput | CorrectiveActionOrderByWithRelationInput[]
    cursor?: CorrectiveActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CorrectiveActionScalarFieldEnum | CorrectiveActionScalarFieldEnum[]
  }

  /**
   * Finding without action
   */
  export type FindingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null
  }


  /**
   * Model CorrectiveAction
   */

  export type AggregateCorrectiveAction = {
    _count: CorrectiveActionCountAggregateOutputType | null
    _min: CorrectiveActionMinAggregateOutputType | null
    _max: CorrectiveActionMaxAggregateOutputType | null
  }

  export type CorrectiveActionMinAggregateOutputType = {
    id: string | null
    auditId: string | null
    findingId: string | null
    title: string | null
    description: string | null
    actionType: string | null
    assignedToId: string | null
    dueDate: Date | null
    status: string | null
    completedAt: Date | null
    verifiedAt: Date | null
    verifiedById: string | null
    evidence: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorrectiveActionMaxAggregateOutputType = {
    id: string | null
    auditId: string | null
    findingId: string | null
    title: string | null
    description: string | null
    actionType: string | null
    assignedToId: string | null
    dueDate: Date | null
    status: string | null
    completedAt: Date | null
    verifiedAt: Date | null
    verifiedById: string | null
    evidence: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorrectiveActionCountAggregateOutputType = {
    id: number
    auditId: number
    findingId: number
    title: number
    description: number
    actionType: number
    assignedToId: number
    dueDate: number
    status: number
    completedAt: number
    verifiedAt: number
    verifiedById: number
    evidence: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CorrectiveActionMinAggregateInputType = {
    id?: true
    auditId?: true
    findingId?: true
    title?: true
    description?: true
    actionType?: true
    assignedToId?: true
    dueDate?: true
    status?: true
    completedAt?: true
    verifiedAt?: true
    verifiedById?: true
    evidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorrectiveActionMaxAggregateInputType = {
    id?: true
    auditId?: true
    findingId?: true
    title?: true
    description?: true
    actionType?: true
    assignedToId?: true
    dueDate?: true
    status?: true
    completedAt?: true
    verifiedAt?: true
    verifiedById?: true
    evidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorrectiveActionCountAggregateInputType = {
    id?: true
    auditId?: true
    findingId?: true
    title?: true
    description?: true
    actionType?: true
    assignedToId?: true
    dueDate?: true
    status?: true
    completedAt?: true
    verifiedAt?: true
    verifiedById?: true
    evidence?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CorrectiveActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorrectiveAction to aggregate.
     */
    where?: CorrectiveActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorrectiveActions to fetch.
     */
    orderBy?: CorrectiveActionOrderByWithRelationInput | CorrectiveActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CorrectiveActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorrectiveActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorrectiveActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CorrectiveActions
    **/
    _count?: true | CorrectiveActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorrectiveActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorrectiveActionMaxAggregateInputType
  }

  export type GetCorrectiveActionAggregateType<T extends CorrectiveActionAggregateArgs> = {
        [P in keyof T & keyof AggregateCorrectiveAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorrectiveAction[P]>
      : GetScalarType<T[P], AggregateCorrectiveAction[P]>
  }




  export type CorrectiveActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorrectiveActionWhereInput
    orderBy?: CorrectiveActionOrderByWithAggregationInput | CorrectiveActionOrderByWithAggregationInput[]
    by: CorrectiveActionScalarFieldEnum[] | CorrectiveActionScalarFieldEnum
    having?: CorrectiveActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorrectiveActionCountAggregateInputType | true
    _min?: CorrectiveActionMinAggregateInputType
    _max?: CorrectiveActionMaxAggregateInputType
  }

  export type CorrectiveActionGroupByOutputType = {
    id: string
    auditId: string
    findingId: string | null
    title: string
    description: string
    actionType: string
    assignedToId: string
    dueDate: Date
    status: string
    completedAt: Date | null
    verifiedAt: Date | null
    verifiedById: string | null
    evidence: string | null
    createdAt: Date
    updatedAt: Date
    _count: CorrectiveActionCountAggregateOutputType | null
    _min: CorrectiveActionMinAggregateOutputType | null
    _max: CorrectiveActionMaxAggregateOutputType | null
  }

  type GetCorrectiveActionGroupByPayload<T extends CorrectiveActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CorrectiveActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorrectiveActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorrectiveActionGroupByOutputType[P]>
            : GetScalarType<T[P], CorrectiveActionGroupByOutputType[P]>
        }
      >
    >


  export type CorrectiveActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    findingId?: boolean
    title?: boolean
    description?: boolean
    actionType?: boolean
    assignedToId?: boolean
    dueDate?: boolean
    status?: boolean
    completedAt?: boolean
    verifiedAt?: boolean
    verifiedById?: boolean
    evidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    finding?: boolean | CorrectiveAction$findingArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    verifiedBy?: boolean | CorrectiveAction$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["correctiveAction"]>

  export type CorrectiveActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    findingId?: boolean
    title?: boolean
    description?: boolean
    actionType?: boolean
    assignedToId?: boolean
    dueDate?: boolean
    status?: boolean
    completedAt?: boolean
    verifiedAt?: boolean
    verifiedById?: boolean
    evidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    finding?: boolean | CorrectiveAction$findingArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    verifiedBy?: boolean | CorrectiveAction$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["correctiveAction"]>

  export type CorrectiveActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    findingId?: boolean
    title?: boolean
    description?: boolean
    actionType?: boolean
    assignedToId?: boolean
    dueDate?: boolean
    status?: boolean
    completedAt?: boolean
    verifiedAt?: boolean
    verifiedById?: boolean
    evidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    finding?: boolean | CorrectiveAction$findingArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    verifiedBy?: boolean | CorrectiveAction$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["correctiveAction"]>

  export type CorrectiveActionSelectScalar = {
    id?: boolean
    auditId?: boolean
    findingId?: boolean
    title?: boolean
    description?: boolean
    actionType?: boolean
    assignedToId?: boolean
    dueDate?: boolean
    status?: boolean
    completedAt?: boolean
    verifiedAt?: boolean
    verifiedById?: boolean
    evidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CorrectiveActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auditId" | "findingId" | "title" | "description" | "actionType" | "assignedToId" | "dueDate" | "status" | "completedAt" | "verifiedAt" | "verifiedById" | "evidence" | "createdAt" | "updatedAt", ExtArgs["result"]["correctiveAction"]>
  export type CorrectiveActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    finding?: boolean | CorrectiveAction$findingArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    verifiedBy?: boolean | CorrectiveAction$verifiedByArgs<ExtArgs>
  }
  export type CorrectiveActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    finding?: boolean | CorrectiveAction$findingArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    verifiedBy?: boolean | CorrectiveAction$verifiedByArgs<ExtArgs>
  }
  export type CorrectiveActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    finding?: boolean | CorrectiveAction$findingArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    verifiedBy?: boolean | CorrectiveAction$verifiedByArgs<ExtArgs>
  }

  export type $CorrectiveActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CorrectiveAction"
    objects: {
      audit: Prisma.$AuditPayload<ExtArgs>
      finding: Prisma.$FindingPayload<ExtArgs> | null
      assignedTo: Prisma.$UserPayload<ExtArgs>
      verifiedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auditId: string
      findingId: string | null
      title: string
      description: string
      actionType: string
      assignedToId: string
      dueDate: Date
      status: string
      completedAt: Date | null
      verifiedAt: Date | null
      verifiedById: string | null
      evidence: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["correctiveAction"]>
    composites: {}
  }

  type CorrectiveActionGetPayload<S extends boolean | null | undefined | CorrectiveActionDefaultArgs> = $Result.GetResult<Prisma.$CorrectiveActionPayload, S>

  type CorrectiveActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CorrectiveActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CorrectiveActionCountAggregateInputType | true
    }

  export interface CorrectiveActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CorrectiveAction'], meta: { name: 'CorrectiveAction' } }
    /**
     * Find zero or one CorrectiveAction that matches the filter.
     * @param {CorrectiveActionFindUniqueArgs} args - Arguments to find a CorrectiveAction
     * @example
     * // Get one CorrectiveAction
     * const correctiveAction = await prisma.correctiveAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CorrectiveActionFindUniqueArgs>(args: SelectSubset<T, CorrectiveActionFindUniqueArgs<ExtArgs>>): Prisma__CorrectiveActionClient<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CorrectiveAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CorrectiveActionFindUniqueOrThrowArgs} args - Arguments to find a CorrectiveAction
     * @example
     * // Get one CorrectiveAction
     * const correctiveAction = await prisma.correctiveAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CorrectiveActionFindUniqueOrThrowArgs>(args: SelectSubset<T, CorrectiveActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CorrectiveActionClient<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CorrectiveAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrectiveActionFindFirstArgs} args - Arguments to find a CorrectiveAction
     * @example
     * // Get one CorrectiveAction
     * const correctiveAction = await prisma.correctiveAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CorrectiveActionFindFirstArgs>(args?: SelectSubset<T, CorrectiveActionFindFirstArgs<ExtArgs>>): Prisma__CorrectiveActionClient<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CorrectiveAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrectiveActionFindFirstOrThrowArgs} args - Arguments to find a CorrectiveAction
     * @example
     * // Get one CorrectiveAction
     * const correctiveAction = await prisma.correctiveAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CorrectiveActionFindFirstOrThrowArgs>(args?: SelectSubset<T, CorrectiveActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CorrectiveActionClient<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CorrectiveActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrectiveActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CorrectiveActions
     * const correctiveActions = await prisma.correctiveAction.findMany()
     * 
     * // Get first 10 CorrectiveActions
     * const correctiveActions = await prisma.correctiveAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const correctiveActionWithIdOnly = await prisma.correctiveAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CorrectiveActionFindManyArgs>(args?: SelectSubset<T, CorrectiveActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CorrectiveAction.
     * @param {CorrectiveActionCreateArgs} args - Arguments to create a CorrectiveAction.
     * @example
     * // Create one CorrectiveAction
     * const CorrectiveAction = await prisma.correctiveAction.create({
     *   data: {
     *     // ... data to create a CorrectiveAction
     *   }
     * })
     * 
     */
    create<T extends CorrectiveActionCreateArgs>(args: SelectSubset<T, CorrectiveActionCreateArgs<ExtArgs>>): Prisma__CorrectiveActionClient<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CorrectiveActions.
     * @param {CorrectiveActionCreateManyArgs} args - Arguments to create many CorrectiveActions.
     * @example
     * // Create many CorrectiveActions
     * const correctiveAction = await prisma.correctiveAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CorrectiveActionCreateManyArgs>(args?: SelectSubset<T, CorrectiveActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CorrectiveActions and returns the data saved in the database.
     * @param {CorrectiveActionCreateManyAndReturnArgs} args - Arguments to create many CorrectiveActions.
     * @example
     * // Create many CorrectiveActions
     * const correctiveAction = await prisma.correctiveAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CorrectiveActions and only return the `id`
     * const correctiveActionWithIdOnly = await prisma.correctiveAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CorrectiveActionCreateManyAndReturnArgs>(args?: SelectSubset<T, CorrectiveActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CorrectiveAction.
     * @param {CorrectiveActionDeleteArgs} args - Arguments to delete one CorrectiveAction.
     * @example
     * // Delete one CorrectiveAction
     * const CorrectiveAction = await prisma.correctiveAction.delete({
     *   where: {
     *     // ... filter to delete one CorrectiveAction
     *   }
     * })
     * 
     */
    delete<T extends CorrectiveActionDeleteArgs>(args: SelectSubset<T, CorrectiveActionDeleteArgs<ExtArgs>>): Prisma__CorrectiveActionClient<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CorrectiveAction.
     * @param {CorrectiveActionUpdateArgs} args - Arguments to update one CorrectiveAction.
     * @example
     * // Update one CorrectiveAction
     * const correctiveAction = await prisma.correctiveAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CorrectiveActionUpdateArgs>(args: SelectSubset<T, CorrectiveActionUpdateArgs<ExtArgs>>): Prisma__CorrectiveActionClient<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CorrectiveActions.
     * @param {CorrectiveActionDeleteManyArgs} args - Arguments to filter CorrectiveActions to delete.
     * @example
     * // Delete a few CorrectiveActions
     * const { count } = await prisma.correctiveAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CorrectiveActionDeleteManyArgs>(args?: SelectSubset<T, CorrectiveActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CorrectiveActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrectiveActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CorrectiveActions
     * const correctiveAction = await prisma.correctiveAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CorrectiveActionUpdateManyArgs>(args: SelectSubset<T, CorrectiveActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CorrectiveActions and returns the data updated in the database.
     * @param {CorrectiveActionUpdateManyAndReturnArgs} args - Arguments to update many CorrectiveActions.
     * @example
     * // Update many CorrectiveActions
     * const correctiveAction = await prisma.correctiveAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CorrectiveActions and only return the `id`
     * const correctiveActionWithIdOnly = await prisma.correctiveAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CorrectiveActionUpdateManyAndReturnArgs>(args: SelectSubset<T, CorrectiveActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CorrectiveAction.
     * @param {CorrectiveActionUpsertArgs} args - Arguments to update or create a CorrectiveAction.
     * @example
     * // Update or create a CorrectiveAction
     * const correctiveAction = await prisma.correctiveAction.upsert({
     *   create: {
     *     // ... data to create a CorrectiveAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CorrectiveAction we want to update
     *   }
     * })
     */
    upsert<T extends CorrectiveActionUpsertArgs>(args: SelectSubset<T, CorrectiveActionUpsertArgs<ExtArgs>>): Prisma__CorrectiveActionClient<$Result.GetResult<Prisma.$CorrectiveActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CorrectiveActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrectiveActionCountArgs} args - Arguments to filter CorrectiveActions to count.
     * @example
     * // Count the number of CorrectiveActions
     * const count = await prisma.correctiveAction.count({
     *   where: {
     *     // ... the filter for the CorrectiveActions we want to count
     *   }
     * })
    **/
    count<T extends CorrectiveActionCountArgs>(
      args?: Subset<T, CorrectiveActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorrectiveActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CorrectiveAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrectiveActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorrectiveActionAggregateArgs>(args: Subset<T, CorrectiveActionAggregateArgs>): Prisma.PrismaPromise<GetCorrectiveActionAggregateType<T>>

    /**
     * Group by CorrectiveAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrectiveActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CorrectiveActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CorrectiveActionGroupByArgs['orderBy'] }
        : { orderBy?: CorrectiveActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CorrectiveActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorrectiveActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CorrectiveAction model
   */
  readonly fields: CorrectiveActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CorrectiveAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CorrectiveActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audit<T extends AuditDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditDefaultArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    finding<T extends CorrectiveAction$findingArgs<ExtArgs> = {}>(args?: Subset<T, CorrectiveAction$findingArgs<ExtArgs>>): Prisma__FindingClient<$Result.GetResult<Prisma.$FindingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    verifiedBy<T extends CorrectiveAction$verifiedByArgs<ExtArgs> = {}>(args?: Subset<T, CorrectiveAction$verifiedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CorrectiveAction model
   */
  interface CorrectiveActionFieldRefs {
    readonly id: FieldRef<"CorrectiveAction", 'String'>
    readonly auditId: FieldRef<"CorrectiveAction", 'String'>
    readonly findingId: FieldRef<"CorrectiveAction", 'String'>
    readonly title: FieldRef<"CorrectiveAction", 'String'>
    readonly description: FieldRef<"CorrectiveAction", 'String'>
    readonly actionType: FieldRef<"CorrectiveAction", 'String'>
    readonly assignedToId: FieldRef<"CorrectiveAction", 'String'>
    readonly dueDate: FieldRef<"CorrectiveAction", 'DateTime'>
    readonly status: FieldRef<"CorrectiveAction", 'String'>
    readonly completedAt: FieldRef<"CorrectiveAction", 'DateTime'>
    readonly verifiedAt: FieldRef<"CorrectiveAction", 'DateTime'>
    readonly verifiedById: FieldRef<"CorrectiveAction", 'String'>
    readonly evidence: FieldRef<"CorrectiveAction", 'String'>
    readonly createdAt: FieldRef<"CorrectiveAction", 'DateTime'>
    readonly updatedAt: FieldRef<"CorrectiveAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CorrectiveAction findUnique
   */
  export type CorrectiveActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
    /**
     * Filter, which CorrectiveAction to fetch.
     */
    where: CorrectiveActionWhereUniqueInput
  }

  /**
   * CorrectiveAction findUniqueOrThrow
   */
  export type CorrectiveActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
    /**
     * Filter, which CorrectiveAction to fetch.
     */
    where: CorrectiveActionWhereUniqueInput
  }

  /**
   * CorrectiveAction findFirst
   */
  export type CorrectiveActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
    /**
     * Filter, which CorrectiveAction to fetch.
     */
    where?: CorrectiveActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorrectiveActions to fetch.
     */
    orderBy?: CorrectiveActionOrderByWithRelationInput | CorrectiveActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorrectiveActions.
     */
    cursor?: CorrectiveActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorrectiveActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorrectiveActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorrectiveActions.
     */
    distinct?: CorrectiveActionScalarFieldEnum | CorrectiveActionScalarFieldEnum[]
  }

  /**
   * CorrectiveAction findFirstOrThrow
   */
  export type CorrectiveActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
    /**
     * Filter, which CorrectiveAction to fetch.
     */
    where?: CorrectiveActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorrectiveActions to fetch.
     */
    orderBy?: CorrectiveActionOrderByWithRelationInput | CorrectiveActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorrectiveActions.
     */
    cursor?: CorrectiveActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorrectiveActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorrectiveActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorrectiveActions.
     */
    distinct?: CorrectiveActionScalarFieldEnum | CorrectiveActionScalarFieldEnum[]
  }

  /**
   * CorrectiveAction findMany
   */
  export type CorrectiveActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
    /**
     * Filter, which CorrectiveActions to fetch.
     */
    where?: CorrectiveActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorrectiveActions to fetch.
     */
    orderBy?: CorrectiveActionOrderByWithRelationInput | CorrectiveActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CorrectiveActions.
     */
    cursor?: CorrectiveActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorrectiveActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorrectiveActions.
     */
    skip?: number
    distinct?: CorrectiveActionScalarFieldEnum | CorrectiveActionScalarFieldEnum[]
  }

  /**
   * CorrectiveAction create
   */
  export type CorrectiveActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
    /**
     * The data needed to create a CorrectiveAction.
     */
    data: XOR<CorrectiveActionCreateInput, CorrectiveActionUncheckedCreateInput>
  }

  /**
   * CorrectiveAction createMany
   */
  export type CorrectiveActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CorrectiveActions.
     */
    data: CorrectiveActionCreateManyInput | CorrectiveActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CorrectiveAction createManyAndReturn
   */
  export type CorrectiveActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * The data used to create many CorrectiveActions.
     */
    data: CorrectiveActionCreateManyInput | CorrectiveActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CorrectiveAction update
   */
  export type CorrectiveActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
    /**
     * The data needed to update a CorrectiveAction.
     */
    data: XOR<CorrectiveActionUpdateInput, CorrectiveActionUncheckedUpdateInput>
    /**
     * Choose, which CorrectiveAction to update.
     */
    where: CorrectiveActionWhereUniqueInput
  }

  /**
   * CorrectiveAction updateMany
   */
  export type CorrectiveActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CorrectiveActions.
     */
    data: XOR<CorrectiveActionUpdateManyMutationInput, CorrectiveActionUncheckedUpdateManyInput>
    /**
     * Filter which CorrectiveActions to update
     */
    where?: CorrectiveActionWhereInput
    /**
     * Limit how many CorrectiveActions to update.
     */
    limit?: number
  }

  /**
   * CorrectiveAction updateManyAndReturn
   */
  export type CorrectiveActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * The data used to update CorrectiveActions.
     */
    data: XOR<CorrectiveActionUpdateManyMutationInput, CorrectiveActionUncheckedUpdateManyInput>
    /**
     * Filter which CorrectiveActions to update
     */
    where?: CorrectiveActionWhereInput
    /**
     * Limit how many CorrectiveActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CorrectiveAction upsert
   */
  export type CorrectiveActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
    /**
     * The filter to search for the CorrectiveAction to update in case it exists.
     */
    where: CorrectiveActionWhereUniqueInput
    /**
     * In case the CorrectiveAction found by the `where` argument doesn't exist, create a new CorrectiveAction with this data.
     */
    create: XOR<CorrectiveActionCreateInput, CorrectiveActionUncheckedCreateInput>
    /**
     * In case the CorrectiveAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CorrectiveActionUpdateInput, CorrectiveActionUncheckedUpdateInput>
  }

  /**
   * CorrectiveAction delete
   */
  export type CorrectiveActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
    /**
     * Filter which CorrectiveAction to delete.
     */
    where: CorrectiveActionWhereUniqueInput
  }

  /**
   * CorrectiveAction deleteMany
   */
  export type CorrectiveActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorrectiveActions to delete
     */
    where?: CorrectiveActionWhereInput
    /**
     * Limit how many CorrectiveActions to delete.
     */
    limit?: number
  }

  /**
   * CorrectiveAction.finding
   */
  export type CorrectiveAction$findingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Finding
     */
    select?: FindingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Finding
     */
    omit?: FindingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FindingInclude<ExtArgs> | null
    where?: FindingWhereInput
  }

  /**
   * CorrectiveAction.verifiedBy
   */
  export type CorrectiveAction$verifiedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CorrectiveAction without action
   */
  export type CorrectiveActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorrectiveAction
     */
    select?: CorrectiveActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CorrectiveAction
     */
    omit?: CorrectiveActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrectiveActionInclude<ExtArgs> | null
  }


  /**
   * Model AuditDocument
   */

  export type AggregateAuditDocument = {
    _count: AuditDocumentCountAggregateOutputType | null
    _min: AuditDocumentMinAggregateOutputType | null
    _max: AuditDocumentMaxAggregateOutputType | null
  }

  export type AuditDocumentMinAggregateOutputType = {
    id: string | null
    auditId: string | null
    title: string | null
    description: string | null
    documentType: $Enums.AuditDocumentType | null
    fileUrl: string | null
    filePath: string | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditDocumentMaxAggregateOutputType = {
    id: string | null
    auditId: string | null
    title: string | null
    description: string | null
    documentType: $Enums.AuditDocumentType | null
    fileUrl: string | null
    filePath: string | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditDocumentCountAggregateOutputType = {
    id: number
    auditId: number
    title: number
    description: number
    documentType: number
    fileUrl: number
    filePath: number
    uploadedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditDocumentMinAggregateInputType = {
    id?: true
    auditId?: true
    title?: true
    description?: true
    documentType?: true
    fileUrl?: true
    filePath?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditDocumentMaxAggregateInputType = {
    id?: true
    auditId?: true
    title?: true
    description?: true
    documentType?: true
    fileUrl?: true
    filePath?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditDocumentCountAggregateInputType = {
    id?: true
    auditId?: true
    title?: true
    description?: true
    documentType?: true
    fileUrl?: true
    filePath?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditDocument to aggregate.
     */
    where?: AuditDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditDocuments to fetch.
     */
    orderBy?: AuditDocumentOrderByWithRelationInput | AuditDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditDocuments
    **/
    _count?: true | AuditDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditDocumentMaxAggregateInputType
  }

  export type GetAuditDocumentAggregateType<T extends AuditDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditDocument[P]>
      : GetScalarType<T[P], AggregateAuditDocument[P]>
  }




  export type AuditDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditDocumentWhereInput
    orderBy?: AuditDocumentOrderByWithAggregationInput | AuditDocumentOrderByWithAggregationInput[]
    by: AuditDocumentScalarFieldEnum[] | AuditDocumentScalarFieldEnum
    having?: AuditDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditDocumentCountAggregateInputType | true
    _min?: AuditDocumentMinAggregateInputType
    _max?: AuditDocumentMaxAggregateInputType
  }

  export type AuditDocumentGroupByOutputType = {
    id: string
    auditId: string
    title: string
    description: string | null
    documentType: $Enums.AuditDocumentType
    fileUrl: string
    filePath: string | null
    uploadedById: string
    createdAt: Date
    updatedAt: Date
    _count: AuditDocumentCountAggregateOutputType | null
    _min: AuditDocumentMinAggregateOutputType | null
    _max: AuditDocumentMaxAggregateOutputType | null
  }

  type GetAuditDocumentGroupByPayload<T extends AuditDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], AuditDocumentGroupByOutputType[P]>
        }
      >
    >


  export type AuditDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    title?: boolean
    description?: boolean
    documentType?: boolean
    fileUrl?: boolean
    filePath?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditDocument"]>

  export type AuditDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    title?: boolean
    description?: boolean
    documentType?: boolean
    fileUrl?: boolean
    filePath?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditDocument"]>

  export type AuditDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    title?: boolean
    description?: boolean
    documentType?: boolean
    fileUrl?: boolean
    filePath?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditDocument"]>

  export type AuditDocumentSelectScalar = {
    id?: boolean
    auditId?: boolean
    title?: boolean
    description?: boolean
    documentType?: boolean
    fileUrl?: boolean
    filePath?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auditId" | "title" | "description" | "documentType" | "fileUrl" | "filePath" | "uploadedById" | "createdAt" | "updatedAt", ExtArgs["result"]["auditDocument"]>
  export type AuditDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditDocument"
    objects: {
      audit: Prisma.$AuditPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auditId: string
      title: string
      description: string | null
      documentType: $Enums.AuditDocumentType
      fileUrl: string
      filePath: string | null
      uploadedById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auditDocument"]>
    composites: {}
  }

  type AuditDocumentGetPayload<S extends boolean | null | undefined | AuditDocumentDefaultArgs> = $Result.GetResult<Prisma.$AuditDocumentPayload, S>

  type AuditDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditDocumentCountAggregateInputType | true
    }

  export interface AuditDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditDocument'], meta: { name: 'AuditDocument' } }
    /**
     * Find zero or one AuditDocument that matches the filter.
     * @param {AuditDocumentFindUniqueArgs} args - Arguments to find a AuditDocument
     * @example
     * // Get one AuditDocument
     * const auditDocument = await prisma.auditDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditDocumentFindUniqueArgs>(args: SelectSubset<T, AuditDocumentFindUniqueArgs<ExtArgs>>): Prisma__AuditDocumentClient<$Result.GetResult<Prisma.$AuditDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditDocumentFindUniqueOrThrowArgs} args - Arguments to find a AuditDocument
     * @example
     * // Get one AuditDocument
     * const auditDocument = await prisma.auditDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditDocumentClient<$Result.GetResult<Prisma.$AuditDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditDocumentFindFirstArgs} args - Arguments to find a AuditDocument
     * @example
     * // Get one AuditDocument
     * const auditDocument = await prisma.auditDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditDocumentFindFirstArgs>(args?: SelectSubset<T, AuditDocumentFindFirstArgs<ExtArgs>>): Prisma__AuditDocumentClient<$Result.GetResult<Prisma.$AuditDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditDocumentFindFirstOrThrowArgs} args - Arguments to find a AuditDocument
     * @example
     * // Get one AuditDocument
     * const auditDocument = await prisma.auditDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditDocumentClient<$Result.GetResult<Prisma.$AuditDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditDocuments
     * const auditDocuments = await prisma.auditDocument.findMany()
     * 
     * // Get first 10 AuditDocuments
     * const auditDocuments = await prisma.auditDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditDocumentWithIdOnly = await prisma.auditDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditDocumentFindManyArgs>(args?: SelectSubset<T, AuditDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditDocument.
     * @param {AuditDocumentCreateArgs} args - Arguments to create a AuditDocument.
     * @example
     * // Create one AuditDocument
     * const AuditDocument = await prisma.auditDocument.create({
     *   data: {
     *     // ... data to create a AuditDocument
     *   }
     * })
     * 
     */
    create<T extends AuditDocumentCreateArgs>(args: SelectSubset<T, AuditDocumentCreateArgs<ExtArgs>>): Prisma__AuditDocumentClient<$Result.GetResult<Prisma.$AuditDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditDocuments.
     * @param {AuditDocumentCreateManyArgs} args - Arguments to create many AuditDocuments.
     * @example
     * // Create many AuditDocuments
     * const auditDocument = await prisma.auditDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditDocumentCreateManyArgs>(args?: SelectSubset<T, AuditDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditDocuments and returns the data saved in the database.
     * @param {AuditDocumentCreateManyAndReturnArgs} args - Arguments to create many AuditDocuments.
     * @example
     * // Create many AuditDocuments
     * const auditDocument = await prisma.auditDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditDocuments and only return the `id`
     * const auditDocumentWithIdOnly = await prisma.auditDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditDocument.
     * @param {AuditDocumentDeleteArgs} args - Arguments to delete one AuditDocument.
     * @example
     * // Delete one AuditDocument
     * const AuditDocument = await prisma.auditDocument.delete({
     *   where: {
     *     // ... filter to delete one AuditDocument
     *   }
     * })
     * 
     */
    delete<T extends AuditDocumentDeleteArgs>(args: SelectSubset<T, AuditDocumentDeleteArgs<ExtArgs>>): Prisma__AuditDocumentClient<$Result.GetResult<Prisma.$AuditDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditDocument.
     * @param {AuditDocumentUpdateArgs} args - Arguments to update one AuditDocument.
     * @example
     * // Update one AuditDocument
     * const auditDocument = await prisma.auditDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditDocumentUpdateArgs>(args: SelectSubset<T, AuditDocumentUpdateArgs<ExtArgs>>): Prisma__AuditDocumentClient<$Result.GetResult<Prisma.$AuditDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditDocuments.
     * @param {AuditDocumentDeleteManyArgs} args - Arguments to filter AuditDocuments to delete.
     * @example
     * // Delete a few AuditDocuments
     * const { count } = await prisma.auditDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditDocumentDeleteManyArgs>(args?: SelectSubset<T, AuditDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditDocuments
     * const auditDocument = await prisma.auditDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditDocumentUpdateManyArgs>(args: SelectSubset<T, AuditDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditDocuments and returns the data updated in the database.
     * @param {AuditDocumentUpdateManyAndReturnArgs} args - Arguments to update many AuditDocuments.
     * @example
     * // Update many AuditDocuments
     * const auditDocument = await prisma.auditDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditDocuments and only return the `id`
     * const auditDocumentWithIdOnly = await prisma.auditDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditDocument.
     * @param {AuditDocumentUpsertArgs} args - Arguments to update or create a AuditDocument.
     * @example
     * // Update or create a AuditDocument
     * const auditDocument = await prisma.auditDocument.upsert({
     *   create: {
     *     // ... data to create a AuditDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditDocument we want to update
     *   }
     * })
     */
    upsert<T extends AuditDocumentUpsertArgs>(args: SelectSubset<T, AuditDocumentUpsertArgs<ExtArgs>>): Prisma__AuditDocumentClient<$Result.GetResult<Prisma.$AuditDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditDocumentCountArgs} args - Arguments to filter AuditDocuments to count.
     * @example
     * // Count the number of AuditDocuments
     * const count = await prisma.auditDocument.count({
     *   where: {
     *     // ... the filter for the AuditDocuments we want to count
     *   }
     * })
    **/
    count<T extends AuditDocumentCountArgs>(
      args?: Subset<T, AuditDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditDocumentAggregateArgs>(args: Subset<T, AuditDocumentAggregateArgs>): Prisma.PrismaPromise<GetAuditDocumentAggregateType<T>>

    /**
     * Group by AuditDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditDocumentGroupByArgs['orderBy'] }
        : { orderBy?: AuditDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditDocument model
   */
  readonly fields: AuditDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audit<T extends AuditDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditDefaultArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditDocument model
   */
  interface AuditDocumentFieldRefs {
    readonly id: FieldRef<"AuditDocument", 'String'>
    readonly auditId: FieldRef<"AuditDocument", 'String'>
    readonly title: FieldRef<"AuditDocument", 'String'>
    readonly description: FieldRef<"AuditDocument", 'String'>
    readonly documentType: FieldRef<"AuditDocument", 'AuditDocumentType'>
    readonly fileUrl: FieldRef<"AuditDocument", 'String'>
    readonly filePath: FieldRef<"AuditDocument", 'String'>
    readonly uploadedById: FieldRef<"AuditDocument", 'String'>
    readonly createdAt: FieldRef<"AuditDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"AuditDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditDocument findUnique
   */
  export type AuditDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AuditDocument to fetch.
     */
    where: AuditDocumentWhereUniqueInput
  }

  /**
   * AuditDocument findUniqueOrThrow
   */
  export type AuditDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AuditDocument to fetch.
     */
    where: AuditDocumentWhereUniqueInput
  }

  /**
   * AuditDocument findFirst
   */
  export type AuditDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AuditDocument to fetch.
     */
    where?: AuditDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditDocuments to fetch.
     */
    orderBy?: AuditDocumentOrderByWithRelationInput | AuditDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditDocuments.
     */
    cursor?: AuditDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditDocuments.
     */
    distinct?: AuditDocumentScalarFieldEnum | AuditDocumentScalarFieldEnum[]
  }

  /**
   * AuditDocument findFirstOrThrow
   */
  export type AuditDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AuditDocument to fetch.
     */
    where?: AuditDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditDocuments to fetch.
     */
    orderBy?: AuditDocumentOrderByWithRelationInput | AuditDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditDocuments.
     */
    cursor?: AuditDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditDocuments.
     */
    distinct?: AuditDocumentScalarFieldEnum | AuditDocumentScalarFieldEnum[]
  }

  /**
   * AuditDocument findMany
   */
  export type AuditDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AuditDocuments to fetch.
     */
    where?: AuditDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditDocuments to fetch.
     */
    orderBy?: AuditDocumentOrderByWithRelationInput | AuditDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditDocuments.
     */
    cursor?: AuditDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditDocuments.
     */
    skip?: number
    distinct?: AuditDocumentScalarFieldEnum | AuditDocumentScalarFieldEnum[]
  }

  /**
   * AuditDocument create
   */
  export type AuditDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditDocument.
     */
    data: XOR<AuditDocumentCreateInput, AuditDocumentUncheckedCreateInput>
  }

  /**
   * AuditDocument createMany
   */
  export type AuditDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditDocuments.
     */
    data: AuditDocumentCreateManyInput | AuditDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditDocument createManyAndReturn
   */
  export type AuditDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many AuditDocuments.
     */
    data: AuditDocumentCreateManyInput | AuditDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditDocument update
   */
  export type AuditDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditDocument.
     */
    data: XOR<AuditDocumentUpdateInput, AuditDocumentUncheckedUpdateInput>
    /**
     * Choose, which AuditDocument to update.
     */
    where: AuditDocumentWhereUniqueInput
  }

  /**
   * AuditDocument updateMany
   */
  export type AuditDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditDocuments.
     */
    data: XOR<AuditDocumentUpdateManyMutationInput, AuditDocumentUncheckedUpdateManyInput>
    /**
     * Filter which AuditDocuments to update
     */
    where?: AuditDocumentWhereInput
    /**
     * Limit how many AuditDocuments to update.
     */
    limit?: number
  }

  /**
   * AuditDocument updateManyAndReturn
   */
  export type AuditDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * The data used to update AuditDocuments.
     */
    data: XOR<AuditDocumentUpdateManyMutationInput, AuditDocumentUncheckedUpdateManyInput>
    /**
     * Filter which AuditDocuments to update
     */
    where?: AuditDocumentWhereInput
    /**
     * Limit how many AuditDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditDocument upsert
   */
  export type AuditDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditDocument to update in case it exists.
     */
    where: AuditDocumentWhereUniqueInput
    /**
     * In case the AuditDocument found by the `where` argument doesn't exist, create a new AuditDocument with this data.
     */
    create: XOR<AuditDocumentCreateInput, AuditDocumentUncheckedCreateInput>
    /**
     * In case the AuditDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditDocumentUpdateInput, AuditDocumentUncheckedUpdateInput>
  }

  /**
   * AuditDocument delete
   */
  export type AuditDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentInclude<ExtArgs> | null
    /**
     * Filter which AuditDocument to delete.
     */
    where: AuditDocumentWhereUniqueInput
  }

  /**
   * AuditDocument deleteMany
   */
  export type AuditDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditDocuments to delete
     */
    where?: AuditDocumentWhereInput
    /**
     * Limit how many AuditDocuments to delete.
     */
    limit?: number
  }

  /**
   * AuditDocument without action
   */
  export type AuditDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditDocument
     */
    select?: AuditDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditDocument
     */
    omit?: AuditDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditDocumentInclude<ExtArgs> | null
  }


  /**
   * Model PreAuditChecklistItem
   */

  export type AggregatePreAuditChecklistItem = {
    _count: PreAuditChecklistItemCountAggregateOutputType | null
    _min: PreAuditChecklistItemMinAggregateOutputType | null
    _max: PreAuditChecklistItemMaxAggregateOutputType | null
  }

  export type PreAuditChecklistItemMinAggregateOutputType = {
    id: string | null
    auditId: string | null
    description: string | null
    isCompleted: boolean | null
    comments: string | null
    responsibleId: string | null
    dueDate: Date | null
    completedAt: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PreAuditChecklistItemMaxAggregateOutputType = {
    id: string | null
    auditId: string | null
    description: string | null
    isCompleted: boolean | null
    comments: string | null
    responsibleId: string | null
    dueDate: Date | null
    completedAt: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PreAuditChecklistItemCountAggregateOutputType = {
    id: number
    auditId: number
    description: number
    isCompleted: number
    comments: number
    responsibleId: number
    dueDate: number
    completedAt: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PreAuditChecklistItemMinAggregateInputType = {
    id?: true
    auditId?: true
    description?: true
    isCompleted?: true
    comments?: true
    responsibleId?: true
    dueDate?: true
    completedAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PreAuditChecklistItemMaxAggregateInputType = {
    id?: true
    auditId?: true
    description?: true
    isCompleted?: true
    comments?: true
    responsibleId?: true
    dueDate?: true
    completedAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PreAuditChecklistItemCountAggregateInputType = {
    id?: true
    auditId?: true
    description?: true
    isCompleted?: true
    comments?: true
    responsibleId?: true
    dueDate?: true
    completedAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PreAuditChecklistItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreAuditChecklistItem to aggregate.
     */
    where?: PreAuditChecklistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreAuditChecklistItems to fetch.
     */
    orderBy?: PreAuditChecklistItemOrderByWithRelationInput | PreAuditChecklistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreAuditChecklistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreAuditChecklistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreAuditChecklistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PreAuditChecklistItems
    **/
    _count?: true | PreAuditChecklistItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreAuditChecklistItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreAuditChecklistItemMaxAggregateInputType
  }

  export type GetPreAuditChecklistItemAggregateType<T extends PreAuditChecklistItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePreAuditChecklistItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreAuditChecklistItem[P]>
      : GetScalarType<T[P], AggregatePreAuditChecklistItem[P]>
  }




  export type PreAuditChecklistItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreAuditChecklistItemWhereInput
    orderBy?: PreAuditChecklistItemOrderByWithAggregationInput | PreAuditChecklistItemOrderByWithAggregationInput[]
    by: PreAuditChecklistItemScalarFieldEnum[] | PreAuditChecklistItemScalarFieldEnum
    having?: PreAuditChecklistItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreAuditChecklistItemCountAggregateInputType | true
    _min?: PreAuditChecklistItemMinAggregateInputType
    _max?: PreAuditChecklistItemMaxAggregateInputType
  }

  export type PreAuditChecklistItemGroupByOutputType = {
    id: string
    auditId: string
    description: string
    isCompleted: boolean
    comments: string | null
    responsibleId: string
    dueDate: Date | null
    completedAt: Date | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: PreAuditChecklistItemCountAggregateOutputType | null
    _min: PreAuditChecklistItemMinAggregateOutputType | null
    _max: PreAuditChecklistItemMaxAggregateOutputType | null
  }

  type GetPreAuditChecklistItemGroupByPayload<T extends PreAuditChecklistItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreAuditChecklistItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreAuditChecklistItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreAuditChecklistItemGroupByOutputType[P]>
            : GetScalarType<T[P], PreAuditChecklistItemGroupByOutputType[P]>
        }
      >
    >


  export type PreAuditChecklistItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    description?: boolean
    isCompleted?: boolean
    comments?: boolean
    responsibleId?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    responsible?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preAuditChecklistItem"]>

  export type PreAuditChecklistItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    description?: boolean
    isCompleted?: boolean
    comments?: boolean
    responsibleId?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    responsible?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preAuditChecklistItem"]>

  export type PreAuditChecklistItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    description?: boolean
    isCompleted?: boolean
    comments?: boolean
    responsibleId?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    responsible?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preAuditChecklistItem"]>

  export type PreAuditChecklistItemSelectScalar = {
    id?: boolean
    auditId?: boolean
    description?: boolean
    isCompleted?: boolean
    comments?: boolean
    responsibleId?: boolean
    dueDate?: boolean
    completedAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PreAuditChecklistItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auditId" | "description" | "isCompleted" | "comments" | "responsibleId" | "dueDate" | "completedAt" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["preAuditChecklistItem"]>
  export type PreAuditChecklistItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    responsible?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PreAuditChecklistItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    responsible?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PreAuditChecklistItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    responsible?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PreAuditChecklistItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PreAuditChecklistItem"
    objects: {
      audit: Prisma.$AuditPayload<ExtArgs>
      responsible: Prisma.$UserPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auditId: string
      description: string
      isCompleted: boolean
      comments: string | null
      responsibleId: string
      dueDate: Date | null
      completedAt: Date | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["preAuditChecklistItem"]>
    composites: {}
  }

  type PreAuditChecklistItemGetPayload<S extends boolean | null | undefined | PreAuditChecklistItemDefaultArgs> = $Result.GetResult<Prisma.$PreAuditChecklistItemPayload, S>

  type PreAuditChecklistItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PreAuditChecklistItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreAuditChecklistItemCountAggregateInputType | true
    }

  export interface PreAuditChecklistItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PreAuditChecklistItem'], meta: { name: 'PreAuditChecklistItem' } }
    /**
     * Find zero or one PreAuditChecklistItem that matches the filter.
     * @param {PreAuditChecklistItemFindUniqueArgs} args - Arguments to find a PreAuditChecklistItem
     * @example
     * // Get one PreAuditChecklistItem
     * const preAuditChecklistItem = await prisma.preAuditChecklistItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PreAuditChecklistItemFindUniqueArgs>(args: SelectSubset<T, PreAuditChecklistItemFindUniqueArgs<ExtArgs>>): Prisma__PreAuditChecklistItemClient<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PreAuditChecklistItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PreAuditChecklistItemFindUniqueOrThrowArgs} args - Arguments to find a PreAuditChecklistItem
     * @example
     * // Get one PreAuditChecklistItem
     * const preAuditChecklistItem = await prisma.preAuditChecklistItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PreAuditChecklistItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PreAuditChecklistItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PreAuditChecklistItemClient<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreAuditChecklistItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreAuditChecklistItemFindFirstArgs} args - Arguments to find a PreAuditChecklistItem
     * @example
     * // Get one PreAuditChecklistItem
     * const preAuditChecklistItem = await prisma.preAuditChecklistItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PreAuditChecklistItemFindFirstArgs>(args?: SelectSubset<T, PreAuditChecklistItemFindFirstArgs<ExtArgs>>): Prisma__PreAuditChecklistItemClient<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreAuditChecklistItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreAuditChecklistItemFindFirstOrThrowArgs} args - Arguments to find a PreAuditChecklistItem
     * @example
     * // Get one PreAuditChecklistItem
     * const preAuditChecklistItem = await prisma.preAuditChecklistItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PreAuditChecklistItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PreAuditChecklistItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PreAuditChecklistItemClient<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PreAuditChecklistItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreAuditChecklistItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreAuditChecklistItems
     * const preAuditChecklistItems = await prisma.preAuditChecklistItem.findMany()
     * 
     * // Get first 10 PreAuditChecklistItems
     * const preAuditChecklistItems = await prisma.preAuditChecklistItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preAuditChecklistItemWithIdOnly = await prisma.preAuditChecklistItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PreAuditChecklistItemFindManyArgs>(args?: SelectSubset<T, PreAuditChecklistItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PreAuditChecklistItem.
     * @param {PreAuditChecklistItemCreateArgs} args - Arguments to create a PreAuditChecklistItem.
     * @example
     * // Create one PreAuditChecklistItem
     * const PreAuditChecklistItem = await prisma.preAuditChecklistItem.create({
     *   data: {
     *     // ... data to create a PreAuditChecklistItem
     *   }
     * })
     * 
     */
    create<T extends PreAuditChecklistItemCreateArgs>(args: SelectSubset<T, PreAuditChecklistItemCreateArgs<ExtArgs>>): Prisma__PreAuditChecklistItemClient<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PreAuditChecklistItems.
     * @param {PreAuditChecklistItemCreateManyArgs} args - Arguments to create many PreAuditChecklistItems.
     * @example
     * // Create many PreAuditChecklistItems
     * const preAuditChecklistItem = await prisma.preAuditChecklistItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PreAuditChecklistItemCreateManyArgs>(args?: SelectSubset<T, PreAuditChecklistItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PreAuditChecklistItems and returns the data saved in the database.
     * @param {PreAuditChecklistItemCreateManyAndReturnArgs} args - Arguments to create many PreAuditChecklistItems.
     * @example
     * // Create many PreAuditChecklistItems
     * const preAuditChecklistItem = await prisma.preAuditChecklistItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PreAuditChecklistItems and only return the `id`
     * const preAuditChecklistItemWithIdOnly = await prisma.preAuditChecklistItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PreAuditChecklistItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PreAuditChecklistItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PreAuditChecklistItem.
     * @param {PreAuditChecklistItemDeleteArgs} args - Arguments to delete one PreAuditChecklistItem.
     * @example
     * // Delete one PreAuditChecklistItem
     * const PreAuditChecklistItem = await prisma.preAuditChecklistItem.delete({
     *   where: {
     *     // ... filter to delete one PreAuditChecklistItem
     *   }
     * })
     * 
     */
    delete<T extends PreAuditChecklistItemDeleteArgs>(args: SelectSubset<T, PreAuditChecklistItemDeleteArgs<ExtArgs>>): Prisma__PreAuditChecklistItemClient<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PreAuditChecklistItem.
     * @param {PreAuditChecklistItemUpdateArgs} args - Arguments to update one PreAuditChecklistItem.
     * @example
     * // Update one PreAuditChecklistItem
     * const preAuditChecklistItem = await prisma.preAuditChecklistItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PreAuditChecklistItemUpdateArgs>(args: SelectSubset<T, PreAuditChecklistItemUpdateArgs<ExtArgs>>): Prisma__PreAuditChecklistItemClient<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PreAuditChecklistItems.
     * @param {PreAuditChecklistItemDeleteManyArgs} args - Arguments to filter PreAuditChecklistItems to delete.
     * @example
     * // Delete a few PreAuditChecklistItems
     * const { count } = await prisma.preAuditChecklistItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PreAuditChecklistItemDeleteManyArgs>(args?: SelectSubset<T, PreAuditChecklistItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreAuditChecklistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreAuditChecklistItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreAuditChecklistItems
     * const preAuditChecklistItem = await prisma.preAuditChecklistItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PreAuditChecklistItemUpdateManyArgs>(args: SelectSubset<T, PreAuditChecklistItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreAuditChecklistItems and returns the data updated in the database.
     * @param {PreAuditChecklistItemUpdateManyAndReturnArgs} args - Arguments to update many PreAuditChecklistItems.
     * @example
     * // Update many PreAuditChecklistItems
     * const preAuditChecklistItem = await prisma.preAuditChecklistItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PreAuditChecklistItems and only return the `id`
     * const preAuditChecklistItemWithIdOnly = await prisma.preAuditChecklistItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PreAuditChecklistItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PreAuditChecklistItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PreAuditChecklistItem.
     * @param {PreAuditChecklistItemUpsertArgs} args - Arguments to update or create a PreAuditChecklistItem.
     * @example
     * // Update or create a PreAuditChecklistItem
     * const preAuditChecklistItem = await prisma.preAuditChecklistItem.upsert({
     *   create: {
     *     // ... data to create a PreAuditChecklistItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreAuditChecklistItem we want to update
     *   }
     * })
     */
    upsert<T extends PreAuditChecklistItemUpsertArgs>(args: SelectSubset<T, PreAuditChecklistItemUpsertArgs<ExtArgs>>): Prisma__PreAuditChecklistItemClient<$Result.GetResult<Prisma.$PreAuditChecklistItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PreAuditChecklistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreAuditChecklistItemCountArgs} args - Arguments to filter PreAuditChecklistItems to count.
     * @example
     * // Count the number of PreAuditChecklistItems
     * const count = await prisma.preAuditChecklistItem.count({
     *   where: {
     *     // ... the filter for the PreAuditChecklistItems we want to count
     *   }
     * })
    **/
    count<T extends PreAuditChecklistItemCountArgs>(
      args?: Subset<T, PreAuditChecklistItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreAuditChecklistItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PreAuditChecklistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreAuditChecklistItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreAuditChecklistItemAggregateArgs>(args: Subset<T, PreAuditChecklistItemAggregateArgs>): Prisma.PrismaPromise<GetPreAuditChecklistItemAggregateType<T>>

    /**
     * Group by PreAuditChecklistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreAuditChecklistItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreAuditChecklistItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreAuditChecklistItemGroupByArgs['orderBy'] }
        : { orderBy?: PreAuditChecklistItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreAuditChecklistItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreAuditChecklistItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PreAuditChecklistItem model
   */
  readonly fields: PreAuditChecklistItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PreAuditChecklistItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreAuditChecklistItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audit<T extends AuditDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditDefaultArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    responsible<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PreAuditChecklistItem model
   */
  interface PreAuditChecklistItemFieldRefs {
    readonly id: FieldRef<"PreAuditChecklistItem", 'String'>
    readonly auditId: FieldRef<"PreAuditChecklistItem", 'String'>
    readonly description: FieldRef<"PreAuditChecklistItem", 'String'>
    readonly isCompleted: FieldRef<"PreAuditChecklistItem", 'Boolean'>
    readonly comments: FieldRef<"PreAuditChecklistItem", 'String'>
    readonly responsibleId: FieldRef<"PreAuditChecklistItem", 'String'>
    readonly dueDate: FieldRef<"PreAuditChecklistItem", 'DateTime'>
    readonly completedAt: FieldRef<"PreAuditChecklistItem", 'DateTime'>
    readonly createdById: FieldRef<"PreAuditChecklistItem", 'String'>
    readonly createdAt: FieldRef<"PreAuditChecklistItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PreAuditChecklistItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PreAuditChecklistItem findUnique
   */
  export type PreAuditChecklistItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which PreAuditChecklistItem to fetch.
     */
    where: PreAuditChecklistItemWhereUniqueInput
  }

  /**
   * PreAuditChecklistItem findUniqueOrThrow
   */
  export type PreAuditChecklistItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which PreAuditChecklistItem to fetch.
     */
    where: PreAuditChecklistItemWhereUniqueInput
  }

  /**
   * PreAuditChecklistItem findFirst
   */
  export type PreAuditChecklistItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which PreAuditChecklistItem to fetch.
     */
    where?: PreAuditChecklistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreAuditChecklistItems to fetch.
     */
    orderBy?: PreAuditChecklistItemOrderByWithRelationInput | PreAuditChecklistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreAuditChecklistItems.
     */
    cursor?: PreAuditChecklistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreAuditChecklistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreAuditChecklistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreAuditChecklistItems.
     */
    distinct?: PreAuditChecklistItemScalarFieldEnum | PreAuditChecklistItemScalarFieldEnum[]
  }

  /**
   * PreAuditChecklistItem findFirstOrThrow
   */
  export type PreAuditChecklistItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which PreAuditChecklistItem to fetch.
     */
    where?: PreAuditChecklistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreAuditChecklistItems to fetch.
     */
    orderBy?: PreAuditChecklistItemOrderByWithRelationInput | PreAuditChecklistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreAuditChecklistItems.
     */
    cursor?: PreAuditChecklistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreAuditChecklistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreAuditChecklistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreAuditChecklistItems.
     */
    distinct?: PreAuditChecklistItemScalarFieldEnum | PreAuditChecklistItemScalarFieldEnum[]
  }

  /**
   * PreAuditChecklistItem findMany
   */
  export type PreAuditChecklistItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which PreAuditChecklistItems to fetch.
     */
    where?: PreAuditChecklistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreAuditChecklistItems to fetch.
     */
    orderBy?: PreAuditChecklistItemOrderByWithRelationInput | PreAuditChecklistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PreAuditChecklistItems.
     */
    cursor?: PreAuditChecklistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreAuditChecklistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreAuditChecklistItems.
     */
    skip?: number
    distinct?: PreAuditChecklistItemScalarFieldEnum | PreAuditChecklistItemScalarFieldEnum[]
  }

  /**
   * PreAuditChecklistItem create
   */
  export type PreAuditChecklistItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PreAuditChecklistItem.
     */
    data: XOR<PreAuditChecklistItemCreateInput, PreAuditChecklistItemUncheckedCreateInput>
  }

  /**
   * PreAuditChecklistItem createMany
   */
  export type PreAuditChecklistItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PreAuditChecklistItems.
     */
    data: PreAuditChecklistItemCreateManyInput | PreAuditChecklistItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PreAuditChecklistItem createManyAndReturn
   */
  export type PreAuditChecklistItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * The data used to create many PreAuditChecklistItems.
     */
    data: PreAuditChecklistItemCreateManyInput | PreAuditChecklistItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PreAuditChecklistItem update
   */
  export type PreAuditChecklistItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PreAuditChecklistItem.
     */
    data: XOR<PreAuditChecklistItemUpdateInput, PreAuditChecklistItemUncheckedUpdateInput>
    /**
     * Choose, which PreAuditChecklistItem to update.
     */
    where: PreAuditChecklistItemWhereUniqueInput
  }

  /**
   * PreAuditChecklistItem updateMany
   */
  export type PreAuditChecklistItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PreAuditChecklistItems.
     */
    data: XOR<PreAuditChecklistItemUpdateManyMutationInput, PreAuditChecklistItemUncheckedUpdateManyInput>
    /**
     * Filter which PreAuditChecklistItems to update
     */
    where?: PreAuditChecklistItemWhereInput
    /**
     * Limit how many PreAuditChecklistItems to update.
     */
    limit?: number
  }

  /**
   * PreAuditChecklistItem updateManyAndReturn
   */
  export type PreAuditChecklistItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * The data used to update PreAuditChecklistItems.
     */
    data: XOR<PreAuditChecklistItemUpdateManyMutationInput, PreAuditChecklistItemUncheckedUpdateManyInput>
    /**
     * Filter which PreAuditChecklistItems to update
     */
    where?: PreAuditChecklistItemWhereInput
    /**
     * Limit how many PreAuditChecklistItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PreAuditChecklistItem upsert
   */
  export type PreAuditChecklistItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PreAuditChecklistItem to update in case it exists.
     */
    where: PreAuditChecklistItemWhereUniqueInput
    /**
     * In case the PreAuditChecklistItem found by the `where` argument doesn't exist, create a new PreAuditChecklistItem with this data.
     */
    create: XOR<PreAuditChecklistItemCreateInput, PreAuditChecklistItemUncheckedCreateInput>
    /**
     * In case the PreAuditChecklistItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreAuditChecklistItemUpdateInput, PreAuditChecklistItemUncheckedUpdateInput>
  }

  /**
   * PreAuditChecklistItem delete
   */
  export type PreAuditChecklistItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemInclude<ExtArgs> | null
    /**
     * Filter which PreAuditChecklistItem to delete.
     */
    where: PreAuditChecklistItemWhereUniqueInput
  }

  /**
   * PreAuditChecklistItem deleteMany
   */
  export type PreAuditChecklistItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreAuditChecklistItems to delete
     */
    where?: PreAuditChecklistItemWhereInput
    /**
     * Limit how many PreAuditChecklistItems to delete.
     */
    limit?: number
  }

  /**
   * PreAuditChecklistItem without action
   */
  export type PreAuditChecklistItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreAuditChecklistItem
     */
    select?: PreAuditChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreAuditChecklistItem
     */
    omit?: PreAuditChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreAuditChecklistItemInclude<ExtArgs> | null
  }


  /**
   * Model AuditReminder
   */

  export type AggregateAuditReminder = {
    _count: AuditReminderCountAggregateOutputType | null
    _min: AuditReminderMinAggregateOutputType | null
    _max: AuditReminderMaxAggregateOutputType | null
  }

  export type AuditReminderMinAggregateOutputType = {
    id: string | null
    auditId: string | null
    title: string | null
    message: string | null
    dueDate: Date | null
    status: string | null
    recipientId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sentAt: Date | null
  }

  export type AuditReminderMaxAggregateOutputType = {
    id: string | null
    auditId: string | null
    title: string | null
    message: string | null
    dueDate: Date | null
    status: string | null
    recipientId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sentAt: Date | null
  }

  export type AuditReminderCountAggregateOutputType = {
    id: number
    auditId: number
    title: number
    message: number
    dueDate: number
    status: number
    recipientId: number
    createdById: number
    createdAt: number
    updatedAt: number
    sentAt: number
    _all: number
  }


  export type AuditReminderMinAggregateInputType = {
    id?: true
    auditId?: true
    title?: true
    message?: true
    dueDate?: true
    status?: true
    recipientId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
  }

  export type AuditReminderMaxAggregateInputType = {
    id?: true
    auditId?: true
    title?: true
    message?: true
    dueDate?: true
    status?: true
    recipientId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
  }

  export type AuditReminderCountAggregateInputType = {
    id?: true
    auditId?: true
    title?: true
    message?: true
    dueDate?: true
    status?: true
    recipientId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
    _all?: true
  }

  export type AuditReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditReminder to aggregate.
     */
    where?: AuditReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditReminders to fetch.
     */
    orderBy?: AuditReminderOrderByWithRelationInput | AuditReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditReminders
    **/
    _count?: true | AuditReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditReminderMaxAggregateInputType
  }

  export type GetAuditReminderAggregateType<T extends AuditReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditReminder[P]>
      : GetScalarType<T[P], AggregateAuditReminder[P]>
  }




  export type AuditReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditReminderWhereInput
    orderBy?: AuditReminderOrderByWithAggregationInput | AuditReminderOrderByWithAggregationInput[]
    by: AuditReminderScalarFieldEnum[] | AuditReminderScalarFieldEnum
    having?: AuditReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditReminderCountAggregateInputType | true
    _min?: AuditReminderMinAggregateInputType
    _max?: AuditReminderMaxAggregateInputType
  }

  export type AuditReminderGroupByOutputType = {
    id: string
    auditId: string
    title: string
    message: string
    dueDate: Date
    status: string
    recipientId: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    sentAt: Date | null
    _count: AuditReminderCountAggregateOutputType | null
    _min: AuditReminderMinAggregateOutputType | null
    _max: AuditReminderMaxAggregateOutputType | null
  }

  type GetAuditReminderGroupByPayload<T extends AuditReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditReminderGroupByOutputType[P]>
            : GetScalarType<T[P], AuditReminderGroupByOutputType[P]>
        }
      >
    >


  export type AuditReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    title?: boolean
    message?: boolean
    dueDate?: boolean
    status?: boolean
    recipientId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditReminder"]>

  export type AuditReminderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    title?: boolean
    message?: boolean
    dueDate?: boolean
    status?: boolean
    recipientId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditReminder"]>

  export type AuditReminderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    title?: boolean
    message?: boolean
    dueDate?: boolean
    status?: boolean
    recipientId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditReminder"]>

  export type AuditReminderSelectScalar = {
    id?: boolean
    auditId?: boolean
    title?: boolean
    message?: boolean
    dueDate?: boolean
    status?: boolean
    recipientId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
  }

  export type AuditReminderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auditId" | "title" | "message" | "dueDate" | "status" | "recipientId" | "createdById" | "createdAt" | "updatedAt" | "sentAt", ExtArgs["result"]["auditReminder"]>
  export type AuditReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditReminderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditReminderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditReminder"
    objects: {
      audit: Prisma.$AuditPayload<ExtArgs>
      recipient: Prisma.$UserPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auditId: string
      title: string
      message: string
      dueDate: Date
      status: string
      recipientId: string
      createdById: string
      createdAt: Date
      updatedAt: Date
      sentAt: Date | null
    }, ExtArgs["result"]["auditReminder"]>
    composites: {}
  }

  type AuditReminderGetPayload<S extends boolean | null | undefined | AuditReminderDefaultArgs> = $Result.GetResult<Prisma.$AuditReminderPayload, S>

  type AuditReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditReminderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditReminderCountAggregateInputType | true
    }

  export interface AuditReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditReminder'], meta: { name: 'AuditReminder' } }
    /**
     * Find zero or one AuditReminder that matches the filter.
     * @param {AuditReminderFindUniqueArgs} args - Arguments to find a AuditReminder
     * @example
     * // Get one AuditReminder
     * const auditReminder = await prisma.auditReminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditReminderFindUniqueArgs>(args: SelectSubset<T, AuditReminderFindUniqueArgs<ExtArgs>>): Prisma__AuditReminderClient<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditReminder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditReminderFindUniqueOrThrowArgs} args - Arguments to find a AuditReminder
     * @example
     * // Get one AuditReminder
     * const auditReminder = await prisma.auditReminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditReminderFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditReminderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditReminderClient<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditReminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditReminderFindFirstArgs} args - Arguments to find a AuditReminder
     * @example
     * // Get one AuditReminder
     * const auditReminder = await prisma.auditReminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditReminderFindFirstArgs>(args?: SelectSubset<T, AuditReminderFindFirstArgs<ExtArgs>>): Prisma__AuditReminderClient<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditReminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditReminderFindFirstOrThrowArgs} args - Arguments to find a AuditReminder
     * @example
     * // Get one AuditReminder
     * const auditReminder = await prisma.auditReminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditReminderFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditReminderFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditReminderClient<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditReminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditReminderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditReminders
     * const auditReminders = await prisma.auditReminder.findMany()
     * 
     * // Get first 10 AuditReminders
     * const auditReminders = await prisma.auditReminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditReminderWithIdOnly = await prisma.auditReminder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditReminderFindManyArgs>(args?: SelectSubset<T, AuditReminderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditReminder.
     * @param {AuditReminderCreateArgs} args - Arguments to create a AuditReminder.
     * @example
     * // Create one AuditReminder
     * const AuditReminder = await prisma.auditReminder.create({
     *   data: {
     *     // ... data to create a AuditReminder
     *   }
     * })
     * 
     */
    create<T extends AuditReminderCreateArgs>(args: SelectSubset<T, AuditReminderCreateArgs<ExtArgs>>): Prisma__AuditReminderClient<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditReminders.
     * @param {AuditReminderCreateManyArgs} args - Arguments to create many AuditReminders.
     * @example
     * // Create many AuditReminders
     * const auditReminder = await prisma.auditReminder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditReminderCreateManyArgs>(args?: SelectSubset<T, AuditReminderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditReminders and returns the data saved in the database.
     * @param {AuditReminderCreateManyAndReturnArgs} args - Arguments to create many AuditReminders.
     * @example
     * // Create many AuditReminders
     * const auditReminder = await prisma.auditReminder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditReminders and only return the `id`
     * const auditReminderWithIdOnly = await prisma.auditReminder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditReminderCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditReminderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditReminder.
     * @param {AuditReminderDeleteArgs} args - Arguments to delete one AuditReminder.
     * @example
     * // Delete one AuditReminder
     * const AuditReminder = await prisma.auditReminder.delete({
     *   where: {
     *     // ... filter to delete one AuditReminder
     *   }
     * })
     * 
     */
    delete<T extends AuditReminderDeleteArgs>(args: SelectSubset<T, AuditReminderDeleteArgs<ExtArgs>>): Prisma__AuditReminderClient<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditReminder.
     * @param {AuditReminderUpdateArgs} args - Arguments to update one AuditReminder.
     * @example
     * // Update one AuditReminder
     * const auditReminder = await prisma.auditReminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditReminderUpdateArgs>(args: SelectSubset<T, AuditReminderUpdateArgs<ExtArgs>>): Prisma__AuditReminderClient<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditReminders.
     * @param {AuditReminderDeleteManyArgs} args - Arguments to filter AuditReminders to delete.
     * @example
     * // Delete a few AuditReminders
     * const { count } = await prisma.auditReminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditReminderDeleteManyArgs>(args?: SelectSubset<T, AuditReminderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditReminders
     * const auditReminder = await prisma.auditReminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditReminderUpdateManyArgs>(args: SelectSubset<T, AuditReminderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditReminders and returns the data updated in the database.
     * @param {AuditReminderUpdateManyAndReturnArgs} args - Arguments to update many AuditReminders.
     * @example
     * // Update many AuditReminders
     * const auditReminder = await prisma.auditReminder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditReminders and only return the `id`
     * const auditReminderWithIdOnly = await prisma.auditReminder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditReminderUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditReminderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditReminder.
     * @param {AuditReminderUpsertArgs} args - Arguments to update or create a AuditReminder.
     * @example
     * // Update or create a AuditReminder
     * const auditReminder = await prisma.auditReminder.upsert({
     *   create: {
     *     // ... data to create a AuditReminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditReminder we want to update
     *   }
     * })
     */
    upsert<T extends AuditReminderUpsertArgs>(args: SelectSubset<T, AuditReminderUpsertArgs<ExtArgs>>): Prisma__AuditReminderClient<$Result.GetResult<Prisma.$AuditReminderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditReminderCountArgs} args - Arguments to filter AuditReminders to count.
     * @example
     * // Count the number of AuditReminders
     * const count = await prisma.auditReminder.count({
     *   where: {
     *     // ... the filter for the AuditReminders we want to count
     *   }
     * })
    **/
    count<T extends AuditReminderCountArgs>(
      args?: Subset<T, AuditReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditReminderAggregateArgs>(args: Subset<T, AuditReminderAggregateArgs>): Prisma.PrismaPromise<GetAuditReminderAggregateType<T>>

    /**
     * Group by AuditReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditReminderGroupByArgs['orderBy'] }
        : { orderBy?: AuditReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditReminder model
   */
  readonly fields: AuditReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditReminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audit<T extends AuditDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditDefaultArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditReminder model
   */
  interface AuditReminderFieldRefs {
    readonly id: FieldRef<"AuditReminder", 'String'>
    readonly auditId: FieldRef<"AuditReminder", 'String'>
    readonly title: FieldRef<"AuditReminder", 'String'>
    readonly message: FieldRef<"AuditReminder", 'String'>
    readonly dueDate: FieldRef<"AuditReminder", 'DateTime'>
    readonly status: FieldRef<"AuditReminder", 'String'>
    readonly recipientId: FieldRef<"AuditReminder", 'String'>
    readonly createdById: FieldRef<"AuditReminder", 'String'>
    readonly createdAt: FieldRef<"AuditReminder", 'DateTime'>
    readonly updatedAt: FieldRef<"AuditReminder", 'DateTime'>
    readonly sentAt: FieldRef<"AuditReminder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditReminder findUnique
   */
  export type AuditReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderInclude<ExtArgs> | null
    /**
     * Filter, which AuditReminder to fetch.
     */
    where: AuditReminderWhereUniqueInput
  }

  /**
   * AuditReminder findUniqueOrThrow
   */
  export type AuditReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderInclude<ExtArgs> | null
    /**
     * Filter, which AuditReminder to fetch.
     */
    where: AuditReminderWhereUniqueInput
  }

  /**
   * AuditReminder findFirst
   */
  export type AuditReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderInclude<ExtArgs> | null
    /**
     * Filter, which AuditReminder to fetch.
     */
    where?: AuditReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditReminders to fetch.
     */
    orderBy?: AuditReminderOrderByWithRelationInput | AuditReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditReminders.
     */
    cursor?: AuditReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditReminders.
     */
    distinct?: AuditReminderScalarFieldEnum | AuditReminderScalarFieldEnum[]
  }

  /**
   * AuditReminder findFirstOrThrow
   */
  export type AuditReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderInclude<ExtArgs> | null
    /**
     * Filter, which AuditReminder to fetch.
     */
    where?: AuditReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditReminders to fetch.
     */
    orderBy?: AuditReminderOrderByWithRelationInput | AuditReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditReminders.
     */
    cursor?: AuditReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditReminders.
     */
    distinct?: AuditReminderScalarFieldEnum | AuditReminderScalarFieldEnum[]
  }

  /**
   * AuditReminder findMany
   */
  export type AuditReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderInclude<ExtArgs> | null
    /**
     * Filter, which AuditReminders to fetch.
     */
    where?: AuditReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditReminders to fetch.
     */
    orderBy?: AuditReminderOrderByWithRelationInput | AuditReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditReminders.
     */
    cursor?: AuditReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditReminders.
     */
    skip?: number
    distinct?: AuditReminderScalarFieldEnum | AuditReminderScalarFieldEnum[]
  }

  /**
   * AuditReminder create
   */
  export type AuditReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditReminder.
     */
    data: XOR<AuditReminderCreateInput, AuditReminderUncheckedCreateInput>
  }

  /**
   * AuditReminder createMany
   */
  export type AuditReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditReminders.
     */
    data: AuditReminderCreateManyInput | AuditReminderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditReminder createManyAndReturn
   */
  export type AuditReminderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * The data used to create many AuditReminders.
     */
    data: AuditReminderCreateManyInput | AuditReminderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditReminder update
   */
  export type AuditReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditReminder.
     */
    data: XOR<AuditReminderUpdateInput, AuditReminderUncheckedUpdateInput>
    /**
     * Choose, which AuditReminder to update.
     */
    where: AuditReminderWhereUniqueInput
  }

  /**
   * AuditReminder updateMany
   */
  export type AuditReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditReminders.
     */
    data: XOR<AuditReminderUpdateManyMutationInput, AuditReminderUncheckedUpdateManyInput>
    /**
     * Filter which AuditReminders to update
     */
    where?: AuditReminderWhereInput
    /**
     * Limit how many AuditReminders to update.
     */
    limit?: number
  }

  /**
   * AuditReminder updateManyAndReturn
   */
  export type AuditReminderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * The data used to update AuditReminders.
     */
    data: XOR<AuditReminderUpdateManyMutationInput, AuditReminderUncheckedUpdateManyInput>
    /**
     * Filter which AuditReminders to update
     */
    where?: AuditReminderWhereInput
    /**
     * Limit how many AuditReminders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditReminder upsert
   */
  export type AuditReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditReminder to update in case it exists.
     */
    where: AuditReminderWhereUniqueInput
    /**
     * In case the AuditReminder found by the `where` argument doesn't exist, create a new AuditReminder with this data.
     */
    create: XOR<AuditReminderCreateInput, AuditReminderUncheckedCreateInput>
    /**
     * In case the AuditReminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditReminderUpdateInput, AuditReminderUncheckedUpdateInput>
  }

  /**
   * AuditReminder delete
   */
  export type AuditReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderInclude<ExtArgs> | null
    /**
     * Filter which AuditReminder to delete.
     */
    where: AuditReminderWhereUniqueInput
  }

  /**
   * AuditReminder deleteMany
   */
  export type AuditReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditReminders to delete
     */
    where?: AuditReminderWhereInput
    /**
     * Limit how many AuditReminders to delete.
     */
    limit?: number
  }

  /**
   * AuditReminder without action
   */
  export type AuditReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditReminder
     */
    select?: AuditReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditReminder
     */
    omit?: AuditReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditReminderInclude<ExtArgs> | null
  }


  /**
   * Model AuditNotification
   */

  export type AggregateAuditNotification = {
    _count: AuditNotificationCountAggregateOutputType | null
    _min: AuditNotificationMinAggregateOutputType | null
    _max: AuditNotificationMaxAggregateOutputType | null
  }

  export type AuditNotificationMinAggregateOutputType = {
    id: string | null
    auditId: string | null
    userId: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    sentAt: Date | null
    readAt: Date | null
  }

  export type AuditNotificationMaxAggregateOutputType = {
    id: string | null
    auditId: string | null
    userId: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    sentAt: Date | null
    readAt: Date | null
  }

  export type AuditNotificationCountAggregateOutputType = {
    id: number
    auditId: number
    userId: number
    title: number
    message: number
    isRead: number
    sentAt: number
    readAt: number
    _all: number
  }


  export type AuditNotificationMinAggregateInputType = {
    id?: true
    auditId?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    sentAt?: true
    readAt?: true
  }

  export type AuditNotificationMaxAggregateInputType = {
    id?: true
    auditId?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    sentAt?: true
    readAt?: true
  }

  export type AuditNotificationCountAggregateInputType = {
    id?: true
    auditId?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    sentAt?: true
    readAt?: true
    _all?: true
  }

  export type AuditNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditNotification to aggregate.
     */
    where?: AuditNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditNotifications to fetch.
     */
    orderBy?: AuditNotificationOrderByWithRelationInput | AuditNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditNotifications
    **/
    _count?: true | AuditNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditNotificationMaxAggregateInputType
  }

  export type GetAuditNotificationAggregateType<T extends AuditNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditNotification[P]>
      : GetScalarType<T[P], AggregateAuditNotification[P]>
  }




  export type AuditNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditNotificationWhereInput
    orderBy?: AuditNotificationOrderByWithAggregationInput | AuditNotificationOrderByWithAggregationInput[]
    by: AuditNotificationScalarFieldEnum[] | AuditNotificationScalarFieldEnum
    having?: AuditNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditNotificationCountAggregateInputType | true
    _min?: AuditNotificationMinAggregateInputType
    _max?: AuditNotificationMaxAggregateInputType
  }

  export type AuditNotificationGroupByOutputType = {
    id: string
    auditId: string
    userId: string
    title: string
    message: string
    isRead: boolean
    sentAt: Date
    readAt: Date | null
    _count: AuditNotificationCountAggregateOutputType | null
    _min: AuditNotificationMinAggregateOutputType | null
    _max: AuditNotificationMaxAggregateOutputType | null
  }

  type GetAuditNotificationGroupByPayload<T extends AuditNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], AuditNotificationGroupByOutputType[P]>
        }
      >
    >


  export type AuditNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    sentAt?: boolean
    readAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditNotification"]>

  export type AuditNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    sentAt?: boolean
    readAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditNotification"]>

  export type AuditNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    sentAt?: boolean
    readAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditNotification"]>

  export type AuditNotificationSelectScalar = {
    id?: boolean
    auditId?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    sentAt?: boolean
    readAt?: boolean
  }

  export type AuditNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auditId" | "userId" | "title" | "message" | "isRead" | "sentAt" | "readAt", ExtArgs["result"]["auditNotification"]>
  export type AuditNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditNotification"
    objects: {
      audit: Prisma.$AuditPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auditId: string
      userId: string
      title: string
      message: string
      isRead: boolean
      sentAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["auditNotification"]>
    composites: {}
  }

  type AuditNotificationGetPayload<S extends boolean | null | undefined | AuditNotificationDefaultArgs> = $Result.GetResult<Prisma.$AuditNotificationPayload, S>

  type AuditNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditNotificationCountAggregateInputType | true
    }

  export interface AuditNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditNotification'], meta: { name: 'AuditNotification' } }
    /**
     * Find zero or one AuditNotification that matches the filter.
     * @param {AuditNotificationFindUniqueArgs} args - Arguments to find a AuditNotification
     * @example
     * // Get one AuditNotification
     * const auditNotification = await prisma.auditNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditNotificationFindUniqueArgs>(args: SelectSubset<T, AuditNotificationFindUniqueArgs<ExtArgs>>): Prisma__AuditNotificationClient<$Result.GetResult<Prisma.$AuditNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditNotificationFindUniqueOrThrowArgs} args - Arguments to find a AuditNotification
     * @example
     * // Get one AuditNotification
     * const auditNotification = await prisma.auditNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditNotificationClient<$Result.GetResult<Prisma.$AuditNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditNotificationFindFirstArgs} args - Arguments to find a AuditNotification
     * @example
     * // Get one AuditNotification
     * const auditNotification = await prisma.auditNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditNotificationFindFirstArgs>(args?: SelectSubset<T, AuditNotificationFindFirstArgs<ExtArgs>>): Prisma__AuditNotificationClient<$Result.GetResult<Prisma.$AuditNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditNotificationFindFirstOrThrowArgs} args - Arguments to find a AuditNotification
     * @example
     * // Get one AuditNotification
     * const auditNotification = await prisma.auditNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditNotificationClient<$Result.GetResult<Prisma.$AuditNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditNotifications
     * const auditNotifications = await prisma.auditNotification.findMany()
     * 
     * // Get first 10 AuditNotifications
     * const auditNotifications = await prisma.auditNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditNotificationWithIdOnly = await prisma.auditNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditNotificationFindManyArgs>(args?: SelectSubset<T, AuditNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditNotification.
     * @param {AuditNotificationCreateArgs} args - Arguments to create a AuditNotification.
     * @example
     * // Create one AuditNotification
     * const AuditNotification = await prisma.auditNotification.create({
     *   data: {
     *     // ... data to create a AuditNotification
     *   }
     * })
     * 
     */
    create<T extends AuditNotificationCreateArgs>(args: SelectSubset<T, AuditNotificationCreateArgs<ExtArgs>>): Prisma__AuditNotificationClient<$Result.GetResult<Prisma.$AuditNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditNotifications.
     * @param {AuditNotificationCreateManyArgs} args - Arguments to create many AuditNotifications.
     * @example
     * // Create many AuditNotifications
     * const auditNotification = await prisma.auditNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditNotificationCreateManyArgs>(args?: SelectSubset<T, AuditNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditNotifications and returns the data saved in the database.
     * @param {AuditNotificationCreateManyAndReturnArgs} args - Arguments to create many AuditNotifications.
     * @example
     * // Create many AuditNotifications
     * const auditNotification = await prisma.auditNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditNotifications and only return the `id`
     * const auditNotificationWithIdOnly = await prisma.auditNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditNotification.
     * @param {AuditNotificationDeleteArgs} args - Arguments to delete one AuditNotification.
     * @example
     * // Delete one AuditNotification
     * const AuditNotification = await prisma.auditNotification.delete({
     *   where: {
     *     // ... filter to delete one AuditNotification
     *   }
     * })
     * 
     */
    delete<T extends AuditNotificationDeleteArgs>(args: SelectSubset<T, AuditNotificationDeleteArgs<ExtArgs>>): Prisma__AuditNotificationClient<$Result.GetResult<Prisma.$AuditNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditNotification.
     * @param {AuditNotificationUpdateArgs} args - Arguments to update one AuditNotification.
     * @example
     * // Update one AuditNotification
     * const auditNotification = await prisma.auditNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditNotificationUpdateArgs>(args: SelectSubset<T, AuditNotificationUpdateArgs<ExtArgs>>): Prisma__AuditNotificationClient<$Result.GetResult<Prisma.$AuditNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditNotifications.
     * @param {AuditNotificationDeleteManyArgs} args - Arguments to filter AuditNotifications to delete.
     * @example
     * // Delete a few AuditNotifications
     * const { count } = await prisma.auditNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditNotificationDeleteManyArgs>(args?: SelectSubset<T, AuditNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditNotifications
     * const auditNotification = await prisma.auditNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditNotificationUpdateManyArgs>(args: SelectSubset<T, AuditNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditNotifications and returns the data updated in the database.
     * @param {AuditNotificationUpdateManyAndReturnArgs} args - Arguments to update many AuditNotifications.
     * @example
     * // Update many AuditNotifications
     * const auditNotification = await prisma.auditNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditNotifications and only return the `id`
     * const auditNotificationWithIdOnly = await prisma.auditNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditNotification.
     * @param {AuditNotificationUpsertArgs} args - Arguments to update or create a AuditNotification.
     * @example
     * // Update or create a AuditNotification
     * const auditNotification = await prisma.auditNotification.upsert({
     *   create: {
     *     // ... data to create a AuditNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditNotification we want to update
     *   }
     * })
     */
    upsert<T extends AuditNotificationUpsertArgs>(args: SelectSubset<T, AuditNotificationUpsertArgs<ExtArgs>>): Prisma__AuditNotificationClient<$Result.GetResult<Prisma.$AuditNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditNotificationCountArgs} args - Arguments to filter AuditNotifications to count.
     * @example
     * // Count the number of AuditNotifications
     * const count = await prisma.auditNotification.count({
     *   where: {
     *     // ... the filter for the AuditNotifications we want to count
     *   }
     * })
    **/
    count<T extends AuditNotificationCountArgs>(
      args?: Subset<T, AuditNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditNotificationAggregateArgs>(args: Subset<T, AuditNotificationAggregateArgs>): Prisma.PrismaPromise<GetAuditNotificationAggregateType<T>>

    /**
     * Group by AuditNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditNotificationGroupByArgs['orderBy'] }
        : { orderBy?: AuditNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditNotification model
   */
  readonly fields: AuditNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audit<T extends AuditDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditDefaultArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditNotification model
   */
  interface AuditNotificationFieldRefs {
    readonly id: FieldRef<"AuditNotification", 'String'>
    readonly auditId: FieldRef<"AuditNotification", 'String'>
    readonly userId: FieldRef<"AuditNotification", 'String'>
    readonly title: FieldRef<"AuditNotification", 'String'>
    readonly message: FieldRef<"AuditNotification", 'String'>
    readonly isRead: FieldRef<"AuditNotification", 'Boolean'>
    readonly sentAt: FieldRef<"AuditNotification", 'DateTime'>
    readonly readAt: FieldRef<"AuditNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditNotification findUnique
   */
  export type AuditNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AuditNotification to fetch.
     */
    where: AuditNotificationWhereUniqueInput
  }

  /**
   * AuditNotification findUniqueOrThrow
   */
  export type AuditNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AuditNotification to fetch.
     */
    where: AuditNotificationWhereUniqueInput
  }

  /**
   * AuditNotification findFirst
   */
  export type AuditNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AuditNotification to fetch.
     */
    where?: AuditNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditNotifications to fetch.
     */
    orderBy?: AuditNotificationOrderByWithRelationInput | AuditNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditNotifications.
     */
    cursor?: AuditNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditNotifications.
     */
    distinct?: AuditNotificationScalarFieldEnum | AuditNotificationScalarFieldEnum[]
  }

  /**
   * AuditNotification findFirstOrThrow
   */
  export type AuditNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AuditNotification to fetch.
     */
    where?: AuditNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditNotifications to fetch.
     */
    orderBy?: AuditNotificationOrderByWithRelationInput | AuditNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditNotifications.
     */
    cursor?: AuditNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditNotifications.
     */
    distinct?: AuditNotificationScalarFieldEnum | AuditNotificationScalarFieldEnum[]
  }

  /**
   * AuditNotification findMany
   */
  export type AuditNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationInclude<ExtArgs> | null
    /**
     * Filter, which AuditNotifications to fetch.
     */
    where?: AuditNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditNotifications to fetch.
     */
    orderBy?: AuditNotificationOrderByWithRelationInput | AuditNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditNotifications.
     */
    cursor?: AuditNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditNotifications.
     */
    skip?: number
    distinct?: AuditNotificationScalarFieldEnum | AuditNotificationScalarFieldEnum[]
  }

  /**
   * AuditNotification create
   */
  export type AuditNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditNotification.
     */
    data: XOR<AuditNotificationCreateInput, AuditNotificationUncheckedCreateInput>
  }

  /**
   * AuditNotification createMany
   */
  export type AuditNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditNotifications.
     */
    data: AuditNotificationCreateManyInput | AuditNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditNotification createManyAndReturn
   */
  export type AuditNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many AuditNotifications.
     */
    data: AuditNotificationCreateManyInput | AuditNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditNotification update
   */
  export type AuditNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditNotification.
     */
    data: XOR<AuditNotificationUpdateInput, AuditNotificationUncheckedUpdateInput>
    /**
     * Choose, which AuditNotification to update.
     */
    where: AuditNotificationWhereUniqueInput
  }

  /**
   * AuditNotification updateMany
   */
  export type AuditNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditNotifications.
     */
    data: XOR<AuditNotificationUpdateManyMutationInput, AuditNotificationUncheckedUpdateManyInput>
    /**
     * Filter which AuditNotifications to update
     */
    where?: AuditNotificationWhereInput
    /**
     * Limit how many AuditNotifications to update.
     */
    limit?: number
  }

  /**
   * AuditNotification updateManyAndReturn
   */
  export type AuditNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * The data used to update AuditNotifications.
     */
    data: XOR<AuditNotificationUpdateManyMutationInput, AuditNotificationUncheckedUpdateManyInput>
    /**
     * Filter which AuditNotifications to update
     */
    where?: AuditNotificationWhereInput
    /**
     * Limit how many AuditNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditNotification upsert
   */
  export type AuditNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditNotification to update in case it exists.
     */
    where: AuditNotificationWhereUniqueInput
    /**
     * In case the AuditNotification found by the `where` argument doesn't exist, create a new AuditNotification with this data.
     */
    create: XOR<AuditNotificationCreateInput, AuditNotificationUncheckedCreateInput>
    /**
     * In case the AuditNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditNotificationUpdateInput, AuditNotificationUncheckedUpdateInput>
  }

  /**
   * AuditNotification delete
   */
  export type AuditNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationInclude<ExtArgs> | null
    /**
     * Filter which AuditNotification to delete.
     */
    where: AuditNotificationWhereUniqueInput
  }

  /**
   * AuditNotification deleteMany
   */
  export type AuditNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditNotifications to delete
     */
    where?: AuditNotificationWhereInput
    /**
     * Limit how many AuditNotifications to delete.
     */
    limit?: number
  }

  /**
   * AuditNotification without action
   */
  export type AuditNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditNotification
     */
    select?: AuditNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditNotification
     */
    omit?: AuditNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditNotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    batchId: 'batchId',
    action: 'action',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const BatchScalarFieldEnum: {
    id: 'id',
    batchNumber: 'batchNumber',
    productId: 'productId',
    dateOfProduction: 'dateOfProduction',
    bestBeforeDate: 'bestBeforeDate',
    sampleAnalysisStarted: 'sampleAnalysisStarted',
    sampleAnalysisCompleted: 'sampleAnalysisCompleted',
    sampleAnalysisStatus: 'sampleAnalysisStatus',
    makerId: 'makerId',
    checkerId: 'checkerId',
    status: 'status',
    rejectionRemarks: 'rejectionRemarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BatchScalarFieldEnum = (typeof BatchScalarFieldEnum)[keyof typeof BatchScalarFieldEnum]


  export const ExportLogScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    exportType: 'exportType',
    exportedBy: 'exportedBy',
    exportedAt: 'exportedAt'
  };

  export type ExportLogScalarFieldEnum = (typeof ExportLogScalarFieldEnum)[keyof typeof ExportLogScalarFieldEnum]


  export const MethodologyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    procedure: 'procedure',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MethodologyScalarFieldEnum = (typeof MethodologyScalarFieldEnum)[keyof typeof MethodologyScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    batchId: 'batchId',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    action: 'action',
    resource: 'resource',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductParameterScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    parameterId: 'parameterId',
    isRequired: 'isRequired',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductParameterScalarFieldEnum = (typeof ProductParameterScalarFieldEnum)[keyof typeof ProductParameterScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UnitOfMeasurementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    symbol: 'symbol',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitOfMeasurementScalarFieldEnum = (typeof UnitOfMeasurementScalarFieldEnum)[keyof typeof UnitOfMeasurementScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    roleId: 'roleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StandardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    categoryId: 'categoryId',
    createdById: 'createdById',
    modifiedById: 'modifiedById',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StandardScalarFieldEnum = (typeof StandardScalarFieldEnum)[keyof typeof StandardScalarFieldEnum]


  export const StandardCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StandardCategoryScalarFieldEnum = (typeof StandardCategoryScalarFieldEnum)[keyof typeof StandardCategoryScalarFieldEnum]


  export const ProductStandardCategoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductStandardCategoryScalarFieldEnum = (typeof ProductStandardCategoryScalarFieldEnum)[keyof typeof ProductStandardCategoryScalarFieldEnum]


  export const StandardParameterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    categoryId: 'categoryId',
    unitId: 'unitId',
    productType: 'productType',
    description: 'description',
    dataType: 'dataType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StandardParameterScalarFieldEnum = (typeof StandardParameterScalarFieldEnum)[keyof typeof StandardParameterScalarFieldEnum]


  export const StandardDefinitionScalarFieldEnum: {
    id: 'id',
    parameterId: 'parameterId',
    standardValue: 'standardValue',
    unitId: 'unitId',
    methodologyId: 'methodologyId',
    createdById: 'createdById',
    modifiedById: 'modifiedById',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StandardDefinitionScalarFieldEnum = (typeof StandardDefinitionScalarFieldEnum)[keyof typeof StandardDefinitionScalarFieldEnum]


  export const BatchParameterValueScalarFieldEnum: {
    id: 'id',
    batchId: 'batchId',
    parameterId: 'parameterId',
    value: 'value',
    unitId: 'unitId',
    methodologyId: 'methodologyId',
    verificationResult: 'verificationResult',
    verificationRemark: 'verificationRemark',
    verifiedById: 'verifiedById',
    verifiedAt: 'verifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BatchParameterValueScalarFieldEnum = (typeof BatchParameterValueScalarFieldEnum)[keyof typeof BatchParameterValueScalarFieldEnum]


  export const TrainingCalendarScalarFieldEnum: {
    id: 'id',
    month: 'month',
    year: 'year',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingCalendarScalarFieldEnum = (typeof TrainingCalendarScalarFieldEnum)[keyof typeof TrainingCalendarScalarFieldEnum]


  export const TrainingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    trainingType: 'trainingType',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    location: 'location',
    maxParticipants: 'maxParticipants',
    trainerId: 'trainerId',
    calendarId: 'calendarId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingScalarFieldEnum = (typeof TrainingScalarFieldEnum)[keyof typeof TrainingScalarFieldEnum]


  export const TrainingSessionScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    title: 'title',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    venue: 'venue',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingSessionScalarFieldEnum = (typeof TrainingSessionScalarFieldEnum)[keyof typeof TrainingSessionScalarFieldEnum]


  export const TrainingDocumentScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    sessionId: 'sessionId',
    title: 'title',
    description: 'description',
    fileUrl: 'fileUrl',
    filePath: 'filePath',
    documentType: 'documentType',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingDocumentScalarFieldEnum = (typeof TrainingDocumentScalarFieldEnum)[keyof typeof TrainingDocumentScalarFieldEnum]


  export const ParticipantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    organization: 'organization',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParticipantScalarFieldEnum = (typeof ParticipantScalarFieldEnum)[keyof typeof ParticipantScalarFieldEnum]


  export const TrainingParticipantScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    participantId: 'participantId',
    inviteSent: 'inviteSent',
    inviteSentAt: 'inviteSentAt',
    inviteAccepted: 'inviteAccepted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingParticipantScalarFieldEnum = (typeof TrainingParticipantScalarFieldEnum)[keyof typeof TrainingParticipantScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    sessionId: 'sessionId',
    participantId: 'participantId',
    status: 'status',
    remarks: 'remarks',
    signatureUrl: 'signatureUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const TrainingPhotoScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    photoUrl: 'photoUrl',
    caption: 'caption',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt'
  };

  export type TrainingPhotoScalarFieldEnum = (typeof TrainingPhotoScalarFieldEnum)[keyof typeof TrainingPhotoScalarFieldEnum]


  export const TrainingFeedbackScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    participantId: 'participantId',
    contentRating: 'contentRating',
    trainerRating: 'trainerRating',
    materialRating: 'materialRating',
    venueRating: 'venueRating',
    overallRating: 'overallRating',
    comments: 'comments',
    suggestedImprovements: 'suggestedImprovements',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingFeedbackScalarFieldEnum = (typeof TrainingFeedbackScalarFieldEnum)[keyof typeof TrainingFeedbackScalarFieldEnum]


  export const FeedbackFormScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    sessionId: 'sessionId',
    participantId: 'participantId',
    fileUrl: 'fileUrl',
    filePath: 'filePath',
    submittedAt: 'submittedAt',
    uploadedById: 'uploadedById'
  };

  export type FeedbackFormScalarFieldEnum = (typeof FeedbackFormScalarFieldEnum)[keyof typeof FeedbackFormScalarFieldEnum]


  export const TrainingFollowupScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    title: 'title',
    description: 'description',
    dueDate: 'dueDate',
    isCompleted: 'isCompleted',
    assignedToId: 'assignedToId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type TrainingFollowupScalarFieldEnum = (typeof TrainingFollowupScalarFieldEnum)[keyof typeof TrainingFollowupScalarFieldEnum]


  export const TrainingNotificationScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    userId: 'userId',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    sentAt: 'sentAt',
    readAt: 'readAt'
  };

  export type TrainingNotificationScalarFieldEnum = (typeof TrainingNotificationScalarFieldEnum)[keyof typeof TrainingNotificationScalarFieldEnum]


  export const TrainingInviteTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    action: 'action',
    trainingId: 'trainingId',
    participantId: 'participantId',
    email: 'email',
    expiresAt: 'expiresAt',
    used: 'used',
    createdAt: 'createdAt'
  };

  export type TrainingInviteTokenScalarFieldEnum = (typeof TrainingInviteTokenScalarFieldEnum)[keyof typeof TrainingInviteTokenScalarFieldEnum]


  export const TrainingSessionPhotoScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    photoUrl: 'photoUrl',
    caption: 'caption',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt'
  };

  export type TrainingSessionPhotoScalarFieldEnum = (typeof TrainingSessionPhotoScalarFieldEnum)[keyof typeof TrainingSessionPhotoScalarFieldEnum]


  export const AuditorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    userId: 'userId',
    isExternal: 'isExternal',
    firmName: 'firmName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditorScalarFieldEnum = (typeof AuditorScalarFieldEnum)[keyof typeof AuditorScalarFieldEnum]


  export const AuditScalarFieldEnum: {
    id: 'id',
    name: 'name',
    auditType: 'auditType',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    auditorId: 'auditorId',
    auditeeId: 'auditeeId',
    firmName: 'firmName',
    departmentId: 'departmentId',
    objectives: 'objectives',
    scope: 'scope',
    summary: 'summary',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditScalarFieldEnum = (typeof AuditScalarFieldEnum)[keyof typeof AuditScalarFieldEnum]


  export const AuditInspectionItemScalarFieldEnum: {
    id: 'id',
    auditId: 'auditId',
    areaName: 'areaName',
    itemName: 'itemName',
    description: 'description',
    standardReference: 'standardReference',
    isCompliant: 'isCompliant',
    comments: 'comments',
    evidence: 'evidence',
    inspectedById: 'inspectedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditInspectionItemScalarFieldEnum = (typeof AuditInspectionItemScalarFieldEnum)[keyof typeof AuditInspectionItemScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const FindingScalarFieldEnum: {
    id: 'id',
    auditId: 'auditId',
    title: 'title',
    description: 'description',
    findingType: 'findingType',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    assignedToId: 'assignedToId',
    evidence: 'evidence',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    closedAt: 'closedAt'
  };

  export type FindingScalarFieldEnum = (typeof FindingScalarFieldEnum)[keyof typeof FindingScalarFieldEnum]


  export const CorrectiveActionScalarFieldEnum: {
    id: 'id',
    auditId: 'auditId',
    findingId: 'findingId',
    title: 'title',
    description: 'description',
    actionType: 'actionType',
    assignedToId: 'assignedToId',
    dueDate: 'dueDate',
    status: 'status',
    completedAt: 'completedAt',
    verifiedAt: 'verifiedAt',
    verifiedById: 'verifiedById',
    evidence: 'evidence',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CorrectiveActionScalarFieldEnum = (typeof CorrectiveActionScalarFieldEnum)[keyof typeof CorrectiveActionScalarFieldEnum]


  export const AuditDocumentScalarFieldEnum: {
    id: 'id',
    auditId: 'auditId',
    title: 'title',
    description: 'description',
    documentType: 'documentType',
    fileUrl: 'fileUrl',
    filePath: 'filePath',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditDocumentScalarFieldEnum = (typeof AuditDocumentScalarFieldEnum)[keyof typeof AuditDocumentScalarFieldEnum]


  export const PreAuditChecklistItemScalarFieldEnum: {
    id: 'id',
    auditId: 'auditId',
    description: 'description',
    isCompleted: 'isCompleted',
    comments: 'comments',
    responsibleId: 'responsibleId',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PreAuditChecklistItemScalarFieldEnum = (typeof PreAuditChecklistItemScalarFieldEnum)[keyof typeof PreAuditChecklistItemScalarFieldEnum]


  export const AuditReminderScalarFieldEnum: {
    id: 'id',
    auditId: 'auditId',
    title: 'title',
    message: 'message',
    dueDate: 'dueDate',
    status: 'status',
    recipientId: 'recipientId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sentAt: 'sentAt'
  };

  export type AuditReminderScalarFieldEnum = (typeof AuditReminderScalarFieldEnum)[keyof typeof AuditReminderScalarFieldEnum]


  export const AuditNotificationScalarFieldEnum: {
    id: 'id',
    auditId: 'auditId',
    userId: 'userId',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    sentAt: 'sentAt',
    readAt: 'readAt'
  };

  export type AuditNotificationScalarFieldEnum = (typeof AuditNotificationScalarFieldEnum)[keyof typeof AuditNotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SampleAnalysisStatus'
   */
  export type EnumSampleAnalysisStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SampleAnalysisStatus'>
    


  /**
   * Reference to a field of type 'SampleAnalysisStatus[]'
   */
  export type ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SampleAnalysisStatus[]'>
    


  /**
   * Reference to a field of type 'BatchStatus'
   */
  export type EnumBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchStatus'>
    


  /**
   * Reference to a field of type 'BatchStatus[]'
   */
  export type ListEnumBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'StandardStatus'
   */
  export type EnumStandardStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StandardStatus'>
    


  /**
   * Reference to a field of type 'StandardStatus[]'
   */
  export type ListEnumStandardStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StandardStatus[]'>
    


  /**
   * Reference to a field of type 'ParameterDataType'
   */
  export type EnumParameterDataTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParameterDataType'>
    


  /**
   * Reference to a field of type 'ParameterDataType[]'
   */
  export type ListEnumParameterDataTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParameterDataType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TrainingType'
   */
  export type EnumTrainingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingType'>
    


  /**
   * Reference to a field of type 'TrainingType[]'
   */
  export type ListEnumTrainingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingType[]'>
    


  /**
   * Reference to a field of type 'TrainingStatus'
   */
  export type EnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus'>
    


  /**
   * Reference to a field of type 'TrainingStatus[]'
   */
  export type ListEnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'AuditType'
   */
  export type EnumAuditTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditType'>
    


  /**
   * Reference to a field of type 'AuditType[]'
   */
  export type ListEnumAuditTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditType[]'>
    


  /**
   * Reference to a field of type 'AuditStatus'
   */
  export type EnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus'>
    


  /**
   * Reference to a field of type 'AuditStatus[]'
   */
  export type ListEnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus[]'>
    


  /**
   * Reference to a field of type 'FindingType'
   */
  export type EnumFindingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FindingType'>
    


  /**
   * Reference to a field of type 'FindingType[]'
   */
  export type ListEnumFindingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FindingType[]'>
    


  /**
   * Reference to a field of type 'FindingStatus'
   */
  export type EnumFindingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FindingStatus'>
    


  /**
   * Reference to a field of type 'FindingStatus[]'
   */
  export type ListEnumFindingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FindingStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'AuditDocumentType'
   */
  export type EnumAuditDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditDocumentType'>
    


  /**
   * Reference to a field of type 'AuditDocumentType[]'
   */
  export type ListEnumAuditDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditDocumentType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringFilter<"ActivityLog"> | string
    batchId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: StringFilter<"ActivityLog"> | string
    details?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    Batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Batch?: BatchOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    userId?: StringFilter<"ActivityLog"> | string
    batchId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: StringFilter<"ActivityLog"> | string
    details?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    Batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    userId?: StringWithAggregatesFilter<"ActivityLog"> | string
    batchId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    details?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type BatchWhereInput = {
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    id?: StringFilter<"Batch"> | string
    batchNumber?: StringFilter<"Batch"> | string
    productId?: StringFilter<"Batch"> | string
    dateOfProduction?: DateTimeFilter<"Batch"> | Date | string
    bestBeforeDate?: DateTimeFilter<"Batch"> | Date | string
    sampleAnalysisStarted?: DateTimeNullableFilter<"Batch"> | Date | string | null
    sampleAnalysisCompleted?: DateTimeNullableFilter<"Batch"> | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFilter<"Batch"> | $Enums.SampleAnalysisStatus
    makerId?: StringFilter<"Batch"> | string
    checkerId?: StringNullableFilter<"Batch"> | string | null
    status?: EnumBatchStatusFilter<"Batch"> | $Enums.BatchStatus
    rejectionRemarks?: StringNullableFilter<"Batch"> | string | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
    ActivityLog?: ActivityLogListRelationFilter
    User_Batch_checkerIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    User_Batch_makerIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    Notification?: NotificationListRelationFilter
    standards?: StandardListRelationFilter
    methodologies?: MethodologyListRelationFilter
    unitOfMeasurements?: UnitOfMeasurementListRelationFilter
    parameterValues?: BatchParameterValueListRelationFilter
  }

  export type BatchOrderByWithRelationInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    productId?: SortOrder
    dateOfProduction?: SortOrder
    bestBeforeDate?: SortOrder
    sampleAnalysisStarted?: SortOrderInput | SortOrder
    sampleAnalysisCompleted?: SortOrderInput | SortOrder
    sampleAnalysisStatus?: SortOrder
    makerId?: SortOrder
    checkerId?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionRemarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ActivityLog?: ActivityLogOrderByRelationAggregateInput
    User_Batch_checkerIdToUser?: UserOrderByWithRelationInput
    User_Batch_makerIdToUser?: UserOrderByWithRelationInput
    Product?: ProductOrderByWithRelationInput
    Notification?: NotificationOrderByRelationAggregateInput
    standards?: StandardOrderByRelationAggregateInput
    methodologies?: MethodologyOrderByRelationAggregateInput
    unitOfMeasurements?: UnitOfMeasurementOrderByRelationAggregateInput
    parameterValues?: BatchParameterValueOrderByRelationAggregateInput
  }

  export type BatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    batchNumber?: string
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    productId?: StringFilter<"Batch"> | string
    dateOfProduction?: DateTimeFilter<"Batch"> | Date | string
    bestBeforeDate?: DateTimeFilter<"Batch"> | Date | string
    sampleAnalysisStarted?: DateTimeNullableFilter<"Batch"> | Date | string | null
    sampleAnalysisCompleted?: DateTimeNullableFilter<"Batch"> | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFilter<"Batch"> | $Enums.SampleAnalysisStatus
    makerId?: StringFilter<"Batch"> | string
    checkerId?: StringNullableFilter<"Batch"> | string | null
    status?: EnumBatchStatusFilter<"Batch"> | $Enums.BatchStatus
    rejectionRemarks?: StringNullableFilter<"Batch"> | string | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
    ActivityLog?: ActivityLogListRelationFilter
    User_Batch_checkerIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    User_Batch_makerIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    Notification?: NotificationListRelationFilter
    standards?: StandardListRelationFilter
    methodologies?: MethodologyListRelationFilter
    unitOfMeasurements?: UnitOfMeasurementListRelationFilter
    parameterValues?: BatchParameterValueListRelationFilter
  }, "id" | "batchNumber">

  export type BatchOrderByWithAggregationInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    productId?: SortOrder
    dateOfProduction?: SortOrder
    bestBeforeDate?: SortOrder
    sampleAnalysisStarted?: SortOrderInput | SortOrder
    sampleAnalysisCompleted?: SortOrderInput | SortOrder
    sampleAnalysisStatus?: SortOrder
    makerId?: SortOrder
    checkerId?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionRemarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BatchCountOrderByAggregateInput
    _max?: BatchMaxOrderByAggregateInput
    _min?: BatchMinOrderByAggregateInput
  }

  export type BatchScalarWhereWithAggregatesInput = {
    AND?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    OR?: BatchScalarWhereWithAggregatesInput[]
    NOT?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Batch"> | string
    batchNumber?: StringWithAggregatesFilter<"Batch"> | string
    productId?: StringWithAggregatesFilter<"Batch"> | string
    dateOfProduction?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    bestBeforeDate?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    sampleAnalysisStarted?: DateTimeNullableWithAggregatesFilter<"Batch"> | Date | string | null
    sampleAnalysisCompleted?: DateTimeNullableWithAggregatesFilter<"Batch"> | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusWithAggregatesFilter<"Batch"> | $Enums.SampleAnalysisStatus
    makerId?: StringWithAggregatesFilter<"Batch"> | string
    checkerId?: StringNullableWithAggregatesFilter<"Batch"> | string | null
    status?: EnumBatchStatusWithAggregatesFilter<"Batch"> | $Enums.BatchStatus
    rejectionRemarks?: StringNullableWithAggregatesFilter<"Batch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
  }

  export type ExportLogWhereInput = {
    AND?: ExportLogWhereInput | ExportLogWhereInput[]
    OR?: ExportLogWhereInput[]
    NOT?: ExportLogWhereInput | ExportLogWhereInput[]
    id?: StringFilter<"ExportLog"> | string
    fileName?: StringFilter<"ExportLog"> | string
    exportType?: StringFilter<"ExportLog"> | string
    exportedBy?: StringFilter<"ExportLog"> | string
    exportedAt?: DateTimeFilter<"ExportLog"> | Date | string
  }

  export type ExportLogOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    exportType?: SortOrder
    exportedBy?: SortOrder
    exportedAt?: SortOrder
  }

  export type ExportLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExportLogWhereInput | ExportLogWhereInput[]
    OR?: ExportLogWhereInput[]
    NOT?: ExportLogWhereInput | ExportLogWhereInput[]
    fileName?: StringFilter<"ExportLog"> | string
    exportType?: StringFilter<"ExportLog"> | string
    exportedBy?: StringFilter<"ExportLog"> | string
    exportedAt?: DateTimeFilter<"ExportLog"> | Date | string
  }, "id">

  export type ExportLogOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    exportType?: SortOrder
    exportedBy?: SortOrder
    exportedAt?: SortOrder
    _count?: ExportLogCountOrderByAggregateInput
    _max?: ExportLogMaxOrderByAggregateInput
    _min?: ExportLogMinOrderByAggregateInput
  }

  export type ExportLogScalarWhereWithAggregatesInput = {
    AND?: ExportLogScalarWhereWithAggregatesInput | ExportLogScalarWhereWithAggregatesInput[]
    OR?: ExportLogScalarWhereWithAggregatesInput[]
    NOT?: ExportLogScalarWhereWithAggregatesInput | ExportLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExportLog"> | string
    fileName?: StringWithAggregatesFilter<"ExportLog"> | string
    exportType?: StringWithAggregatesFilter<"ExportLog"> | string
    exportedBy?: StringWithAggregatesFilter<"ExportLog"> | string
    exportedAt?: DateTimeWithAggregatesFilter<"ExportLog"> | Date | string
  }

  export type MethodologyWhereInput = {
    AND?: MethodologyWhereInput | MethodologyWhereInput[]
    OR?: MethodologyWhereInput[]
    NOT?: MethodologyWhereInput | MethodologyWhereInput[]
    id?: StringFilter<"Methodology"> | string
    name?: StringFilter<"Methodology"> | string
    description?: StringFilter<"Methodology"> | string
    procedure?: StringFilter<"Methodology"> | string
    createdAt?: DateTimeFilter<"Methodology"> | Date | string
    updatedAt?: DateTimeFilter<"Methodology"> | Date | string
    Standards?: StandardListRelationFilter
    batches?: BatchListRelationFilter
    batchParameterValues?: BatchParameterValueListRelationFilter
    standardDefinitions?: StandardDefinitionListRelationFilter
  }

  export type MethodologyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    procedure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Standards?: StandardOrderByRelationAggregateInput
    batches?: BatchOrderByRelationAggregateInput
    batchParameterValues?: BatchParameterValueOrderByRelationAggregateInput
    standardDefinitions?: StandardDefinitionOrderByRelationAggregateInput
  }

  export type MethodologyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MethodologyWhereInput | MethodologyWhereInput[]
    OR?: MethodologyWhereInput[]
    NOT?: MethodologyWhereInput | MethodologyWhereInput[]
    description?: StringFilter<"Methodology"> | string
    procedure?: StringFilter<"Methodology"> | string
    createdAt?: DateTimeFilter<"Methodology"> | Date | string
    updatedAt?: DateTimeFilter<"Methodology"> | Date | string
    Standards?: StandardListRelationFilter
    batches?: BatchListRelationFilter
    batchParameterValues?: BatchParameterValueListRelationFilter
    standardDefinitions?: StandardDefinitionListRelationFilter
  }, "id" | "name">

  export type MethodologyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    procedure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MethodologyCountOrderByAggregateInput
    _max?: MethodologyMaxOrderByAggregateInput
    _min?: MethodologyMinOrderByAggregateInput
  }

  export type MethodologyScalarWhereWithAggregatesInput = {
    AND?: MethodologyScalarWhereWithAggregatesInput | MethodologyScalarWhereWithAggregatesInput[]
    OR?: MethodologyScalarWhereWithAggregatesInput[]
    NOT?: MethodologyScalarWhereWithAggregatesInput | MethodologyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Methodology"> | string
    name?: StringWithAggregatesFilter<"Methodology"> | string
    description?: StringWithAggregatesFilter<"Methodology"> | string
    procedure?: StringWithAggregatesFilter<"Methodology"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Methodology"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Methodology"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    batchId?: StringNullableFilter<"Notification"> | string | null
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    Batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    Batch?: BatchOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    batchId?: StringNullableFilter<"Notification"> | string | null
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    Batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    batchId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    Role?: RoleListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Role?: RoleOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    action_resource?: PermissionActionResourceCompoundUniqueInput
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    action?: StringFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    Role?: RoleListRelationFilter
  }, "id" | "action_resource">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    resource?: StringWithAggregatesFilter<"Permission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    code?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    Batch?: BatchListRelationFilter
    standardCategories?: ProductStandardCategoryListRelationFilter
    parameters?: ProductParameterListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Batch?: BatchOrderByRelationAggregateInput
    standardCategories?: ProductStandardCategoryOrderByRelationAggregateInput
    parameters?: ProductParameterOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    Batch?: BatchListRelationFilter
    standardCategories?: ProductStandardCategoryListRelationFilter
    parameters?: ProductParameterListRelationFilter
  }, "id" | "name" | "code">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    code?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductParameterWhereInput = {
    AND?: ProductParameterWhereInput | ProductParameterWhereInput[]
    OR?: ProductParameterWhereInput[]
    NOT?: ProductParameterWhereInput | ProductParameterWhereInput[]
    id?: StringFilter<"ProductParameter"> | string
    productId?: StringFilter<"ProductParameter"> | string
    parameterId?: StringFilter<"ProductParameter"> | string
    isRequired?: BoolFilter<"ProductParameter"> | boolean
    createdAt?: DateTimeFilter<"ProductParameter"> | Date | string
    updatedAt?: DateTimeFilter<"ProductParameter"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    parameter?: XOR<StandardParameterScalarRelationFilter, StandardParameterWhereInput>
  }

  export type ProductParameterOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    parameterId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    parameter?: StandardParameterOrderByWithRelationInput
  }

  export type ProductParameterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_parameterId?: ProductParameterProductIdParameterIdCompoundUniqueInput
    AND?: ProductParameterWhereInput | ProductParameterWhereInput[]
    OR?: ProductParameterWhereInput[]
    NOT?: ProductParameterWhereInput | ProductParameterWhereInput[]
    productId?: StringFilter<"ProductParameter"> | string
    parameterId?: StringFilter<"ProductParameter"> | string
    isRequired?: BoolFilter<"ProductParameter"> | boolean
    createdAt?: DateTimeFilter<"ProductParameter"> | Date | string
    updatedAt?: DateTimeFilter<"ProductParameter"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    parameter?: XOR<StandardParameterScalarRelationFilter, StandardParameterWhereInput>
  }, "id" | "productId_parameterId">

  export type ProductParameterOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    parameterId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductParameterCountOrderByAggregateInput
    _max?: ProductParameterMaxOrderByAggregateInput
    _min?: ProductParameterMinOrderByAggregateInput
  }

  export type ProductParameterScalarWhereWithAggregatesInput = {
    AND?: ProductParameterScalarWhereWithAggregatesInput | ProductParameterScalarWhereWithAggregatesInput[]
    OR?: ProductParameterScalarWhereWithAggregatesInput[]
    NOT?: ProductParameterScalarWhereWithAggregatesInput | ProductParameterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductParameter"> | string
    productId?: StringWithAggregatesFilter<"ProductParameter"> | string
    parameterId?: StringWithAggregatesFilter<"ProductParameter"> | string
    isRequired?: BoolWithAggregatesFilter<"ProductParameter"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductParameter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductParameter"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    User?: UserListRelationFilter
    Permission?: PermissionListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByRelationAggregateInput
    Permission?: PermissionOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    User?: UserListRelationFilter
    Permission?: PermissionListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type UnitOfMeasurementWhereInput = {
    AND?: UnitOfMeasurementWhereInput | UnitOfMeasurementWhereInput[]
    OR?: UnitOfMeasurementWhereInput[]
    NOT?: UnitOfMeasurementWhereInput | UnitOfMeasurementWhereInput[]
    id?: StringFilter<"UnitOfMeasurement"> | string
    name?: StringFilter<"UnitOfMeasurement"> | string
    symbol?: StringFilter<"UnitOfMeasurement"> | string
    description?: StringNullableFilter<"UnitOfMeasurement"> | string | null
    createdAt?: DateTimeFilter<"UnitOfMeasurement"> | Date | string
    updatedAt?: DateTimeFilter<"UnitOfMeasurement"> | Date | string
    Standards?: StandardListRelationFilter
    batchParameterValues?: BatchParameterValueListRelationFilter
    standardParameters?: StandardParameterListRelationFilter
    standardDefinitions?: StandardDefinitionListRelationFilter
    batches?: BatchListRelationFilter
  }

  export type UnitOfMeasurementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Standards?: StandardOrderByRelationAggregateInput
    batchParameterValues?: BatchParameterValueOrderByRelationAggregateInput
    standardParameters?: StandardParameterOrderByRelationAggregateInput
    standardDefinitions?: StandardDefinitionOrderByRelationAggregateInput
    batches?: BatchOrderByRelationAggregateInput
  }

  export type UnitOfMeasurementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: UnitOfMeasurementWhereInput | UnitOfMeasurementWhereInput[]
    OR?: UnitOfMeasurementWhereInput[]
    NOT?: UnitOfMeasurementWhereInput | UnitOfMeasurementWhereInput[]
    symbol?: StringFilter<"UnitOfMeasurement"> | string
    description?: StringNullableFilter<"UnitOfMeasurement"> | string | null
    createdAt?: DateTimeFilter<"UnitOfMeasurement"> | Date | string
    updatedAt?: DateTimeFilter<"UnitOfMeasurement"> | Date | string
    Standards?: StandardListRelationFilter
    batchParameterValues?: BatchParameterValueListRelationFilter
    standardParameters?: StandardParameterListRelationFilter
    standardDefinitions?: StandardDefinitionListRelationFilter
    batches?: BatchListRelationFilter
  }, "id" | "name">

  export type UnitOfMeasurementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitOfMeasurementCountOrderByAggregateInput
    _max?: UnitOfMeasurementMaxOrderByAggregateInput
    _min?: UnitOfMeasurementMinOrderByAggregateInput
  }

  export type UnitOfMeasurementScalarWhereWithAggregatesInput = {
    AND?: UnitOfMeasurementScalarWhereWithAggregatesInput | UnitOfMeasurementScalarWhereWithAggregatesInput[]
    OR?: UnitOfMeasurementScalarWhereWithAggregatesInput[]
    NOT?: UnitOfMeasurementScalarWhereWithAggregatesInput | UnitOfMeasurementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitOfMeasurement"> | string
    name?: StringWithAggregatesFilter<"UnitOfMeasurement"> | string
    symbol?: StringWithAggregatesFilter<"UnitOfMeasurement"> | string
    description?: StringNullableWithAggregatesFilter<"UnitOfMeasurement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UnitOfMeasurement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitOfMeasurement"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    ActivityLog?: ActivityLogListRelationFilter
    Batch_Batch_checkerIdToUser?: BatchListRelationFilter
    Batch_Batch_makerIdToUser?: BatchListRelationFilter
    Notification?: NotificationListRelationFilter
    Role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    StandardsCreated?: StandardListRelationFilter
    StandardsModified?: StandardListRelationFilter
    standardDefinitionsCreated?: StandardDefinitionListRelationFilter
    standardDefinitionsModified?: StandardDefinitionListRelationFilter
    trainerTrainings?: TrainingListRelationFilter
    createdTrainings?: TrainingListRelationFilter
    uploadedDocuments?: TrainingDocumentListRelationFilter
    uploadedPhotos?: TrainingPhotoListRelationFilter
    assignedFollowups?: TrainingFollowupListRelationFilter
    createdFollowups?: TrainingFollowupListRelationFilter
    trainingNotifications?: TrainingNotificationListRelationFilter
    auditorProfile?: XOR<AuditorNullableScalarRelationFilter, AuditorWhereInput> | null
    auditeeAudits?: AuditListRelationFilter
    createdAudits?: AuditListRelationFilter
    assignedFindings?: FindingListRelationFilter
    assignedActions?: CorrectiveActionListRelationFilter
    verifiedActions?: CorrectiveActionListRelationFilter
    uploadedAuditDocuments?: AuditDocumentListRelationFilter
    createdReminders?: AuditReminderListRelationFilter
    receivedReminders?: AuditReminderListRelationFilter
    auditNotifications?: AuditNotificationListRelationFilter
    responsibleForChecklistItems?: PreAuditChecklistItemListRelationFilter
    createdChecklistItems?: PreAuditChecklistItemListRelationFilter
    inspectedItems?: AuditInspectionItemListRelationFilter
    uploadedFeedbackForms?: FeedbackFormListRelationFilter
    uploadedSessionPhotos?: TrainingSessionPhotoListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ActivityLog?: ActivityLogOrderByRelationAggregateInput
    Batch_Batch_checkerIdToUser?: BatchOrderByRelationAggregateInput
    Batch_Batch_makerIdToUser?: BatchOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    Role?: RoleOrderByWithRelationInput
    StandardsCreated?: StandardOrderByRelationAggregateInput
    StandardsModified?: StandardOrderByRelationAggregateInput
    standardDefinitionsCreated?: StandardDefinitionOrderByRelationAggregateInput
    standardDefinitionsModified?: StandardDefinitionOrderByRelationAggregateInput
    trainerTrainings?: TrainingOrderByRelationAggregateInput
    createdTrainings?: TrainingOrderByRelationAggregateInput
    uploadedDocuments?: TrainingDocumentOrderByRelationAggregateInput
    uploadedPhotos?: TrainingPhotoOrderByRelationAggregateInput
    assignedFollowups?: TrainingFollowupOrderByRelationAggregateInput
    createdFollowups?: TrainingFollowupOrderByRelationAggregateInput
    trainingNotifications?: TrainingNotificationOrderByRelationAggregateInput
    auditorProfile?: AuditorOrderByWithRelationInput
    auditeeAudits?: AuditOrderByRelationAggregateInput
    createdAudits?: AuditOrderByRelationAggregateInput
    assignedFindings?: FindingOrderByRelationAggregateInput
    assignedActions?: CorrectiveActionOrderByRelationAggregateInput
    verifiedActions?: CorrectiveActionOrderByRelationAggregateInput
    uploadedAuditDocuments?: AuditDocumentOrderByRelationAggregateInput
    createdReminders?: AuditReminderOrderByRelationAggregateInput
    receivedReminders?: AuditReminderOrderByRelationAggregateInput
    auditNotifications?: AuditNotificationOrderByRelationAggregateInput
    responsibleForChecklistItems?: PreAuditChecklistItemOrderByRelationAggregateInput
    createdChecklistItems?: PreAuditChecklistItemOrderByRelationAggregateInput
    inspectedItems?: AuditInspectionItemOrderByRelationAggregateInput
    uploadedFeedbackForms?: FeedbackFormOrderByRelationAggregateInput
    uploadedSessionPhotos?: TrainingSessionPhotoOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    ActivityLog?: ActivityLogListRelationFilter
    Batch_Batch_checkerIdToUser?: BatchListRelationFilter
    Batch_Batch_makerIdToUser?: BatchListRelationFilter
    Notification?: NotificationListRelationFilter
    Role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    StandardsCreated?: StandardListRelationFilter
    StandardsModified?: StandardListRelationFilter
    standardDefinitionsCreated?: StandardDefinitionListRelationFilter
    standardDefinitionsModified?: StandardDefinitionListRelationFilter
    trainerTrainings?: TrainingListRelationFilter
    createdTrainings?: TrainingListRelationFilter
    uploadedDocuments?: TrainingDocumentListRelationFilter
    uploadedPhotos?: TrainingPhotoListRelationFilter
    assignedFollowups?: TrainingFollowupListRelationFilter
    createdFollowups?: TrainingFollowupListRelationFilter
    trainingNotifications?: TrainingNotificationListRelationFilter
    auditorProfile?: XOR<AuditorNullableScalarRelationFilter, AuditorWhereInput> | null
    auditeeAudits?: AuditListRelationFilter
    createdAudits?: AuditListRelationFilter
    assignedFindings?: FindingListRelationFilter
    assignedActions?: CorrectiveActionListRelationFilter
    verifiedActions?: CorrectiveActionListRelationFilter
    uploadedAuditDocuments?: AuditDocumentListRelationFilter
    createdReminders?: AuditReminderListRelationFilter
    receivedReminders?: AuditReminderListRelationFilter
    auditNotifications?: AuditNotificationListRelationFilter
    responsibleForChecklistItems?: PreAuditChecklistItemListRelationFilter
    createdChecklistItems?: PreAuditChecklistItemListRelationFilter
    inspectedItems?: AuditInspectionItemListRelationFilter
    uploadedFeedbackForms?: FeedbackFormListRelationFilter
    uploadedSessionPhotos?: TrainingSessionPhotoListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    roleId?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type StandardWhereInput = {
    AND?: StandardWhereInput | StandardWhereInput[]
    OR?: StandardWhereInput[]
    NOT?: StandardWhereInput | StandardWhereInput[]
    id?: StringFilter<"Standard"> | string
    name?: StringFilter<"Standard"> | string
    code?: StringFilter<"Standard"> | string
    description?: StringFilter<"Standard"> | string
    categoryId?: StringFilter<"Standard"> | string
    createdById?: StringFilter<"Standard"> | string
    modifiedById?: StringNullableFilter<"Standard"> | string | null
    status?: EnumStandardStatusFilter<"Standard"> | $Enums.StandardStatus
    createdAt?: DateTimeFilter<"Standard"> | Date | string
    updatedAt?: DateTimeFilter<"Standard"> | Date | string
    Category?: XOR<StandardCategoryScalarRelationFilter, StandardCategoryWhereInput>
    CreatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ModifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    batches?: BatchListRelationFilter
    methodologies?: MethodologyListRelationFilter
    units?: UnitOfMeasurementListRelationFilter
  }

  export type StandardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Category?: StandardCategoryOrderByWithRelationInput
    CreatedBy?: UserOrderByWithRelationInput
    ModifiedBy?: UserOrderByWithRelationInput
    batches?: BatchOrderByRelationAggregateInput
    methodologies?: MethodologyOrderByRelationAggregateInput
    units?: UnitOfMeasurementOrderByRelationAggregateInput
  }

  export type StandardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: StandardWhereInput | StandardWhereInput[]
    OR?: StandardWhereInput[]
    NOT?: StandardWhereInput | StandardWhereInput[]
    description?: StringFilter<"Standard"> | string
    categoryId?: StringFilter<"Standard"> | string
    createdById?: StringFilter<"Standard"> | string
    modifiedById?: StringNullableFilter<"Standard"> | string | null
    status?: EnumStandardStatusFilter<"Standard"> | $Enums.StandardStatus
    createdAt?: DateTimeFilter<"Standard"> | Date | string
    updatedAt?: DateTimeFilter<"Standard"> | Date | string
    Category?: XOR<StandardCategoryScalarRelationFilter, StandardCategoryWhereInput>
    CreatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ModifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    batches?: BatchListRelationFilter
    methodologies?: MethodologyListRelationFilter
    units?: UnitOfMeasurementListRelationFilter
  }, "id" | "name" | "code">

  export type StandardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StandardCountOrderByAggregateInput
    _max?: StandardMaxOrderByAggregateInput
    _min?: StandardMinOrderByAggregateInput
  }

  export type StandardScalarWhereWithAggregatesInput = {
    AND?: StandardScalarWhereWithAggregatesInput | StandardScalarWhereWithAggregatesInput[]
    OR?: StandardScalarWhereWithAggregatesInput[]
    NOT?: StandardScalarWhereWithAggregatesInput | StandardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Standard"> | string
    name?: StringWithAggregatesFilter<"Standard"> | string
    code?: StringWithAggregatesFilter<"Standard"> | string
    description?: StringWithAggregatesFilter<"Standard"> | string
    categoryId?: StringWithAggregatesFilter<"Standard"> | string
    createdById?: StringWithAggregatesFilter<"Standard"> | string
    modifiedById?: StringNullableWithAggregatesFilter<"Standard"> | string | null
    status?: EnumStandardStatusWithAggregatesFilter<"Standard"> | $Enums.StandardStatus
    createdAt?: DateTimeWithAggregatesFilter<"Standard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Standard"> | Date | string
  }

  export type StandardCategoryWhereInput = {
    AND?: StandardCategoryWhereInput | StandardCategoryWhereInput[]
    OR?: StandardCategoryWhereInput[]
    NOT?: StandardCategoryWhereInput | StandardCategoryWhereInput[]
    id?: StringFilter<"StandardCategory"> | string
    name?: StringFilter<"StandardCategory"> | string
    description?: StringNullableFilter<"StandardCategory"> | string | null
    createdAt?: DateTimeFilter<"StandardCategory"> | Date | string
    updatedAt?: DateTimeFilter<"StandardCategory"> | Date | string
    parameters?: StandardParameterListRelationFilter
    Standards?: StandardListRelationFilter
    products?: ProductStandardCategoryListRelationFilter
  }

  export type StandardCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parameters?: StandardParameterOrderByRelationAggregateInput
    Standards?: StandardOrderByRelationAggregateInput
    products?: ProductStandardCategoryOrderByRelationAggregateInput
  }

  export type StandardCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: StandardCategoryWhereInput | StandardCategoryWhereInput[]
    OR?: StandardCategoryWhereInput[]
    NOT?: StandardCategoryWhereInput | StandardCategoryWhereInput[]
    description?: StringNullableFilter<"StandardCategory"> | string | null
    createdAt?: DateTimeFilter<"StandardCategory"> | Date | string
    updatedAt?: DateTimeFilter<"StandardCategory"> | Date | string
    parameters?: StandardParameterListRelationFilter
    Standards?: StandardListRelationFilter
    products?: ProductStandardCategoryListRelationFilter
  }, "id" | "name">

  export type StandardCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StandardCategoryCountOrderByAggregateInput
    _max?: StandardCategoryMaxOrderByAggregateInput
    _min?: StandardCategoryMinOrderByAggregateInput
  }

  export type StandardCategoryScalarWhereWithAggregatesInput = {
    AND?: StandardCategoryScalarWhereWithAggregatesInput | StandardCategoryScalarWhereWithAggregatesInput[]
    OR?: StandardCategoryScalarWhereWithAggregatesInput[]
    NOT?: StandardCategoryScalarWhereWithAggregatesInput | StandardCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StandardCategory"> | string
    name?: StringWithAggregatesFilter<"StandardCategory"> | string
    description?: StringNullableWithAggregatesFilter<"StandardCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StandardCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StandardCategory"> | Date | string
  }

  export type ProductStandardCategoryWhereInput = {
    AND?: ProductStandardCategoryWhereInput | ProductStandardCategoryWhereInput[]
    OR?: ProductStandardCategoryWhereInput[]
    NOT?: ProductStandardCategoryWhereInput | ProductStandardCategoryWhereInput[]
    id?: StringFilter<"ProductStandardCategory"> | string
    productId?: StringFilter<"ProductStandardCategory"> | string
    categoryId?: StringFilter<"ProductStandardCategory"> | string
    createdAt?: DateTimeFilter<"ProductStandardCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductStandardCategory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    category?: XOR<StandardCategoryScalarRelationFilter, StandardCategoryWhereInput>
  }

  export type ProductStandardCategoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    category?: StandardCategoryOrderByWithRelationInput
  }

  export type ProductStandardCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_categoryId?: ProductStandardCategoryProductIdCategoryIdCompoundUniqueInput
    AND?: ProductStandardCategoryWhereInput | ProductStandardCategoryWhereInput[]
    OR?: ProductStandardCategoryWhereInput[]
    NOT?: ProductStandardCategoryWhereInput | ProductStandardCategoryWhereInput[]
    productId?: StringFilter<"ProductStandardCategory"> | string
    categoryId?: StringFilter<"ProductStandardCategory"> | string
    createdAt?: DateTimeFilter<"ProductStandardCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductStandardCategory"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    category?: XOR<StandardCategoryScalarRelationFilter, StandardCategoryWhereInput>
  }, "id" | "productId_categoryId">

  export type ProductStandardCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductStandardCategoryCountOrderByAggregateInput
    _max?: ProductStandardCategoryMaxOrderByAggregateInput
    _min?: ProductStandardCategoryMinOrderByAggregateInput
  }

  export type ProductStandardCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductStandardCategoryScalarWhereWithAggregatesInput | ProductStandardCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductStandardCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductStandardCategoryScalarWhereWithAggregatesInput | ProductStandardCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductStandardCategory"> | string
    productId?: StringWithAggregatesFilter<"ProductStandardCategory"> | string
    categoryId?: StringWithAggregatesFilter<"ProductStandardCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductStandardCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductStandardCategory"> | Date | string
  }

  export type StandardParameterWhereInput = {
    AND?: StandardParameterWhereInput | StandardParameterWhereInput[]
    OR?: StandardParameterWhereInput[]
    NOT?: StandardParameterWhereInput | StandardParameterWhereInput[]
    id?: StringFilter<"StandardParameter"> | string
    name?: StringFilter<"StandardParameter"> | string
    categoryId?: StringFilter<"StandardParameter"> | string
    unitId?: StringNullableFilter<"StandardParameter"> | string | null
    productType?: StringNullableFilter<"StandardParameter"> | string | null
    description?: StringNullableFilter<"StandardParameter"> | string | null
    dataType?: EnumParameterDataTypeFilter<"StandardParameter"> | $Enums.ParameterDataType
    createdAt?: DateTimeFilter<"StandardParameter"> | Date | string
    updatedAt?: DateTimeFilter<"StandardParameter"> | Date | string
    category?: XOR<StandardCategoryScalarRelationFilter, StandardCategoryWhereInput>
    batchValues?: BatchParameterValueListRelationFilter
    unit?: XOR<UnitOfMeasurementNullableScalarRelationFilter, UnitOfMeasurementWhereInput> | null
    standards?: StandardDefinitionListRelationFilter
    products?: ProductParameterListRelationFilter
  }

  export type StandardParameterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrderInput | SortOrder
    productType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    dataType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: StandardCategoryOrderByWithRelationInput
    batchValues?: BatchParameterValueOrderByRelationAggregateInput
    unit?: UnitOfMeasurementOrderByWithRelationInput
    standards?: StandardDefinitionOrderByRelationAggregateInput
    products?: ProductParameterOrderByRelationAggregateInput
  }

  export type StandardParameterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_categoryId_productType?: StandardParameterNameCategoryIdProductTypeCompoundUniqueInput
    AND?: StandardParameterWhereInput | StandardParameterWhereInput[]
    OR?: StandardParameterWhereInput[]
    NOT?: StandardParameterWhereInput | StandardParameterWhereInput[]
    name?: StringFilter<"StandardParameter"> | string
    categoryId?: StringFilter<"StandardParameter"> | string
    unitId?: StringNullableFilter<"StandardParameter"> | string | null
    productType?: StringNullableFilter<"StandardParameter"> | string | null
    description?: StringNullableFilter<"StandardParameter"> | string | null
    dataType?: EnumParameterDataTypeFilter<"StandardParameter"> | $Enums.ParameterDataType
    createdAt?: DateTimeFilter<"StandardParameter"> | Date | string
    updatedAt?: DateTimeFilter<"StandardParameter"> | Date | string
    category?: XOR<StandardCategoryScalarRelationFilter, StandardCategoryWhereInput>
    batchValues?: BatchParameterValueListRelationFilter
    unit?: XOR<UnitOfMeasurementNullableScalarRelationFilter, UnitOfMeasurementWhereInput> | null
    standards?: StandardDefinitionListRelationFilter
    products?: ProductParameterListRelationFilter
  }, "id" | "name_categoryId_productType">

  export type StandardParameterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrderInput | SortOrder
    productType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    dataType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StandardParameterCountOrderByAggregateInput
    _max?: StandardParameterMaxOrderByAggregateInput
    _min?: StandardParameterMinOrderByAggregateInput
  }

  export type StandardParameterScalarWhereWithAggregatesInput = {
    AND?: StandardParameterScalarWhereWithAggregatesInput | StandardParameterScalarWhereWithAggregatesInput[]
    OR?: StandardParameterScalarWhereWithAggregatesInput[]
    NOT?: StandardParameterScalarWhereWithAggregatesInput | StandardParameterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StandardParameter"> | string
    name?: StringWithAggregatesFilter<"StandardParameter"> | string
    categoryId?: StringWithAggregatesFilter<"StandardParameter"> | string
    unitId?: StringNullableWithAggregatesFilter<"StandardParameter"> | string | null
    productType?: StringNullableWithAggregatesFilter<"StandardParameter"> | string | null
    description?: StringNullableWithAggregatesFilter<"StandardParameter"> | string | null
    dataType?: EnumParameterDataTypeWithAggregatesFilter<"StandardParameter"> | $Enums.ParameterDataType
    createdAt?: DateTimeWithAggregatesFilter<"StandardParameter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StandardParameter"> | Date | string
  }

  export type StandardDefinitionWhereInput = {
    AND?: StandardDefinitionWhereInput | StandardDefinitionWhereInput[]
    OR?: StandardDefinitionWhereInput[]
    NOT?: StandardDefinitionWhereInput | StandardDefinitionWhereInput[]
    id?: StringFilter<"StandardDefinition"> | string
    parameterId?: StringFilter<"StandardDefinition"> | string
    standardValue?: StringFilter<"StandardDefinition"> | string
    unitId?: StringNullableFilter<"StandardDefinition"> | string | null
    methodologyId?: StringNullableFilter<"StandardDefinition"> | string | null
    createdById?: StringFilter<"StandardDefinition"> | string
    modifiedById?: StringNullableFilter<"StandardDefinition"> | string | null
    status?: EnumStandardStatusFilter<"StandardDefinition"> | $Enums.StandardStatus
    createdAt?: DateTimeFilter<"StandardDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"StandardDefinition"> | Date | string
    parameter?: XOR<StandardParameterScalarRelationFilter, StandardParameterWhereInput>
    unit?: XOR<UnitOfMeasurementNullableScalarRelationFilter, UnitOfMeasurementWhereInput> | null
    methodology?: XOR<MethodologyNullableScalarRelationFilter, MethodologyWhereInput> | null
    CreatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ModifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type StandardDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    parameterId?: SortOrder
    standardValue?: SortOrder
    unitId?: SortOrderInput | SortOrder
    methodologyId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parameter?: StandardParameterOrderByWithRelationInput
    unit?: UnitOfMeasurementOrderByWithRelationInput
    methodology?: MethodologyOrderByWithRelationInput
    CreatedBy?: UserOrderByWithRelationInput
    ModifiedBy?: UserOrderByWithRelationInput
  }

  export type StandardDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StandardDefinitionWhereInput | StandardDefinitionWhereInput[]
    OR?: StandardDefinitionWhereInput[]
    NOT?: StandardDefinitionWhereInput | StandardDefinitionWhereInput[]
    parameterId?: StringFilter<"StandardDefinition"> | string
    standardValue?: StringFilter<"StandardDefinition"> | string
    unitId?: StringNullableFilter<"StandardDefinition"> | string | null
    methodologyId?: StringNullableFilter<"StandardDefinition"> | string | null
    createdById?: StringFilter<"StandardDefinition"> | string
    modifiedById?: StringNullableFilter<"StandardDefinition"> | string | null
    status?: EnumStandardStatusFilter<"StandardDefinition"> | $Enums.StandardStatus
    createdAt?: DateTimeFilter<"StandardDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"StandardDefinition"> | Date | string
    parameter?: XOR<StandardParameterScalarRelationFilter, StandardParameterWhereInput>
    unit?: XOR<UnitOfMeasurementNullableScalarRelationFilter, UnitOfMeasurementWhereInput> | null
    methodology?: XOR<MethodologyNullableScalarRelationFilter, MethodologyWhereInput> | null
    CreatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ModifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type StandardDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    parameterId?: SortOrder
    standardValue?: SortOrder
    unitId?: SortOrderInput | SortOrder
    methodologyId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StandardDefinitionCountOrderByAggregateInput
    _max?: StandardDefinitionMaxOrderByAggregateInput
    _min?: StandardDefinitionMinOrderByAggregateInput
  }

  export type StandardDefinitionScalarWhereWithAggregatesInput = {
    AND?: StandardDefinitionScalarWhereWithAggregatesInput | StandardDefinitionScalarWhereWithAggregatesInput[]
    OR?: StandardDefinitionScalarWhereWithAggregatesInput[]
    NOT?: StandardDefinitionScalarWhereWithAggregatesInput | StandardDefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StandardDefinition"> | string
    parameterId?: StringWithAggregatesFilter<"StandardDefinition"> | string
    standardValue?: StringWithAggregatesFilter<"StandardDefinition"> | string
    unitId?: StringNullableWithAggregatesFilter<"StandardDefinition"> | string | null
    methodologyId?: StringNullableWithAggregatesFilter<"StandardDefinition"> | string | null
    createdById?: StringWithAggregatesFilter<"StandardDefinition"> | string
    modifiedById?: StringNullableWithAggregatesFilter<"StandardDefinition"> | string | null
    status?: EnumStandardStatusWithAggregatesFilter<"StandardDefinition"> | $Enums.StandardStatus
    createdAt?: DateTimeWithAggregatesFilter<"StandardDefinition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StandardDefinition"> | Date | string
  }

  export type BatchParameterValueWhereInput = {
    AND?: BatchParameterValueWhereInput | BatchParameterValueWhereInput[]
    OR?: BatchParameterValueWhereInput[]
    NOT?: BatchParameterValueWhereInput | BatchParameterValueWhereInput[]
    id?: StringFilter<"BatchParameterValue"> | string
    batchId?: StringFilter<"BatchParameterValue"> | string
    parameterId?: StringFilter<"BatchParameterValue"> | string
    value?: StringFilter<"BatchParameterValue"> | string
    unitId?: StringNullableFilter<"BatchParameterValue"> | string | null
    methodologyId?: StringNullableFilter<"BatchParameterValue"> | string | null
    verificationResult?: StringNullableFilter<"BatchParameterValue"> | string | null
    verificationRemark?: StringNullableFilter<"BatchParameterValue"> | string | null
    verifiedById?: StringNullableFilter<"BatchParameterValue"> | string | null
    verifiedAt?: DateTimeNullableFilter<"BatchParameterValue"> | Date | string | null
    createdAt?: DateTimeFilter<"BatchParameterValue"> | Date | string
    updatedAt?: DateTimeFilter<"BatchParameterValue"> | Date | string
    batch?: XOR<BatchScalarRelationFilter, BatchWhereInput>
    parameter?: XOR<StandardParameterScalarRelationFilter, StandardParameterWhereInput>
    unit?: XOR<UnitOfMeasurementNullableScalarRelationFilter, UnitOfMeasurementWhereInput> | null
    methodology?: XOR<MethodologyNullableScalarRelationFilter, MethodologyWhereInput> | null
  }

  export type BatchParameterValueOrderByWithRelationInput = {
    id?: SortOrder
    batchId?: SortOrder
    parameterId?: SortOrder
    value?: SortOrder
    unitId?: SortOrderInput | SortOrder
    methodologyId?: SortOrderInput | SortOrder
    verificationResult?: SortOrderInput | SortOrder
    verificationRemark?: SortOrderInput | SortOrder
    verifiedById?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    batch?: BatchOrderByWithRelationInput
    parameter?: StandardParameterOrderByWithRelationInput
    unit?: UnitOfMeasurementOrderByWithRelationInput
    methodology?: MethodologyOrderByWithRelationInput
  }

  export type BatchParameterValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    batchId_parameterId?: BatchParameterValueBatchIdParameterIdCompoundUniqueInput
    AND?: BatchParameterValueWhereInput | BatchParameterValueWhereInput[]
    OR?: BatchParameterValueWhereInput[]
    NOT?: BatchParameterValueWhereInput | BatchParameterValueWhereInput[]
    batchId?: StringFilter<"BatchParameterValue"> | string
    parameterId?: StringFilter<"BatchParameterValue"> | string
    value?: StringFilter<"BatchParameterValue"> | string
    unitId?: StringNullableFilter<"BatchParameterValue"> | string | null
    methodologyId?: StringNullableFilter<"BatchParameterValue"> | string | null
    verificationResult?: StringNullableFilter<"BatchParameterValue"> | string | null
    verificationRemark?: StringNullableFilter<"BatchParameterValue"> | string | null
    verifiedById?: StringNullableFilter<"BatchParameterValue"> | string | null
    verifiedAt?: DateTimeNullableFilter<"BatchParameterValue"> | Date | string | null
    createdAt?: DateTimeFilter<"BatchParameterValue"> | Date | string
    updatedAt?: DateTimeFilter<"BatchParameterValue"> | Date | string
    batch?: XOR<BatchScalarRelationFilter, BatchWhereInput>
    parameter?: XOR<StandardParameterScalarRelationFilter, StandardParameterWhereInput>
    unit?: XOR<UnitOfMeasurementNullableScalarRelationFilter, UnitOfMeasurementWhereInput> | null
    methodology?: XOR<MethodologyNullableScalarRelationFilter, MethodologyWhereInput> | null
  }, "id" | "batchId_parameterId">

  export type BatchParameterValueOrderByWithAggregationInput = {
    id?: SortOrder
    batchId?: SortOrder
    parameterId?: SortOrder
    value?: SortOrder
    unitId?: SortOrderInput | SortOrder
    methodologyId?: SortOrderInput | SortOrder
    verificationResult?: SortOrderInput | SortOrder
    verificationRemark?: SortOrderInput | SortOrder
    verifiedById?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BatchParameterValueCountOrderByAggregateInput
    _max?: BatchParameterValueMaxOrderByAggregateInput
    _min?: BatchParameterValueMinOrderByAggregateInput
  }

  export type BatchParameterValueScalarWhereWithAggregatesInput = {
    AND?: BatchParameterValueScalarWhereWithAggregatesInput | BatchParameterValueScalarWhereWithAggregatesInput[]
    OR?: BatchParameterValueScalarWhereWithAggregatesInput[]
    NOT?: BatchParameterValueScalarWhereWithAggregatesInput | BatchParameterValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BatchParameterValue"> | string
    batchId?: StringWithAggregatesFilter<"BatchParameterValue"> | string
    parameterId?: StringWithAggregatesFilter<"BatchParameterValue"> | string
    value?: StringWithAggregatesFilter<"BatchParameterValue"> | string
    unitId?: StringNullableWithAggregatesFilter<"BatchParameterValue"> | string | null
    methodologyId?: StringNullableWithAggregatesFilter<"BatchParameterValue"> | string | null
    verificationResult?: StringNullableWithAggregatesFilter<"BatchParameterValue"> | string | null
    verificationRemark?: StringNullableWithAggregatesFilter<"BatchParameterValue"> | string | null
    verifiedById?: StringNullableWithAggregatesFilter<"BatchParameterValue"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"BatchParameterValue"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BatchParameterValue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BatchParameterValue"> | Date | string
  }

  export type TrainingCalendarWhereInput = {
    AND?: TrainingCalendarWhereInput | TrainingCalendarWhereInput[]
    OR?: TrainingCalendarWhereInput[]
    NOT?: TrainingCalendarWhereInput | TrainingCalendarWhereInput[]
    id?: StringFilter<"TrainingCalendar"> | string
    month?: IntFilter<"TrainingCalendar"> | number
    year?: IntFilter<"TrainingCalendar"> | number
    description?: StringNullableFilter<"TrainingCalendar"> | string | null
    createdAt?: DateTimeFilter<"TrainingCalendar"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingCalendar"> | Date | string
    trainings?: TrainingListRelationFilter
  }

  export type TrainingCalendarOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainings?: TrainingOrderByRelationAggregateInput
  }

  export type TrainingCalendarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    month_year?: TrainingCalendarMonthYearCompoundUniqueInput
    AND?: TrainingCalendarWhereInput | TrainingCalendarWhereInput[]
    OR?: TrainingCalendarWhereInput[]
    NOT?: TrainingCalendarWhereInput | TrainingCalendarWhereInput[]
    month?: IntFilter<"TrainingCalendar"> | number
    year?: IntFilter<"TrainingCalendar"> | number
    description?: StringNullableFilter<"TrainingCalendar"> | string | null
    createdAt?: DateTimeFilter<"TrainingCalendar"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingCalendar"> | Date | string
    trainings?: TrainingListRelationFilter
  }, "id" | "month_year">

  export type TrainingCalendarOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingCalendarCountOrderByAggregateInput
    _avg?: TrainingCalendarAvgOrderByAggregateInput
    _max?: TrainingCalendarMaxOrderByAggregateInput
    _min?: TrainingCalendarMinOrderByAggregateInput
    _sum?: TrainingCalendarSumOrderByAggregateInput
  }

  export type TrainingCalendarScalarWhereWithAggregatesInput = {
    AND?: TrainingCalendarScalarWhereWithAggregatesInput | TrainingCalendarScalarWhereWithAggregatesInput[]
    OR?: TrainingCalendarScalarWhereWithAggregatesInput[]
    NOT?: TrainingCalendarScalarWhereWithAggregatesInput | TrainingCalendarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingCalendar"> | string
    month?: IntWithAggregatesFilter<"TrainingCalendar"> | number
    year?: IntWithAggregatesFilter<"TrainingCalendar"> | number
    description?: StringNullableWithAggregatesFilter<"TrainingCalendar"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TrainingCalendar"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingCalendar"> | Date | string
  }

  export type TrainingWhereInput = {
    AND?: TrainingWhereInput | TrainingWhereInput[]
    OR?: TrainingWhereInput[]
    NOT?: TrainingWhereInput | TrainingWhereInput[]
    id?: StringFilter<"Training"> | string
    title?: StringFilter<"Training"> | string
    description?: StringNullableFilter<"Training"> | string | null
    trainingType?: EnumTrainingTypeFilter<"Training"> | $Enums.TrainingType
    status?: EnumTrainingStatusFilter<"Training"> | $Enums.TrainingStatus
    startDate?: DateTimeFilter<"Training"> | Date | string
    endDate?: DateTimeFilter<"Training"> | Date | string
    location?: StringFilter<"Training"> | string
    maxParticipants?: IntNullableFilter<"Training"> | number | null
    trainerId?: StringFilter<"Training"> | string
    calendarId?: StringFilter<"Training"> | string
    createdById?: StringFilter<"Training"> | string
    createdAt?: DateTimeFilter<"Training"> | Date | string
    updatedAt?: DateTimeFilter<"Training"> | Date | string
    trainer?: XOR<UserScalarRelationFilter, UserWhereInput>
    calendar?: XOR<TrainingCalendarScalarRelationFilter, TrainingCalendarWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    sessions?: TrainingSessionListRelationFilter
    documents?: TrainingDocumentListRelationFilter
    attendance?: AttendanceListRelationFilter
    participants?: TrainingParticipantListRelationFilter
    photos?: TrainingPhotoListRelationFilter
    feedback?: TrainingFeedbackListRelationFilter
    followups?: TrainingFollowupListRelationFilter
    notifications?: TrainingNotificationListRelationFilter
    inviteTokens?: TrainingInviteTokenListRelationFilter
    feedbackForms?: FeedbackFormListRelationFilter
  }

  export type TrainingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    trainingType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    trainerId?: SortOrder
    calendarId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainer?: UserOrderByWithRelationInput
    calendar?: TrainingCalendarOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    sessions?: TrainingSessionOrderByRelationAggregateInput
    documents?: TrainingDocumentOrderByRelationAggregateInput
    attendance?: AttendanceOrderByRelationAggregateInput
    participants?: TrainingParticipantOrderByRelationAggregateInput
    photos?: TrainingPhotoOrderByRelationAggregateInput
    feedback?: TrainingFeedbackOrderByRelationAggregateInput
    followups?: TrainingFollowupOrderByRelationAggregateInput
    notifications?: TrainingNotificationOrderByRelationAggregateInput
    inviteTokens?: TrainingInviteTokenOrderByRelationAggregateInput
    feedbackForms?: FeedbackFormOrderByRelationAggregateInput
  }

  export type TrainingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingWhereInput | TrainingWhereInput[]
    OR?: TrainingWhereInput[]
    NOT?: TrainingWhereInput | TrainingWhereInput[]
    title?: StringFilter<"Training"> | string
    description?: StringNullableFilter<"Training"> | string | null
    trainingType?: EnumTrainingTypeFilter<"Training"> | $Enums.TrainingType
    status?: EnumTrainingStatusFilter<"Training"> | $Enums.TrainingStatus
    startDate?: DateTimeFilter<"Training"> | Date | string
    endDate?: DateTimeFilter<"Training"> | Date | string
    location?: StringFilter<"Training"> | string
    maxParticipants?: IntNullableFilter<"Training"> | number | null
    trainerId?: StringFilter<"Training"> | string
    calendarId?: StringFilter<"Training"> | string
    createdById?: StringFilter<"Training"> | string
    createdAt?: DateTimeFilter<"Training"> | Date | string
    updatedAt?: DateTimeFilter<"Training"> | Date | string
    trainer?: XOR<UserScalarRelationFilter, UserWhereInput>
    calendar?: XOR<TrainingCalendarScalarRelationFilter, TrainingCalendarWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    sessions?: TrainingSessionListRelationFilter
    documents?: TrainingDocumentListRelationFilter
    attendance?: AttendanceListRelationFilter
    participants?: TrainingParticipantListRelationFilter
    photos?: TrainingPhotoListRelationFilter
    feedback?: TrainingFeedbackListRelationFilter
    followups?: TrainingFollowupListRelationFilter
    notifications?: TrainingNotificationListRelationFilter
    inviteTokens?: TrainingInviteTokenListRelationFilter
    feedbackForms?: FeedbackFormListRelationFilter
  }, "id">

  export type TrainingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    trainingType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    trainerId?: SortOrder
    calendarId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingCountOrderByAggregateInput
    _avg?: TrainingAvgOrderByAggregateInput
    _max?: TrainingMaxOrderByAggregateInput
    _min?: TrainingMinOrderByAggregateInput
    _sum?: TrainingSumOrderByAggregateInput
  }

  export type TrainingScalarWhereWithAggregatesInput = {
    AND?: TrainingScalarWhereWithAggregatesInput | TrainingScalarWhereWithAggregatesInput[]
    OR?: TrainingScalarWhereWithAggregatesInput[]
    NOT?: TrainingScalarWhereWithAggregatesInput | TrainingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Training"> | string
    title?: StringWithAggregatesFilter<"Training"> | string
    description?: StringNullableWithAggregatesFilter<"Training"> | string | null
    trainingType?: EnumTrainingTypeWithAggregatesFilter<"Training"> | $Enums.TrainingType
    status?: EnumTrainingStatusWithAggregatesFilter<"Training"> | $Enums.TrainingStatus
    startDate?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    location?: StringWithAggregatesFilter<"Training"> | string
    maxParticipants?: IntNullableWithAggregatesFilter<"Training"> | number | null
    trainerId?: StringWithAggregatesFilter<"Training"> | string
    calendarId?: StringWithAggregatesFilter<"Training"> | string
    createdById?: StringWithAggregatesFilter<"Training"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Training"> | Date | string
  }

  export type TrainingSessionWhereInput = {
    AND?: TrainingSessionWhereInput | TrainingSessionWhereInput[]
    OR?: TrainingSessionWhereInput[]
    NOT?: TrainingSessionWhereInput | TrainingSessionWhereInput[]
    id?: StringFilter<"TrainingSession"> | string
    trainingId?: StringFilter<"TrainingSession"> | string
    title?: StringFilter<"TrainingSession"> | string
    description?: StringNullableFilter<"TrainingSession"> | string | null
    startTime?: DateTimeFilter<"TrainingSession"> | Date | string
    endTime?: DateTimeFilter<"TrainingSession"> | Date | string
    venue?: StringFilter<"TrainingSession"> | string
    status?: EnumTrainingStatusFilter<"TrainingSession"> | $Enums.TrainingStatus
    createdAt?: DateTimeFilter<"TrainingSession"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingSession"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    attendance?: AttendanceListRelationFilter
    feedbackForms?: FeedbackFormListRelationFilter
    photos?: TrainingSessionPhotoListRelationFilter
  }

  export type TrainingSessionOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    attendance?: AttendanceOrderByRelationAggregateInput
    feedbackForms?: FeedbackFormOrderByRelationAggregateInput
    photos?: TrainingSessionPhotoOrderByRelationAggregateInput
  }

  export type TrainingSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingSessionWhereInput | TrainingSessionWhereInput[]
    OR?: TrainingSessionWhereInput[]
    NOT?: TrainingSessionWhereInput | TrainingSessionWhereInput[]
    trainingId?: StringFilter<"TrainingSession"> | string
    title?: StringFilter<"TrainingSession"> | string
    description?: StringNullableFilter<"TrainingSession"> | string | null
    startTime?: DateTimeFilter<"TrainingSession"> | Date | string
    endTime?: DateTimeFilter<"TrainingSession"> | Date | string
    venue?: StringFilter<"TrainingSession"> | string
    status?: EnumTrainingStatusFilter<"TrainingSession"> | $Enums.TrainingStatus
    createdAt?: DateTimeFilter<"TrainingSession"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingSession"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    attendance?: AttendanceListRelationFilter
    feedbackForms?: FeedbackFormListRelationFilter
    photos?: TrainingSessionPhotoListRelationFilter
  }, "id">

  export type TrainingSessionOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingSessionCountOrderByAggregateInput
    _max?: TrainingSessionMaxOrderByAggregateInput
    _min?: TrainingSessionMinOrderByAggregateInput
  }

  export type TrainingSessionScalarWhereWithAggregatesInput = {
    AND?: TrainingSessionScalarWhereWithAggregatesInput | TrainingSessionScalarWhereWithAggregatesInput[]
    OR?: TrainingSessionScalarWhereWithAggregatesInput[]
    NOT?: TrainingSessionScalarWhereWithAggregatesInput | TrainingSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingSession"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingSession"> | string
    title?: StringWithAggregatesFilter<"TrainingSession"> | string
    description?: StringNullableWithAggregatesFilter<"TrainingSession"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"TrainingSession"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"TrainingSession"> | Date | string
    venue?: StringWithAggregatesFilter<"TrainingSession"> | string
    status?: EnumTrainingStatusWithAggregatesFilter<"TrainingSession"> | $Enums.TrainingStatus
    createdAt?: DateTimeWithAggregatesFilter<"TrainingSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingSession"> | Date | string
  }

  export type TrainingDocumentWhereInput = {
    AND?: TrainingDocumentWhereInput | TrainingDocumentWhereInput[]
    OR?: TrainingDocumentWhereInput[]
    NOT?: TrainingDocumentWhereInput | TrainingDocumentWhereInput[]
    id?: StringFilter<"TrainingDocument"> | string
    trainingId?: StringFilter<"TrainingDocument"> | string
    sessionId?: StringNullableFilter<"TrainingDocument"> | string | null
    title?: StringFilter<"TrainingDocument"> | string
    description?: StringNullableFilter<"TrainingDocument"> | string | null
    fileUrl?: StringFilter<"TrainingDocument"> | string
    filePath?: StringNullableFilter<"TrainingDocument"> | string | null
    documentType?: EnumDocumentTypeFilter<"TrainingDocument"> | $Enums.DocumentType
    uploadedById?: StringFilter<"TrainingDocument"> | string
    createdAt?: DateTimeFilter<"TrainingDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDocument"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrainingDocumentOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrderInput | SortOrder
    documentType?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type TrainingDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingDocumentWhereInput | TrainingDocumentWhereInput[]
    OR?: TrainingDocumentWhereInput[]
    NOT?: TrainingDocumentWhereInput | TrainingDocumentWhereInput[]
    trainingId?: StringFilter<"TrainingDocument"> | string
    sessionId?: StringNullableFilter<"TrainingDocument"> | string | null
    title?: StringFilter<"TrainingDocument"> | string
    description?: StringNullableFilter<"TrainingDocument"> | string | null
    fileUrl?: StringFilter<"TrainingDocument"> | string
    filePath?: StringNullableFilter<"TrainingDocument"> | string | null
    documentType?: EnumDocumentTypeFilter<"TrainingDocument"> | $Enums.DocumentType
    uploadedById?: StringFilter<"TrainingDocument"> | string
    createdAt?: DateTimeFilter<"TrainingDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDocument"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TrainingDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrderInput | SortOrder
    documentType?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingDocumentCountOrderByAggregateInput
    _max?: TrainingDocumentMaxOrderByAggregateInput
    _min?: TrainingDocumentMinOrderByAggregateInput
  }

  export type TrainingDocumentScalarWhereWithAggregatesInput = {
    AND?: TrainingDocumentScalarWhereWithAggregatesInput | TrainingDocumentScalarWhereWithAggregatesInput[]
    OR?: TrainingDocumentScalarWhereWithAggregatesInput[]
    NOT?: TrainingDocumentScalarWhereWithAggregatesInput | TrainingDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingDocument"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingDocument"> | string
    sessionId?: StringNullableWithAggregatesFilter<"TrainingDocument"> | string | null
    title?: StringWithAggregatesFilter<"TrainingDocument"> | string
    description?: StringNullableWithAggregatesFilter<"TrainingDocument"> | string | null
    fileUrl?: StringWithAggregatesFilter<"TrainingDocument"> | string
    filePath?: StringNullableWithAggregatesFilter<"TrainingDocument"> | string | null
    documentType?: EnumDocumentTypeWithAggregatesFilter<"TrainingDocument"> | $Enums.DocumentType
    uploadedById?: StringWithAggregatesFilter<"TrainingDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrainingDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingDocument"> | Date | string
  }

  export type ParticipantWhereInput = {
    AND?: ParticipantWhereInput | ParticipantWhereInput[]
    OR?: ParticipantWhereInput[]
    NOT?: ParticipantWhereInput | ParticipantWhereInput[]
    id?: StringFilter<"Participant"> | string
    name?: StringFilter<"Participant"> | string
    email?: StringFilter<"Participant"> | string
    phone?: StringNullableFilter<"Participant"> | string | null
    organization?: StringNullableFilter<"Participant"> | string | null
    position?: StringNullableFilter<"Participant"> | string | null
    createdAt?: DateTimeFilter<"Participant"> | Date | string
    updatedAt?: DateTimeFilter<"Participant"> | Date | string
    trainings?: TrainingParticipantListRelationFilter
    attendances?: AttendanceListRelationFilter
    feedbacks?: TrainingFeedbackListRelationFilter
    inviteTokens?: TrainingInviteTokenListRelationFilter
    feedbackForms?: FeedbackFormListRelationFilter
  }

  export type ParticipantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainings?: TrainingParticipantOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    feedbacks?: TrainingFeedbackOrderByRelationAggregateInput
    inviteTokens?: TrainingInviteTokenOrderByRelationAggregateInput
    feedbackForms?: FeedbackFormOrderByRelationAggregateInput
  }

  export type ParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: ParticipantWhereInput | ParticipantWhereInput[]
    OR?: ParticipantWhereInput[]
    NOT?: ParticipantWhereInput | ParticipantWhereInput[]
    name?: StringFilter<"Participant"> | string
    phone?: StringNullableFilter<"Participant"> | string | null
    organization?: StringNullableFilter<"Participant"> | string | null
    position?: StringNullableFilter<"Participant"> | string | null
    createdAt?: DateTimeFilter<"Participant"> | Date | string
    updatedAt?: DateTimeFilter<"Participant"> | Date | string
    trainings?: TrainingParticipantListRelationFilter
    attendances?: AttendanceListRelationFilter
    feedbacks?: TrainingFeedbackListRelationFilter
    inviteTokens?: TrainingInviteTokenListRelationFilter
    feedbackForms?: FeedbackFormListRelationFilter
  }, "id" | "email">

  export type ParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParticipantCountOrderByAggregateInput
    _max?: ParticipantMaxOrderByAggregateInput
    _min?: ParticipantMinOrderByAggregateInput
  }

  export type ParticipantScalarWhereWithAggregatesInput = {
    AND?: ParticipantScalarWhereWithAggregatesInput | ParticipantScalarWhereWithAggregatesInput[]
    OR?: ParticipantScalarWhereWithAggregatesInput[]
    NOT?: ParticipantScalarWhereWithAggregatesInput | ParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Participant"> | string
    name?: StringWithAggregatesFilter<"Participant"> | string
    email?: StringWithAggregatesFilter<"Participant"> | string
    phone?: StringNullableWithAggregatesFilter<"Participant"> | string | null
    organization?: StringNullableWithAggregatesFilter<"Participant"> | string | null
    position?: StringNullableWithAggregatesFilter<"Participant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Participant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Participant"> | Date | string
  }

  export type TrainingParticipantWhereInput = {
    AND?: TrainingParticipantWhereInput | TrainingParticipantWhereInput[]
    OR?: TrainingParticipantWhereInput[]
    NOT?: TrainingParticipantWhereInput | TrainingParticipantWhereInput[]
    id?: StringFilter<"TrainingParticipant"> | string
    trainingId?: StringFilter<"TrainingParticipant"> | string
    participantId?: StringFilter<"TrainingParticipant"> | string
    inviteSent?: BoolFilter<"TrainingParticipant"> | boolean
    inviteSentAt?: DateTimeNullableFilter<"TrainingParticipant"> | Date | string | null
    inviteAccepted?: BoolFilter<"TrainingParticipant"> | boolean
    createdAt?: DateTimeFilter<"TrainingParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingParticipant"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    participant?: XOR<ParticipantScalarRelationFilter, ParticipantWhereInput>
  }

  export type TrainingParticipantOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrder
    inviteSent?: SortOrder
    inviteSentAt?: SortOrderInput | SortOrder
    inviteAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    participant?: ParticipantOrderByWithRelationInput
  }

  export type TrainingParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trainingId_participantId?: TrainingParticipantTrainingIdParticipantIdCompoundUniqueInput
    AND?: TrainingParticipantWhereInput | TrainingParticipantWhereInput[]
    OR?: TrainingParticipantWhereInput[]
    NOT?: TrainingParticipantWhereInput | TrainingParticipantWhereInput[]
    trainingId?: StringFilter<"TrainingParticipant"> | string
    participantId?: StringFilter<"TrainingParticipant"> | string
    inviteSent?: BoolFilter<"TrainingParticipant"> | boolean
    inviteSentAt?: DateTimeNullableFilter<"TrainingParticipant"> | Date | string | null
    inviteAccepted?: BoolFilter<"TrainingParticipant"> | boolean
    createdAt?: DateTimeFilter<"TrainingParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingParticipant"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    participant?: XOR<ParticipantScalarRelationFilter, ParticipantWhereInput>
  }, "id" | "trainingId_participantId">

  export type TrainingParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrder
    inviteSent?: SortOrder
    inviteSentAt?: SortOrderInput | SortOrder
    inviteAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingParticipantCountOrderByAggregateInput
    _max?: TrainingParticipantMaxOrderByAggregateInput
    _min?: TrainingParticipantMinOrderByAggregateInput
  }

  export type TrainingParticipantScalarWhereWithAggregatesInput = {
    AND?: TrainingParticipantScalarWhereWithAggregatesInput | TrainingParticipantScalarWhereWithAggregatesInput[]
    OR?: TrainingParticipantScalarWhereWithAggregatesInput[]
    NOT?: TrainingParticipantScalarWhereWithAggregatesInput | TrainingParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingParticipant"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingParticipant"> | string
    participantId?: StringWithAggregatesFilter<"TrainingParticipant"> | string
    inviteSent?: BoolWithAggregatesFilter<"TrainingParticipant"> | boolean
    inviteSentAt?: DateTimeNullableWithAggregatesFilter<"TrainingParticipant"> | Date | string | null
    inviteAccepted?: BoolWithAggregatesFilter<"TrainingParticipant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TrainingParticipant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingParticipant"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    trainingId?: StringFilter<"Attendance"> | string
    sessionId?: StringFilter<"Attendance"> | string
    participantId?: StringFilter<"Attendance"> | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    remarks?: StringNullableFilter<"Attendance"> | string | null
    signatureUrl?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    session?: XOR<TrainingSessionScalarRelationFilter, TrainingSessionWhereInput>
    participant?: XOR<ParticipantScalarRelationFilter, ParticipantWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    participantId?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    session?: TrainingSessionOrderByWithRelationInput
    participant?: ParticipantOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_participantId?: AttendanceSessionIdParticipantIdCompoundUniqueInput
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    trainingId?: StringFilter<"Attendance"> | string
    sessionId?: StringFilter<"Attendance"> | string
    participantId?: StringFilter<"Attendance"> | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    remarks?: StringNullableFilter<"Attendance"> | string | null
    signatureUrl?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    session?: XOR<TrainingSessionScalarRelationFilter, TrainingSessionWhereInput>
    participant?: XOR<ParticipantScalarRelationFilter, ParticipantWhereInput>
  }, "id" | "sessionId_participantId">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    participantId?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    trainingId?: StringWithAggregatesFilter<"Attendance"> | string
    sessionId?: StringWithAggregatesFilter<"Attendance"> | string
    participantId?: StringWithAggregatesFilter<"Attendance"> | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"Attendance"> | $Enums.AttendanceStatus
    remarks?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    signatureUrl?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type TrainingPhotoWhereInput = {
    AND?: TrainingPhotoWhereInput | TrainingPhotoWhereInput[]
    OR?: TrainingPhotoWhereInput[]
    NOT?: TrainingPhotoWhereInput | TrainingPhotoWhereInput[]
    id?: StringFilter<"TrainingPhoto"> | string
    trainingId?: StringFilter<"TrainingPhoto"> | string
    photoUrl?: StringFilter<"TrainingPhoto"> | string
    caption?: StringNullableFilter<"TrainingPhoto"> | string | null
    uploadedById?: StringFilter<"TrainingPhoto"> | string
    createdAt?: DateTimeFilter<"TrainingPhoto"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrainingPhotoOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type TrainingPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingPhotoWhereInput | TrainingPhotoWhereInput[]
    OR?: TrainingPhotoWhereInput[]
    NOT?: TrainingPhotoWhereInput | TrainingPhotoWhereInput[]
    trainingId?: StringFilter<"TrainingPhoto"> | string
    photoUrl?: StringFilter<"TrainingPhoto"> | string
    caption?: StringNullableFilter<"TrainingPhoto"> | string | null
    uploadedById?: StringFilter<"TrainingPhoto"> | string
    createdAt?: DateTimeFilter<"TrainingPhoto"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TrainingPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    _count?: TrainingPhotoCountOrderByAggregateInput
    _max?: TrainingPhotoMaxOrderByAggregateInput
    _min?: TrainingPhotoMinOrderByAggregateInput
  }

  export type TrainingPhotoScalarWhereWithAggregatesInput = {
    AND?: TrainingPhotoScalarWhereWithAggregatesInput | TrainingPhotoScalarWhereWithAggregatesInput[]
    OR?: TrainingPhotoScalarWhereWithAggregatesInput[]
    NOT?: TrainingPhotoScalarWhereWithAggregatesInput | TrainingPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingPhoto"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingPhoto"> | string
    photoUrl?: StringWithAggregatesFilter<"TrainingPhoto"> | string
    caption?: StringNullableWithAggregatesFilter<"TrainingPhoto"> | string | null
    uploadedById?: StringWithAggregatesFilter<"TrainingPhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrainingPhoto"> | Date | string
  }

  export type TrainingFeedbackWhereInput = {
    AND?: TrainingFeedbackWhereInput | TrainingFeedbackWhereInput[]
    OR?: TrainingFeedbackWhereInput[]
    NOT?: TrainingFeedbackWhereInput | TrainingFeedbackWhereInput[]
    id?: StringFilter<"TrainingFeedback"> | string
    trainingId?: StringFilter<"TrainingFeedback"> | string
    participantId?: StringFilter<"TrainingFeedback"> | string
    contentRating?: IntFilter<"TrainingFeedback"> | number
    trainerRating?: IntFilter<"TrainingFeedback"> | number
    materialRating?: IntFilter<"TrainingFeedback"> | number
    venueRating?: IntFilter<"TrainingFeedback"> | number
    overallRating?: IntFilter<"TrainingFeedback"> | number
    comments?: StringNullableFilter<"TrainingFeedback"> | string | null
    suggestedImprovements?: StringNullableFilter<"TrainingFeedback"> | string | null
    createdAt?: DateTimeFilter<"TrainingFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingFeedback"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    participant?: XOR<ParticipantScalarRelationFilter, ParticipantWhereInput>
  }

  export type TrainingFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrder
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
    comments?: SortOrderInput | SortOrder
    suggestedImprovements?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    participant?: ParticipantOrderByWithRelationInput
  }

  export type TrainingFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trainingId_participantId?: TrainingFeedbackTrainingIdParticipantIdCompoundUniqueInput
    AND?: TrainingFeedbackWhereInput | TrainingFeedbackWhereInput[]
    OR?: TrainingFeedbackWhereInput[]
    NOT?: TrainingFeedbackWhereInput | TrainingFeedbackWhereInput[]
    trainingId?: StringFilter<"TrainingFeedback"> | string
    participantId?: StringFilter<"TrainingFeedback"> | string
    contentRating?: IntFilter<"TrainingFeedback"> | number
    trainerRating?: IntFilter<"TrainingFeedback"> | number
    materialRating?: IntFilter<"TrainingFeedback"> | number
    venueRating?: IntFilter<"TrainingFeedback"> | number
    overallRating?: IntFilter<"TrainingFeedback"> | number
    comments?: StringNullableFilter<"TrainingFeedback"> | string | null
    suggestedImprovements?: StringNullableFilter<"TrainingFeedback"> | string | null
    createdAt?: DateTimeFilter<"TrainingFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingFeedback"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    participant?: XOR<ParticipantScalarRelationFilter, ParticipantWhereInput>
  }, "id" | "trainingId_participantId">

  export type TrainingFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrder
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
    comments?: SortOrderInput | SortOrder
    suggestedImprovements?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingFeedbackCountOrderByAggregateInput
    _avg?: TrainingFeedbackAvgOrderByAggregateInput
    _max?: TrainingFeedbackMaxOrderByAggregateInput
    _min?: TrainingFeedbackMinOrderByAggregateInput
    _sum?: TrainingFeedbackSumOrderByAggregateInput
  }

  export type TrainingFeedbackScalarWhereWithAggregatesInput = {
    AND?: TrainingFeedbackScalarWhereWithAggregatesInput | TrainingFeedbackScalarWhereWithAggregatesInput[]
    OR?: TrainingFeedbackScalarWhereWithAggregatesInput[]
    NOT?: TrainingFeedbackScalarWhereWithAggregatesInput | TrainingFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingFeedback"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingFeedback"> | string
    participantId?: StringWithAggregatesFilter<"TrainingFeedback"> | string
    contentRating?: IntWithAggregatesFilter<"TrainingFeedback"> | number
    trainerRating?: IntWithAggregatesFilter<"TrainingFeedback"> | number
    materialRating?: IntWithAggregatesFilter<"TrainingFeedback"> | number
    venueRating?: IntWithAggregatesFilter<"TrainingFeedback"> | number
    overallRating?: IntWithAggregatesFilter<"TrainingFeedback"> | number
    comments?: StringNullableWithAggregatesFilter<"TrainingFeedback"> | string | null
    suggestedImprovements?: StringNullableWithAggregatesFilter<"TrainingFeedback"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TrainingFeedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingFeedback"> | Date | string
  }

  export type FeedbackFormWhereInput = {
    AND?: FeedbackFormWhereInput | FeedbackFormWhereInput[]
    OR?: FeedbackFormWhereInput[]
    NOT?: FeedbackFormWhereInput | FeedbackFormWhereInput[]
    id?: StringFilter<"FeedbackForm"> | string
    trainingId?: StringFilter<"FeedbackForm"> | string
    sessionId?: StringFilter<"FeedbackForm"> | string
    participantId?: StringFilter<"FeedbackForm"> | string
    fileUrl?: StringFilter<"FeedbackForm"> | string
    filePath?: StringNullableFilter<"FeedbackForm"> | string | null
    submittedAt?: DateTimeFilter<"FeedbackForm"> | Date | string
    uploadedById?: StringFilter<"FeedbackForm"> | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    session?: XOR<TrainingSessionScalarRelationFilter, TrainingSessionWhereInput>
    participant?: XOR<ParticipantScalarRelationFilter, ParticipantWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FeedbackFormOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    participantId?: SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    uploadedById?: SortOrder
    training?: TrainingOrderByWithRelationInput
    session?: TrainingSessionOrderByWithRelationInput
    participant?: ParticipantOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type FeedbackFormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_participantId?: FeedbackFormSessionIdParticipantIdCompoundUniqueInput
    AND?: FeedbackFormWhereInput | FeedbackFormWhereInput[]
    OR?: FeedbackFormWhereInput[]
    NOT?: FeedbackFormWhereInput | FeedbackFormWhereInput[]
    trainingId?: StringFilter<"FeedbackForm"> | string
    sessionId?: StringFilter<"FeedbackForm"> | string
    participantId?: StringFilter<"FeedbackForm"> | string
    fileUrl?: StringFilter<"FeedbackForm"> | string
    filePath?: StringNullableFilter<"FeedbackForm"> | string | null
    submittedAt?: DateTimeFilter<"FeedbackForm"> | Date | string
    uploadedById?: StringFilter<"FeedbackForm"> | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    session?: XOR<TrainingSessionScalarRelationFilter, TrainingSessionWhereInput>
    participant?: XOR<ParticipantScalarRelationFilter, ParticipantWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionId_participantId">

  export type FeedbackFormOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    participantId?: SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    uploadedById?: SortOrder
    _count?: FeedbackFormCountOrderByAggregateInput
    _max?: FeedbackFormMaxOrderByAggregateInput
    _min?: FeedbackFormMinOrderByAggregateInput
  }

  export type FeedbackFormScalarWhereWithAggregatesInput = {
    AND?: FeedbackFormScalarWhereWithAggregatesInput | FeedbackFormScalarWhereWithAggregatesInput[]
    OR?: FeedbackFormScalarWhereWithAggregatesInput[]
    NOT?: FeedbackFormScalarWhereWithAggregatesInput | FeedbackFormScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeedbackForm"> | string
    trainingId?: StringWithAggregatesFilter<"FeedbackForm"> | string
    sessionId?: StringWithAggregatesFilter<"FeedbackForm"> | string
    participantId?: StringWithAggregatesFilter<"FeedbackForm"> | string
    fileUrl?: StringWithAggregatesFilter<"FeedbackForm"> | string
    filePath?: StringNullableWithAggregatesFilter<"FeedbackForm"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"FeedbackForm"> | Date | string
    uploadedById?: StringWithAggregatesFilter<"FeedbackForm"> | string
  }

  export type TrainingFollowupWhereInput = {
    AND?: TrainingFollowupWhereInput | TrainingFollowupWhereInput[]
    OR?: TrainingFollowupWhereInput[]
    NOT?: TrainingFollowupWhereInput | TrainingFollowupWhereInput[]
    id?: StringFilter<"TrainingFollowup"> | string
    trainingId?: StringFilter<"TrainingFollowup"> | string
    title?: StringFilter<"TrainingFollowup"> | string
    description?: StringFilter<"TrainingFollowup"> | string
    dueDate?: DateTimeNullableFilter<"TrainingFollowup"> | Date | string | null
    isCompleted?: BoolFilter<"TrainingFollowup"> | boolean
    assignedToId?: StringFilter<"TrainingFollowup"> | string
    createdById?: StringFilter<"TrainingFollowup"> | string
    createdAt?: DateTimeFilter<"TrainingFollowup"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingFollowup"> | Date | string
    completedAt?: DateTimeNullableFilter<"TrainingFollowup"> | Date | string | null
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    assignedTo?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrainingFollowupOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    training?: TrainingOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type TrainingFollowupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingFollowupWhereInput | TrainingFollowupWhereInput[]
    OR?: TrainingFollowupWhereInput[]
    NOT?: TrainingFollowupWhereInput | TrainingFollowupWhereInput[]
    trainingId?: StringFilter<"TrainingFollowup"> | string
    title?: StringFilter<"TrainingFollowup"> | string
    description?: StringFilter<"TrainingFollowup"> | string
    dueDate?: DateTimeNullableFilter<"TrainingFollowup"> | Date | string | null
    isCompleted?: BoolFilter<"TrainingFollowup"> | boolean
    assignedToId?: StringFilter<"TrainingFollowup"> | string
    createdById?: StringFilter<"TrainingFollowup"> | string
    createdAt?: DateTimeFilter<"TrainingFollowup"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingFollowup"> | Date | string
    completedAt?: DateTimeNullableFilter<"TrainingFollowup"> | Date | string | null
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    assignedTo?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TrainingFollowupOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: TrainingFollowupCountOrderByAggregateInput
    _max?: TrainingFollowupMaxOrderByAggregateInput
    _min?: TrainingFollowupMinOrderByAggregateInput
  }

  export type TrainingFollowupScalarWhereWithAggregatesInput = {
    AND?: TrainingFollowupScalarWhereWithAggregatesInput | TrainingFollowupScalarWhereWithAggregatesInput[]
    OR?: TrainingFollowupScalarWhereWithAggregatesInput[]
    NOT?: TrainingFollowupScalarWhereWithAggregatesInput | TrainingFollowupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingFollowup"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingFollowup"> | string
    title?: StringWithAggregatesFilter<"TrainingFollowup"> | string
    description?: StringWithAggregatesFilter<"TrainingFollowup"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"TrainingFollowup"> | Date | string | null
    isCompleted?: BoolWithAggregatesFilter<"TrainingFollowup"> | boolean
    assignedToId?: StringWithAggregatesFilter<"TrainingFollowup"> | string
    createdById?: StringWithAggregatesFilter<"TrainingFollowup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrainingFollowup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingFollowup"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"TrainingFollowup"> | Date | string | null
  }

  export type TrainingNotificationWhereInput = {
    AND?: TrainingNotificationWhereInput | TrainingNotificationWhereInput[]
    OR?: TrainingNotificationWhereInput[]
    NOT?: TrainingNotificationWhereInput | TrainingNotificationWhereInput[]
    id?: StringFilter<"TrainingNotification"> | string
    trainingId?: StringFilter<"TrainingNotification"> | string
    userId?: StringFilter<"TrainingNotification"> | string
    title?: StringFilter<"TrainingNotification"> | string
    message?: StringFilter<"TrainingNotification"> | string
    isRead?: BoolFilter<"TrainingNotification"> | boolean
    sentAt?: DateTimeFilter<"TrainingNotification"> | Date | string
    readAt?: DateTimeNullableFilter<"TrainingNotification"> | Date | string | null
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrainingNotificationOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    training?: TrainingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TrainingNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingNotificationWhereInput | TrainingNotificationWhereInput[]
    OR?: TrainingNotificationWhereInput[]
    NOT?: TrainingNotificationWhereInput | TrainingNotificationWhereInput[]
    trainingId?: StringFilter<"TrainingNotification"> | string
    userId?: StringFilter<"TrainingNotification"> | string
    title?: StringFilter<"TrainingNotification"> | string
    message?: StringFilter<"TrainingNotification"> | string
    isRead?: BoolFilter<"TrainingNotification"> | boolean
    sentAt?: DateTimeFilter<"TrainingNotification"> | Date | string
    readAt?: DateTimeNullableFilter<"TrainingNotification"> | Date | string | null
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TrainingNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: TrainingNotificationCountOrderByAggregateInput
    _max?: TrainingNotificationMaxOrderByAggregateInput
    _min?: TrainingNotificationMinOrderByAggregateInput
  }

  export type TrainingNotificationScalarWhereWithAggregatesInput = {
    AND?: TrainingNotificationScalarWhereWithAggregatesInput | TrainingNotificationScalarWhereWithAggregatesInput[]
    OR?: TrainingNotificationScalarWhereWithAggregatesInput[]
    NOT?: TrainingNotificationScalarWhereWithAggregatesInput | TrainingNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingNotification"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingNotification"> | string
    userId?: StringWithAggregatesFilter<"TrainingNotification"> | string
    title?: StringWithAggregatesFilter<"TrainingNotification"> | string
    message?: StringWithAggregatesFilter<"TrainingNotification"> | string
    isRead?: BoolWithAggregatesFilter<"TrainingNotification"> | boolean
    sentAt?: DateTimeWithAggregatesFilter<"TrainingNotification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"TrainingNotification"> | Date | string | null
  }

  export type TrainingInviteTokenWhereInput = {
    AND?: TrainingInviteTokenWhereInput | TrainingInviteTokenWhereInput[]
    OR?: TrainingInviteTokenWhereInput[]
    NOT?: TrainingInviteTokenWhereInput | TrainingInviteTokenWhereInput[]
    id?: StringFilter<"TrainingInviteToken"> | string
    token?: StringFilter<"TrainingInviteToken"> | string
    action?: StringFilter<"TrainingInviteToken"> | string
    trainingId?: StringFilter<"TrainingInviteToken"> | string
    participantId?: StringNullableFilter<"TrainingInviteToken"> | string | null
    email?: StringFilter<"TrainingInviteToken"> | string
    expiresAt?: DateTimeFilter<"TrainingInviteToken"> | Date | string
    used?: BoolFilter<"TrainingInviteToken"> | boolean
    createdAt?: DateTimeFilter<"TrainingInviteToken"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    participant?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
  }

  export type TrainingInviteTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    action?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrderInput | SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    participant?: ParticipantOrderByWithRelationInput
  }

  export type TrainingInviteTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: TrainingInviteTokenWhereInput | TrainingInviteTokenWhereInput[]
    OR?: TrainingInviteTokenWhereInput[]
    NOT?: TrainingInviteTokenWhereInput | TrainingInviteTokenWhereInput[]
    action?: StringFilter<"TrainingInviteToken"> | string
    trainingId?: StringFilter<"TrainingInviteToken"> | string
    participantId?: StringNullableFilter<"TrainingInviteToken"> | string | null
    email?: StringFilter<"TrainingInviteToken"> | string
    expiresAt?: DateTimeFilter<"TrainingInviteToken"> | Date | string
    used?: BoolFilter<"TrainingInviteToken"> | boolean
    createdAt?: DateTimeFilter<"TrainingInviteToken"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    participant?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
  }, "id" | "token">

  export type TrainingInviteTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    action?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrderInput | SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    _count?: TrainingInviteTokenCountOrderByAggregateInput
    _max?: TrainingInviteTokenMaxOrderByAggregateInput
    _min?: TrainingInviteTokenMinOrderByAggregateInput
  }

  export type TrainingInviteTokenScalarWhereWithAggregatesInput = {
    AND?: TrainingInviteTokenScalarWhereWithAggregatesInput | TrainingInviteTokenScalarWhereWithAggregatesInput[]
    OR?: TrainingInviteTokenScalarWhereWithAggregatesInput[]
    NOT?: TrainingInviteTokenScalarWhereWithAggregatesInput | TrainingInviteTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingInviteToken"> | string
    token?: StringWithAggregatesFilter<"TrainingInviteToken"> | string
    action?: StringWithAggregatesFilter<"TrainingInviteToken"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingInviteToken"> | string
    participantId?: StringNullableWithAggregatesFilter<"TrainingInviteToken"> | string | null
    email?: StringWithAggregatesFilter<"TrainingInviteToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"TrainingInviteToken"> | Date | string
    used?: BoolWithAggregatesFilter<"TrainingInviteToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TrainingInviteToken"> | Date | string
  }

  export type TrainingSessionPhotoWhereInput = {
    AND?: TrainingSessionPhotoWhereInput | TrainingSessionPhotoWhereInput[]
    OR?: TrainingSessionPhotoWhereInput[]
    NOT?: TrainingSessionPhotoWhereInput | TrainingSessionPhotoWhereInput[]
    id?: StringFilter<"TrainingSessionPhoto"> | string
    sessionId?: StringFilter<"TrainingSessionPhoto"> | string
    photoUrl?: StringFilter<"TrainingSessionPhoto"> | string
    caption?: StringNullableFilter<"TrainingSessionPhoto"> | string | null
    uploadedById?: StringFilter<"TrainingSessionPhoto"> | string
    createdAt?: DateTimeFilter<"TrainingSessionPhoto"> | Date | string
    session?: XOR<TrainingSessionScalarRelationFilter, TrainingSessionWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrainingSessionPhotoOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    session?: TrainingSessionOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type TrainingSessionPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingSessionPhotoWhereInput | TrainingSessionPhotoWhereInput[]
    OR?: TrainingSessionPhotoWhereInput[]
    NOT?: TrainingSessionPhotoWhereInput | TrainingSessionPhotoWhereInput[]
    sessionId?: StringFilter<"TrainingSessionPhoto"> | string
    photoUrl?: StringFilter<"TrainingSessionPhoto"> | string
    caption?: StringNullableFilter<"TrainingSessionPhoto"> | string | null
    uploadedById?: StringFilter<"TrainingSessionPhoto"> | string
    createdAt?: DateTimeFilter<"TrainingSessionPhoto"> | Date | string
    session?: XOR<TrainingSessionScalarRelationFilter, TrainingSessionWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TrainingSessionPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    _count?: TrainingSessionPhotoCountOrderByAggregateInput
    _max?: TrainingSessionPhotoMaxOrderByAggregateInput
    _min?: TrainingSessionPhotoMinOrderByAggregateInput
  }

  export type TrainingSessionPhotoScalarWhereWithAggregatesInput = {
    AND?: TrainingSessionPhotoScalarWhereWithAggregatesInput | TrainingSessionPhotoScalarWhereWithAggregatesInput[]
    OR?: TrainingSessionPhotoScalarWhereWithAggregatesInput[]
    NOT?: TrainingSessionPhotoScalarWhereWithAggregatesInput | TrainingSessionPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingSessionPhoto"> | string
    sessionId?: StringWithAggregatesFilter<"TrainingSessionPhoto"> | string
    photoUrl?: StringWithAggregatesFilter<"TrainingSessionPhoto"> | string
    caption?: StringNullableWithAggregatesFilter<"TrainingSessionPhoto"> | string | null
    uploadedById?: StringWithAggregatesFilter<"TrainingSessionPhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrainingSessionPhoto"> | Date | string
  }

  export type AuditorWhereInput = {
    AND?: AuditorWhereInput | AuditorWhereInput[]
    OR?: AuditorWhereInput[]
    NOT?: AuditorWhereInput | AuditorWhereInput[]
    id?: StringFilter<"Auditor"> | string
    name?: StringFilter<"Auditor"> | string
    email?: StringFilter<"Auditor"> | string
    userId?: StringNullableFilter<"Auditor"> | string | null
    isExternal?: BoolFilter<"Auditor"> | boolean
    firmName?: StringNullableFilter<"Auditor"> | string | null
    createdAt?: DateTimeFilter<"Auditor"> | Date | string
    updatedAt?: DateTimeFilter<"Auditor"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    audits?: AuditListRelationFilter
  }

  export type AuditorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    userId?: SortOrderInput | SortOrder
    isExternal?: SortOrder
    firmName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    audits?: AuditOrderByRelationAggregateInput
  }

  export type AuditorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AuditorWhereInput | AuditorWhereInput[]
    OR?: AuditorWhereInput[]
    NOT?: AuditorWhereInput | AuditorWhereInput[]
    name?: StringFilter<"Auditor"> | string
    email?: StringFilter<"Auditor"> | string
    isExternal?: BoolFilter<"Auditor"> | boolean
    firmName?: StringNullableFilter<"Auditor"> | string | null
    createdAt?: DateTimeFilter<"Auditor"> | Date | string
    updatedAt?: DateTimeFilter<"Auditor"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    audits?: AuditListRelationFilter
  }, "id" | "userId">

  export type AuditorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    userId?: SortOrderInput | SortOrder
    isExternal?: SortOrder
    firmName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditorCountOrderByAggregateInput
    _max?: AuditorMaxOrderByAggregateInput
    _min?: AuditorMinOrderByAggregateInput
  }

  export type AuditorScalarWhereWithAggregatesInput = {
    AND?: AuditorScalarWhereWithAggregatesInput | AuditorScalarWhereWithAggregatesInput[]
    OR?: AuditorScalarWhereWithAggregatesInput[]
    NOT?: AuditorScalarWhereWithAggregatesInput | AuditorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Auditor"> | string
    name?: StringWithAggregatesFilter<"Auditor"> | string
    email?: StringWithAggregatesFilter<"Auditor"> | string
    userId?: StringNullableWithAggregatesFilter<"Auditor"> | string | null
    isExternal?: BoolWithAggregatesFilter<"Auditor"> | boolean
    firmName?: StringNullableWithAggregatesFilter<"Auditor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Auditor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Auditor"> | Date | string
  }

  export type AuditWhereInput = {
    AND?: AuditWhereInput | AuditWhereInput[]
    OR?: AuditWhereInput[]
    NOT?: AuditWhereInput | AuditWhereInput[]
    id?: StringFilter<"Audit"> | string
    name?: StringFilter<"Audit"> | string
    auditType?: EnumAuditTypeFilter<"Audit"> | $Enums.AuditType
    status?: EnumAuditStatusFilter<"Audit"> | $Enums.AuditStatus
    startDate?: DateTimeFilter<"Audit"> | Date | string
    endDate?: DateTimeNullableFilter<"Audit"> | Date | string | null
    auditorId?: StringFilter<"Audit"> | string
    auditeeId?: StringNullableFilter<"Audit"> | string | null
    firmName?: StringNullableFilter<"Audit"> | string | null
    departmentId?: StringNullableFilter<"Audit"> | string | null
    objectives?: StringNullableFilter<"Audit"> | string | null
    scope?: StringNullableFilter<"Audit"> | string | null
    summary?: StringNullableFilter<"Audit"> | string | null
    createdById?: StringFilter<"Audit"> | string
    createdAt?: DateTimeFilter<"Audit"> | Date | string
    updatedAt?: DateTimeFilter<"Audit"> | Date | string
    auditor?: XOR<AuditorScalarRelationFilter, AuditorWhereInput>
    auditee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    findings?: FindingListRelationFilter
    documents?: AuditDocumentListRelationFilter
    actions?: CorrectiveActionListRelationFilter
    reminders?: AuditReminderListRelationFilter
    notifications?: AuditNotificationListRelationFilter
    checklistItems?: PreAuditChecklistItemListRelationFilter
    inspectionItems?: AuditInspectionItemListRelationFilter
  }

  export type AuditOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    auditType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    auditorId?: SortOrder
    auditeeId?: SortOrderInput | SortOrder
    firmName?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    auditor?: AuditorOrderByWithRelationInput
    auditee?: UserOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    findings?: FindingOrderByRelationAggregateInput
    documents?: AuditDocumentOrderByRelationAggregateInput
    actions?: CorrectiveActionOrderByRelationAggregateInput
    reminders?: AuditReminderOrderByRelationAggregateInput
    notifications?: AuditNotificationOrderByRelationAggregateInput
    checklistItems?: PreAuditChecklistItemOrderByRelationAggregateInput
    inspectionItems?: AuditInspectionItemOrderByRelationAggregateInput
  }

  export type AuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditWhereInput | AuditWhereInput[]
    OR?: AuditWhereInput[]
    NOT?: AuditWhereInput | AuditWhereInput[]
    name?: StringFilter<"Audit"> | string
    auditType?: EnumAuditTypeFilter<"Audit"> | $Enums.AuditType
    status?: EnumAuditStatusFilter<"Audit"> | $Enums.AuditStatus
    startDate?: DateTimeFilter<"Audit"> | Date | string
    endDate?: DateTimeNullableFilter<"Audit"> | Date | string | null
    auditorId?: StringFilter<"Audit"> | string
    auditeeId?: StringNullableFilter<"Audit"> | string | null
    firmName?: StringNullableFilter<"Audit"> | string | null
    departmentId?: StringNullableFilter<"Audit"> | string | null
    objectives?: StringNullableFilter<"Audit"> | string | null
    scope?: StringNullableFilter<"Audit"> | string | null
    summary?: StringNullableFilter<"Audit"> | string | null
    createdById?: StringFilter<"Audit"> | string
    createdAt?: DateTimeFilter<"Audit"> | Date | string
    updatedAt?: DateTimeFilter<"Audit"> | Date | string
    auditor?: XOR<AuditorScalarRelationFilter, AuditorWhereInput>
    auditee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    findings?: FindingListRelationFilter
    documents?: AuditDocumentListRelationFilter
    actions?: CorrectiveActionListRelationFilter
    reminders?: AuditReminderListRelationFilter
    notifications?: AuditNotificationListRelationFilter
    checklistItems?: PreAuditChecklistItemListRelationFilter
    inspectionItems?: AuditInspectionItemListRelationFilter
  }, "id">

  export type AuditOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    auditType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    auditorId?: SortOrder
    auditeeId?: SortOrderInput | SortOrder
    firmName?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditCountOrderByAggregateInput
    _max?: AuditMaxOrderByAggregateInput
    _min?: AuditMinOrderByAggregateInput
  }

  export type AuditScalarWhereWithAggregatesInput = {
    AND?: AuditScalarWhereWithAggregatesInput | AuditScalarWhereWithAggregatesInput[]
    OR?: AuditScalarWhereWithAggregatesInput[]
    NOT?: AuditScalarWhereWithAggregatesInput | AuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Audit"> | string
    name?: StringWithAggregatesFilter<"Audit"> | string
    auditType?: EnumAuditTypeWithAggregatesFilter<"Audit"> | $Enums.AuditType
    status?: EnumAuditStatusWithAggregatesFilter<"Audit"> | $Enums.AuditStatus
    startDate?: DateTimeWithAggregatesFilter<"Audit"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Audit"> | Date | string | null
    auditorId?: StringWithAggregatesFilter<"Audit"> | string
    auditeeId?: StringNullableWithAggregatesFilter<"Audit"> | string | null
    firmName?: StringNullableWithAggregatesFilter<"Audit"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"Audit"> | string | null
    objectives?: StringNullableWithAggregatesFilter<"Audit"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Audit"> | string | null
    summary?: StringNullableWithAggregatesFilter<"Audit"> | string | null
    createdById?: StringWithAggregatesFilter<"Audit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Audit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Audit"> | Date | string
  }

  export type AuditInspectionItemWhereInput = {
    AND?: AuditInspectionItemWhereInput | AuditInspectionItemWhereInput[]
    OR?: AuditInspectionItemWhereInput[]
    NOT?: AuditInspectionItemWhereInput | AuditInspectionItemWhereInput[]
    id?: StringFilter<"AuditInspectionItem"> | string
    auditId?: StringFilter<"AuditInspectionItem"> | string
    areaName?: StringFilter<"AuditInspectionItem"> | string
    itemName?: StringFilter<"AuditInspectionItem"> | string
    description?: StringNullableFilter<"AuditInspectionItem"> | string | null
    standardReference?: StringNullableFilter<"AuditInspectionItem"> | string | null
    isCompliant?: BoolNullableFilter<"AuditInspectionItem"> | boolean | null
    comments?: StringNullableFilter<"AuditInspectionItem"> | string | null
    evidence?: StringNullableFilter<"AuditInspectionItem"> | string | null
    inspectedById?: StringNullableFilter<"AuditInspectionItem"> | string | null
    createdAt?: DateTimeFilter<"AuditInspectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"AuditInspectionItem"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    inspectedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditInspectionItemOrderByWithRelationInput = {
    id?: SortOrder
    auditId?: SortOrder
    areaName?: SortOrder
    itemName?: SortOrder
    description?: SortOrderInput | SortOrder
    standardReference?: SortOrderInput | SortOrder
    isCompliant?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    inspectedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    audit?: AuditOrderByWithRelationInput
    inspectedBy?: UserOrderByWithRelationInput
  }

  export type AuditInspectionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditInspectionItemWhereInput | AuditInspectionItemWhereInput[]
    OR?: AuditInspectionItemWhereInput[]
    NOT?: AuditInspectionItemWhereInput | AuditInspectionItemWhereInput[]
    auditId?: StringFilter<"AuditInspectionItem"> | string
    areaName?: StringFilter<"AuditInspectionItem"> | string
    itemName?: StringFilter<"AuditInspectionItem"> | string
    description?: StringNullableFilter<"AuditInspectionItem"> | string | null
    standardReference?: StringNullableFilter<"AuditInspectionItem"> | string | null
    isCompliant?: BoolNullableFilter<"AuditInspectionItem"> | boolean | null
    comments?: StringNullableFilter<"AuditInspectionItem"> | string | null
    evidence?: StringNullableFilter<"AuditInspectionItem"> | string | null
    inspectedById?: StringNullableFilter<"AuditInspectionItem"> | string | null
    createdAt?: DateTimeFilter<"AuditInspectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"AuditInspectionItem"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    inspectedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditInspectionItemOrderByWithAggregationInput = {
    id?: SortOrder
    auditId?: SortOrder
    areaName?: SortOrder
    itemName?: SortOrder
    description?: SortOrderInput | SortOrder
    standardReference?: SortOrderInput | SortOrder
    isCompliant?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    inspectedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditInspectionItemCountOrderByAggregateInput
    _max?: AuditInspectionItemMaxOrderByAggregateInput
    _min?: AuditInspectionItemMinOrderByAggregateInput
  }

  export type AuditInspectionItemScalarWhereWithAggregatesInput = {
    AND?: AuditInspectionItemScalarWhereWithAggregatesInput | AuditInspectionItemScalarWhereWithAggregatesInput[]
    OR?: AuditInspectionItemScalarWhereWithAggregatesInput[]
    NOT?: AuditInspectionItemScalarWhereWithAggregatesInput | AuditInspectionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditInspectionItem"> | string
    auditId?: StringWithAggregatesFilter<"AuditInspectionItem"> | string
    areaName?: StringWithAggregatesFilter<"AuditInspectionItem"> | string
    itemName?: StringWithAggregatesFilter<"AuditInspectionItem"> | string
    description?: StringNullableWithAggregatesFilter<"AuditInspectionItem"> | string | null
    standardReference?: StringNullableWithAggregatesFilter<"AuditInspectionItem"> | string | null
    isCompliant?: BoolNullableWithAggregatesFilter<"AuditInspectionItem"> | boolean | null
    comments?: StringNullableWithAggregatesFilter<"AuditInspectionItem"> | string | null
    evidence?: StringNullableWithAggregatesFilter<"AuditInspectionItem"> | string | null
    inspectedById?: StringNullableWithAggregatesFilter<"AuditInspectionItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditInspectionItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuditInspectionItem"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    audits?: AuditListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    audits?: AuditOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    description?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    audits?: AuditListRelationFilter
  }, "id" | "name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type FindingWhereInput = {
    AND?: FindingWhereInput | FindingWhereInput[]
    OR?: FindingWhereInput[]
    NOT?: FindingWhereInput | FindingWhereInput[]
    id?: StringFilter<"Finding"> | string
    auditId?: StringFilter<"Finding"> | string
    title?: StringFilter<"Finding"> | string
    description?: StringFilter<"Finding"> | string
    findingType?: EnumFindingTypeFilter<"Finding"> | $Enums.FindingType
    status?: EnumFindingStatusFilter<"Finding"> | $Enums.FindingStatus
    priority?: EnumPriorityNullableFilter<"Finding"> | $Enums.Priority | null
    dueDate?: DateTimeNullableFilter<"Finding"> | Date | string | null
    assignedToId?: StringNullableFilter<"Finding"> | string | null
    evidence?: StringNullableFilter<"Finding"> | string | null
    createdAt?: DateTimeFilter<"Finding"> | Date | string
    updatedAt?: DateTimeFilter<"Finding"> | Date | string
    closedAt?: DateTimeNullableFilter<"Finding"> | Date | string | null
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    actions?: CorrectiveActionListRelationFilter
  }

  export type FindingOrderByWithRelationInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    findingType?: SortOrder
    status?: SortOrder
    priority?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    audit?: AuditOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    actions?: CorrectiveActionOrderByRelationAggregateInput
  }

  export type FindingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FindingWhereInput | FindingWhereInput[]
    OR?: FindingWhereInput[]
    NOT?: FindingWhereInput | FindingWhereInput[]
    auditId?: StringFilter<"Finding"> | string
    title?: StringFilter<"Finding"> | string
    description?: StringFilter<"Finding"> | string
    findingType?: EnumFindingTypeFilter<"Finding"> | $Enums.FindingType
    status?: EnumFindingStatusFilter<"Finding"> | $Enums.FindingStatus
    priority?: EnumPriorityNullableFilter<"Finding"> | $Enums.Priority | null
    dueDate?: DateTimeNullableFilter<"Finding"> | Date | string | null
    assignedToId?: StringNullableFilter<"Finding"> | string | null
    evidence?: StringNullableFilter<"Finding"> | string | null
    createdAt?: DateTimeFilter<"Finding"> | Date | string
    updatedAt?: DateTimeFilter<"Finding"> | Date | string
    closedAt?: DateTimeNullableFilter<"Finding"> | Date | string | null
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    actions?: CorrectiveActionListRelationFilter
  }, "id">

  export type FindingOrderByWithAggregationInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    findingType?: SortOrder
    status?: SortOrder
    priority?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    _count?: FindingCountOrderByAggregateInput
    _max?: FindingMaxOrderByAggregateInput
    _min?: FindingMinOrderByAggregateInput
  }

  export type FindingScalarWhereWithAggregatesInput = {
    AND?: FindingScalarWhereWithAggregatesInput | FindingScalarWhereWithAggregatesInput[]
    OR?: FindingScalarWhereWithAggregatesInput[]
    NOT?: FindingScalarWhereWithAggregatesInput | FindingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Finding"> | string
    auditId?: StringWithAggregatesFilter<"Finding"> | string
    title?: StringWithAggregatesFilter<"Finding"> | string
    description?: StringWithAggregatesFilter<"Finding"> | string
    findingType?: EnumFindingTypeWithAggregatesFilter<"Finding"> | $Enums.FindingType
    status?: EnumFindingStatusWithAggregatesFilter<"Finding"> | $Enums.FindingStatus
    priority?: EnumPriorityNullableWithAggregatesFilter<"Finding"> | $Enums.Priority | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Finding"> | Date | string | null
    assignedToId?: StringNullableWithAggregatesFilter<"Finding"> | string | null
    evidence?: StringNullableWithAggregatesFilter<"Finding"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Finding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Finding"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"Finding"> | Date | string | null
  }

  export type CorrectiveActionWhereInput = {
    AND?: CorrectiveActionWhereInput | CorrectiveActionWhereInput[]
    OR?: CorrectiveActionWhereInput[]
    NOT?: CorrectiveActionWhereInput | CorrectiveActionWhereInput[]
    id?: StringFilter<"CorrectiveAction"> | string
    auditId?: StringFilter<"CorrectiveAction"> | string
    findingId?: StringNullableFilter<"CorrectiveAction"> | string | null
    title?: StringFilter<"CorrectiveAction"> | string
    description?: StringFilter<"CorrectiveAction"> | string
    actionType?: StringFilter<"CorrectiveAction"> | string
    assignedToId?: StringFilter<"CorrectiveAction"> | string
    dueDate?: DateTimeFilter<"CorrectiveAction"> | Date | string
    status?: StringFilter<"CorrectiveAction"> | string
    completedAt?: DateTimeNullableFilter<"CorrectiveAction"> | Date | string | null
    verifiedAt?: DateTimeNullableFilter<"CorrectiveAction"> | Date | string | null
    verifiedById?: StringNullableFilter<"CorrectiveAction"> | string | null
    evidence?: StringNullableFilter<"CorrectiveAction"> | string | null
    createdAt?: DateTimeFilter<"CorrectiveAction"> | Date | string
    updatedAt?: DateTimeFilter<"CorrectiveAction"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    finding?: XOR<FindingNullableScalarRelationFilter, FindingWhereInput> | null
    assignedTo?: XOR<UserScalarRelationFilter, UserWhereInput>
    verifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CorrectiveActionOrderByWithRelationInput = {
    id?: SortOrder
    auditId?: SortOrder
    findingId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    actionType?: SortOrder
    assignedToId?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verifiedById?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    audit?: AuditOrderByWithRelationInput
    finding?: FindingOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    verifiedBy?: UserOrderByWithRelationInput
  }

  export type CorrectiveActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CorrectiveActionWhereInput | CorrectiveActionWhereInput[]
    OR?: CorrectiveActionWhereInput[]
    NOT?: CorrectiveActionWhereInput | CorrectiveActionWhereInput[]
    auditId?: StringFilter<"CorrectiveAction"> | string
    findingId?: StringNullableFilter<"CorrectiveAction"> | string | null
    title?: StringFilter<"CorrectiveAction"> | string
    description?: StringFilter<"CorrectiveAction"> | string
    actionType?: StringFilter<"CorrectiveAction"> | string
    assignedToId?: StringFilter<"CorrectiveAction"> | string
    dueDate?: DateTimeFilter<"CorrectiveAction"> | Date | string
    status?: StringFilter<"CorrectiveAction"> | string
    completedAt?: DateTimeNullableFilter<"CorrectiveAction"> | Date | string | null
    verifiedAt?: DateTimeNullableFilter<"CorrectiveAction"> | Date | string | null
    verifiedById?: StringNullableFilter<"CorrectiveAction"> | string | null
    evidence?: StringNullableFilter<"CorrectiveAction"> | string | null
    createdAt?: DateTimeFilter<"CorrectiveAction"> | Date | string
    updatedAt?: DateTimeFilter<"CorrectiveAction"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    finding?: XOR<FindingNullableScalarRelationFilter, FindingWhereInput> | null
    assignedTo?: XOR<UserScalarRelationFilter, UserWhereInput>
    verifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type CorrectiveActionOrderByWithAggregationInput = {
    id?: SortOrder
    auditId?: SortOrder
    findingId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    actionType?: SortOrder
    assignedToId?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verifiedById?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CorrectiveActionCountOrderByAggregateInput
    _max?: CorrectiveActionMaxOrderByAggregateInput
    _min?: CorrectiveActionMinOrderByAggregateInput
  }

  export type CorrectiveActionScalarWhereWithAggregatesInput = {
    AND?: CorrectiveActionScalarWhereWithAggregatesInput | CorrectiveActionScalarWhereWithAggregatesInput[]
    OR?: CorrectiveActionScalarWhereWithAggregatesInput[]
    NOT?: CorrectiveActionScalarWhereWithAggregatesInput | CorrectiveActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CorrectiveAction"> | string
    auditId?: StringWithAggregatesFilter<"CorrectiveAction"> | string
    findingId?: StringNullableWithAggregatesFilter<"CorrectiveAction"> | string | null
    title?: StringWithAggregatesFilter<"CorrectiveAction"> | string
    description?: StringWithAggregatesFilter<"CorrectiveAction"> | string
    actionType?: StringWithAggregatesFilter<"CorrectiveAction"> | string
    assignedToId?: StringWithAggregatesFilter<"CorrectiveAction"> | string
    dueDate?: DateTimeWithAggregatesFilter<"CorrectiveAction"> | Date | string
    status?: StringWithAggregatesFilter<"CorrectiveAction"> | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"CorrectiveAction"> | Date | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"CorrectiveAction"> | Date | string | null
    verifiedById?: StringNullableWithAggregatesFilter<"CorrectiveAction"> | string | null
    evidence?: StringNullableWithAggregatesFilter<"CorrectiveAction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CorrectiveAction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CorrectiveAction"> | Date | string
  }

  export type AuditDocumentWhereInput = {
    AND?: AuditDocumentWhereInput | AuditDocumentWhereInput[]
    OR?: AuditDocumentWhereInput[]
    NOT?: AuditDocumentWhereInput | AuditDocumentWhereInput[]
    id?: StringFilter<"AuditDocument"> | string
    auditId?: StringFilter<"AuditDocument"> | string
    title?: StringFilter<"AuditDocument"> | string
    description?: StringNullableFilter<"AuditDocument"> | string | null
    documentType?: EnumAuditDocumentTypeFilter<"AuditDocument"> | $Enums.AuditDocumentType
    fileUrl?: StringFilter<"AuditDocument"> | string
    filePath?: StringNullableFilter<"AuditDocument"> | string | null
    uploadedById?: StringFilter<"AuditDocument"> | string
    createdAt?: DateTimeFilter<"AuditDocument"> | Date | string
    updatedAt?: DateTimeFilter<"AuditDocument"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditDocumentOrderByWithRelationInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    documentType?: SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    audit?: AuditOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type AuditDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditDocumentWhereInput | AuditDocumentWhereInput[]
    OR?: AuditDocumentWhereInput[]
    NOT?: AuditDocumentWhereInput | AuditDocumentWhereInput[]
    auditId?: StringFilter<"AuditDocument"> | string
    title?: StringFilter<"AuditDocument"> | string
    description?: StringNullableFilter<"AuditDocument"> | string | null
    documentType?: EnumAuditDocumentTypeFilter<"AuditDocument"> | $Enums.AuditDocumentType
    fileUrl?: StringFilter<"AuditDocument"> | string
    filePath?: StringNullableFilter<"AuditDocument"> | string | null
    uploadedById?: StringFilter<"AuditDocument"> | string
    createdAt?: DateTimeFilter<"AuditDocument"> | Date | string
    updatedAt?: DateTimeFilter<"AuditDocument"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    documentType?: SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditDocumentCountOrderByAggregateInput
    _max?: AuditDocumentMaxOrderByAggregateInput
    _min?: AuditDocumentMinOrderByAggregateInput
  }

  export type AuditDocumentScalarWhereWithAggregatesInput = {
    AND?: AuditDocumentScalarWhereWithAggregatesInput | AuditDocumentScalarWhereWithAggregatesInput[]
    OR?: AuditDocumentScalarWhereWithAggregatesInput[]
    NOT?: AuditDocumentScalarWhereWithAggregatesInput | AuditDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditDocument"> | string
    auditId?: StringWithAggregatesFilter<"AuditDocument"> | string
    title?: StringWithAggregatesFilter<"AuditDocument"> | string
    description?: StringNullableWithAggregatesFilter<"AuditDocument"> | string | null
    documentType?: EnumAuditDocumentTypeWithAggregatesFilter<"AuditDocument"> | $Enums.AuditDocumentType
    fileUrl?: StringWithAggregatesFilter<"AuditDocument"> | string
    filePath?: StringNullableWithAggregatesFilter<"AuditDocument"> | string | null
    uploadedById?: StringWithAggregatesFilter<"AuditDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuditDocument"> | Date | string
  }

  export type PreAuditChecklistItemWhereInput = {
    AND?: PreAuditChecklistItemWhereInput | PreAuditChecklistItemWhereInput[]
    OR?: PreAuditChecklistItemWhereInput[]
    NOT?: PreAuditChecklistItemWhereInput | PreAuditChecklistItemWhereInput[]
    id?: StringFilter<"PreAuditChecklistItem"> | string
    auditId?: StringFilter<"PreAuditChecklistItem"> | string
    description?: StringFilter<"PreAuditChecklistItem"> | string
    isCompleted?: BoolFilter<"PreAuditChecklistItem"> | boolean
    comments?: StringNullableFilter<"PreAuditChecklistItem"> | string | null
    responsibleId?: StringFilter<"PreAuditChecklistItem"> | string
    dueDate?: DateTimeNullableFilter<"PreAuditChecklistItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PreAuditChecklistItem"> | Date | string | null
    createdById?: StringFilter<"PreAuditChecklistItem"> | string
    createdAt?: DateTimeFilter<"PreAuditChecklistItem"> | Date | string
    updatedAt?: DateTimeFilter<"PreAuditChecklistItem"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    responsible?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PreAuditChecklistItemOrderByWithRelationInput = {
    id?: SortOrder
    auditId?: SortOrder
    description?: SortOrder
    isCompleted?: SortOrder
    comments?: SortOrderInput | SortOrder
    responsibleId?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    audit?: AuditOrderByWithRelationInput
    responsible?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type PreAuditChecklistItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PreAuditChecklistItemWhereInput | PreAuditChecklistItemWhereInput[]
    OR?: PreAuditChecklistItemWhereInput[]
    NOT?: PreAuditChecklistItemWhereInput | PreAuditChecklistItemWhereInput[]
    auditId?: StringFilter<"PreAuditChecklistItem"> | string
    description?: StringFilter<"PreAuditChecklistItem"> | string
    isCompleted?: BoolFilter<"PreAuditChecklistItem"> | boolean
    comments?: StringNullableFilter<"PreAuditChecklistItem"> | string | null
    responsibleId?: StringFilter<"PreAuditChecklistItem"> | string
    dueDate?: DateTimeNullableFilter<"PreAuditChecklistItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PreAuditChecklistItem"> | Date | string | null
    createdById?: StringFilter<"PreAuditChecklistItem"> | string
    createdAt?: DateTimeFilter<"PreAuditChecklistItem"> | Date | string
    updatedAt?: DateTimeFilter<"PreAuditChecklistItem"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    responsible?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PreAuditChecklistItemOrderByWithAggregationInput = {
    id?: SortOrder
    auditId?: SortOrder
    description?: SortOrder
    isCompleted?: SortOrder
    comments?: SortOrderInput | SortOrder
    responsibleId?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PreAuditChecklistItemCountOrderByAggregateInput
    _max?: PreAuditChecklistItemMaxOrderByAggregateInput
    _min?: PreAuditChecklistItemMinOrderByAggregateInput
  }

  export type PreAuditChecklistItemScalarWhereWithAggregatesInput = {
    AND?: PreAuditChecklistItemScalarWhereWithAggregatesInput | PreAuditChecklistItemScalarWhereWithAggregatesInput[]
    OR?: PreAuditChecklistItemScalarWhereWithAggregatesInput[]
    NOT?: PreAuditChecklistItemScalarWhereWithAggregatesInput | PreAuditChecklistItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PreAuditChecklistItem"> | string
    auditId?: StringWithAggregatesFilter<"PreAuditChecklistItem"> | string
    description?: StringWithAggregatesFilter<"PreAuditChecklistItem"> | string
    isCompleted?: BoolWithAggregatesFilter<"PreAuditChecklistItem"> | boolean
    comments?: StringNullableWithAggregatesFilter<"PreAuditChecklistItem"> | string | null
    responsibleId?: StringWithAggregatesFilter<"PreAuditChecklistItem"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"PreAuditChecklistItem"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"PreAuditChecklistItem"> | Date | string | null
    createdById?: StringWithAggregatesFilter<"PreAuditChecklistItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PreAuditChecklistItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PreAuditChecklistItem"> | Date | string
  }

  export type AuditReminderWhereInput = {
    AND?: AuditReminderWhereInput | AuditReminderWhereInput[]
    OR?: AuditReminderWhereInput[]
    NOT?: AuditReminderWhereInput | AuditReminderWhereInput[]
    id?: StringFilter<"AuditReminder"> | string
    auditId?: StringFilter<"AuditReminder"> | string
    title?: StringFilter<"AuditReminder"> | string
    message?: StringFilter<"AuditReminder"> | string
    dueDate?: DateTimeFilter<"AuditReminder"> | Date | string
    status?: StringFilter<"AuditReminder"> | string
    recipientId?: StringFilter<"AuditReminder"> | string
    createdById?: StringFilter<"AuditReminder"> | string
    createdAt?: DateTimeFilter<"AuditReminder"> | Date | string
    updatedAt?: DateTimeFilter<"AuditReminder"> | Date | string
    sentAt?: DateTimeNullableFilter<"AuditReminder"> | Date | string | null
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditReminderOrderByWithRelationInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    recipientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    audit?: AuditOrderByWithRelationInput
    recipient?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type AuditReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditReminderWhereInput | AuditReminderWhereInput[]
    OR?: AuditReminderWhereInput[]
    NOT?: AuditReminderWhereInput | AuditReminderWhereInput[]
    auditId?: StringFilter<"AuditReminder"> | string
    title?: StringFilter<"AuditReminder"> | string
    message?: StringFilter<"AuditReminder"> | string
    dueDate?: DateTimeFilter<"AuditReminder"> | Date | string
    status?: StringFilter<"AuditReminder"> | string
    recipientId?: StringFilter<"AuditReminder"> | string
    createdById?: StringFilter<"AuditReminder"> | string
    createdAt?: DateTimeFilter<"AuditReminder"> | Date | string
    updatedAt?: DateTimeFilter<"AuditReminder"> | Date | string
    sentAt?: DateTimeNullableFilter<"AuditReminder"> | Date | string | null
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditReminderOrderByWithAggregationInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    recipientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    _count?: AuditReminderCountOrderByAggregateInput
    _max?: AuditReminderMaxOrderByAggregateInput
    _min?: AuditReminderMinOrderByAggregateInput
  }

  export type AuditReminderScalarWhereWithAggregatesInput = {
    AND?: AuditReminderScalarWhereWithAggregatesInput | AuditReminderScalarWhereWithAggregatesInput[]
    OR?: AuditReminderScalarWhereWithAggregatesInput[]
    NOT?: AuditReminderScalarWhereWithAggregatesInput | AuditReminderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditReminder"> | string
    auditId?: StringWithAggregatesFilter<"AuditReminder"> | string
    title?: StringWithAggregatesFilter<"AuditReminder"> | string
    message?: StringWithAggregatesFilter<"AuditReminder"> | string
    dueDate?: DateTimeWithAggregatesFilter<"AuditReminder"> | Date | string
    status?: StringWithAggregatesFilter<"AuditReminder"> | string
    recipientId?: StringWithAggregatesFilter<"AuditReminder"> | string
    createdById?: StringWithAggregatesFilter<"AuditReminder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditReminder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuditReminder"> | Date | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"AuditReminder"> | Date | string | null
  }

  export type AuditNotificationWhereInput = {
    AND?: AuditNotificationWhereInput | AuditNotificationWhereInput[]
    OR?: AuditNotificationWhereInput[]
    NOT?: AuditNotificationWhereInput | AuditNotificationWhereInput[]
    id?: StringFilter<"AuditNotification"> | string
    auditId?: StringFilter<"AuditNotification"> | string
    userId?: StringFilter<"AuditNotification"> | string
    title?: StringFilter<"AuditNotification"> | string
    message?: StringFilter<"AuditNotification"> | string
    isRead?: BoolFilter<"AuditNotification"> | boolean
    sentAt?: DateTimeFilter<"AuditNotification"> | Date | string
    readAt?: DateTimeNullableFilter<"AuditNotification"> | Date | string | null
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditNotificationOrderByWithRelationInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    audit?: AuditOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditNotificationWhereInput | AuditNotificationWhereInput[]
    OR?: AuditNotificationWhereInput[]
    NOT?: AuditNotificationWhereInput | AuditNotificationWhereInput[]
    auditId?: StringFilter<"AuditNotification"> | string
    userId?: StringFilter<"AuditNotification"> | string
    title?: StringFilter<"AuditNotification"> | string
    message?: StringFilter<"AuditNotification"> | string
    isRead?: BoolFilter<"AuditNotification"> | boolean
    sentAt?: DateTimeFilter<"AuditNotification"> | Date | string
    readAt?: DateTimeNullableFilter<"AuditNotification"> | Date | string | null
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: AuditNotificationCountOrderByAggregateInput
    _max?: AuditNotificationMaxOrderByAggregateInput
    _min?: AuditNotificationMinOrderByAggregateInput
  }

  export type AuditNotificationScalarWhereWithAggregatesInput = {
    AND?: AuditNotificationScalarWhereWithAggregatesInput | AuditNotificationScalarWhereWithAggregatesInput[]
    OR?: AuditNotificationScalarWhereWithAggregatesInput[]
    NOT?: AuditNotificationScalarWhereWithAggregatesInput | AuditNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditNotification"> | string
    auditId?: StringWithAggregatesFilter<"AuditNotification"> | string
    userId?: StringWithAggregatesFilter<"AuditNotification"> | string
    title?: StringWithAggregatesFilter<"AuditNotification"> | string
    message?: StringWithAggregatesFilter<"AuditNotification"> | string
    isRead?: BoolWithAggregatesFilter<"AuditNotification"> | boolean
    sentAt?: DateTimeWithAggregatesFilter<"AuditNotification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"AuditNotification"> | Date | string | null
  }

  export type ActivityLogCreateInput = {
    id: string
    action: string
    details?: string | null
    createdAt?: Date | string
    Batch?: BatchCreateNestedOneWithoutActivityLogInput
    User: UserCreateNestedOneWithoutActivityLogInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id: string
    userId: string
    batchId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneWithoutActivityLogNestedInput
    User?: UserUpdateOneRequiredWithoutActivityLogNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id: string
    userId: string
    batchId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchCreateManyInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportLogCreateInput = {
    id: string
    fileName: string
    exportType: string
    exportedBy: string
    exportedAt?: Date | string
  }

  export type ExportLogUncheckedCreateInput = {
    id: string
    fileName: string
    exportType: string
    exportedBy: string
    exportedAt?: Date | string
  }

  export type ExportLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    exportedBy?: StringFieldUpdateOperationsInput | string
    exportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    exportedBy?: StringFieldUpdateOperationsInput | string
    exportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportLogCreateManyInput = {
    id: string
    fileName: string
    exportType: string
    exportedBy: string
    exportedAt?: Date | string
  }

  export type ExportLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    exportedBy?: StringFieldUpdateOperationsInput | string
    exportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    exportedBy?: StringFieldUpdateOperationsInput | string
    exportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodologyCreateInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutMethodologiesInput
    batches?: BatchCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutMethodologyInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyUncheckedCreateInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutMethodologiesInput
    batches?: BatchUncheckedCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutMethodologyInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutMethodologiesNestedInput
    batches?: BatchUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutMethodologyNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutMethodologiesNestedInput
    batches?: BatchUncheckedUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutMethodologyNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyCreateManyInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MethodologyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodologyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    Batch?: BatchCreateNestedOneWithoutNotificationInput
    User: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id: string
    userId: string
    batchId?: string | null
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneWithoutNotificationNestedInput
    User?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id: string
    userId: string
    batchId?: string | null
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id: string
    action: string
    resource: string
    createdAt?: Date | string
    updatedAt: Date | string
    Role?: RoleCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id: string
    action: string
    resource: string
    createdAt?: Date | string
    updatedAt: Date | string
    Role?: RoleUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id: string
    action: string
    resource: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Batch?: BatchCreateNestedManyWithoutProductInput
    standardCategories?: ProductStandardCategoryCreateNestedManyWithoutProductInput
    parameters?: ProductParameterCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Batch?: BatchUncheckedCreateNestedManyWithoutProductInput
    standardCategories?: ProductStandardCategoryUncheckedCreateNestedManyWithoutProductInput
    parameters?: ProductParameterUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateManyWithoutProductNestedInput
    standardCategories?: ProductStandardCategoryUpdateManyWithoutProductNestedInput
    parameters?: ProductParameterUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUncheckedUpdateManyWithoutProductNestedInput
    standardCategories?: ProductStandardCategoryUncheckedUpdateManyWithoutProductNestedInput
    parameters?: ProductParameterUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductParameterCreateInput = {
    id?: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutParametersInput
    parameter: StandardParameterCreateNestedOneWithoutProductsInput
  }

  export type ProductParameterUncheckedCreateInput = {
    id?: string
    productId: string
    parameterId: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductParameterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutParametersNestedInput
    parameter?: StandardParameterUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductParameterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductParameterCreateManyInput = {
    id?: string
    productId: string
    parameterId: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductParameterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductParameterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedManyWithoutRoleInput
    Permission?: PermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserUncheckedCreateNestedManyWithoutRoleInput
    Permission?: PermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateManyWithoutRoleNestedInput
    Permission?: PermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUncheckedUpdateManyWithoutRoleNestedInput
    Permission?: PermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfMeasurementCreateInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutUnitInput
    standardParameters?: StandardParameterCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutUnitInput
    batches?: BatchCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementUncheckedCreateInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutUnitInput
    standardParameters?: StandardParameterUncheckedCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutUnitInput
    batches?: BatchUncheckedCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutUnitNestedInput
    standardParameters?: StandardParameterUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutUnitNestedInput
    batches?: BatchUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutUnitNestedInput
    standardParameters?: StandardParameterUncheckedUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutUnitNestedInput
    batches?: BatchUncheckedUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type UnitOfMeasurementCreateManyInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type UnitOfMeasurementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfMeasurementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardCreateInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    Category: StandardCategoryCreateNestedOneWithoutStandardsInput
    CreatedBy: UserCreateNestedOneWithoutStandardsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardsModifiedInput
    batches?: BatchCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardsModifiedNestedInput
    batches?: BatchUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardCreateManyInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardCategoryCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parameters?: StandardParameterCreateNestedManyWithoutCategoryInput
    Standards?: StandardCreateNestedManyWithoutCategoryInput
    products?: ProductStandardCategoryCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parameters?: StandardParameterUncheckedCreateNestedManyWithoutCategoryInput
    Standards?: StandardUncheckedCreateNestedManyWithoutCategoryInput
    products?: ProductStandardCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: StandardParameterUpdateManyWithoutCategoryNestedInput
    Standards?: StandardUpdateManyWithoutCategoryNestedInput
    products?: ProductStandardCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type StandardCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: StandardParameterUncheckedUpdateManyWithoutCategoryNestedInput
    Standards?: StandardUncheckedUpdateManyWithoutCategoryNestedInput
    products?: ProductStandardCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type StandardCategoryCreateManyInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStandardCategoryCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutStandardCategoriesInput
    category: StandardCategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductStandardCategoryUncheckedCreateInput = {
    id?: string
    productId: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductStandardCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStandardCategoriesNestedInput
    category?: StandardCategoryUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductStandardCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStandardCategoryCreateManyInput = {
    id?: string
    productId: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductStandardCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStandardCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardParameterCreateInput = {
    id: string
    name: string
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    category: StandardCategoryCreateNestedOneWithoutParametersInput
    batchValues?: BatchParameterValueCreateNestedManyWithoutParameterInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardParametersInput
    standards?: StandardDefinitionCreateNestedManyWithoutParameterInput
    products?: ProductParameterCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterUncheckedCreateInput = {
    id: string
    name: string
    categoryId: string
    unitId?: string | null
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    batchValues?: BatchParameterValueUncheckedCreateNestedManyWithoutParameterInput
    standards?: StandardDefinitionUncheckedCreateNestedManyWithoutParameterInput
    products?: ProductParameterUncheckedCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StandardCategoryUpdateOneRequiredWithoutParametersNestedInput
    batchValues?: BatchParameterValueUpdateManyWithoutParameterNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutStandardParametersNestedInput
    standards?: StandardDefinitionUpdateManyWithoutParameterNestedInput
    products?: ProductParameterUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchValues?: BatchParameterValueUncheckedUpdateManyWithoutParameterNestedInput
    standards?: StandardDefinitionUncheckedUpdateManyWithoutParameterNestedInput
    products?: ProductParameterUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterCreateManyInput = {
    id: string
    name: string
    categoryId: string
    unitId?: string | null
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardParameterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardParameterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionCreateInput = {
    id: string
    standardValue: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    parameter: StandardParameterCreateNestedOneWithoutStandardsInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardDefinitionsInput
    methodology?: MethodologyCreateNestedOneWithoutStandardDefinitionsInput
    CreatedBy: UserCreateNestedOneWithoutStandardDefinitionsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardDefinitionsModifiedInput
  }

  export type StandardDefinitionUncheckedCreateInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StandardParameterUpdateOneRequiredWithoutStandardsNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutStandardDefinitionsNestedInput
    methodology?: MethodologyUpdateOneWithoutStandardDefinitionsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardDefinitionsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardDefinitionsModifiedNestedInput
  }

  export type StandardDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionCreateManyInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueCreateInput = {
    id: string
    value: string
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    batch: BatchCreateNestedOneWithoutParameterValuesInput
    parameter: StandardParameterCreateNestedOneWithoutBatchValuesInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutBatchParameterValuesInput
    methodology?: MethodologyCreateNestedOneWithoutBatchParameterValuesInput
  }

  export type BatchParameterValueUncheckedCreateInput = {
    id: string
    batchId: string
    parameterId: string
    value: string
    unitId?: string | null
    methodologyId?: string | null
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchParameterValueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneRequiredWithoutParameterValuesNestedInput
    parameter?: StandardParameterUpdateOneRequiredWithoutBatchValuesNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutBatchParameterValuesNestedInput
    methodology?: MethodologyUpdateOneWithoutBatchParameterValuesNestedInput
  }

  export type BatchParameterValueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueCreateManyInput = {
    id: string
    batchId: string
    parameterId: string
    value: string
    unitId?: string | null
    methodologyId?: string | null
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchParameterValueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingCalendarCreateInput = {
    id?: string
    month: number
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingCreateNestedManyWithoutCalendarInput
  }

  export type TrainingCalendarUncheckedCreateInput = {
    id?: string
    month: number
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type TrainingCalendarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingUpdateManyWithoutCalendarNestedInput
  }

  export type TrainingCalendarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type TrainingCalendarCreateManyInput = {
    id?: string
    month: number
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingCalendarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingCalendarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingCreateInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutSessionsInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutSessionInput
    photos?: TrainingSessionPhotoCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionUncheckedCreateInput = {
    id?: string
    trainingId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutSessionInput
    photos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutSessionsNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutSessionNestedInput
    photos?: TrainingSessionPhotoUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutSessionNestedInput
    photos?: TrainingSessionPhotoUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionCreateManyInput = {
    id?: string
    trainingId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentCreateInput = {
    id?: string
    sessionId?: string | null
    title: string
    description?: string | null
    fileUrl: string
    filePath?: string | null
    documentType: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutDocumentsInput
    uploadedBy: UserCreateNestedOneWithoutUploadedDocumentsInput
  }

  export type TrainingDocumentUncheckedCreateInput = {
    id?: string
    trainingId: string
    sessionId?: string | null
    title: string
    description?: string | null
    fileUrl: string
    filePath?: string | null
    documentType: $Enums.DocumentType
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
  }

  export type TrainingDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentCreateManyInput = {
    id?: string
    trainingId: string
    sessionId?: string | null
    title: string
    description?: string | null
    fileUrl: string
    filePath?: string | null
    documentType: $Enums.DocumentType
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipantCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    organization?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingParticipantCreateNestedManyWithoutParticipantInput
    attendances?: AttendanceCreateNestedManyWithoutParticipantInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutParticipantInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutParticipantInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    organization?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingParticipantUncheckedCreateNestedManyWithoutParticipantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutParticipantInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutParticipantInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutParticipantInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingParticipantUpdateManyWithoutParticipantNestedInput
    attendances?: AttendanceUpdateManyWithoutParticipantNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutParticipantNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutParticipantNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingParticipantUncheckedUpdateManyWithoutParticipantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutParticipantNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutParticipantNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutParticipantNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    organization?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantCreateInput = {
    id?: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutParticipantsInput
    participant: ParticipantCreateNestedOneWithoutTrainingsInput
  }

  export type TrainingParticipantUncheckedCreateInput = {
    id?: string
    trainingId: string
    participantId: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutParticipantsNestedInput
    participant?: ParticipantUpdateOneRequiredWithoutTrainingsNestedInput
  }

  export type TrainingParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantCreateManyInput = {
    id?: string
    trainingId: string
    participantId: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutAttendanceInput
    session: TrainingSessionCreateNestedOneWithoutAttendanceInput
    participant: ParticipantCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    trainingId: string
    sessionId: string
    participantId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutAttendanceNestedInput
    session?: TrainingSessionUpdateOneRequiredWithoutAttendanceNestedInput
    participant?: ParticipantUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    trainingId: string
    sessionId: string
    participantId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoCreateInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
    training: TrainingCreateNestedOneWithoutPhotosInput
    uploadedBy: UserCreateNestedOneWithoutUploadedPhotosInput
  }

  export type TrainingPhotoUncheckedCreateInput = {
    id?: string
    trainingId: string
    photoUrl: string
    caption?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type TrainingPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutPhotosNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedPhotosNestedInput
  }

  export type TrainingPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoCreateManyInput = {
    id?: string
    trainingId: string
    photoUrl: string
    caption?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type TrainingPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackCreateInput = {
    id?: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutFeedbackInput
    participant: ParticipantCreateNestedOneWithoutFeedbacksInput
  }

  export type TrainingFeedbackUncheckedCreateInput = {
    id?: string
    trainingId: string
    participantId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutFeedbackNestedInput
    participant?: ParticipantUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type TrainingFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackCreateManyInput = {
    id?: string
    trainingId: string
    participantId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackFormCreateInput = {
    id?: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
    training: TrainingCreateNestedOneWithoutFeedbackFormsInput
    session: TrainingSessionCreateNestedOneWithoutFeedbackFormsInput
    participant: ParticipantCreateNestedOneWithoutFeedbackFormsInput
    uploadedBy: UserCreateNestedOneWithoutUploadedFeedbackFormsInput
  }

  export type FeedbackFormUncheckedCreateInput = {
    id?: string
    trainingId: string
    sessionId: string
    participantId: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
    uploadedById: string
  }

  export type FeedbackFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutFeedbackFormsNestedInput
    session?: TrainingSessionUpdateOneRequiredWithoutFeedbackFormsNestedInput
    participant?: ParticipantUpdateOneRequiredWithoutFeedbackFormsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedFeedbackFormsNestedInput
  }

  export type FeedbackFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackFormCreateManyInput = {
    id?: string
    trainingId: string
    sessionId: string
    participantId: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
    uploadedById: string
  }

  export type FeedbackFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type TrainingFollowupCreateInput = {
    id?: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    training: TrainingCreateNestedOneWithoutFollowupsInput
    assignedTo: UserCreateNestedOneWithoutAssignedFollowupsInput
    createdBy: UserCreateNestedOneWithoutCreatedFollowupsInput
  }

  export type TrainingFollowupUncheckedCreateInput = {
    id?: string
    trainingId: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    assignedToId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingFollowupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training?: TrainingUpdateOneRequiredWithoutFollowupsNestedInput
    assignedTo?: UserUpdateOneRequiredWithoutAssignedFollowupsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedFollowupsNestedInput
  }

  export type TrainingFollowupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingFollowupCreateManyInput = {
    id?: string
    trainingId: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    assignedToId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingFollowupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingFollowupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationCreateInput = {
    id?: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    training: TrainingCreateNestedOneWithoutNotificationsInput
    user: UserCreateNestedOneWithoutTrainingNotificationsInput
  }

  export type TrainingNotificationUncheckedCreateInput = {
    id?: string
    trainingId: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type TrainingNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training?: TrainingUpdateOneRequiredWithoutNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutTrainingNotificationsNestedInput
  }

  export type TrainingNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationCreateManyInput = {
    id?: string
    trainingId: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type TrainingNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingInviteTokenCreateInput = {
    id?: string
    token: string
    action: string
    email: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    training: TrainingCreateNestedOneWithoutInviteTokensInput
    participant?: ParticipantCreateNestedOneWithoutInviteTokensInput
  }

  export type TrainingInviteTokenUncheckedCreateInput = {
    id?: string
    token: string
    action: string
    trainingId: string
    participantId?: string | null
    email: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type TrainingInviteTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutInviteTokensNestedInput
    participant?: ParticipantUpdateOneWithoutInviteTokensNestedInput
  }

  export type TrainingInviteTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingInviteTokenCreateManyInput = {
    id?: string
    token: string
    action: string
    trainingId: string
    participantId?: string | null
    email: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type TrainingInviteTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingInviteTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionPhotoCreateInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
    session: TrainingSessionCreateNestedOneWithoutPhotosInput
    uploadedBy: UserCreateNestedOneWithoutUploadedSessionPhotosInput
  }

  export type TrainingSessionPhotoUncheckedCreateInput = {
    id?: string
    sessionId: string
    photoUrl: string
    caption?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type TrainingSessionPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TrainingSessionUpdateOneRequiredWithoutPhotosNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedSessionPhotosNestedInput
  }

  export type TrainingSessionPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionPhotoCreateManyInput = {
    id?: string
    sessionId: string
    photoUrl: string
    caption?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type TrainingSessionPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditorCreateInput = {
    id?: string
    name: string
    email: string
    isExternal?: boolean
    firmName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditorProfileInput
    audits?: AuditCreateNestedManyWithoutAuditorInput
  }

  export type AuditorUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    userId?: string | null
    isExternal?: boolean
    firmName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditUncheckedCreateNestedManyWithoutAuditorInput
  }

  export type AuditorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditorProfileNestedInput
    audits?: AuditUpdateManyWithoutAuditorNestedInput
  }

  export type AuditorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUncheckedUpdateManyWithoutAuditorNestedInput
  }

  export type AuditorCreateManyInput = {
    id?: string
    name: string
    email: string
    userId?: string | null
    isExternal?: boolean
    firmName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditCreateInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditor: AuditorCreateNestedOneWithoutAuditsInput
    auditee?: UserCreateNestedOneWithoutAuditeeAuditsInput
    department?: DepartmentCreateNestedOneWithoutAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    findings?: FindingCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    auditeeId?: string | null
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    findings?: FindingUncheckedCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentUncheckedCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderUncheckedCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationUncheckedCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditor?: AuditorUpdateOneRequiredWithoutAuditsNestedInput
    auditee?: UserUpdateOneWithoutAuditeeAuditsNestedInput
    department?: DepartmentUpdateOneWithoutAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    findings?: FindingUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    findings?: FindingUncheckedUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUncheckedUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUncheckedUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUncheckedUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUncheckedUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type AuditCreateManyInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    auditeeId?: string | null
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditInspectionItemCreateInput = {
    id?: string
    areaName: string
    itemName: string
    description?: string | null
    standardReference?: string | null
    isCompliant?: boolean | null
    comments?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutInspectionItemsInput
    inspectedBy?: UserCreateNestedOneWithoutInspectedItemsInput
  }

  export type AuditInspectionItemUncheckedCreateInput = {
    id?: string
    auditId: string
    areaName: string
    itemName: string
    description?: string | null
    standardReference?: string | null
    isCompliant?: boolean | null
    comments?: string | null
    evidence?: string | null
    inspectedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditInspectionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    areaName?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standardReference?: NullableStringFieldUpdateOperationsInput | string | null
    isCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutInspectionItemsNestedInput
    inspectedBy?: UserUpdateOneWithoutInspectedItemsNestedInput
  }

  export type AuditInspectionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    areaName?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standardReference?: NullableStringFieldUpdateOperationsInput | string | null
    isCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    inspectedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditInspectionItemCreateManyInput = {
    id?: string
    auditId: string
    areaName: string
    itemName: string
    description?: string | null
    standardReference?: string | null
    isCompliant?: boolean | null
    comments?: string | null
    evidence?: string | null
    inspectedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditInspectionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    areaName?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standardReference?: NullableStringFieldUpdateOperationsInput | string | null
    isCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditInspectionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    areaName?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standardReference?: NullableStringFieldUpdateOperationsInput | string | null
    isCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    inspectedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FindingCreateInput = {
    id?: string
    title: string
    description: string
    findingType: $Enums.FindingType
    status?: $Enums.FindingStatus
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    audit: AuditCreateNestedOneWithoutFindingsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedFindingsInput
    actions?: CorrectiveActionCreateNestedManyWithoutFindingInput
  }

  export type FindingUncheckedCreateInput = {
    id?: string
    auditId: string
    title: string
    description: string
    findingType: $Enums.FindingType
    status?: $Enums.FindingStatus
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assignedToId?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutFindingInput
  }

  export type FindingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    findingType?: EnumFindingTypeFieldUpdateOperationsInput | $Enums.FindingType
    status?: EnumFindingStatusFieldUpdateOperationsInput | $Enums.FindingStatus
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: AuditUpdateOneRequiredWithoutFindingsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedFindingsNestedInput
    actions?: CorrectiveActionUpdateManyWithoutFindingNestedInput
  }

  export type FindingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    findingType?: EnumFindingTypeFieldUpdateOperationsInput | $Enums.FindingType
    status?: EnumFindingStatusFieldUpdateOperationsInput | $Enums.FindingStatus
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actions?: CorrectiveActionUncheckedUpdateManyWithoutFindingNestedInput
  }

  export type FindingCreateManyInput = {
    id?: string
    auditId: string
    title: string
    description: string
    findingType: $Enums.FindingType
    status?: $Enums.FindingStatus
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assignedToId?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type FindingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    findingType?: EnumFindingTypeFieldUpdateOperationsInput | $Enums.FindingType
    status?: EnumFindingStatusFieldUpdateOperationsInput | $Enums.FindingStatus
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FindingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    findingType?: EnumFindingTypeFieldUpdateOperationsInput | $Enums.FindingType
    status?: EnumFindingStatusFieldUpdateOperationsInput | $Enums.FindingStatus
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CorrectiveActionCreateInput = {
    id?: string
    title: string
    description: string
    actionType: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutActionsInput
    finding?: FindingCreateNestedOneWithoutActionsInput
    assignedTo: UserCreateNestedOneWithoutAssignedActionsInput
    verifiedBy?: UserCreateNestedOneWithoutVerifiedActionsInput
  }

  export type CorrectiveActionUncheckedCreateInput = {
    id?: string
    auditId: string
    findingId?: string | null
    title: string
    description: string
    actionType: string
    assignedToId: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    verifiedById?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrectiveActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutActionsNestedInput
    finding?: FindingUpdateOneWithoutActionsNestedInput
    assignedTo?: UserUpdateOneRequiredWithoutAssignedActionsNestedInput
    verifiedBy?: UserUpdateOneWithoutVerifiedActionsNestedInput
  }

  export type CorrectiveActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    findingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrectiveActionCreateManyInput = {
    id?: string
    auditId: string
    findingId?: string | null
    title: string
    description: string
    actionType: string
    assignedToId: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    verifiedById?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrectiveActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrectiveActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    findingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditDocumentCreateInput = {
    id?: string
    title: string
    description?: string | null
    documentType: $Enums.AuditDocumentType
    fileUrl: string
    filePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutDocumentsInput
    uploadedBy: UserCreateNestedOneWithoutUploadedAuditDocumentsInput
  }

  export type AuditDocumentUncheckedCreateInput = {
    id?: string
    auditId: string
    title: string
    description?: string | null
    documentType: $Enums.AuditDocumentType
    fileUrl: string
    filePath?: string | null
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumAuditDocumentTypeFieldUpdateOperationsInput | $Enums.AuditDocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedAuditDocumentsNestedInput
  }

  export type AuditDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumAuditDocumentTypeFieldUpdateOperationsInput | $Enums.AuditDocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditDocumentCreateManyInput = {
    id?: string
    auditId: string
    title: string
    description?: string | null
    documentType: $Enums.AuditDocumentType
    fileUrl: string
    filePath?: string | null
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumAuditDocumentTypeFieldUpdateOperationsInput | $Enums.AuditDocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumAuditDocumentTypeFieldUpdateOperationsInput | $Enums.AuditDocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreAuditChecklistItemCreateInput = {
    id?: string
    description: string
    isCompleted?: boolean
    comments?: string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutChecklistItemsInput
    responsible: UserCreateNestedOneWithoutResponsibleForChecklistItemsInput
    createdBy: UserCreateNestedOneWithoutCreatedChecklistItemsInput
  }

  export type PreAuditChecklistItemUncheckedCreateInput = {
    id?: string
    auditId: string
    description: string
    isCompleted?: boolean
    comments?: string | null
    responsibleId: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreAuditChecklistItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutChecklistItemsNestedInput
    responsible?: UserUpdateOneRequiredWithoutResponsibleForChecklistItemsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedChecklistItemsNestedInput
  }

  export type PreAuditChecklistItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreAuditChecklistItemCreateManyInput = {
    id?: string
    auditId: string
    description: string
    isCompleted?: boolean
    comments?: string | null
    responsibleId: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreAuditChecklistItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreAuditChecklistItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditReminderCreateInput = {
    id?: string
    title: string
    message: string
    dueDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    audit: AuditCreateNestedOneWithoutRemindersInput
    recipient: UserCreateNestedOneWithoutReceivedRemindersInput
    createdBy: UserCreateNestedOneWithoutCreatedRemindersInput
  }

  export type AuditReminderUncheckedCreateInput = {
    id?: string
    auditId: string
    title: string
    message: string
    dueDate: Date | string
    status: string
    recipientId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
  }

  export type AuditReminderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: AuditUpdateOneRequiredWithoutRemindersNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedRemindersNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedRemindersNestedInput
  }

  export type AuditReminderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditReminderCreateManyInput = {
    id?: string
    auditId: string
    title: string
    message: string
    dueDate: Date | string
    status: string
    recipientId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
  }

  export type AuditReminderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditReminderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditNotificationCreateInput = {
    id?: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    audit: AuditCreateNestedOneWithoutNotificationsInput
    user: UserCreateNestedOneWithoutAuditNotificationsInput
  }

  export type AuditNotificationUncheckedCreateInput = {
    id?: string
    auditId: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type AuditNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: AuditUpdateOneRequiredWithoutNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutAuditNotificationsNestedInput
  }

  export type AuditNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditNotificationCreateManyInput = {
    id?: string
    auditId: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type AuditNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BatchNullableScalarRelationFilter = {
    is?: BatchWhereInput | null
    isNot?: BatchWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumSampleAnalysisStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleAnalysisStatus | EnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleAnalysisStatusFilter<$PrismaModel> | $Enums.SampleAnalysisStatus
  }

  export type EnumBatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusFilter<$PrismaModel> | $Enums.BatchStatus
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type StandardListRelationFilter = {
    every?: StandardWhereInput
    some?: StandardWhereInput
    none?: StandardWhereInput
  }

  export type MethodologyListRelationFilter = {
    every?: MethodologyWhereInput
    some?: MethodologyWhereInput
    none?: MethodologyWhereInput
  }

  export type UnitOfMeasurementListRelationFilter = {
    every?: UnitOfMeasurementWhereInput
    some?: UnitOfMeasurementWhereInput
    none?: UnitOfMeasurementWhereInput
  }

  export type BatchParameterValueListRelationFilter = {
    every?: BatchParameterValueWhereInput
    some?: BatchParameterValueWhereInput
    none?: BatchParameterValueWhereInput
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StandardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MethodologyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOfMeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BatchParameterValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BatchCountOrderByAggregateInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    productId?: SortOrder
    dateOfProduction?: SortOrder
    bestBeforeDate?: SortOrder
    sampleAnalysisStarted?: SortOrder
    sampleAnalysisCompleted?: SortOrder
    sampleAnalysisStatus?: SortOrder
    makerId?: SortOrder
    checkerId?: SortOrder
    status?: SortOrder
    rejectionRemarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchMaxOrderByAggregateInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    productId?: SortOrder
    dateOfProduction?: SortOrder
    bestBeforeDate?: SortOrder
    sampleAnalysisStarted?: SortOrder
    sampleAnalysisCompleted?: SortOrder
    sampleAnalysisStatus?: SortOrder
    makerId?: SortOrder
    checkerId?: SortOrder
    status?: SortOrder
    rejectionRemarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchMinOrderByAggregateInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    productId?: SortOrder
    dateOfProduction?: SortOrder
    bestBeforeDate?: SortOrder
    sampleAnalysisStarted?: SortOrder
    sampleAnalysisCompleted?: SortOrder
    sampleAnalysisStatus?: SortOrder
    makerId?: SortOrder
    checkerId?: SortOrder
    status?: SortOrder
    rejectionRemarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumSampleAnalysisStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleAnalysisStatus | EnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleAnalysisStatusWithAggregatesFilter<$PrismaModel> | $Enums.SampleAnalysisStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSampleAnalysisStatusFilter<$PrismaModel>
    _max?: NestedEnumSampleAnalysisStatusFilter<$PrismaModel>
  }

  export type EnumBatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchStatusFilter<$PrismaModel>
  }

  export type ExportLogCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    exportType?: SortOrder
    exportedBy?: SortOrder
    exportedAt?: SortOrder
  }

  export type ExportLogMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    exportType?: SortOrder
    exportedBy?: SortOrder
    exportedAt?: SortOrder
  }

  export type ExportLogMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    exportType?: SortOrder
    exportedBy?: SortOrder
    exportedAt?: SortOrder
  }

  export type BatchListRelationFilter = {
    every?: BatchWhereInput
    some?: BatchWhereInput
    none?: BatchWhereInput
  }

  export type StandardDefinitionListRelationFilter = {
    every?: StandardDefinitionWhereInput
    some?: StandardDefinitionWhereInput
    none?: StandardDefinitionWhereInput
  }

  export type BatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StandardDefinitionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MethodologyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    procedure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MethodologyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    procedure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MethodologyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    procedure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionActionResourceCompoundUniqueInput = {
    action: string
    resource: string
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductStandardCategoryListRelationFilter = {
    every?: ProductStandardCategoryWhereInput
    some?: ProductStandardCategoryWhereInput
    none?: ProductStandardCategoryWhereInput
  }

  export type ProductParameterListRelationFilter = {
    every?: ProductParameterWhereInput
    some?: ProductParameterWhereInput
    none?: ProductParameterWhereInput
  }

  export type ProductStandardCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductParameterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardParameterScalarRelationFilter = {
    is?: StandardParameterWhereInput
    isNot?: StandardParameterWhereInput
  }

  export type ProductParameterProductIdParameterIdCompoundUniqueInput = {
    productId: string
    parameterId: string
  }

  export type ProductParameterCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    parameterId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductParameterMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    parameterId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductParameterMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    parameterId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardParameterListRelationFilter = {
    every?: StandardParameterWhereInput
    some?: StandardParameterWhereInput
    none?: StandardParameterWhereInput
  }

  export type StandardParameterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOfMeasurementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitOfMeasurementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitOfMeasurementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type TrainingListRelationFilter = {
    every?: TrainingWhereInput
    some?: TrainingWhereInput
    none?: TrainingWhereInput
  }

  export type TrainingDocumentListRelationFilter = {
    every?: TrainingDocumentWhereInput
    some?: TrainingDocumentWhereInput
    none?: TrainingDocumentWhereInput
  }

  export type TrainingPhotoListRelationFilter = {
    every?: TrainingPhotoWhereInput
    some?: TrainingPhotoWhereInput
    none?: TrainingPhotoWhereInput
  }

  export type TrainingFollowupListRelationFilter = {
    every?: TrainingFollowupWhereInput
    some?: TrainingFollowupWhereInput
    none?: TrainingFollowupWhereInput
  }

  export type TrainingNotificationListRelationFilter = {
    every?: TrainingNotificationWhereInput
    some?: TrainingNotificationWhereInput
    none?: TrainingNotificationWhereInput
  }

  export type AuditorNullableScalarRelationFilter = {
    is?: AuditorWhereInput | null
    isNot?: AuditorWhereInput | null
  }

  export type AuditListRelationFilter = {
    every?: AuditWhereInput
    some?: AuditWhereInput
    none?: AuditWhereInput
  }

  export type FindingListRelationFilter = {
    every?: FindingWhereInput
    some?: FindingWhereInput
    none?: FindingWhereInput
  }

  export type CorrectiveActionListRelationFilter = {
    every?: CorrectiveActionWhereInput
    some?: CorrectiveActionWhereInput
    none?: CorrectiveActionWhereInput
  }

  export type AuditDocumentListRelationFilter = {
    every?: AuditDocumentWhereInput
    some?: AuditDocumentWhereInput
    none?: AuditDocumentWhereInput
  }

  export type AuditReminderListRelationFilter = {
    every?: AuditReminderWhereInput
    some?: AuditReminderWhereInput
    none?: AuditReminderWhereInput
  }

  export type AuditNotificationListRelationFilter = {
    every?: AuditNotificationWhereInput
    some?: AuditNotificationWhereInput
    none?: AuditNotificationWhereInput
  }

  export type PreAuditChecklistItemListRelationFilter = {
    every?: PreAuditChecklistItemWhereInput
    some?: PreAuditChecklistItemWhereInput
    none?: PreAuditChecklistItemWhereInput
  }

  export type AuditInspectionItemListRelationFilter = {
    every?: AuditInspectionItemWhereInput
    some?: AuditInspectionItemWhereInput
    none?: AuditInspectionItemWhereInput
  }

  export type FeedbackFormListRelationFilter = {
    every?: FeedbackFormWhereInput
    some?: FeedbackFormWhereInput
    none?: FeedbackFormWhereInput
  }

  export type TrainingSessionPhotoListRelationFilter = {
    every?: TrainingSessionPhotoWhereInput
    some?: TrainingSessionPhotoWhereInput
    none?: TrainingSessionPhotoWhereInput
  }

  export type TrainingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingFollowupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FindingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CorrectiveActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PreAuditChecklistItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditInspectionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingSessionPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStandardStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StandardStatus | EnumStandardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStandardStatusFilter<$PrismaModel> | $Enums.StandardStatus
  }

  export type StandardCategoryScalarRelationFilter = {
    is?: StandardCategoryWhereInput
    isNot?: StandardCategoryWhereInput
  }

  export type StandardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStandardStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StandardStatus | EnumStandardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStandardStatusWithAggregatesFilter<$PrismaModel> | $Enums.StandardStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStandardStatusFilter<$PrismaModel>
    _max?: NestedEnumStandardStatusFilter<$PrismaModel>
  }

  export type StandardCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductStandardCategoryProductIdCategoryIdCompoundUniqueInput = {
    productId: string
    categoryId: string
  }

  export type ProductStandardCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductStandardCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductStandardCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumParameterDataTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ParameterDataType | EnumParameterDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParameterDataTypeFilter<$PrismaModel> | $Enums.ParameterDataType
  }

  export type UnitOfMeasurementNullableScalarRelationFilter = {
    is?: UnitOfMeasurementWhereInput | null
    isNot?: UnitOfMeasurementWhereInput | null
  }

  export type StandardParameterNameCategoryIdProductTypeCompoundUniqueInput = {
    name: string
    categoryId: string
    productType: string
  }

  export type StandardParameterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
    productType?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardParameterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
    productType?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardParameterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
    productType?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumParameterDataTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParameterDataType | EnumParameterDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParameterDataTypeWithAggregatesFilter<$PrismaModel> | $Enums.ParameterDataType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParameterDataTypeFilter<$PrismaModel>
    _max?: NestedEnumParameterDataTypeFilter<$PrismaModel>
  }

  export type MethodologyNullableScalarRelationFilter = {
    is?: MethodologyWhereInput | null
    isNot?: MethodologyWhereInput | null
  }

  export type StandardDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    parameterId?: SortOrder
    standardValue?: SortOrder
    unitId?: SortOrder
    methodologyId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    parameterId?: SortOrder
    standardValue?: SortOrder
    unitId?: SortOrder
    methodologyId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    parameterId?: SortOrder
    standardValue?: SortOrder
    unitId?: SortOrder
    methodologyId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchScalarRelationFilter = {
    is?: BatchWhereInput
    isNot?: BatchWhereInput
  }

  export type BatchParameterValueBatchIdParameterIdCompoundUniqueInput = {
    batchId: string
    parameterId: string
  }

  export type BatchParameterValueCountOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    parameterId?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
    methodologyId?: SortOrder
    verificationResult?: SortOrder
    verificationRemark?: SortOrder
    verifiedById?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchParameterValueMaxOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    parameterId?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
    methodologyId?: SortOrder
    verificationResult?: SortOrder
    verificationRemark?: SortOrder
    verifiedById?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchParameterValueMinOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    parameterId?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
    methodologyId?: SortOrder
    verificationResult?: SortOrder
    verificationRemark?: SortOrder
    verifiedById?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TrainingCalendarMonthYearCompoundUniqueInput = {
    month: number
    year: number
  }

  export type TrainingCalendarCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingCalendarAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
  }

  export type TrainingCalendarMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingCalendarMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingCalendarSumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumTrainingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingTypeFilter<$PrismaModel> | $Enums.TrainingType
  }

  export type EnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TrainingCalendarScalarRelationFilter = {
    is?: TrainingCalendarWhereInput
    isNot?: TrainingCalendarWhereInput
  }

  export type TrainingSessionListRelationFilter = {
    every?: TrainingSessionWhereInput
    some?: TrainingSessionWhereInput
    none?: TrainingSessionWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type TrainingParticipantListRelationFilter = {
    every?: TrainingParticipantWhereInput
    some?: TrainingParticipantWhereInput
    none?: TrainingParticipantWhereInput
  }

  export type TrainingFeedbackListRelationFilter = {
    every?: TrainingFeedbackWhereInput
    some?: TrainingFeedbackWhereInput
    none?: TrainingFeedbackWhereInput
  }

  export type TrainingInviteTokenListRelationFilter = {
    every?: TrainingInviteTokenWhereInput
    some?: TrainingInviteTokenWhereInput
    none?: TrainingInviteTokenWhereInput
  }

  export type TrainingSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingInviteTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    trainingType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    maxParticipants?: SortOrder
    trainerId?: SortOrder
    calendarId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingAvgOrderByAggregateInput = {
    maxParticipants?: SortOrder
  }

  export type TrainingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    trainingType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    maxParticipants?: SortOrder
    trainerId?: SortOrder
    calendarId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    trainingType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    maxParticipants?: SortOrder
    trainerId?: SortOrder
    calendarId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingSumOrderByAggregateInput = {
    maxParticipants?: SortOrder
  }

  export type EnumTrainingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrainingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingTypeFilter<$PrismaModel>
    _max?: NestedEnumTrainingTypeFilter<$PrismaModel>
  }

  export type EnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type TrainingScalarRelationFilter = {
    is?: TrainingWhereInput
    isNot?: TrainingWhereInput
  }

  export type TrainingSessionCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingSessionMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type TrainingDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrder
    documentType?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrder
    documentType?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrder
    documentType?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type ParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    organization?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    organization?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    organization?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParticipantScalarRelationFilter = {
    is?: ParticipantWhereInput
    isNot?: ParticipantWhereInput
  }

  export type TrainingParticipantTrainingIdParticipantIdCompoundUniqueInput = {
    trainingId: string
    participantId: string
  }

  export type TrainingParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrder
    inviteSent?: SortOrder
    inviteSentAt?: SortOrder
    inviteAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrder
    inviteSent?: SortOrder
    inviteSentAt?: SortOrder
    inviteAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrder
    inviteSent?: SortOrder
    inviteSentAt?: SortOrder
    inviteAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type TrainingSessionScalarRelationFilter = {
    is?: TrainingSessionWhereInput
    isNot?: TrainingSessionWhereInput
  }

  export type AttendanceSessionIdParticipantIdCompoundUniqueInput = {
    sessionId: string
    participantId: string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    participantId?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    signatureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    participantId?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    signatureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    participantId?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    signatureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type TrainingPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingFeedbackTrainingIdParticipantIdCompoundUniqueInput = {
    trainingId: string
    participantId: string
  }

  export type TrainingFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrder
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
    comments?: SortOrder
    suggestedImprovements?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingFeedbackAvgOrderByAggregateInput = {
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
  }

  export type TrainingFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrder
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
    comments?: SortOrder
    suggestedImprovements?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrder
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
    comments?: SortOrder
    suggestedImprovements?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingFeedbackSumOrderByAggregateInput = {
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
  }

  export type FeedbackFormSessionIdParticipantIdCompoundUniqueInput = {
    sessionId: string
    participantId: string
  }

  export type FeedbackFormCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    participantId?: SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrder
    submittedAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type FeedbackFormMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    participantId?: SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrder
    submittedAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type FeedbackFormMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    participantId?: SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrder
    submittedAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type TrainingFollowupCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    isCompleted?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TrainingFollowupMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    isCompleted?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TrainingFollowupMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    isCompleted?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TrainingNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
  }

  export type TrainingNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
  }

  export type TrainingNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
  }

  export type ParticipantNullableScalarRelationFilter = {
    is?: ParticipantWhereInput | null
    isNot?: ParticipantWhereInput | null
  }

  export type TrainingInviteTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    action?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingInviteTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    action?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingInviteTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    action?: SortOrder
    trainingId?: SortOrder
    participantId?: SortOrder
    email?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingSessionPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingSessionPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingSessionPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    isExternal?: SortOrder
    firmName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    isExternal?: SortOrder
    firmName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    userId?: SortOrder
    isExternal?: SortOrder
    firmName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuditTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditType | EnumAuditTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditType[] | ListEnumAuditTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditType[] | ListEnumAuditTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditTypeFilter<$PrismaModel> | $Enums.AuditType
  }

  export type EnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type AuditorScalarRelationFilter = {
    is?: AuditorWhereInput
    isNot?: AuditorWhereInput
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type AuditCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    auditType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    auditorId?: SortOrder
    auditeeId?: SortOrder
    firmName?: SortOrder
    departmentId?: SortOrder
    objectives?: SortOrder
    scope?: SortOrder
    summary?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    auditType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    auditorId?: SortOrder
    auditeeId?: SortOrder
    firmName?: SortOrder
    departmentId?: SortOrder
    objectives?: SortOrder
    scope?: SortOrder
    summary?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    auditType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    auditorId?: SortOrder
    auditeeId?: SortOrder
    firmName?: SortOrder
    departmentId?: SortOrder
    objectives?: SortOrder
    scope?: SortOrder
    summary?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuditTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditType | EnumAuditTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditType[] | ListEnumAuditTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditType[] | ListEnumAuditTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditTypeFilter<$PrismaModel>
  }

  export type EnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type AuditScalarRelationFilter = {
    is?: AuditWhereInput
    isNot?: AuditWhereInput
  }

  export type AuditInspectionItemCountOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    areaName?: SortOrder
    itemName?: SortOrder
    description?: SortOrder
    standardReference?: SortOrder
    isCompliant?: SortOrder
    comments?: SortOrder
    evidence?: SortOrder
    inspectedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditInspectionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    areaName?: SortOrder
    itemName?: SortOrder
    description?: SortOrder
    standardReference?: SortOrder
    isCompliant?: SortOrder
    comments?: SortOrder
    evidence?: SortOrder
    inspectedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditInspectionItemMinOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    areaName?: SortOrder
    itemName?: SortOrder
    description?: SortOrder
    standardReference?: SortOrder
    isCompliant?: SortOrder
    comments?: SortOrder
    evidence?: SortOrder
    inspectedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFindingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FindingType | EnumFindingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FindingType[] | ListEnumFindingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FindingType[] | ListEnumFindingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFindingTypeFilter<$PrismaModel> | $Enums.FindingType
  }

  export type EnumFindingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FindingStatus | EnumFindingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FindingStatus[] | ListEnumFindingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FindingStatus[] | ListEnumFindingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFindingStatusFilter<$PrismaModel> | $Enums.FindingStatus
  }

  export type EnumPriorityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableFilter<$PrismaModel> | $Enums.Priority | null
  }

  export type FindingCountOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    findingType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    assignedToId?: SortOrder
    evidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type FindingMaxOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    findingType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    assignedToId?: SortOrder
    evidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type FindingMinOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    findingType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    assignedToId?: SortOrder
    evidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type EnumFindingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FindingType | EnumFindingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FindingType[] | ListEnumFindingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FindingType[] | ListEnumFindingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFindingTypeWithAggregatesFilter<$PrismaModel> | $Enums.FindingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFindingTypeFilter<$PrismaModel>
    _max?: NestedEnumFindingTypeFilter<$PrismaModel>
  }

  export type EnumFindingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FindingStatus | EnumFindingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FindingStatus[] | ListEnumFindingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FindingStatus[] | ListEnumFindingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFindingStatusWithAggregatesFilter<$PrismaModel> | $Enums.FindingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFindingStatusFilter<$PrismaModel>
    _max?: NestedEnumFindingStatusFilter<$PrismaModel>
  }

  export type EnumPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Priority | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPriorityNullableFilter<$PrismaModel>
    _max?: NestedEnumPriorityNullableFilter<$PrismaModel>
  }

  export type FindingNullableScalarRelationFilter = {
    is?: FindingWhereInput | null
    isNot?: FindingWhereInput | null
  }

  export type CorrectiveActionCountOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    findingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    actionType?: SortOrder
    assignedToId?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    verifiedAt?: SortOrder
    verifiedById?: SortOrder
    evidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorrectiveActionMaxOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    findingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    actionType?: SortOrder
    assignedToId?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    verifiedAt?: SortOrder
    verifiedById?: SortOrder
    evidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorrectiveActionMinOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    findingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    actionType?: SortOrder
    assignedToId?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    verifiedAt?: SortOrder
    verifiedById?: SortOrder
    evidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuditDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditDocumentType | EnumAuditDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditDocumentType[] | ListEnumAuditDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditDocumentType[] | ListEnumAuditDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditDocumentTypeFilter<$PrismaModel> | $Enums.AuditDocumentType
  }

  export type AuditDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    documentType?: SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    documentType?: SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    documentType?: SortOrder
    fileUrl?: SortOrder
    filePath?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuditDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditDocumentType | EnumAuditDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditDocumentType[] | ListEnumAuditDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditDocumentType[] | ListEnumAuditDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditDocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditDocumentTypeFilter<$PrismaModel>
  }

  export type PreAuditChecklistItemCountOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    description?: SortOrder
    isCompleted?: SortOrder
    comments?: SortOrder
    responsibleId?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreAuditChecklistItemMaxOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    description?: SortOrder
    isCompleted?: SortOrder
    comments?: SortOrder
    responsibleId?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreAuditChecklistItemMinOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    description?: SortOrder
    isCompleted?: SortOrder
    comments?: SortOrder
    responsibleId?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditReminderCountOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    recipientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
  }

  export type AuditReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    recipientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
  }

  export type AuditReminderMinOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    recipientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
  }

  export type AuditNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
  }

  export type AuditNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
  }

  export type AuditNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
  }

  export type BatchCreateNestedOneWithoutActivityLogInput = {
    create?: XOR<BatchCreateWithoutActivityLogInput, BatchUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: BatchCreateOrConnectWithoutActivityLogInput
    connect?: BatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivityLogInput = {
    create?: XOR<UserCreateWithoutActivityLogInput, UserUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BatchUpdateOneWithoutActivityLogNestedInput = {
    create?: XOR<BatchCreateWithoutActivityLogInput, BatchUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: BatchCreateOrConnectWithoutActivityLogInput
    upsert?: BatchUpsertWithoutActivityLogInput
    disconnect?: BatchWhereInput | boolean
    delete?: BatchWhereInput | boolean
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutActivityLogInput, BatchUpdateWithoutActivityLogInput>, BatchUncheckedUpdateWithoutActivityLogInput>
  }

  export type UserUpdateOneRequiredWithoutActivityLogNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogInput, UserUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogInput
    upsert?: UserUpsertWithoutActivityLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogInput, UserUpdateWithoutActivityLogInput>, UserUncheckedUpdateWithoutActivityLogInput>
  }

  export type ActivityLogCreateNestedManyWithoutBatchInput = {
    create?: XOR<ActivityLogCreateWithoutBatchInput, ActivityLogUncheckedCreateWithoutBatchInput> | ActivityLogCreateWithoutBatchInput[] | ActivityLogUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutBatchInput | ActivityLogCreateOrConnectWithoutBatchInput[]
    createMany?: ActivityLogCreateManyBatchInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput = {
    create?: XOR<UserCreateWithoutBatch_Batch_checkerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_checkerIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBatch_Batch_checkerIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput = {
    create?: XOR<UserCreateWithoutBatch_Batch_makerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_makerIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBatch_Batch_makerIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutBatchInput = {
    create?: XOR<ProductCreateWithoutBatchInput, ProductUncheckedCreateWithoutBatchInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBatchInput
    connect?: ProductWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutBatchInput = {
    create?: XOR<NotificationCreateWithoutBatchInput, NotificationUncheckedCreateWithoutBatchInput> | NotificationCreateWithoutBatchInput[] | NotificationUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBatchInput | NotificationCreateOrConnectWithoutBatchInput[]
    createMany?: NotificationCreateManyBatchInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StandardCreateNestedManyWithoutBatchesInput = {
    create?: XOR<StandardCreateWithoutBatchesInput, StandardUncheckedCreateWithoutBatchesInput> | StandardCreateWithoutBatchesInput[] | StandardUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutBatchesInput | StandardCreateOrConnectWithoutBatchesInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type MethodologyCreateNestedManyWithoutBatchesInput = {
    create?: XOR<MethodologyCreateWithoutBatchesInput, MethodologyUncheckedCreateWithoutBatchesInput> | MethodologyCreateWithoutBatchesInput[] | MethodologyUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutBatchesInput | MethodologyCreateOrConnectWithoutBatchesInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
  }

  export type UnitOfMeasurementCreateNestedManyWithoutBatchesInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutBatchesInput, UnitOfMeasurementUncheckedCreateWithoutBatchesInput> | UnitOfMeasurementCreateWithoutBatchesInput[] | UnitOfMeasurementUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutBatchesInput | UnitOfMeasurementCreateOrConnectWithoutBatchesInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
  }

  export type BatchParameterValueCreateNestedManyWithoutBatchInput = {
    create?: XOR<BatchParameterValueCreateWithoutBatchInput, BatchParameterValueUncheckedCreateWithoutBatchInput> | BatchParameterValueCreateWithoutBatchInput[] | BatchParameterValueUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutBatchInput | BatchParameterValueCreateOrConnectWithoutBatchInput[]
    createMany?: BatchParameterValueCreateManyBatchInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<ActivityLogCreateWithoutBatchInput, ActivityLogUncheckedCreateWithoutBatchInput> | ActivityLogCreateWithoutBatchInput[] | ActivityLogUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutBatchInput | ActivityLogCreateOrConnectWithoutBatchInput[]
    createMany?: ActivityLogCreateManyBatchInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<NotificationCreateWithoutBatchInput, NotificationUncheckedCreateWithoutBatchInput> | NotificationCreateWithoutBatchInput[] | NotificationUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBatchInput | NotificationCreateOrConnectWithoutBatchInput[]
    createMany?: NotificationCreateManyBatchInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StandardUncheckedCreateNestedManyWithoutBatchesInput = {
    create?: XOR<StandardCreateWithoutBatchesInput, StandardUncheckedCreateWithoutBatchesInput> | StandardCreateWithoutBatchesInput[] | StandardUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutBatchesInput | StandardCreateOrConnectWithoutBatchesInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type MethodologyUncheckedCreateNestedManyWithoutBatchesInput = {
    create?: XOR<MethodologyCreateWithoutBatchesInput, MethodologyUncheckedCreateWithoutBatchesInput> | MethodologyCreateWithoutBatchesInput[] | MethodologyUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutBatchesInput | MethodologyCreateOrConnectWithoutBatchesInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
  }

  export type UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutBatchesInput, UnitOfMeasurementUncheckedCreateWithoutBatchesInput> | UnitOfMeasurementCreateWithoutBatchesInput[] | UnitOfMeasurementUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutBatchesInput | UnitOfMeasurementCreateOrConnectWithoutBatchesInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
  }

  export type BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<BatchParameterValueCreateWithoutBatchInput, BatchParameterValueUncheckedCreateWithoutBatchInput> | BatchParameterValueCreateWithoutBatchInput[] | BatchParameterValueUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutBatchInput | BatchParameterValueCreateOrConnectWithoutBatchInput[]
    createMany?: BatchParameterValueCreateManyBatchInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumSampleAnalysisStatusFieldUpdateOperationsInput = {
    set?: $Enums.SampleAnalysisStatus
  }

  export type EnumBatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.BatchStatus
  }

  export type ActivityLogUpdateManyWithoutBatchNestedInput = {
    create?: XOR<ActivityLogCreateWithoutBatchInput, ActivityLogUncheckedCreateWithoutBatchInput> | ActivityLogCreateWithoutBatchInput[] | ActivityLogUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutBatchInput | ActivityLogCreateOrConnectWithoutBatchInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutBatchInput | ActivityLogUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: ActivityLogCreateManyBatchInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutBatchInput | ActivityLogUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutBatchInput | ActivityLogUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutBatch_Batch_checkerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_checkerIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBatch_Batch_checkerIdToUserInput
    upsert?: UserUpsertWithoutBatch_Batch_checkerIdToUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBatch_Batch_checkerIdToUserInput, UserUpdateWithoutBatch_Batch_checkerIdToUserInput>, UserUncheckedUpdateWithoutBatch_Batch_checkerIdToUserInput>
  }

  export type UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutBatch_Batch_makerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_makerIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBatch_Batch_makerIdToUserInput
    upsert?: UserUpsertWithoutBatch_Batch_makerIdToUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBatch_Batch_makerIdToUserInput, UserUpdateWithoutBatch_Batch_makerIdToUserInput>, UserUncheckedUpdateWithoutBatch_Batch_makerIdToUserInput>
  }

  export type ProductUpdateOneRequiredWithoutBatchNestedInput = {
    create?: XOR<ProductCreateWithoutBatchInput, ProductUncheckedCreateWithoutBatchInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBatchInput
    upsert?: ProductUpsertWithoutBatchInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutBatchInput, ProductUpdateWithoutBatchInput>, ProductUncheckedUpdateWithoutBatchInput>
  }

  export type NotificationUpdateManyWithoutBatchNestedInput = {
    create?: XOR<NotificationCreateWithoutBatchInput, NotificationUncheckedCreateWithoutBatchInput> | NotificationCreateWithoutBatchInput[] | NotificationUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBatchInput | NotificationCreateOrConnectWithoutBatchInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBatchInput | NotificationUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: NotificationCreateManyBatchInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBatchInput | NotificationUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBatchInput | NotificationUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StandardUpdateManyWithoutBatchesNestedInput = {
    create?: XOR<StandardCreateWithoutBatchesInput, StandardUncheckedCreateWithoutBatchesInput> | StandardCreateWithoutBatchesInput[] | StandardUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutBatchesInput | StandardCreateOrConnectWithoutBatchesInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutBatchesInput | StandardUpsertWithWhereUniqueWithoutBatchesInput[]
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutBatchesInput | StandardUpdateWithWhereUniqueWithoutBatchesInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutBatchesInput | StandardUpdateManyWithWhereWithoutBatchesInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type MethodologyUpdateManyWithoutBatchesNestedInput = {
    create?: XOR<MethodologyCreateWithoutBatchesInput, MethodologyUncheckedCreateWithoutBatchesInput> | MethodologyCreateWithoutBatchesInput[] | MethodologyUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutBatchesInput | MethodologyCreateOrConnectWithoutBatchesInput[]
    upsert?: MethodologyUpsertWithWhereUniqueWithoutBatchesInput | MethodologyUpsertWithWhereUniqueWithoutBatchesInput[]
    set?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    disconnect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    delete?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    update?: MethodologyUpdateWithWhereUniqueWithoutBatchesInput | MethodologyUpdateWithWhereUniqueWithoutBatchesInput[]
    updateMany?: MethodologyUpdateManyWithWhereWithoutBatchesInput | MethodologyUpdateManyWithWhereWithoutBatchesInput[]
    deleteMany?: MethodologyScalarWhereInput | MethodologyScalarWhereInput[]
  }

  export type UnitOfMeasurementUpdateManyWithoutBatchesNestedInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutBatchesInput, UnitOfMeasurementUncheckedCreateWithoutBatchesInput> | UnitOfMeasurementCreateWithoutBatchesInput[] | UnitOfMeasurementUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutBatchesInput | UnitOfMeasurementCreateOrConnectWithoutBatchesInput[]
    upsert?: UnitOfMeasurementUpsertWithWhereUniqueWithoutBatchesInput | UnitOfMeasurementUpsertWithWhereUniqueWithoutBatchesInput[]
    set?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    disconnect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    delete?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    update?: UnitOfMeasurementUpdateWithWhereUniqueWithoutBatchesInput | UnitOfMeasurementUpdateWithWhereUniqueWithoutBatchesInput[]
    updateMany?: UnitOfMeasurementUpdateManyWithWhereWithoutBatchesInput | UnitOfMeasurementUpdateManyWithWhereWithoutBatchesInput[]
    deleteMany?: UnitOfMeasurementScalarWhereInput | UnitOfMeasurementScalarWhereInput[]
  }

  export type BatchParameterValueUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutBatchInput, BatchParameterValueUncheckedCreateWithoutBatchInput> | BatchParameterValueCreateWithoutBatchInput[] | BatchParameterValueUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutBatchInput | BatchParameterValueCreateOrConnectWithoutBatchInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutBatchInput | BatchParameterValueUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BatchParameterValueCreateManyBatchInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutBatchInput | BatchParameterValueUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutBatchInput | BatchParameterValueUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<ActivityLogCreateWithoutBatchInput, ActivityLogUncheckedCreateWithoutBatchInput> | ActivityLogCreateWithoutBatchInput[] | ActivityLogUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutBatchInput | ActivityLogCreateOrConnectWithoutBatchInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutBatchInput | ActivityLogUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: ActivityLogCreateManyBatchInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutBatchInput | ActivityLogUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutBatchInput | ActivityLogUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<NotificationCreateWithoutBatchInput, NotificationUncheckedCreateWithoutBatchInput> | NotificationCreateWithoutBatchInput[] | NotificationUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBatchInput | NotificationCreateOrConnectWithoutBatchInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBatchInput | NotificationUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: NotificationCreateManyBatchInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBatchInput | NotificationUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBatchInput | NotificationUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StandardUncheckedUpdateManyWithoutBatchesNestedInput = {
    create?: XOR<StandardCreateWithoutBatchesInput, StandardUncheckedCreateWithoutBatchesInput> | StandardCreateWithoutBatchesInput[] | StandardUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutBatchesInput | StandardCreateOrConnectWithoutBatchesInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutBatchesInput | StandardUpsertWithWhereUniqueWithoutBatchesInput[]
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutBatchesInput | StandardUpdateWithWhereUniqueWithoutBatchesInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutBatchesInput | StandardUpdateManyWithWhereWithoutBatchesInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type MethodologyUncheckedUpdateManyWithoutBatchesNestedInput = {
    create?: XOR<MethodologyCreateWithoutBatchesInput, MethodologyUncheckedCreateWithoutBatchesInput> | MethodologyCreateWithoutBatchesInput[] | MethodologyUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutBatchesInput | MethodologyCreateOrConnectWithoutBatchesInput[]
    upsert?: MethodologyUpsertWithWhereUniqueWithoutBatchesInput | MethodologyUpsertWithWhereUniqueWithoutBatchesInput[]
    set?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    disconnect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    delete?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    update?: MethodologyUpdateWithWhereUniqueWithoutBatchesInput | MethodologyUpdateWithWhereUniqueWithoutBatchesInput[]
    updateMany?: MethodologyUpdateManyWithWhereWithoutBatchesInput | MethodologyUpdateManyWithWhereWithoutBatchesInput[]
    deleteMany?: MethodologyScalarWhereInput | MethodologyScalarWhereInput[]
  }

  export type UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutBatchesInput, UnitOfMeasurementUncheckedCreateWithoutBatchesInput> | UnitOfMeasurementCreateWithoutBatchesInput[] | UnitOfMeasurementUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutBatchesInput | UnitOfMeasurementCreateOrConnectWithoutBatchesInput[]
    upsert?: UnitOfMeasurementUpsertWithWhereUniqueWithoutBatchesInput | UnitOfMeasurementUpsertWithWhereUniqueWithoutBatchesInput[]
    set?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    disconnect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    delete?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    update?: UnitOfMeasurementUpdateWithWhereUniqueWithoutBatchesInput | UnitOfMeasurementUpdateWithWhereUniqueWithoutBatchesInput[]
    updateMany?: UnitOfMeasurementUpdateManyWithWhereWithoutBatchesInput | UnitOfMeasurementUpdateManyWithWhereWithoutBatchesInput[]
    deleteMany?: UnitOfMeasurementScalarWhereInput | UnitOfMeasurementScalarWhereInput[]
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutBatchInput, BatchParameterValueUncheckedCreateWithoutBatchInput> | BatchParameterValueCreateWithoutBatchInput[] | BatchParameterValueUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutBatchInput | BatchParameterValueCreateOrConnectWithoutBatchInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutBatchInput | BatchParameterValueUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BatchParameterValueCreateManyBatchInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutBatchInput | BatchParameterValueUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutBatchInput | BatchParameterValueUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type StandardCreateNestedManyWithoutMethodologiesInput = {
    create?: XOR<StandardCreateWithoutMethodologiesInput, StandardUncheckedCreateWithoutMethodologiesInput> | StandardCreateWithoutMethodologiesInput[] | StandardUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutMethodologiesInput | StandardCreateOrConnectWithoutMethodologiesInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type BatchCreateNestedManyWithoutMethodologiesInput = {
    create?: XOR<BatchCreateWithoutMethodologiesInput, BatchUncheckedCreateWithoutMethodologiesInput> | BatchCreateWithoutMethodologiesInput[] | BatchUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutMethodologiesInput | BatchCreateOrConnectWithoutMethodologiesInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchParameterValueCreateNestedManyWithoutMethodologyInput = {
    create?: XOR<BatchParameterValueCreateWithoutMethodologyInput, BatchParameterValueUncheckedCreateWithoutMethodologyInput> | BatchParameterValueCreateWithoutMethodologyInput[] | BatchParameterValueUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutMethodologyInput | BatchParameterValueCreateOrConnectWithoutMethodologyInput[]
    createMany?: BatchParameterValueCreateManyMethodologyInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type StandardDefinitionCreateNestedManyWithoutMethodologyInput = {
    create?: XOR<StandardDefinitionCreateWithoutMethodologyInput, StandardDefinitionUncheckedCreateWithoutMethodologyInput> | StandardDefinitionCreateWithoutMethodologyInput[] | StandardDefinitionUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutMethodologyInput | StandardDefinitionCreateOrConnectWithoutMethodologyInput[]
    createMany?: StandardDefinitionCreateManyMethodologyInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type StandardUncheckedCreateNestedManyWithoutMethodologiesInput = {
    create?: XOR<StandardCreateWithoutMethodologiesInput, StandardUncheckedCreateWithoutMethodologiesInput> | StandardCreateWithoutMethodologiesInput[] | StandardUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutMethodologiesInput | StandardCreateOrConnectWithoutMethodologiesInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutMethodologiesInput = {
    create?: XOR<BatchCreateWithoutMethodologiesInput, BatchUncheckedCreateWithoutMethodologiesInput> | BatchCreateWithoutMethodologiesInput[] | BatchUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutMethodologiesInput | BatchCreateOrConnectWithoutMethodologiesInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchParameterValueUncheckedCreateNestedManyWithoutMethodologyInput = {
    create?: XOR<BatchParameterValueCreateWithoutMethodologyInput, BatchParameterValueUncheckedCreateWithoutMethodologyInput> | BatchParameterValueCreateWithoutMethodologyInput[] | BatchParameterValueUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutMethodologyInput | BatchParameterValueCreateOrConnectWithoutMethodologyInput[]
    createMany?: BatchParameterValueCreateManyMethodologyInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type StandardDefinitionUncheckedCreateNestedManyWithoutMethodologyInput = {
    create?: XOR<StandardDefinitionCreateWithoutMethodologyInput, StandardDefinitionUncheckedCreateWithoutMethodologyInput> | StandardDefinitionCreateWithoutMethodologyInput[] | StandardDefinitionUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutMethodologyInput | StandardDefinitionCreateOrConnectWithoutMethodologyInput[]
    createMany?: StandardDefinitionCreateManyMethodologyInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type StandardUpdateManyWithoutMethodologiesNestedInput = {
    create?: XOR<StandardCreateWithoutMethodologiesInput, StandardUncheckedCreateWithoutMethodologiesInput> | StandardCreateWithoutMethodologiesInput[] | StandardUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutMethodologiesInput | StandardCreateOrConnectWithoutMethodologiesInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutMethodologiesInput | StandardUpsertWithWhereUniqueWithoutMethodologiesInput[]
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutMethodologiesInput | StandardUpdateWithWhereUniqueWithoutMethodologiesInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutMethodologiesInput | StandardUpdateManyWithWhereWithoutMethodologiesInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type BatchUpdateManyWithoutMethodologiesNestedInput = {
    create?: XOR<BatchCreateWithoutMethodologiesInput, BatchUncheckedCreateWithoutMethodologiesInput> | BatchCreateWithoutMethodologiesInput[] | BatchUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutMethodologiesInput | BatchCreateOrConnectWithoutMethodologiesInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutMethodologiesInput | BatchUpsertWithWhereUniqueWithoutMethodologiesInput[]
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutMethodologiesInput | BatchUpdateWithWhereUniqueWithoutMethodologiesInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutMethodologiesInput | BatchUpdateManyWithWhereWithoutMethodologiesInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchParameterValueUpdateManyWithoutMethodologyNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutMethodologyInput, BatchParameterValueUncheckedCreateWithoutMethodologyInput> | BatchParameterValueCreateWithoutMethodologyInput[] | BatchParameterValueUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutMethodologyInput | BatchParameterValueCreateOrConnectWithoutMethodologyInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutMethodologyInput | BatchParameterValueUpsertWithWhereUniqueWithoutMethodologyInput[]
    createMany?: BatchParameterValueCreateManyMethodologyInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutMethodologyInput | BatchParameterValueUpdateWithWhereUniqueWithoutMethodologyInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutMethodologyInput | BatchParameterValueUpdateManyWithWhereWithoutMethodologyInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type StandardDefinitionUpdateManyWithoutMethodologyNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutMethodologyInput, StandardDefinitionUncheckedCreateWithoutMethodologyInput> | StandardDefinitionCreateWithoutMethodologyInput[] | StandardDefinitionUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutMethodologyInput | StandardDefinitionCreateOrConnectWithoutMethodologyInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutMethodologyInput | StandardDefinitionUpsertWithWhereUniqueWithoutMethodologyInput[]
    createMany?: StandardDefinitionCreateManyMethodologyInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutMethodologyInput | StandardDefinitionUpdateWithWhereUniqueWithoutMethodologyInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutMethodologyInput | StandardDefinitionUpdateManyWithWhereWithoutMethodologyInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type StandardUncheckedUpdateManyWithoutMethodologiesNestedInput = {
    create?: XOR<StandardCreateWithoutMethodologiesInput, StandardUncheckedCreateWithoutMethodologiesInput> | StandardCreateWithoutMethodologiesInput[] | StandardUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutMethodologiesInput | StandardCreateOrConnectWithoutMethodologiesInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutMethodologiesInput | StandardUpsertWithWhereUniqueWithoutMethodologiesInput[]
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutMethodologiesInput | StandardUpdateWithWhereUniqueWithoutMethodologiesInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutMethodologiesInput | StandardUpdateManyWithWhereWithoutMethodologiesInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutMethodologiesNestedInput = {
    create?: XOR<BatchCreateWithoutMethodologiesInput, BatchUncheckedCreateWithoutMethodologiesInput> | BatchCreateWithoutMethodologiesInput[] | BatchUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutMethodologiesInput | BatchCreateOrConnectWithoutMethodologiesInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutMethodologiesInput | BatchUpsertWithWhereUniqueWithoutMethodologiesInput[]
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutMethodologiesInput | BatchUpdateWithWhereUniqueWithoutMethodologiesInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutMethodologiesInput | BatchUpdateManyWithWhereWithoutMethodologiesInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutMethodologyNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutMethodologyInput, BatchParameterValueUncheckedCreateWithoutMethodologyInput> | BatchParameterValueCreateWithoutMethodologyInput[] | BatchParameterValueUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutMethodologyInput | BatchParameterValueCreateOrConnectWithoutMethodologyInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutMethodologyInput | BatchParameterValueUpsertWithWhereUniqueWithoutMethodologyInput[]
    createMany?: BatchParameterValueCreateManyMethodologyInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutMethodologyInput | BatchParameterValueUpdateWithWhereUniqueWithoutMethodologyInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutMethodologyInput | BatchParameterValueUpdateManyWithWhereWithoutMethodologyInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutMethodologyNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutMethodologyInput, StandardDefinitionUncheckedCreateWithoutMethodologyInput> | StandardDefinitionCreateWithoutMethodologyInput[] | StandardDefinitionUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutMethodologyInput | StandardDefinitionCreateOrConnectWithoutMethodologyInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutMethodologyInput | StandardDefinitionUpsertWithWhereUniqueWithoutMethodologyInput[]
    createMany?: StandardDefinitionCreateManyMethodologyInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutMethodologyInput | StandardDefinitionUpdateWithWhereUniqueWithoutMethodologyInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutMethodologyInput | StandardDefinitionUpdateManyWithWhereWithoutMethodologyInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type BatchCreateNestedOneWithoutNotificationInput = {
    create?: XOR<BatchCreateWithoutNotificationInput, BatchUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: BatchCreateOrConnectWithoutNotificationInput
    connect?: BatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BatchUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<BatchCreateWithoutNotificationInput, BatchUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: BatchCreateOrConnectWithoutNotificationInput
    upsert?: BatchUpsertWithoutNotificationInput
    disconnect?: BatchWhereInput | boolean
    delete?: BatchWhereInput | boolean
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutNotificationInput, BatchUpdateWithoutNotificationInput>, BatchUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type RoleCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RoleCreateWithoutPermissionInput, RoleUncheckedCreateWithoutPermissionInput> | RoleCreateWithoutPermissionInput[] | RoleUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionInput | RoleCreateOrConnectWithoutPermissionInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RoleCreateWithoutPermissionInput, RoleUncheckedCreateWithoutPermissionInput> | RoleCreateWithoutPermissionInput[] | RoleUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionInput | RoleCreateOrConnectWithoutPermissionInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type RoleUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionInput, RoleUncheckedCreateWithoutPermissionInput> | RoleCreateWithoutPermissionInput[] | RoleUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionInput | RoleCreateOrConnectWithoutPermissionInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutPermissionInput | RoleUpsertWithWhereUniqueWithoutPermissionInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutPermissionInput | RoleUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutPermissionInput | RoleUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionInput, RoleUncheckedCreateWithoutPermissionInput> | RoleCreateWithoutPermissionInput[] | RoleUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionInput | RoleCreateOrConnectWithoutPermissionInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutPermissionInput | RoleUpsertWithWhereUniqueWithoutPermissionInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutPermissionInput | RoleUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutPermissionInput | RoleUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type BatchCreateNestedManyWithoutProductInput = {
    create?: XOR<BatchCreateWithoutProductInput, BatchUncheckedCreateWithoutProductInput> | BatchCreateWithoutProductInput[] | BatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutProductInput | BatchCreateOrConnectWithoutProductInput[]
    createMany?: BatchCreateManyProductInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type ProductStandardCategoryCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductStandardCategoryCreateWithoutProductInput, ProductStandardCategoryUncheckedCreateWithoutProductInput> | ProductStandardCategoryCreateWithoutProductInput[] | ProductStandardCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStandardCategoryCreateOrConnectWithoutProductInput | ProductStandardCategoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductStandardCategoryCreateManyProductInputEnvelope
    connect?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
  }

  export type ProductParameterCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductParameterCreateWithoutProductInput, ProductParameterUncheckedCreateWithoutProductInput> | ProductParameterCreateWithoutProductInput[] | ProductParameterUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductParameterCreateOrConnectWithoutProductInput | ProductParameterCreateOrConnectWithoutProductInput[]
    createMany?: ProductParameterCreateManyProductInputEnvelope
    connect?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<BatchCreateWithoutProductInput, BatchUncheckedCreateWithoutProductInput> | BatchCreateWithoutProductInput[] | BatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutProductInput | BatchCreateOrConnectWithoutProductInput[]
    createMany?: BatchCreateManyProductInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type ProductStandardCategoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductStandardCategoryCreateWithoutProductInput, ProductStandardCategoryUncheckedCreateWithoutProductInput> | ProductStandardCategoryCreateWithoutProductInput[] | ProductStandardCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStandardCategoryCreateOrConnectWithoutProductInput | ProductStandardCategoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductStandardCategoryCreateManyProductInputEnvelope
    connect?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
  }

  export type ProductParameterUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductParameterCreateWithoutProductInput, ProductParameterUncheckedCreateWithoutProductInput> | ProductParameterCreateWithoutProductInput[] | ProductParameterUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductParameterCreateOrConnectWithoutProductInput | ProductParameterCreateOrConnectWithoutProductInput[]
    createMany?: ProductParameterCreateManyProductInputEnvelope
    connect?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
  }

  export type BatchUpdateManyWithoutProductNestedInput = {
    create?: XOR<BatchCreateWithoutProductInput, BatchUncheckedCreateWithoutProductInput> | BatchCreateWithoutProductInput[] | BatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutProductInput | BatchCreateOrConnectWithoutProductInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutProductInput | BatchUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: BatchCreateManyProductInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutProductInput | BatchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutProductInput | BatchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type ProductStandardCategoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductStandardCategoryCreateWithoutProductInput, ProductStandardCategoryUncheckedCreateWithoutProductInput> | ProductStandardCategoryCreateWithoutProductInput[] | ProductStandardCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStandardCategoryCreateOrConnectWithoutProductInput | ProductStandardCategoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductStandardCategoryUpsertWithWhereUniqueWithoutProductInput | ProductStandardCategoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductStandardCategoryCreateManyProductInputEnvelope
    set?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    disconnect?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    delete?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    connect?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    update?: ProductStandardCategoryUpdateWithWhereUniqueWithoutProductInput | ProductStandardCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductStandardCategoryUpdateManyWithWhereWithoutProductInput | ProductStandardCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductStandardCategoryScalarWhereInput | ProductStandardCategoryScalarWhereInput[]
  }

  export type ProductParameterUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductParameterCreateWithoutProductInput, ProductParameterUncheckedCreateWithoutProductInput> | ProductParameterCreateWithoutProductInput[] | ProductParameterUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductParameterCreateOrConnectWithoutProductInput | ProductParameterCreateOrConnectWithoutProductInput[]
    upsert?: ProductParameterUpsertWithWhereUniqueWithoutProductInput | ProductParameterUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductParameterCreateManyProductInputEnvelope
    set?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    disconnect?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    delete?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    connect?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    update?: ProductParameterUpdateWithWhereUniqueWithoutProductInput | ProductParameterUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductParameterUpdateManyWithWhereWithoutProductInput | ProductParameterUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductParameterScalarWhereInput | ProductParameterScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<BatchCreateWithoutProductInput, BatchUncheckedCreateWithoutProductInput> | BatchCreateWithoutProductInput[] | BatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutProductInput | BatchCreateOrConnectWithoutProductInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutProductInput | BatchUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: BatchCreateManyProductInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutProductInput | BatchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutProductInput | BatchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type ProductStandardCategoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductStandardCategoryCreateWithoutProductInput, ProductStandardCategoryUncheckedCreateWithoutProductInput> | ProductStandardCategoryCreateWithoutProductInput[] | ProductStandardCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStandardCategoryCreateOrConnectWithoutProductInput | ProductStandardCategoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductStandardCategoryUpsertWithWhereUniqueWithoutProductInput | ProductStandardCategoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductStandardCategoryCreateManyProductInputEnvelope
    set?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    disconnect?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    delete?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    connect?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    update?: ProductStandardCategoryUpdateWithWhereUniqueWithoutProductInput | ProductStandardCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductStandardCategoryUpdateManyWithWhereWithoutProductInput | ProductStandardCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductStandardCategoryScalarWhereInput | ProductStandardCategoryScalarWhereInput[]
  }

  export type ProductParameterUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductParameterCreateWithoutProductInput, ProductParameterUncheckedCreateWithoutProductInput> | ProductParameterCreateWithoutProductInput[] | ProductParameterUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductParameterCreateOrConnectWithoutProductInput | ProductParameterCreateOrConnectWithoutProductInput[]
    upsert?: ProductParameterUpsertWithWhereUniqueWithoutProductInput | ProductParameterUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductParameterCreateManyProductInputEnvelope
    set?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    disconnect?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    delete?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    connect?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    update?: ProductParameterUpdateWithWhereUniqueWithoutProductInput | ProductParameterUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductParameterUpdateManyWithWhereWithoutProductInput | ProductParameterUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductParameterScalarWhereInput | ProductParameterScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutParametersInput = {
    create?: XOR<ProductCreateWithoutParametersInput, ProductUncheckedCreateWithoutParametersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutParametersInput
    connect?: ProductWhereUniqueInput
  }

  export type StandardParameterCreateNestedOneWithoutProductsInput = {
    create?: XOR<StandardParameterCreateWithoutProductsInput, StandardParameterUncheckedCreateWithoutProductsInput>
    connectOrCreate?: StandardParameterCreateOrConnectWithoutProductsInput
    connect?: StandardParameterWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutParametersNestedInput = {
    create?: XOR<ProductCreateWithoutParametersInput, ProductUncheckedCreateWithoutParametersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutParametersInput
    upsert?: ProductUpsertWithoutParametersInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutParametersInput, ProductUpdateWithoutParametersInput>, ProductUncheckedUpdateWithoutParametersInput>
  }

  export type StandardParameterUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<StandardParameterCreateWithoutProductsInput, StandardParameterUncheckedCreateWithoutProductsInput>
    connectOrCreate?: StandardParameterCreateOrConnectWithoutProductsInput
    upsert?: StandardParameterUpsertWithoutProductsInput
    connect?: StandardParameterWhereUniqueInput
    update?: XOR<XOR<StandardParameterUpdateToOneWithWhereWithoutProductsInput, StandardParameterUpdateWithoutProductsInput>, StandardParameterUncheckedUpdateWithoutProductsInput>
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutRoleInput | PermissionUpsertWithWhereUniqueWithoutRoleInput[]
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutRoleInput | PermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutRoleInput | PermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutRoleInput | PermissionUpsertWithWhereUniqueWithoutRoleInput[]
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutRoleInput | PermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutRoleInput | PermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type StandardCreateNestedManyWithoutUnitsInput = {
    create?: XOR<StandardCreateWithoutUnitsInput, StandardUncheckedCreateWithoutUnitsInput> | StandardCreateWithoutUnitsInput[] | StandardUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutUnitsInput | StandardCreateOrConnectWithoutUnitsInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type BatchParameterValueCreateNestedManyWithoutUnitInput = {
    create?: XOR<BatchParameterValueCreateWithoutUnitInput, BatchParameterValueUncheckedCreateWithoutUnitInput> | BatchParameterValueCreateWithoutUnitInput[] | BatchParameterValueUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutUnitInput | BatchParameterValueCreateOrConnectWithoutUnitInput[]
    createMany?: BatchParameterValueCreateManyUnitInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type StandardParameterCreateNestedManyWithoutUnitInput = {
    create?: XOR<StandardParameterCreateWithoutUnitInput, StandardParameterUncheckedCreateWithoutUnitInput> | StandardParameterCreateWithoutUnitInput[] | StandardParameterUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StandardParameterCreateOrConnectWithoutUnitInput | StandardParameterCreateOrConnectWithoutUnitInput[]
    createMany?: StandardParameterCreateManyUnitInputEnvelope
    connect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
  }

  export type StandardDefinitionCreateNestedManyWithoutUnitInput = {
    create?: XOR<StandardDefinitionCreateWithoutUnitInput, StandardDefinitionUncheckedCreateWithoutUnitInput> | StandardDefinitionCreateWithoutUnitInput[] | StandardDefinitionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutUnitInput | StandardDefinitionCreateOrConnectWithoutUnitInput[]
    createMany?: StandardDefinitionCreateManyUnitInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type BatchCreateNestedManyWithoutUnitOfMeasurementsInput = {
    create?: XOR<BatchCreateWithoutUnitOfMeasurementsInput, BatchUncheckedCreateWithoutUnitOfMeasurementsInput> | BatchCreateWithoutUnitOfMeasurementsInput[] | BatchUncheckedCreateWithoutUnitOfMeasurementsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUnitOfMeasurementsInput | BatchCreateOrConnectWithoutUnitOfMeasurementsInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type StandardUncheckedCreateNestedManyWithoutUnitsInput = {
    create?: XOR<StandardCreateWithoutUnitsInput, StandardUncheckedCreateWithoutUnitsInput> | StandardCreateWithoutUnitsInput[] | StandardUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutUnitsInput | StandardCreateOrConnectWithoutUnitsInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type BatchParameterValueUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<BatchParameterValueCreateWithoutUnitInput, BatchParameterValueUncheckedCreateWithoutUnitInput> | BatchParameterValueCreateWithoutUnitInput[] | BatchParameterValueUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutUnitInput | BatchParameterValueCreateOrConnectWithoutUnitInput[]
    createMany?: BatchParameterValueCreateManyUnitInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type StandardParameterUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<StandardParameterCreateWithoutUnitInput, StandardParameterUncheckedCreateWithoutUnitInput> | StandardParameterCreateWithoutUnitInput[] | StandardParameterUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StandardParameterCreateOrConnectWithoutUnitInput | StandardParameterCreateOrConnectWithoutUnitInput[]
    createMany?: StandardParameterCreateManyUnitInputEnvelope
    connect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
  }

  export type StandardDefinitionUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<StandardDefinitionCreateWithoutUnitInput, StandardDefinitionUncheckedCreateWithoutUnitInput> | StandardDefinitionCreateWithoutUnitInput[] | StandardDefinitionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutUnitInput | StandardDefinitionCreateOrConnectWithoutUnitInput[]
    createMany?: StandardDefinitionCreateManyUnitInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutUnitOfMeasurementsInput = {
    create?: XOR<BatchCreateWithoutUnitOfMeasurementsInput, BatchUncheckedCreateWithoutUnitOfMeasurementsInput> | BatchCreateWithoutUnitOfMeasurementsInput[] | BatchUncheckedCreateWithoutUnitOfMeasurementsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUnitOfMeasurementsInput | BatchCreateOrConnectWithoutUnitOfMeasurementsInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type StandardUpdateManyWithoutUnitsNestedInput = {
    create?: XOR<StandardCreateWithoutUnitsInput, StandardUncheckedCreateWithoutUnitsInput> | StandardCreateWithoutUnitsInput[] | StandardUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutUnitsInput | StandardCreateOrConnectWithoutUnitsInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutUnitsInput | StandardUpsertWithWhereUniqueWithoutUnitsInput[]
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutUnitsInput | StandardUpdateWithWhereUniqueWithoutUnitsInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutUnitsInput | StandardUpdateManyWithWhereWithoutUnitsInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type BatchParameterValueUpdateManyWithoutUnitNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutUnitInput, BatchParameterValueUncheckedCreateWithoutUnitInput> | BatchParameterValueCreateWithoutUnitInput[] | BatchParameterValueUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutUnitInput | BatchParameterValueCreateOrConnectWithoutUnitInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutUnitInput | BatchParameterValueUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: BatchParameterValueCreateManyUnitInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutUnitInput | BatchParameterValueUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutUnitInput | BatchParameterValueUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type StandardParameterUpdateManyWithoutUnitNestedInput = {
    create?: XOR<StandardParameterCreateWithoutUnitInput, StandardParameterUncheckedCreateWithoutUnitInput> | StandardParameterCreateWithoutUnitInput[] | StandardParameterUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StandardParameterCreateOrConnectWithoutUnitInput | StandardParameterCreateOrConnectWithoutUnitInput[]
    upsert?: StandardParameterUpsertWithWhereUniqueWithoutUnitInput | StandardParameterUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: StandardParameterCreateManyUnitInputEnvelope
    set?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    disconnect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    delete?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    connect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    update?: StandardParameterUpdateWithWhereUniqueWithoutUnitInput | StandardParameterUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: StandardParameterUpdateManyWithWhereWithoutUnitInput | StandardParameterUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: StandardParameterScalarWhereInput | StandardParameterScalarWhereInput[]
  }

  export type StandardDefinitionUpdateManyWithoutUnitNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutUnitInput, StandardDefinitionUncheckedCreateWithoutUnitInput> | StandardDefinitionCreateWithoutUnitInput[] | StandardDefinitionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutUnitInput | StandardDefinitionCreateOrConnectWithoutUnitInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutUnitInput | StandardDefinitionUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: StandardDefinitionCreateManyUnitInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutUnitInput | StandardDefinitionUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutUnitInput | StandardDefinitionUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type BatchUpdateManyWithoutUnitOfMeasurementsNestedInput = {
    create?: XOR<BatchCreateWithoutUnitOfMeasurementsInput, BatchUncheckedCreateWithoutUnitOfMeasurementsInput> | BatchCreateWithoutUnitOfMeasurementsInput[] | BatchUncheckedCreateWithoutUnitOfMeasurementsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUnitOfMeasurementsInput | BatchCreateOrConnectWithoutUnitOfMeasurementsInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUnitOfMeasurementsInput | BatchUpsertWithWhereUniqueWithoutUnitOfMeasurementsInput[]
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUnitOfMeasurementsInput | BatchUpdateWithWhereUniqueWithoutUnitOfMeasurementsInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUnitOfMeasurementsInput | BatchUpdateManyWithWhereWithoutUnitOfMeasurementsInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type StandardUncheckedUpdateManyWithoutUnitsNestedInput = {
    create?: XOR<StandardCreateWithoutUnitsInput, StandardUncheckedCreateWithoutUnitsInput> | StandardCreateWithoutUnitsInput[] | StandardUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutUnitsInput | StandardCreateOrConnectWithoutUnitsInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutUnitsInput | StandardUpsertWithWhereUniqueWithoutUnitsInput[]
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutUnitsInput | StandardUpdateWithWhereUniqueWithoutUnitsInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutUnitsInput | StandardUpdateManyWithWhereWithoutUnitsInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutUnitInput, BatchParameterValueUncheckedCreateWithoutUnitInput> | BatchParameterValueCreateWithoutUnitInput[] | BatchParameterValueUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutUnitInput | BatchParameterValueCreateOrConnectWithoutUnitInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutUnitInput | BatchParameterValueUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: BatchParameterValueCreateManyUnitInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutUnitInput | BatchParameterValueUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutUnitInput | BatchParameterValueUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type StandardParameterUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<StandardParameterCreateWithoutUnitInput, StandardParameterUncheckedCreateWithoutUnitInput> | StandardParameterCreateWithoutUnitInput[] | StandardParameterUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StandardParameterCreateOrConnectWithoutUnitInput | StandardParameterCreateOrConnectWithoutUnitInput[]
    upsert?: StandardParameterUpsertWithWhereUniqueWithoutUnitInput | StandardParameterUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: StandardParameterCreateManyUnitInputEnvelope
    set?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    disconnect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    delete?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    connect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    update?: StandardParameterUpdateWithWhereUniqueWithoutUnitInput | StandardParameterUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: StandardParameterUpdateManyWithWhereWithoutUnitInput | StandardParameterUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: StandardParameterScalarWhereInput | StandardParameterScalarWhereInput[]
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutUnitInput, StandardDefinitionUncheckedCreateWithoutUnitInput> | StandardDefinitionCreateWithoutUnitInput[] | StandardDefinitionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutUnitInput | StandardDefinitionCreateOrConnectWithoutUnitInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutUnitInput | StandardDefinitionUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: StandardDefinitionCreateManyUnitInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutUnitInput | StandardDefinitionUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutUnitInput | StandardDefinitionUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutUnitOfMeasurementsNestedInput = {
    create?: XOR<BatchCreateWithoutUnitOfMeasurementsInput, BatchUncheckedCreateWithoutUnitOfMeasurementsInput> | BatchCreateWithoutUnitOfMeasurementsInput[] | BatchUncheckedCreateWithoutUnitOfMeasurementsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUnitOfMeasurementsInput | BatchCreateOrConnectWithoutUnitOfMeasurementsInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUnitOfMeasurementsInput | BatchUpsertWithWhereUniqueWithoutUnitOfMeasurementsInput[]
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUnitOfMeasurementsInput | BatchUpdateWithWhereUniqueWithoutUnitOfMeasurementsInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUnitOfMeasurementsInput | BatchUpdateManyWithWhereWithoutUnitOfMeasurementsInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput> | BatchCreateWithoutUser_Batch_checkerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_checkerIdToUserInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput> | BatchCreateWithoutUser_Batch_makerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_makerIdToUserInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type RoleCreateNestedOneWithoutUserInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput
    connect?: RoleWhereUniqueInput
  }

  export type StandardCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StandardCreateWithoutCreatedByInput, StandardUncheckedCreateWithoutCreatedByInput> | StandardCreateWithoutCreatedByInput[] | StandardUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCreatedByInput | StandardCreateOrConnectWithoutCreatedByInput[]
    createMany?: StandardCreateManyCreatedByInputEnvelope
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type StandardCreateNestedManyWithoutModifiedByInput = {
    create?: XOR<StandardCreateWithoutModifiedByInput, StandardUncheckedCreateWithoutModifiedByInput> | StandardCreateWithoutModifiedByInput[] | StandardUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutModifiedByInput | StandardCreateOrConnectWithoutModifiedByInput[]
    createMany?: StandardCreateManyModifiedByInputEnvelope
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type StandardDefinitionCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StandardDefinitionCreateWithoutCreatedByInput, StandardDefinitionUncheckedCreateWithoutCreatedByInput> | StandardDefinitionCreateWithoutCreatedByInput[] | StandardDefinitionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutCreatedByInput | StandardDefinitionCreateOrConnectWithoutCreatedByInput[]
    createMany?: StandardDefinitionCreateManyCreatedByInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type StandardDefinitionCreateNestedManyWithoutModifiedByInput = {
    create?: XOR<StandardDefinitionCreateWithoutModifiedByInput, StandardDefinitionUncheckedCreateWithoutModifiedByInput> | StandardDefinitionCreateWithoutModifiedByInput[] | StandardDefinitionUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutModifiedByInput | StandardDefinitionCreateOrConnectWithoutModifiedByInput[]
    createMany?: StandardDefinitionCreateManyModifiedByInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type TrainingCreateNestedManyWithoutTrainerInput = {
    create?: XOR<TrainingCreateWithoutTrainerInput, TrainingUncheckedCreateWithoutTrainerInput> | TrainingCreateWithoutTrainerInput[] | TrainingUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutTrainerInput | TrainingCreateOrConnectWithoutTrainerInput[]
    createMany?: TrainingCreateManyTrainerInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type TrainingCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TrainingCreateWithoutCreatedByInput, TrainingUncheckedCreateWithoutCreatedByInput> | TrainingCreateWithoutCreatedByInput[] | TrainingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCreatedByInput | TrainingCreateOrConnectWithoutCreatedByInput[]
    createMany?: TrainingCreateManyCreatedByInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type TrainingDocumentCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TrainingDocumentCreateWithoutUploadedByInput, TrainingDocumentUncheckedCreateWithoutUploadedByInput> | TrainingDocumentCreateWithoutUploadedByInput[] | TrainingDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutUploadedByInput | TrainingDocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: TrainingDocumentCreateManyUploadedByInputEnvelope
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
  }

  export type TrainingPhotoCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TrainingPhotoCreateWithoutUploadedByInput, TrainingPhotoUncheckedCreateWithoutUploadedByInput> | TrainingPhotoCreateWithoutUploadedByInput[] | TrainingPhotoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutUploadedByInput | TrainingPhotoCreateOrConnectWithoutUploadedByInput[]
    createMany?: TrainingPhotoCreateManyUploadedByInputEnvelope
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
  }

  export type TrainingFollowupCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TrainingFollowupCreateWithoutAssignedToInput, TrainingFollowupUncheckedCreateWithoutAssignedToInput> | TrainingFollowupCreateWithoutAssignedToInput[] | TrainingFollowupUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutAssignedToInput | TrainingFollowupCreateOrConnectWithoutAssignedToInput[]
    createMany?: TrainingFollowupCreateManyAssignedToInputEnvelope
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
  }

  export type TrainingFollowupCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TrainingFollowupCreateWithoutCreatedByInput, TrainingFollowupUncheckedCreateWithoutCreatedByInput> | TrainingFollowupCreateWithoutCreatedByInput[] | TrainingFollowupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutCreatedByInput | TrainingFollowupCreateOrConnectWithoutCreatedByInput[]
    createMany?: TrainingFollowupCreateManyCreatedByInputEnvelope
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
  }

  export type TrainingNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<TrainingNotificationCreateWithoutUserInput, TrainingNotificationUncheckedCreateWithoutUserInput> | TrainingNotificationCreateWithoutUserInput[] | TrainingNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutUserInput | TrainingNotificationCreateOrConnectWithoutUserInput[]
    createMany?: TrainingNotificationCreateManyUserInputEnvelope
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
  }

  export type AuditorCreateNestedOneWithoutUserInput = {
    create?: XOR<AuditorCreateWithoutUserInput, AuditorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuditorCreateOrConnectWithoutUserInput
    connect?: AuditorWhereUniqueInput
  }

  export type AuditCreateNestedManyWithoutAuditeeInput = {
    create?: XOR<AuditCreateWithoutAuditeeInput, AuditUncheckedCreateWithoutAuditeeInput> | AuditCreateWithoutAuditeeInput[] | AuditUncheckedCreateWithoutAuditeeInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutAuditeeInput | AuditCreateOrConnectWithoutAuditeeInput[]
    createMany?: AuditCreateManyAuditeeInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type AuditCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput> | AuditCreateWithoutCreatedByInput[] | AuditUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutCreatedByInput | AuditCreateOrConnectWithoutCreatedByInput[]
    createMany?: AuditCreateManyCreatedByInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type FindingCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<FindingCreateWithoutAssignedToInput, FindingUncheckedCreateWithoutAssignedToInput> | FindingCreateWithoutAssignedToInput[] | FindingUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: FindingCreateOrConnectWithoutAssignedToInput | FindingCreateOrConnectWithoutAssignedToInput[]
    createMany?: FindingCreateManyAssignedToInputEnvelope
    connect?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
  }

  export type CorrectiveActionCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<CorrectiveActionCreateWithoutAssignedToInput, CorrectiveActionUncheckedCreateWithoutAssignedToInput> | CorrectiveActionCreateWithoutAssignedToInput[] | CorrectiveActionUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutAssignedToInput | CorrectiveActionCreateOrConnectWithoutAssignedToInput[]
    createMany?: CorrectiveActionCreateManyAssignedToInputEnvelope
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
  }

  export type CorrectiveActionCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<CorrectiveActionCreateWithoutVerifiedByInput, CorrectiveActionUncheckedCreateWithoutVerifiedByInput> | CorrectiveActionCreateWithoutVerifiedByInput[] | CorrectiveActionUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutVerifiedByInput | CorrectiveActionCreateOrConnectWithoutVerifiedByInput[]
    createMany?: CorrectiveActionCreateManyVerifiedByInputEnvelope
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
  }

  export type AuditDocumentCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<AuditDocumentCreateWithoutUploadedByInput, AuditDocumentUncheckedCreateWithoutUploadedByInput> | AuditDocumentCreateWithoutUploadedByInput[] | AuditDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: AuditDocumentCreateOrConnectWithoutUploadedByInput | AuditDocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: AuditDocumentCreateManyUploadedByInputEnvelope
    connect?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
  }

  export type AuditReminderCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AuditReminderCreateWithoutCreatedByInput, AuditReminderUncheckedCreateWithoutCreatedByInput> | AuditReminderCreateWithoutCreatedByInput[] | AuditReminderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditReminderCreateOrConnectWithoutCreatedByInput | AuditReminderCreateOrConnectWithoutCreatedByInput[]
    createMany?: AuditReminderCreateManyCreatedByInputEnvelope
    connect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
  }

  export type AuditReminderCreateNestedManyWithoutRecipientInput = {
    create?: XOR<AuditReminderCreateWithoutRecipientInput, AuditReminderUncheckedCreateWithoutRecipientInput> | AuditReminderCreateWithoutRecipientInput[] | AuditReminderUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: AuditReminderCreateOrConnectWithoutRecipientInput | AuditReminderCreateOrConnectWithoutRecipientInput[]
    createMany?: AuditReminderCreateManyRecipientInputEnvelope
    connect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
  }

  export type AuditNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditNotificationCreateWithoutUserInput, AuditNotificationUncheckedCreateWithoutUserInput> | AuditNotificationCreateWithoutUserInput[] | AuditNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditNotificationCreateOrConnectWithoutUserInput | AuditNotificationCreateOrConnectWithoutUserInput[]
    createMany?: AuditNotificationCreateManyUserInputEnvelope
    connect?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
  }

  export type PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput = {
    create?: XOR<PreAuditChecklistItemCreateWithoutResponsibleInput, PreAuditChecklistItemUncheckedCreateWithoutResponsibleInput> | PreAuditChecklistItemCreateWithoutResponsibleInput[] | PreAuditChecklistItemUncheckedCreateWithoutResponsibleInput[]
    connectOrCreate?: PreAuditChecklistItemCreateOrConnectWithoutResponsibleInput | PreAuditChecklistItemCreateOrConnectWithoutResponsibleInput[]
    createMany?: PreAuditChecklistItemCreateManyResponsibleInputEnvelope
    connect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
  }

  export type PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PreAuditChecklistItemCreateWithoutCreatedByInput, PreAuditChecklistItemUncheckedCreateWithoutCreatedByInput> | PreAuditChecklistItemCreateWithoutCreatedByInput[] | PreAuditChecklistItemUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PreAuditChecklistItemCreateOrConnectWithoutCreatedByInput | PreAuditChecklistItemCreateOrConnectWithoutCreatedByInput[]
    createMany?: PreAuditChecklistItemCreateManyCreatedByInputEnvelope
    connect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
  }

  export type AuditInspectionItemCreateNestedManyWithoutInspectedByInput = {
    create?: XOR<AuditInspectionItemCreateWithoutInspectedByInput, AuditInspectionItemUncheckedCreateWithoutInspectedByInput> | AuditInspectionItemCreateWithoutInspectedByInput[] | AuditInspectionItemUncheckedCreateWithoutInspectedByInput[]
    connectOrCreate?: AuditInspectionItemCreateOrConnectWithoutInspectedByInput | AuditInspectionItemCreateOrConnectWithoutInspectedByInput[]
    createMany?: AuditInspectionItemCreateManyInspectedByInputEnvelope
    connect?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
  }

  export type FeedbackFormCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<FeedbackFormCreateWithoutUploadedByInput, FeedbackFormUncheckedCreateWithoutUploadedByInput> | FeedbackFormCreateWithoutUploadedByInput[] | FeedbackFormUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutUploadedByInput | FeedbackFormCreateOrConnectWithoutUploadedByInput[]
    createMany?: FeedbackFormCreateManyUploadedByInputEnvelope
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
  }

  export type TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TrainingSessionPhotoCreateWithoutUploadedByInput, TrainingSessionPhotoUncheckedCreateWithoutUploadedByInput> | TrainingSessionPhotoCreateWithoutUploadedByInput[] | TrainingSessionPhotoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingSessionPhotoCreateOrConnectWithoutUploadedByInput | TrainingSessionPhotoCreateOrConnectWithoutUploadedByInput[]
    createMany?: TrainingSessionPhotoCreateManyUploadedByInputEnvelope
    connect?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput> | BatchCreateWithoutUser_Batch_checkerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_checkerIdToUserInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput> | BatchCreateWithoutUser_Batch_makerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_makerIdToUserInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StandardUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StandardCreateWithoutCreatedByInput, StandardUncheckedCreateWithoutCreatedByInput> | StandardCreateWithoutCreatedByInput[] | StandardUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCreatedByInput | StandardCreateOrConnectWithoutCreatedByInput[]
    createMany?: StandardCreateManyCreatedByInputEnvelope
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type StandardUncheckedCreateNestedManyWithoutModifiedByInput = {
    create?: XOR<StandardCreateWithoutModifiedByInput, StandardUncheckedCreateWithoutModifiedByInput> | StandardCreateWithoutModifiedByInput[] | StandardUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutModifiedByInput | StandardCreateOrConnectWithoutModifiedByInput[]
    createMany?: StandardCreateManyModifiedByInputEnvelope
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StandardDefinitionCreateWithoutCreatedByInput, StandardDefinitionUncheckedCreateWithoutCreatedByInput> | StandardDefinitionCreateWithoutCreatedByInput[] | StandardDefinitionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutCreatedByInput | StandardDefinitionCreateOrConnectWithoutCreatedByInput[]
    createMany?: StandardDefinitionCreateManyCreatedByInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput = {
    create?: XOR<StandardDefinitionCreateWithoutModifiedByInput, StandardDefinitionUncheckedCreateWithoutModifiedByInput> | StandardDefinitionCreateWithoutModifiedByInput[] | StandardDefinitionUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutModifiedByInput | StandardDefinitionCreateOrConnectWithoutModifiedByInput[]
    createMany?: StandardDefinitionCreateManyModifiedByInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type TrainingUncheckedCreateNestedManyWithoutTrainerInput = {
    create?: XOR<TrainingCreateWithoutTrainerInput, TrainingUncheckedCreateWithoutTrainerInput> | TrainingCreateWithoutTrainerInput[] | TrainingUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutTrainerInput | TrainingCreateOrConnectWithoutTrainerInput[]
    createMany?: TrainingCreateManyTrainerInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type TrainingUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TrainingCreateWithoutCreatedByInput, TrainingUncheckedCreateWithoutCreatedByInput> | TrainingCreateWithoutCreatedByInput[] | TrainingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCreatedByInput | TrainingCreateOrConnectWithoutCreatedByInput[]
    createMany?: TrainingCreateManyCreatedByInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TrainingDocumentCreateWithoutUploadedByInput, TrainingDocumentUncheckedCreateWithoutUploadedByInput> | TrainingDocumentCreateWithoutUploadedByInput[] | TrainingDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutUploadedByInput | TrainingDocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: TrainingDocumentCreateManyUploadedByInputEnvelope
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
  }

  export type TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TrainingPhotoCreateWithoutUploadedByInput, TrainingPhotoUncheckedCreateWithoutUploadedByInput> | TrainingPhotoCreateWithoutUploadedByInput[] | TrainingPhotoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutUploadedByInput | TrainingPhotoCreateOrConnectWithoutUploadedByInput[]
    createMany?: TrainingPhotoCreateManyUploadedByInputEnvelope
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
  }

  export type TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TrainingFollowupCreateWithoutAssignedToInput, TrainingFollowupUncheckedCreateWithoutAssignedToInput> | TrainingFollowupCreateWithoutAssignedToInput[] | TrainingFollowupUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutAssignedToInput | TrainingFollowupCreateOrConnectWithoutAssignedToInput[]
    createMany?: TrainingFollowupCreateManyAssignedToInputEnvelope
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
  }

  export type TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TrainingFollowupCreateWithoutCreatedByInput, TrainingFollowupUncheckedCreateWithoutCreatedByInput> | TrainingFollowupCreateWithoutCreatedByInput[] | TrainingFollowupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutCreatedByInput | TrainingFollowupCreateOrConnectWithoutCreatedByInput[]
    createMany?: TrainingFollowupCreateManyCreatedByInputEnvelope
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
  }

  export type TrainingNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TrainingNotificationCreateWithoutUserInput, TrainingNotificationUncheckedCreateWithoutUserInput> | TrainingNotificationCreateWithoutUserInput[] | TrainingNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutUserInput | TrainingNotificationCreateOrConnectWithoutUserInput[]
    createMany?: TrainingNotificationCreateManyUserInputEnvelope
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
  }

  export type AuditorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AuditorCreateWithoutUserInput, AuditorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuditorCreateOrConnectWithoutUserInput
    connect?: AuditorWhereUniqueInput
  }

  export type AuditUncheckedCreateNestedManyWithoutAuditeeInput = {
    create?: XOR<AuditCreateWithoutAuditeeInput, AuditUncheckedCreateWithoutAuditeeInput> | AuditCreateWithoutAuditeeInput[] | AuditUncheckedCreateWithoutAuditeeInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutAuditeeInput | AuditCreateOrConnectWithoutAuditeeInput[]
    createMany?: AuditCreateManyAuditeeInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type AuditUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput> | AuditCreateWithoutCreatedByInput[] | AuditUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutCreatedByInput | AuditCreateOrConnectWithoutCreatedByInput[]
    createMany?: AuditCreateManyCreatedByInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type FindingUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<FindingCreateWithoutAssignedToInput, FindingUncheckedCreateWithoutAssignedToInput> | FindingCreateWithoutAssignedToInput[] | FindingUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: FindingCreateOrConnectWithoutAssignedToInput | FindingCreateOrConnectWithoutAssignedToInput[]
    createMany?: FindingCreateManyAssignedToInputEnvelope
    connect?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
  }

  export type CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<CorrectiveActionCreateWithoutAssignedToInput, CorrectiveActionUncheckedCreateWithoutAssignedToInput> | CorrectiveActionCreateWithoutAssignedToInput[] | CorrectiveActionUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutAssignedToInput | CorrectiveActionCreateOrConnectWithoutAssignedToInput[]
    createMany?: CorrectiveActionCreateManyAssignedToInputEnvelope
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
  }

  export type CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<CorrectiveActionCreateWithoutVerifiedByInput, CorrectiveActionUncheckedCreateWithoutVerifiedByInput> | CorrectiveActionCreateWithoutVerifiedByInput[] | CorrectiveActionUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutVerifiedByInput | CorrectiveActionCreateOrConnectWithoutVerifiedByInput[]
    createMany?: CorrectiveActionCreateManyVerifiedByInputEnvelope
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
  }

  export type AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<AuditDocumentCreateWithoutUploadedByInput, AuditDocumentUncheckedCreateWithoutUploadedByInput> | AuditDocumentCreateWithoutUploadedByInput[] | AuditDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: AuditDocumentCreateOrConnectWithoutUploadedByInput | AuditDocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: AuditDocumentCreateManyUploadedByInputEnvelope
    connect?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
  }

  export type AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AuditReminderCreateWithoutCreatedByInput, AuditReminderUncheckedCreateWithoutCreatedByInput> | AuditReminderCreateWithoutCreatedByInput[] | AuditReminderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditReminderCreateOrConnectWithoutCreatedByInput | AuditReminderCreateOrConnectWithoutCreatedByInput[]
    createMany?: AuditReminderCreateManyCreatedByInputEnvelope
    connect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
  }

  export type AuditReminderUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<AuditReminderCreateWithoutRecipientInput, AuditReminderUncheckedCreateWithoutRecipientInput> | AuditReminderCreateWithoutRecipientInput[] | AuditReminderUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: AuditReminderCreateOrConnectWithoutRecipientInput | AuditReminderCreateOrConnectWithoutRecipientInput[]
    createMany?: AuditReminderCreateManyRecipientInputEnvelope
    connect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
  }

  export type AuditNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditNotificationCreateWithoutUserInput, AuditNotificationUncheckedCreateWithoutUserInput> | AuditNotificationCreateWithoutUserInput[] | AuditNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditNotificationCreateOrConnectWithoutUserInput | AuditNotificationCreateOrConnectWithoutUserInput[]
    createMany?: AuditNotificationCreateManyUserInputEnvelope
    connect?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
  }

  export type PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput = {
    create?: XOR<PreAuditChecklistItemCreateWithoutResponsibleInput, PreAuditChecklistItemUncheckedCreateWithoutResponsibleInput> | PreAuditChecklistItemCreateWithoutResponsibleInput[] | PreAuditChecklistItemUncheckedCreateWithoutResponsibleInput[]
    connectOrCreate?: PreAuditChecklistItemCreateOrConnectWithoutResponsibleInput | PreAuditChecklistItemCreateOrConnectWithoutResponsibleInput[]
    createMany?: PreAuditChecklistItemCreateManyResponsibleInputEnvelope
    connect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
  }

  export type PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PreAuditChecklistItemCreateWithoutCreatedByInput, PreAuditChecklistItemUncheckedCreateWithoutCreatedByInput> | PreAuditChecklistItemCreateWithoutCreatedByInput[] | PreAuditChecklistItemUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PreAuditChecklistItemCreateOrConnectWithoutCreatedByInput | PreAuditChecklistItemCreateOrConnectWithoutCreatedByInput[]
    createMany?: PreAuditChecklistItemCreateManyCreatedByInputEnvelope
    connect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
  }

  export type AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput = {
    create?: XOR<AuditInspectionItemCreateWithoutInspectedByInput, AuditInspectionItemUncheckedCreateWithoutInspectedByInput> | AuditInspectionItemCreateWithoutInspectedByInput[] | AuditInspectionItemUncheckedCreateWithoutInspectedByInput[]
    connectOrCreate?: AuditInspectionItemCreateOrConnectWithoutInspectedByInput | AuditInspectionItemCreateOrConnectWithoutInspectedByInput[]
    createMany?: AuditInspectionItemCreateManyInspectedByInputEnvelope
    connect?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
  }

  export type FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<FeedbackFormCreateWithoutUploadedByInput, FeedbackFormUncheckedCreateWithoutUploadedByInput> | FeedbackFormCreateWithoutUploadedByInput[] | FeedbackFormUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutUploadedByInput | FeedbackFormCreateOrConnectWithoutUploadedByInput[]
    createMany?: FeedbackFormCreateManyUploadedByInputEnvelope
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
  }

  export type TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TrainingSessionPhotoCreateWithoutUploadedByInput, TrainingSessionPhotoUncheckedCreateWithoutUploadedByInput> | TrainingSessionPhotoCreateWithoutUploadedByInput[] | TrainingSessionPhotoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingSessionPhotoCreateOrConnectWithoutUploadedByInput | TrainingSessionPhotoCreateOrConnectWithoutUploadedByInput[]
    createMany?: TrainingSessionPhotoCreateManyUploadedByInputEnvelope
    connect?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput> | BatchCreateWithoutUser_Batch_checkerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput | BatchUpsertWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_checkerIdToUserInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput | BatchUpdateWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUser_Batch_checkerIdToUserInput | BatchUpdateManyWithWhereWithoutUser_Batch_checkerIdToUserInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput> | BatchCreateWithoutUser_Batch_makerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUser_Batch_makerIdToUserInput | BatchUpsertWithWhereUniqueWithoutUser_Batch_makerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_makerIdToUserInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUser_Batch_makerIdToUserInput | BatchUpdateWithWhereUniqueWithoutUser_Batch_makerIdToUserInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUser_Batch_makerIdToUserInput | BatchUpdateManyWithWhereWithoutUser_Batch_makerIdToUserInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RoleUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput
    upsert?: RoleUpsertWithoutUserInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserInput, RoleUpdateWithoutUserInput>, RoleUncheckedUpdateWithoutUserInput>
  }

  export type StandardUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StandardCreateWithoutCreatedByInput, StandardUncheckedCreateWithoutCreatedByInput> | StandardCreateWithoutCreatedByInput[] | StandardUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCreatedByInput | StandardCreateOrConnectWithoutCreatedByInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutCreatedByInput | StandardUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StandardCreateManyCreatedByInputEnvelope
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutCreatedByInput | StandardUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutCreatedByInput | StandardUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type StandardUpdateManyWithoutModifiedByNestedInput = {
    create?: XOR<StandardCreateWithoutModifiedByInput, StandardUncheckedCreateWithoutModifiedByInput> | StandardCreateWithoutModifiedByInput[] | StandardUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutModifiedByInput | StandardCreateOrConnectWithoutModifiedByInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutModifiedByInput | StandardUpsertWithWhereUniqueWithoutModifiedByInput[]
    createMany?: StandardCreateManyModifiedByInputEnvelope
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutModifiedByInput | StandardUpdateWithWhereUniqueWithoutModifiedByInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutModifiedByInput | StandardUpdateManyWithWhereWithoutModifiedByInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type StandardDefinitionUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutCreatedByInput, StandardDefinitionUncheckedCreateWithoutCreatedByInput> | StandardDefinitionCreateWithoutCreatedByInput[] | StandardDefinitionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutCreatedByInput | StandardDefinitionCreateOrConnectWithoutCreatedByInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutCreatedByInput | StandardDefinitionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StandardDefinitionCreateManyCreatedByInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutCreatedByInput | StandardDefinitionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutCreatedByInput | StandardDefinitionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type StandardDefinitionUpdateManyWithoutModifiedByNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutModifiedByInput, StandardDefinitionUncheckedCreateWithoutModifiedByInput> | StandardDefinitionCreateWithoutModifiedByInput[] | StandardDefinitionUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutModifiedByInput | StandardDefinitionCreateOrConnectWithoutModifiedByInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutModifiedByInput | StandardDefinitionUpsertWithWhereUniqueWithoutModifiedByInput[]
    createMany?: StandardDefinitionCreateManyModifiedByInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutModifiedByInput | StandardDefinitionUpdateWithWhereUniqueWithoutModifiedByInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutModifiedByInput | StandardDefinitionUpdateManyWithWhereWithoutModifiedByInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type TrainingUpdateManyWithoutTrainerNestedInput = {
    create?: XOR<TrainingCreateWithoutTrainerInput, TrainingUncheckedCreateWithoutTrainerInput> | TrainingCreateWithoutTrainerInput[] | TrainingUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutTrainerInput | TrainingCreateOrConnectWithoutTrainerInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutTrainerInput | TrainingUpsertWithWhereUniqueWithoutTrainerInput[]
    createMany?: TrainingCreateManyTrainerInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutTrainerInput | TrainingUpdateWithWhereUniqueWithoutTrainerInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutTrainerInput | TrainingUpdateManyWithWhereWithoutTrainerInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type TrainingUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TrainingCreateWithoutCreatedByInput, TrainingUncheckedCreateWithoutCreatedByInput> | TrainingCreateWithoutCreatedByInput[] | TrainingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCreatedByInput | TrainingCreateOrConnectWithoutCreatedByInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutCreatedByInput | TrainingUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TrainingCreateManyCreatedByInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutCreatedByInput | TrainingUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutCreatedByInput | TrainingUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type TrainingDocumentUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TrainingDocumentCreateWithoutUploadedByInput, TrainingDocumentUncheckedCreateWithoutUploadedByInput> | TrainingDocumentCreateWithoutUploadedByInput[] | TrainingDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutUploadedByInput | TrainingDocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: TrainingDocumentUpsertWithWhereUniqueWithoutUploadedByInput | TrainingDocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TrainingDocumentCreateManyUploadedByInputEnvelope
    set?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    disconnect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    delete?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    update?: TrainingDocumentUpdateWithWhereUniqueWithoutUploadedByInput | TrainingDocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TrainingDocumentUpdateManyWithWhereWithoutUploadedByInput | TrainingDocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
  }

  export type TrainingPhotoUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TrainingPhotoCreateWithoutUploadedByInput, TrainingPhotoUncheckedCreateWithoutUploadedByInput> | TrainingPhotoCreateWithoutUploadedByInput[] | TrainingPhotoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutUploadedByInput | TrainingPhotoCreateOrConnectWithoutUploadedByInput[]
    upsert?: TrainingPhotoUpsertWithWhereUniqueWithoutUploadedByInput | TrainingPhotoUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TrainingPhotoCreateManyUploadedByInputEnvelope
    set?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    disconnect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    delete?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    update?: TrainingPhotoUpdateWithWhereUniqueWithoutUploadedByInput | TrainingPhotoUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TrainingPhotoUpdateManyWithWhereWithoutUploadedByInput | TrainingPhotoUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TrainingPhotoScalarWhereInput | TrainingPhotoScalarWhereInput[]
  }

  export type TrainingFollowupUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TrainingFollowupCreateWithoutAssignedToInput, TrainingFollowupUncheckedCreateWithoutAssignedToInput> | TrainingFollowupCreateWithoutAssignedToInput[] | TrainingFollowupUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutAssignedToInput | TrainingFollowupCreateOrConnectWithoutAssignedToInput[]
    upsert?: TrainingFollowupUpsertWithWhereUniqueWithoutAssignedToInput | TrainingFollowupUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TrainingFollowupCreateManyAssignedToInputEnvelope
    set?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    disconnect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    delete?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    update?: TrainingFollowupUpdateWithWhereUniqueWithoutAssignedToInput | TrainingFollowupUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TrainingFollowupUpdateManyWithWhereWithoutAssignedToInput | TrainingFollowupUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
  }

  export type TrainingFollowupUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TrainingFollowupCreateWithoutCreatedByInput, TrainingFollowupUncheckedCreateWithoutCreatedByInput> | TrainingFollowupCreateWithoutCreatedByInput[] | TrainingFollowupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutCreatedByInput | TrainingFollowupCreateOrConnectWithoutCreatedByInput[]
    upsert?: TrainingFollowupUpsertWithWhereUniqueWithoutCreatedByInput | TrainingFollowupUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TrainingFollowupCreateManyCreatedByInputEnvelope
    set?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    disconnect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    delete?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    update?: TrainingFollowupUpdateWithWhereUniqueWithoutCreatedByInput | TrainingFollowupUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TrainingFollowupUpdateManyWithWhereWithoutCreatedByInput | TrainingFollowupUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
  }

  export type TrainingNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrainingNotificationCreateWithoutUserInput, TrainingNotificationUncheckedCreateWithoutUserInput> | TrainingNotificationCreateWithoutUserInput[] | TrainingNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutUserInput | TrainingNotificationCreateOrConnectWithoutUserInput[]
    upsert?: TrainingNotificationUpsertWithWhereUniqueWithoutUserInput | TrainingNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrainingNotificationCreateManyUserInputEnvelope
    set?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    disconnect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    delete?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    update?: TrainingNotificationUpdateWithWhereUniqueWithoutUserInput | TrainingNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrainingNotificationUpdateManyWithWhereWithoutUserInput | TrainingNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrainingNotificationScalarWhereInput | TrainingNotificationScalarWhereInput[]
  }

  export type AuditorUpdateOneWithoutUserNestedInput = {
    create?: XOR<AuditorCreateWithoutUserInput, AuditorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuditorCreateOrConnectWithoutUserInput
    upsert?: AuditorUpsertWithoutUserInput
    disconnect?: AuditorWhereInput | boolean
    delete?: AuditorWhereInput | boolean
    connect?: AuditorWhereUniqueInput
    update?: XOR<XOR<AuditorUpdateToOneWithWhereWithoutUserInput, AuditorUpdateWithoutUserInput>, AuditorUncheckedUpdateWithoutUserInput>
  }

  export type AuditUpdateManyWithoutAuditeeNestedInput = {
    create?: XOR<AuditCreateWithoutAuditeeInput, AuditUncheckedCreateWithoutAuditeeInput> | AuditCreateWithoutAuditeeInput[] | AuditUncheckedCreateWithoutAuditeeInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutAuditeeInput | AuditCreateOrConnectWithoutAuditeeInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutAuditeeInput | AuditUpsertWithWhereUniqueWithoutAuditeeInput[]
    createMany?: AuditCreateManyAuditeeInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutAuditeeInput | AuditUpdateWithWhereUniqueWithoutAuditeeInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutAuditeeInput | AuditUpdateManyWithWhereWithoutAuditeeInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type AuditUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput> | AuditCreateWithoutCreatedByInput[] | AuditUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutCreatedByInput | AuditCreateOrConnectWithoutCreatedByInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutCreatedByInput | AuditUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AuditCreateManyCreatedByInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutCreatedByInput | AuditUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutCreatedByInput | AuditUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type FindingUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<FindingCreateWithoutAssignedToInput, FindingUncheckedCreateWithoutAssignedToInput> | FindingCreateWithoutAssignedToInput[] | FindingUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: FindingCreateOrConnectWithoutAssignedToInput | FindingCreateOrConnectWithoutAssignedToInput[]
    upsert?: FindingUpsertWithWhereUniqueWithoutAssignedToInput | FindingUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: FindingCreateManyAssignedToInputEnvelope
    set?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    disconnect?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    delete?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    connect?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    update?: FindingUpdateWithWhereUniqueWithoutAssignedToInput | FindingUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: FindingUpdateManyWithWhereWithoutAssignedToInput | FindingUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: FindingScalarWhereInput | FindingScalarWhereInput[]
  }

  export type CorrectiveActionUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<CorrectiveActionCreateWithoutAssignedToInput, CorrectiveActionUncheckedCreateWithoutAssignedToInput> | CorrectiveActionCreateWithoutAssignedToInput[] | CorrectiveActionUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutAssignedToInput | CorrectiveActionCreateOrConnectWithoutAssignedToInput[]
    upsert?: CorrectiveActionUpsertWithWhereUniqueWithoutAssignedToInput | CorrectiveActionUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: CorrectiveActionCreateManyAssignedToInputEnvelope
    set?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    disconnect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    delete?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    update?: CorrectiveActionUpdateWithWhereUniqueWithoutAssignedToInput | CorrectiveActionUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: CorrectiveActionUpdateManyWithWhereWithoutAssignedToInput | CorrectiveActionUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: CorrectiveActionScalarWhereInput | CorrectiveActionScalarWhereInput[]
  }

  export type CorrectiveActionUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<CorrectiveActionCreateWithoutVerifiedByInput, CorrectiveActionUncheckedCreateWithoutVerifiedByInput> | CorrectiveActionCreateWithoutVerifiedByInput[] | CorrectiveActionUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutVerifiedByInput | CorrectiveActionCreateOrConnectWithoutVerifiedByInput[]
    upsert?: CorrectiveActionUpsertWithWhereUniqueWithoutVerifiedByInput | CorrectiveActionUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: CorrectiveActionCreateManyVerifiedByInputEnvelope
    set?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    disconnect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    delete?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    update?: CorrectiveActionUpdateWithWhereUniqueWithoutVerifiedByInput | CorrectiveActionUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: CorrectiveActionUpdateManyWithWhereWithoutVerifiedByInput | CorrectiveActionUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: CorrectiveActionScalarWhereInput | CorrectiveActionScalarWhereInput[]
  }

  export type AuditDocumentUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<AuditDocumentCreateWithoutUploadedByInput, AuditDocumentUncheckedCreateWithoutUploadedByInput> | AuditDocumentCreateWithoutUploadedByInput[] | AuditDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: AuditDocumentCreateOrConnectWithoutUploadedByInput | AuditDocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: AuditDocumentUpsertWithWhereUniqueWithoutUploadedByInput | AuditDocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: AuditDocumentCreateManyUploadedByInputEnvelope
    set?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    disconnect?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    delete?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    connect?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    update?: AuditDocumentUpdateWithWhereUniqueWithoutUploadedByInput | AuditDocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: AuditDocumentUpdateManyWithWhereWithoutUploadedByInput | AuditDocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: AuditDocumentScalarWhereInput | AuditDocumentScalarWhereInput[]
  }

  export type AuditReminderUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AuditReminderCreateWithoutCreatedByInput, AuditReminderUncheckedCreateWithoutCreatedByInput> | AuditReminderCreateWithoutCreatedByInput[] | AuditReminderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditReminderCreateOrConnectWithoutCreatedByInput | AuditReminderCreateOrConnectWithoutCreatedByInput[]
    upsert?: AuditReminderUpsertWithWhereUniqueWithoutCreatedByInput | AuditReminderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AuditReminderCreateManyCreatedByInputEnvelope
    set?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    disconnect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    delete?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    connect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    update?: AuditReminderUpdateWithWhereUniqueWithoutCreatedByInput | AuditReminderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AuditReminderUpdateManyWithWhereWithoutCreatedByInput | AuditReminderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AuditReminderScalarWhereInput | AuditReminderScalarWhereInput[]
  }

  export type AuditReminderUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<AuditReminderCreateWithoutRecipientInput, AuditReminderUncheckedCreateWithoutRecipientInput> | AuditReminderCreateWithoutRecipientInput[] | AuditReminderUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: AuditReminderCreateOrConnectWithoutRecipientInput | AuditReminderCreateOrConnectWithoutRecipientInput[]
    upsert?: AuditReminderUpsertWithWhereUniqueWithoutRecipientInput | AuditReminderUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: AuditReminderCreateManyRecipientInputEnvelope
    set?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    disconnect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    delete?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    connect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    update?: AuditReminderUpdateWithWhereUniqueWithoutRecipientInput | AuditReminderUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: AuditReminderUpdateManyWithWhereWithoutRecipientInput | AuditReminderUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: AuditReminderScalarWhereInput | AuditReminderScalarWhereInput[]
  }

  export type AuditNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditNotificationCreateWithoutUserInput, AuditNotificationUncheckedCreateWithoutUserInput> | AuditNotificationCreateWithoutUserInput[] | AuditNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditNotificationCreateOrConnectWithoutUserInput | AuditNotificationCreateOrConnectWithoutUserInput[]
    upsert?: AuditNotificationUpsertWithWhereUniqueWithoutUserInput | AuditNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditNotificationCreateManyUserInputEnvelope
    set?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    disconnect?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    delete?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    connect?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    update?: AuditNotificationUpdateWithWhereUniqueWithoutUserInput | AuditNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditNotificationUpdateManyWithWhereWithoutUserInput | AuditNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditNotificationScalarWhereInput | AuditNotificationScalarWhereInput[]
  }

  export type PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput = {
    create?: XOR<PreAuditChecklistItemCreateWithoutResponsibleInput, PreAuditChecklistItemUncheckedCreateWithoutResponsibleInput> | PreAuditChecklistItemCreateWithoutResponsibleInput[] | PreAuditChecklistItemUncheckedCreateWithoutResponsibleInput[]
    connectOrCreate?: PreAuditChecklistItemCreateOrConnectWithoutResponsibleInput | PreAuditChecklistItemCreateOrConnectWithoutResponsibleInput[]
    upsert?: PreAuditChecklistItemUpsertWithWhereUniqueWithoutResponsibleInput | PreAuditChecklistItemUpsertWithWhereUniqueWithoutResponsibleInput[]
    createMany?: PreAuditChecklistItemCreateManyResponsibleInputEnvelope
    set?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    disconnect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    delete?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    connect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    update?: PreAuditChecklistItemUpdateWithWhereUniqueWithoutResponsibleInput | PreAuditChecklistItemUpdateWithWhereUniqueWithoutResponsibleInput[]
    updateMany?: PreAuditChecklistItemUpdateManyWithWhereWithoutResponsibleInput | PreAuditChecklistItemUpdateManyWithWhereWithoutResponsibleInput[]
    deleteMany?: PreAuditChecklistItemScalarWhereInput | PreAuditChecklistItemScalarWhereInput[]
  }

  export type PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PreAuditChecklistItemCreateWithoutCreatedByInput, PreAuditChecklistItemUncheckedCreateWithoutCreatedByInput> | PreAuditChecklistItemCreateWithoutCreatedByInput[] | PreAuditChecklistItemUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PreAuditChecklistItemCreateOrConnectWithoutCreatedByInput | PreAuditChecklistItemCreateOrConnectWithoutCreatedByInput[]
    upsert?: PreAuditChecklistItemUpsertWithWhereUniqueWithoutCreatedByInput | PreAuditChecklistItemUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PreAuditChecklistItemCreateManyCreatedByInputEnvelope
    set?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    disconnect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    delete?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    connect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    update?: PreAuditChecklistItemUpdateWithWhereUniqueWithoutCreatedByInput | PreAuditChecklistItemUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PreAuditChecklistItemUpdateManyWithWhereWithoutCreatedByInput | PreAuditChecklistItemUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PreAuditChecklistItemScalarWhereInput | PreAuditChecklistItemScalarWhereInput[]
  }

  export type AuditInspectionItemUpdateManyWithoutInspectedByNestedInput = {
    create?: XOR<AuditInspectionItemCreateWithoutInspectedByInput, AuditInspectionItemUncheckedCreateWithoutInspectedByInput> | AuditInspectionItemCreateWithoutInspectedByInput[] | AuditInspectionItemUncheckedCreateWithoutInspectedByInput[]
    connectOrCreate?: AuditInspectionItemCreateOrConnectWithoutInspectedByInput | AuditInspectionItemCreateOrConnectWithoutInspectedByInput[]
    upsert?: AuditInspectionItemUpsertWithWhereUniqueWithoutInspectedByInput | AuditInspectionItemUpsertWithWhereUniqueWithoutInspectedByInput[]
    createMany?: AuditInspectionItemCreateManyInspectedByInputEnvelope
    set?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    disconnect?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    delete?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    connect?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    update?: AuditInspectionItemUpdateWithWhereUniqueWithoutInspectedByInput | AuditInspectionItemUpdateWithWhereUniqueWithoutInspectedByInput[]
    updateMany?: AuditInspectionItemUpdateManyWithWhereWithoutInspectedByInput | AuditInspectionItemUpdateManyWithWhereWithoutInspectedByInput[]
    deleteMany?: AuditInspectionItemScalarWhereInput | AuditInspectionItemScalarWhereInput[]
  }

  export type FeedbackFormUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<FeedbackFormCreateWithoutUploadedByInput, FeedbackFormUncheckedCreateWithoutUploadedByInput> | FeedbackFormCreateWithoutUploadedByInput[] | FeedbackFormUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutUploadedByInput | FeedbackFormCreateOrConnectWithoutUploadedByInput[]
    upsert?: FeedbackFormUpsertWithWhereUniqueWithoutUploadedByInput | FeedbackFormUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: FeedbackFormCreateManyUploadedByInputEnvelope
    set?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    disconnect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    delete?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    update?: FeedbackFormUpdateWithWhereUniqueWithoutUploadedByInput | FeedbackFormUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: FeedbackFormUpdateManyWithWhereWithoutUploadedByInput | FeedbackFormUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: FeedbackFormScalarWhereInput | FeedbackFormScalarWhereInput[]
  }

  export type TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TrainingSessionPhotoCreateWithoutUploadedByInput, TrainingSessionPhotoUncheckedCreateWithoutUploadedByInput> | TrainingSessionPhotoCreateWithoutUploadedByInput[] | TrainingSessionPhotoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingSessionPhotoCreateOrConnectWithoutUploadedByInput | TrainingSessionPhotoCreateOrConnectWithoutUploadedByInput[]
    upsert?: TrainingSessionPhotoUpsertWithWhereUniqueWithoutUploadedByInput | TrainingSessionPhotoUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TrainingSessionPhotoCreateManyUploadedByInputEnvelope
    set?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    disconnect?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    delete?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    connect?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    update?: TrainingSessionPhotoUpdateWithWhereUniqueWithoutUploadedByInput | TrainingSessionPhotoUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TrainingSessionPhotoUpdateManyWithWhereWithoutUploadedByInput | TrainingSessionPhotoUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TrainingSessionPhotoScalarWhereInput | TrainingSessionPhotoScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput> | BatchCreateWithoutUser_Batch_checkerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput | BatchUpsertWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_checkerIdToUserInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput | BatchUpdateWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUser_Batch_checkerIdToUserInput | BatchUpdateManyWithWhereWithoutUser_Batch_checkerIdToUserInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput> | BatchCreateWithoutUser_Batch_makerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUser_Batch_makerIdToUserInput | BatchUpsertWithWhereUniqueWithoutUser_Batch_makerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_makerIdToUserInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUser_Batch_makerIdToUserInput | BatchUpdateWithWhereUniqueWithoutUser_Batch_makerIdToUserInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUser_Batch_makerIdToUserInput | BatchUpdateManyWithWhereWithoutUser_Batch_makerIdToUserInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StandardUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StandardCreateWithoutCreatedByInput, StandardUncheckedCreateWithoutCreatedByInput> | StandardCreateWithoutCreatedByInput[] | StandardUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCreatedByInput | StandardCreateOrConnectWithoutCreatedByInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutCreatedByInput | StandardUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StandardCreateManyCreatedByInputEnvelope
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutCreatedByInput | StandardUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutCreatedByInput | StandardUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type StandardUncheckedUpdateManyWithoutModifiedByNestedInput = {
    create?: XOR<StandardCreateWithoutModifiedByInput, StandardUncheckedCreateWithoutModifiedByInput> | StandardCreateWithoutModifiedByInput[] | StandardUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutModifiedByInput | StandardCreateOrConnectWithoutModifiedByInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutModifiedByInput | StandardUpsertWithWhereUniqueWithoutModifiedByInput[]
    createMany?: StandardCreateManyModifiedByInputEnvelope
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutModifiedByInput | StandardUpdateWithWhereUniqueWithoutModifiedByInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutModifiedByInput | StandardUpdateManyWithWhereWithoutModifiedByInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutCreatedByInput, StandardDefinitionUncheckedCreateWithoutCreatedByInput> | StandardDefinitionCreateWithoutCreatedByInput[] | StandardDefinitionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutCreatedByInput | StandardDefinitionCreateOrConnectWithoutCreatedByInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutCreatedByInput | StandardDefinitionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StandardDefinitionCreateManyCreatedByInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutCreatedByInput | StandardDefinitionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutCreatedByInput | StandardDefinitionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutModifiedByInput, StandardDefinitionUncheckedCreateWithoutModifiedByInput> | StandardDefinitionCreateWithoutModifiedByInput[] | StandardDefinitionUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutModifiedByInput | StandardDefinitionCreateOrConnectWithoutModifiedByInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutModifiedByInput | StandardDefinitionUpsertWithWhereUniqueWithoutModifiedByInput[]
    createMany?: StandardDefinitionCreateManyModifiedByInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutModifiedByInput | StandardDefinitionUpdateWithWhereUniqueWithoutModifiedByInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutModifiedByInput | StandardDefinitionUpdateManyWithWhereWithoutModifiedByInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type TrainingUncheckedUpdateManyWithoutTrainerNestedInput = {
    create?: XOR<TrainingCreateWithoutTrainerInput, TrainingUncheckedCreateWithoutTrainerInput> | TrainingCreateWithoutTrainerInput[] | TrainingUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutTrainerInput | TrainingCreateOrConnectWithoutTrainerInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutTrainerInput | TrainingUpsertWithWhereUniqueWithoutTrainerInput[]
    createMany?: TrainingCreateManyTrainerInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutTrainerInput | TrainingUpdateWithWhereUniqueWithoutTrainerInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutTrainerInput | TrainingUpdateManyWithWhereWithoutTrainerInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type TrainingUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TrainingCreateWithoutCreatedByInput, TrainingUncheckedCreateWithoutCreatedByInput> | TrainingCreateWithoutCreatedByInput[] | TrainingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCreatedByInput | TrainingCreateOrConnectWithoutCreatedByInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutCreatedByInput | TrainingUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TrainingCreateManyCreatedByInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutCreatedByInput | TrainingUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutCreatedByInput | TrainingUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TrainingDocumentCreateWithoutUploadedByInput, TrainingDocumentUncheckedCreateWithoutUploadedByInput> | TrainingDocumentCreateWithoutUploadedByInput[] | TrainingDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutUploadedByInput | TrainingDocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: TrainingDocumentUpsertWithWhereUniqueWithoutUploadedByInput | TrainingDocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TrainingDocumentCreateManyUploadedByInputEnvelope
    set?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    disconnect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    delete?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    update?: TrainingDocumentUpdateWithWhereUniqueWithoutUploadedByInput | TrainingDocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TrainingDocumentUpdateManyWithWhereWithoutUploadedByInput | TrainingDocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
  }

  export type TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TrainingPhotoCreateWithoutUploadedByInput, TrainingPhotoUncheckedCreateWithoutUploadedByInput> | TrainingPhotoCreateWithoutUploadedByInput[] | TrainingPhotoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutUploadedByInput | TrainingPhotoCreateOrConnectWithoutUploadedByInput[]
    upsert?: TrainingPhotoUpsertWithWhereUniqueWithoutUploadedByInput | TrainingPhotoUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TrainingPhotoCreateManyUploadedByInputEnvelope
    set?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    disconnect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    delete?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    update?: TrainingPhotoUpdateWithWhereUniqueWithoutUploadedByInput | TrainingPhotoUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TrainingPhotoUpdateManyWithWhereWithoutUploadedByInput | TrainingPhotoUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TrainingPhotoScalarWhereInput | TrainingPhotoScalarWhereInput[]
  }

  export type TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TrainingFollowupCreateWithoutAssignedToInput, TrainingFollowupUncheckedCreateWithoutAssignedToInput> | TrainingFollowupCreateWithoutAssignedToInput[] | TrainingFollowupUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutAssignedToInput | TrainingFollowupCreateOrConnectWithoutAssignedToInput[]
    upsert?: TrainingFollowupUpsertWithWhereUniqueWithoutAssignedToInput | TrainingFollowupUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TrainingFollowupCreateManyAssignedToInputEnvelope
    set?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    disconnect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    delete?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    update?: TrainingFollowupUpdateWithWhereUniqueWithoutAssignedToInput | TrainingFollowupUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TrainingFollowupUpdateManyWithWhereWithoutAssignedToInput | TrainingFollowupUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
  }

  export type TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TrainingFollowupCreateWithoutCreatedByInput, TrainingFollowupUncheckedCreateWithoutCreatedByInput> | TrainingFollowupCreateWithoutCreatedByInput[] | TrainingFollowupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutCreatedByInput | TrainingFollowupCreateOrConnectWithoutCreatedByInput[]
    upsert?: TrainingFollowupUpsertWithWhereUniqueWithoutCreatedByInput | TrainingFollowupUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TrainingFollowupCreateManyCreatedByInputEnvelope
    set?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    disconnect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    delete?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    update?: TrainingFollowupUpdateWithWhereUniqueWithoutCreatedByInput | TrainingFollowupUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TrainingFollowupUpdateManyWithWhereWithoutCreatedByInput | TrainingFollowupUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
  }

  export type TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrainingNotificationCreateWithoutUserInput, TrainingNotificationUncheckedCreateWithoutUserInput> | TrainingNotificationCreateWithoutUserInput[] | TrainingNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutUserInput | TrainingNotificationCreateOrConnectWithoutUserInput[]
    upsert?: TrainingNotificationUpsertWithWhereUniqueWithoutUserInput | TrainingNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrainingNotificationCreateManyUserInputEnvelope
    set?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    disconnect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    delete?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    update?: TrainingNotificationUpdateWithWhereUniqueWithoutUserInput | TrainingNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrainingNotificationUpdateManyWithWhereWithoutUserInput | TrainingNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrainingNotificationScalarWhereInput | TrainingNotificationScalarWhereInput[]
  }

  export type AuditorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AuditorCreateWithoutUserInput, AuditorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuditorCreateOrConnectWithoutUserInput
    upsert?: AuditorUpsertWithoutUserInput
    disconnect?: AuditorWhereInput | boolean
    delete?: AuditorWhereInput | boolean
    connect?: AuditorWhereUniqueInput
    update?: XOR<XOR<AuditorUpdateToOneWithWhereWithoutUserInput, AuditorUpdateWithoutUserInput>, AuditorUncheckedUpdateWithoutUserInput>
  }

  export type AuditUncheckedUpdateManyWithoutAuditeeNestedInput = {
    create?: XOR<AuditCreateWithoutAuditeeInput, AuditUncheckedCreateWithoutAuditeeInput> | AuditCreateWithoutAuditeeInput[] | AuditUncheckedCreateWithoutAuditeeInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutAuditeeInput | AuditCreateOrConnectWithoutAuditeeInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutAuditeeInput | AuditUpsertWithWhereUniqueWithoutAuditeeInput[]
    createMany?: AuditCreateManyAuditeeInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutAuditeeInput | AuditUpdateWithWhereUniqueWithoutAuditeeInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutAuditeeInput | AuditUpdateManyWithWhereWithoutAuditeeInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type AuditUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput> | AuditCreateWithoutCreatedByInput[] | AuditUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutCreatedByInput | AuditCreateOrConnectWithoutCreatedByInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutCreatedByInput | AuditUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AuditCreateManyCreatedByInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutCreatedByInput | AuditUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutCreatedByInput | AuditUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type FindingUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<FindingCreateWithoutAssignedToInput, FindingUncheckedCreateWithoutAssignedToInput> | FindingCreateWithoutAssignedToInput[] | FindingUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: FindingCreateOrConnectWithoutAssignedToInput | FindingCreateOrConnectWithoutAssignedToInput[]
    upsert?: FindingUpsertWithWhereUniqueWithoutAssignedToInput | FindingUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: FindingCreateManyAssignedToInputEnvelope
    set?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    disconnect?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    delete?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    connect?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    update?: FindingUpdateWithWhereUniqueWithoutAssignedToInput | FindingUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: FindingUpdateManyWithWhereWithoutAssignedToInput | FindingUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: FindingScalarWhereInput | FindingScalarWhereInput[]
  }

  export type CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<CorrectiveActionCreateWithoutAssignedToInput, CorrectiveActionUncheckedCreateWithoutAssignedToInput> | CorrectiveActionCreateWithoutAssignedToInput[] | CorrectiveActionUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutAssignedToInput | CorrectiveActionCreateOrConnectWithoutAssignedToInput[]
    upsert?: CorrectiveActionUpsertWithWhereUniqueWithoutAssignedToInput | CorrectiveActionUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: CorrectiveActionCreateManyAssignedToInputEnvelope
    set?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    disconnect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    delete?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    update?: CorrectiveActionUpdateWithWhereUniqueWithoutAssignedToInput | CorrectiveActionUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: CorrectiveActionUpdateManyWithWhereWithoutAssignedToInput | CorrectiveActionUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: CorrectiveActionScalarWhereInput | CorrectiveActionScalarWhereInput[]
  }

  export type CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<CorrectiveActionCreateWithoutVerifiedByInput, CorrectiveActionUncheckedCreateWithoutVerifiedByInput> | CorrectiveActionCreateWithoutVerifiedByInput[] | CorrectiveActionUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutVerifiedByInput | CorrectiveActionCreateOrConnectWithoutVerifiedByInput[]
    upsert?: CorrectiveActionUpsertWithWhereUniqueWithoutVerifiedByInput | CorrectiveActionUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: CorrectiveActionCreateManyVerifiedByInputEnvelope
    set?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    disconnect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    delete?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    update?: CorrectiveActionUpdateWithWhereUniqueWithoutVerifiedByInput | CorrectiveActionUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: CorrectiveActionUpdateManyWithWhereWithoutVerifiedByInput | CorrectiveActionUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: CorrectiveActionScalarWhereInput | CorrectiveActionScalarWhereInput[]
  }

  export type AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<AuditDocumentCreateWithoutUploadedByInput, AuditDocumentUncheckedCreateWithoutUploadedByInput> | AuditDocumentCreateWithoutUploadedByInput[] | AuditDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: AuditDocumentCreateOrConnectWithoutUploadedByInput | AuditDocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: AuditDocumentUpsertWithWhereUniqueWithoutUploadedByInput | AuditDocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: AuditDocumentCreateManyUploadedByInputEnvelope
    set?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    disconnect?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    delete?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    connect?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    update?: AuditDocumentUpdateWithWhereUniqueWithoutUploadedByInput | AuditDocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: AuditDocumentUpdateManyWithWhereWithoutUploadedByInput | AuditDocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: AuditDocumentScalarWhereInput | AuditDocumentScalarWhereInput[]
  }

  export type AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AuditReminderCreateWithoutCreatedByInput, AuditReminderUncheckedCreateWithoutCreatedByInput> | AuditReminderCreateWithoutCreatedByInput[] | AuditReminderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditReminderCreateOrConnectWithoutCreatedByInput | AuditReminderCreateOrConnectWithoutCreatedByInput[]
    upsert?: AuditReminderUpsertWithWhereUniqueWithoutCreatedByInput | AuditReminderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AuditReminderCreateManyCreatedByInputEnvelope
    set?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    disconnect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    delete?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    connect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    update?: AuditReminderUpdateWithWhereUniqueWithoutCreatedByInput | AuditReminderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AuditReminderUpdateManyWithWhereWithoutCreatedByInput | AuditReminderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AuditReminderScalarWhereInput | AuditReminderScalarWhereInput[]
  }

  export type AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<AuditReminderCreateWithoutRecipientInput, AuditReminderUncheckedCreateWithoutRecipientInput> | AuditReminderCreateWithoutRecipientInput[] | AuditReminderUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: AuditReminderCreateOrConnectWithoutRecipientInput | AuditReminderCreateOrConnectWithoutRecipientInput[]
    upsert?: AuditReminderUpsertWithWhereUniqueWithoutRecipientInput | AuditReminderUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: AuditReminderCreateManyRecipientInputEnvelope
    set?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    disconnect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    delete?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    connect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    update?: AuditReminderUpdateWithWhereUniqueWithoutRecipientInput | AuditReminderUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: AuditReminderUpdateManyWithWhereWithoutRecipientInput | AuditReminderUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: AuditReminderScalarWhereInput | AuditReminderScalarWhereInput[]
  }

  export type AuditNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditNotificationCreateWithoutUserInput, AuditNotificationUncheckedCreateWithoutUserInput> | AuditNotificationCreateWithoutUserInput[] | AuditNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditNotificationCreateOrConnectWithoutUserInput | AuditNotificationCreateOrConnectWithoutUserInput[]
    upsert?: AuditNotificationUpsertWithWhereUniqueWithoutUserInput | AuditNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditNotificationCreateManyUserInputEnvelope
    set?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    disconnect?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    delete?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    connect?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    update?: AuditNotificationUpdateWithWhereUniqueWithoutUserInput | AuditNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditNotificationUpdateManyWithWhereWithoutUserInput | AuditNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditNotificationScalarWhereInput | AuditNotificationScalarWhereInput[]
  }

  export type PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput = {
    create?: XOR<PreAuditChecklistItemCreateWithoutResponsibleInput, PreAuditChecklistItemUncheckedCreateWithoutResponsibleInput> | PreAuditChecklistItemCreateWithoutResponsibleInput[] | PreAuditChecklistItemUncheckedCreateWithoutResponsibleInput[]
    connectOrCreate?: PreAuditChecklistItemCreateOrConnectWithoutResponsibleInput | PreAuditChecklistItemCreateOrConnectWithoutResponsibleInput[]
    upsert?: PreAuditChecklistItemUpsertWithWhereUniqueWithoutResponsibleInput | PreAuditChecklistItemUpsertWithWhereUniqueWithoutResponsibleInput[]
    createMany?: PreAuditChecklistItemCreateManyResponsibleInputEnvelope
    set?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    disconnect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    delete?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    connect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    update?: PreAuditChecklistItemUpdateWithWhereUniqueWithoutResponsibleInput | PreAuditChecklistItemUpdateWithWhereUniqueWithoutResponsibleInput[]
    updateMany?: PreAuditChecklistItemUpdateManyWithWhereWithoutResponsibleInput | PreAuditChecklistItemUpdateManyWithWhereWithoutResponsibleInput[]
    deleteMany?: PreAuditChecklistItemScalarWhereInput | PreAuditChecklistItemScalarWhereInput[]
  }

  export type PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PreAuditChecklistItemCreateWithoutCreatedByInput, PreAuditChecklistItemUncheckedCreateWithoutCreatedByInput> | PreAuditChecklistItemCreateWithoutCreatedByInput[] | PreAuditChecklistItemUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PreAuditChecklistItemCreateOrConnectWithoutCreatedByInput | PreAuditChecklistItemCreateOrConnectWithoutCreatedByInput[]
    upsert?: PreAuditChecklistItemUpsertWithWhereUniqueWithoutCreatedByInput | PreAuditChecklistItemUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PreAuditChecklistItemCreateManyCreatedByInputEnvelope
    set?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    disconnect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    delete?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    connect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    update?: PreAuditChecklistItemUpdateWithWhereUniqueWithoutCreatedByInput | PreAuditChecklistItemUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PreAuditChecklistItemUpdateManyWithWhereWithoutCreatedByInput | PreAuditChecklistItemUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PreAuditChecklistItemScalarWhereInput | PreAuditChecklistItemScalarWhereInput[]
  }

  export type AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput = {
    create?: XOR<AuditInspectionItemCreateWithoutInspectedByInput, AuditInspectionItemUncheckedCreateWithoutInspectedByInput> | AuditInspectionItemCreateWithoutInspectedByInput[] | AuditInspectionItemUncheckedCreateWithoutInspectedByInput[]
    connectOrCreate?: AuditInspectionItemCreateOrConnectWithoutInspectedByInput | AuditInspectionItemCreateOrConnectWithoutInspectedByInput[]
    upsert?: AuditInspectionItemUpsertWithWhereUniqueWithoutInspectedByInput | AuditInspectionItemUpsertWithWhereUniqueWithoutInspectedByInput[]
    createMany?: AuditInspectionItemCreateManyInspectedByInputEnvelope
    set?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    disconnect?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    delete?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    connect?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    update?: AuditInspectionItemUpdateWithWhereUniqueWithoutInspectedByInput | AuditInspectionItemUpdateWithWhereUniqueWithoutInspectedByInput[]
    updateMany?: AuditInspectionItemUpdateManyWithWhereWithoutInspectedByInput | AuditInspectionItemUpdateManyWithWhereWithoutInspectedByInput[]
    deleteMany?: AuditInspectionItemScalarWhereInput | AuditInspectionItemScalarWhereInput[]
  }

  export type FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<FeedbackFormCreateWithoutUploadedByInput, FeedbackFormUncheckedCreateWithoutUploadedByInput> | FeedbackFormCreateWithoutUploadedByInput[] | FeedbackFormUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutUploadedByInput | FeedbackFormCreateOrConnectWithoutUploadedByInput[]
    upsert?: FeedbackFormUpsertWithWhereUniqueWithoutUploadedByInput | FeedbackFormUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: FeedbackFormCreateManyUploadedByInputEnvelope
    set?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    disconnect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    delete?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    update?: FeedbackFormUpdateWithWhereUniqueWithoutUploadedByInput | FeedbackFormUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: FeedbackFormUpdateManyWithWhereWithoutUploadedByInput | FeedbackFormUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: FeedbackFormScalarWhereInput | FeedbackFormScalarWhereInput[]
  }

  export type TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TrainingSessionPhotoCreateWithoutUploadedByInput, TrainingSessionPhotoUncheckedCreateWithoutUploadedByInput> | TrainingSessionPhotoCreateWithoutUploadedByInput[] | TrainingSessionPhotoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingSessionPhotoCreateOrConnectWithoutUploadedByInput | TrainingSessionPhotoCreateOrConnectWithoutUploadedByInput[]
    upsert?: TrainingSessionPhotoUpsertWithWhereUniqueWithoutUploadedByInput | TrainingSessionPhotoUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TrainingSessionPhotoCreateManyUploadedByInputEnvelope
    set?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    disconnect?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    delete?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    connect?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    update?: TrainingSessionPhotoUpdateWithWhereUniqueWithoutUploadedByInput | TrainingSessionPhotoUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TrainingSessionPhotoUpdateManyWithWhereWithoutUploadedByInput | TrainingSessionPhotoUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TrainingSessionPhotoScalarWhereInput | TrainingSessionPhotoScalarWhereInput[]
  }

  export type StandardCategoryCreateNestedOneWithoutStandardsInput = {
    create?: XOR<StandardCategoryCreateWithoutStandardsInput, StandardCategoryUncheckedCreateWithoutStandardsInput>
    connectOrCreate?: StandardCategoryCreateOrConnectWithoutStandardsInput
    connect?: StandardCategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStandardsCreatedInput = {
    create?: XOR<UserCreateWithoutStandardsCreatedInput, UserUncheckedCreateWithoutStandardsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStandardsModifiedInput = {
    create?: XOR<UserCreateWithoutStandardsModifiedInput, UserUncheckedCreateWithoutStandardsModifiedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardsModifiedInput
    connect?: UserWhereUniqueInput
  }

  export type BatchCreateNestedManyWithoutStandardsInput = {
    create?: XOR<BatchCreateWithoutStandardsInput, BatchUncheckedCreateWithoutStandardsInput> | BatchCreateWithoutStandardsInput[] | BatchUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutStandardsInput | BatchCreateOrConnectWithoutStandardsInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type MethodologyCreateNestedManyWithoutStandardsInput = {
    create?: XOR<MethodologyCreateWithoutStandardsInput, MethodologyUncheckedCreateWithoutStandardsInput> | MethodologyCreateWithoutStandardsInput[] | MethodologyUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutStandardsInput | MethodologyCreateOrConnectWithoutStandardsInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
  }

  export type UnitOfMeasurementCreateNestedManyWithoutStandardsInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardsInput, UnitOfMeasurementUncheckedCreateWithoutStandardsInput> | UnitOfMeasurementCreateWithoutStandardsInput[] | UnitOfMeasurementUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardsInput | UnitOfMeasurementCreateOrConnectWithoutStandardsInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutStandardsInput = {
    create?: XOR<BatchCreateWithoutStandardsInput, BatchUncheckedCreateWithoutStandardsInput> | BatchCreateWithoutStandardsInput[] | BatchUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutStandardsInput | BatchCreateOrConnectWithoutStandardsInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type MethodologyUncheckedCreateNestedManyWithoutStandardsInput = {
    create?: XOR<MethodologyCreateWithoutStandardsInput, MethodologyUncheckedCreateWithoutStandardsInput> | MethodologyCreateWithoutStandardsInput[] | MethodologyUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutStandardsInput | MethodologyCreateOrConnectWithoutStandardsInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
  }

  export type UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardsInput, UnitOfMeasurementUncheckedCreateWithoutStandardsInput> | UnitOfMeasurementCreateWithoutStandardsInput[] | UnitOfMeasurementUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardsInput | UnitOfMeasurementCreateOrConnectWithoutStandardsInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
  }

  export type EnumStandardStatusFieldUpdateOperationsInput = {
    set?: $Enums.StandardStatus
  }

  export type StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput = {
    create?: XOR<StandardCategoryCreateWithoutStandardsInput, StandardCategoryUncheckedCreateWithoutStandardsInput>
    connectOrCreate?: StandardCategoryCreateOrConnectWithoutStandardsInput
    upsert?: StandardCategoryUpsertWithoutStandardsInput
    connect?: StandardCategoryWhereUniqueInput
    update?: XOR<XOR<StandardCategoryUpdateToOneWithWhereWithoutStandardsInput, StandardCategoryUpdateWithoutStandardsInput>, StandardCategoryUncheckedUpdateWithoutStandardsInput>
  }

  export type UserUpdateOneRequiredWithoutStandardsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutStandardsCreatedInput, UserUncheckedCreateWithoutStandardsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardsCreatedInput
    upsert?: UserUpsertWithoutStandardsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStandardsCreatedInput, UserUpdateWithoutStandardsCreatedInput>, UserUncheckedUpdateWithoutStandardsCreatedInput>
  }

  export type UserUpdateOneWithoutStandardsModifiedNestedInput = {
    create?: XOR<UserCreateWithoutStandardsModifiedInput, UserUncheckedCreateWithoutStandardsModifiedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardsModifiedInput
    upsert?: UserUpsertWithoutStandardsModifiedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStandardsModifiedInput, UserUpdateWithoutStandardsModifiedInput>, UserUncheckedUpdateWithoutStandardsModifiedInput>
  }

  export type BatchUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<BatchCreateWithoutStandardsInput, BatchUncheckedCreateWithoutStandardsInput> | BatchCreateWithoutStandardsInput[] | BatchUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutStandardsInput | BatchCreateOrConnectWithoutStandardsInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutStandardsInput | BatchUpsertWithWhereUniqueWithoutStandardsInput[]
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutStandardsInput | BatchUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutStandardsInput | BatchUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type MethodologyUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<MethodologyCreateWithoutStandardsInput, MethodologyUncheckedCreateWithoutStandardsInput> | MethodologyCreateWithoutStandardsInput[] | MethodologyUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutStandardsInput | MethodologyCreateOrConnectWithoutStandardsInput[]
    upsert?: MethodologyUpsertWithWhereUniqueWithoutStandardsInput | MethodologyUpsertWithWhereUniqueWithoutStandardsInput[]
    set?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    disconnect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    delete?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    update?: MethodologyUpdateWithWhereUniqueWithoutStandardsInput | MethodologyUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: MethodologyUpdateManyWithWhereWithoutStandardsInput | MethodologyUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: MethodologyScalarWhereInput | MethodologyScalarWhereInput[]
  }

  export type UnitOfMeasurementUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardsInput, UnitOfMeasurementUncheckedCreateWithoutStandardsInput> | UnitOfMeasurementCreateWithoutStandardsInput[] | UnitOfMeasurementUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardsInput | UnitOfMeasurementCreateOrConnectWithoutStandardsInput[]
    upsert?: UnitOfMeasurementUpsertWithWhereUniqueWithoutStandardsInput | UnitOfMeasurementUpsertWithWhereUniqueWithoutStandardsInput[]
    set?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    disconnect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    delete?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    update?: UnitOfMeasurementUpdateWithWhereUniqueWithoutStandardsInput | UnitOfMeasurementUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: UnitOfMeasurementUpdateManyWithWhereWithoutStandardsInput | UnitOfMeasurementUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: UnitOfMeasurementScalarWhereInput | UnitOfMeasurementScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<BatchCreateWithoutStandardsInput, BatchUncheckedCreateWithoutStandardsInput> | BatchCreateWithoutStandardsInput[] | BatchUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutStandardsInput | BatchCreateOrConnectWithoutStandardsInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutStandardsInput | BatchUpsertWithWhereUniqueWithoutStandardsInput[]
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutStandardsInput | BatchUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutStandardsInput | BatchUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type MethodologyUncheckedUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<MethodologyCreateWithoutStandardsInput, MethodologyUncheckedCreateWithoutStandardsInput> | MethodologyCreateWithoutStandardsInput[] | MethodologyUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutStandardsInput | MethodologyCreateOrConnectWithoutStandardsInput[]
    upsert?: MethodologyUpsertWithWhereUniqueWithoutStandardsInput | MethodologyUpsertWithWhereUniqueWithoutStandardsInput[]
    set?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    disconnect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    delete?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    update?: MethodologyUpdateWithWhereUniqueWithoutStandardsInput | MethodologyUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: MethodologyUpdateManyWithWhereWithoutStandardsInput | MethodologyUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: MethodologyScalarWhereInput | MethodologyScalarWhereInput[]
  }

  export type UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardsInput, UnitOfMeasurementUncheckedCreateWithoutStandardsInput> | UnitOfMeasurementCreateWithoutStandardsInput[] | UnitOfMeasurementUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardsInput | UnitOfMeasurementCreateOrConnectWithoutStandardsInput[]
    upsert?: UnitOfMeasurementUpsertWithWhereUniqueWithoutStandardsInput | UnitOfMeasurementUpsertWithWhereUniqueWithoutStandardsInput[]
    set?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    disconnect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    delete?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    update?: UnitOfMeasurementUpdateWithWhereUniqueWithoutStandardsInput | UnitOfMeasurementUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: UnitOfMeasurementUpdateManyWithWhereWithoutStandardsInput | UnitOfMeasurementUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: UnitOfMeasurementScalarWhereInput | UnitOfMeasurementScalarWhereInput[]
  }

  export type StandardParameterCreateNestedManyWithoutCategoryInput = {
    create?: XOR<StandardParameterCreateWithoutCategoryInput, StandardParameterUncheckedCreateWithoutCategoryInput> | StandardParameterCreateWithoutCategoryInput[] | StandardParameterUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardParameterCreateOrConnectWithoutCategoryInput | StandardParameterCreateOrConnectWithoutCategoryInput[]
    createMany?: StandardParameterCreateManyCategoryInputEnvelope
    connect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
  }

  export type StandardCreateNestedManyWithoutCategoryInput = {
    create?: XOR<StandardCreateWithoutCategoryInput, StandardUncheckedCreateWithoutCategoryInput> | StandardCreateWithoutCategoryInput[] | StandardUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCategoryInput | StandardCreateOrConnectWithoutCategoryInput[]
    createMany?: StandardCreateManyCategoryInputEnvelope
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type ProductStandardCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductStandardCategoryCreateWithoutCategoryInput, ProductStandardCategoryUncheckedCreateWithoutCategoryInput> | ProductStandardCategoryCreateWithoutCategoryInput[] | ProductStandardCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductStandardCategoryCreateOrConnectWithoutCategoryInput | ProductStandardCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductStandardCategoryCreateManyCategoryInputEnvelope
    connect?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
  }

  export type StandardParameterUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<StandardParameterCreateWithoutCategoryInput, StandardParameterUncheckedCreateWithoutCategoryInput> | StandardParameterCreateWithoutCategoryInput[] | StandardParameterUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardParameterCreateOrConnectWithoutCategoryInput | StandardParameterCreateOrConnectWithoutCategoryInput[]
    createMany?: StandardParameterCreateManyCategoryInputEnvelope
    connect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
  }

  export type StandardUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<StandardCreateWithoutCategoryInput, StandardUncheckedCreateWithoutCategoryInput> | StandardCreateWithoutCategoryInput[] | StandardUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCategoryInput | StandardCreateOrConnectWithoutCategoryInput[]
    createMany?: StandardCreateManyCategoryInputEnvelope
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type ProductStandardCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductStandardCategoryCreateWithoutCategoryInput, ProductStandardCategoryUncheckedCreateWithoutCategoryInput> | ProductStandardCategoryCreateWithoutCategoryInput[] | ProductStandardCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductStandardCategoryCreateOrConnectWithoutCategoryInput | ProductStandardCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductStandardCategoryCreateManyCategoryInputEnvelope
    connect?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
  }

  export type StandardParameterUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<StandardParameterCreateWithoutCategoryInput, StandardParameterUncheckedCreateWithoutCategoryInput> | StandardParameterCreateWithoutCategoryInput[] | StandardParameterUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardParameterCreateOrConnectWithoutCategoryInput | StandardParameterCreateOrConnectWithoutCategoryInput[]
    upsert?: StandardParameterUpsertWithWhereUniqueWithoutCategoryInput | StandardParameterUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: StandardParameterCreateManyCategoryInputEnvelope
    set?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    disconnect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    delete?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    connect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    update?: StandardParameterUpdateWithWhereUniqueWithoutCategoryInput | StandardParameterUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: StandardParameterUpdateManyWithWhereWithoutCategoryInput | StandardParameterUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: StandardParameterScalarWhereInput | StandardParameterScalarWhereInput[]
  }

  export type StandardUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<StandardCreateWithoutCategoryInput, StandardUncheckedCreateWithoutCategoryInput> | StandardCreateWithoutCategoryInput[] | StandardUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCategoryInput | StandardCreateOrConnectWithoutCategoryInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutCategoryInput | StandardUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: StandardCreateManyCategoryInputEnvelope
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutCategoryInput | StandardUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutCategoryInput | StandardUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type ProductStandardCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductStandardCategoryCreateWithoutCategoryInput, ProductStandardCategoryUncheckedCreateWithoutCategoryInput> | ProductStandardCategoryCreateWithoutCategoryInput[] | ProductStandardCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductStandardCategoryCreateOrConnectWithoutCategoryInput | ProductStandardCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductStandardCategoryUpsertWithWhereUniqueWithoutCategoryInput | ProductStandardCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductStandardCategoryCreateManyCategoryInputEnvelope
    set?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    disconnect?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    delete?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    connect?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    update?: ProductStandardCategoryUpdateWithWhereUniqueWithoutCategoryInput | ProductStandardCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductStandardCategoryUpdateManyWithWhereWithoutCategoryInput | ProductStandardCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductStandardCategoryScalarWhereInput | ProductStandardCategoryScalarWhereInput[]
  }

  export type StandardParameterUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<StandardParameterCreateWithoutCategoryInput, StandardParameterUncheckedCreateWithoutCategoryInput> | StandardParameterCreateWithoutCategoryInput[] | StandardParameterUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardParameterCreateOrConnectWithoutCategoryInput | StandardParameterCreateOrConnectWithoutCategoryInput[]
    upsert?: StandardParameterUpsertWithWhereUniqueWithoutCategoryInput | StandardParameterUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: StandardParameterCreateManyCategoryInputEnvelope
    set?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    disconnect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    delete?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    connect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    update?: StandardParameterUpdateWithWhereUniqueWithoutCategoryInput | StandardParameterUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: StandardParameterUpdateManyWithWhereWithoutCategoryInput | StandardParameterUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: StandardParameterScalarWhereInput | StandardParameterScalarWhereInput[]
  }

  export type StandardUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<StandardCreateWithoutCategoryInput, StandardUncheckedCreateWithoutCategoryInput> | StandardCreateWithoutCategoryInput[] | StandardUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCategoryInput | StandardCreateOrConnectWithoutCategoryInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutCategoryInput | StandardUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: StandardCreateManyCategoryInputEnvelope
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutCategoryInput | StandardUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutCategoryInput | StandardUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type ProductStandardCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductStandardCategoryCreateWithoutCategoryInput, ProductStandardCategoryUncheckedCreateWithoutCategoryInput> | ProductStandardCategoryCreateWithoutCategoryInput[] | ProductStandardCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductStandardCategoryCreateOrConnectWithoutCategoryInput | ProductStandardCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductStandardCategoryUpsertWithWhereUniqueWithoutCategoryInput | ProductStandardCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductStandardCategoryCreateManyCategoryInputEnvelope
    set?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    disconnect?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    delete?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    connect?: ProductStandardCategoryWhereUniqueInput | ProductStandardCategoryWhereUniqueInput[]
    update?: ProductStandardCategoryUpdateWithWhereUniqueWithoutCategoryInput | ProductStandardCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductStandardCategoryUpdateManyWithWhereWithoutCategoryInput | ProductStandardCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductStandardCategoryScalarWhereInput | ProductStandardCategoryScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutStandardCategoriesInput = {
    create?: XOR<ProductCreateWithoutStandardCategoriesInput, ProductUncheckedCreateWithoutStandardCategoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStandardCategoriesInput
    connect?: ProductWhereUniqueInput
  }

  export type StandardCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<StandardCategoryCreateWithoutProductsInput, StandardCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: StandardCategoryCreateOrConnectWithoutProductsInput
    connect?: StandardCategoryWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutStandardCategoriesNestedInput = {
    create?: XOR<ProductCreateWithoutStandardCategoriesInput, ProductUncheckedCreateWithoutStandardCategoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStandardCategoriesInput
    upsert?: ProductUpsertWithoutStandardCategoriesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStandardCategoriesInput, ProductUpdateWithoutStandardCategoriesInput>, ProductUncheckedUpdateWithoutStandardCategoriesInput>
  }

  export type StandardCategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<StandardCategoryCreateWithoutProductsInput, StandardCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: StandardCategoryCreateOrConnectWithoutProductsInput
    upsert?: StandardCategoryUpsertWithoutProductsInput
    connect?: StandardCategoryWhereUniqueInput
    update?: XOR<XOR<StandardCategoryUpdateToOneWithWhereWithoutProductsInput, StandardCategoryUpdateWithoutProductsInput>, StandardCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type StandardCategoryCreateNestedOneWithoutParametersInput = {
    create?: XOR<StandardCategoryCreateWithoutParametersInput, StandardCategoryUncheckedCreateWithoutParametersInput>
    connectOrCreate?: StandardCategoryCreateOrConnectWithoutParametersInput
    connect?: StandardCategoryWhereUniqueInput
  }

  export type BatchParameterValueCreateNestedManyWithoutParameterInput = {
    create?: XOR<BatchParameterValueCreateWithoutParameterInput, BatchParameterValueUncheckedCreateWithoutParameterInput> | BatchParameterValueCreateWithoutParameterInput[] | BatchParameterValueUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutParameterInput | BatchParameterValueCreateOrConnectWithoutParameterInput[]
    createMany?: BatchParameterValueCreateManyParameterInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type UnitOfMeasurementCreateNestedOneWithoutStandardParametersInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardParametersInput, UnitOfMeasurementUncheckedCreateWithoutStandardParametersInput>
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardParametersInput
    connect?: UnitOfMeasurementWhereUniqueInput
  }

  export type StandardDefinitionCreateNestedManyWithoutParameterInput = {
    create?: XOR<StandardDefinitionCreateWithoutParameterInput, StandardDefinitionUncheckedCreateWithoutParameterInput> | StandardDefinitionCreateWithoutParameterInput[] | StandardDefinitionUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutParameterInput | StandardDefinitionCreateOrConnectWithoutParameterInput[]
    createMany?: StandardDefinitionCreateManyParameterInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type ProductParameterCreateNestedManyWithoutParameterInput = {
    create?: XOR<ProductParameterCreateWithoutParameterInput, ProductParameterUncheckedCreateWithoutParameterInput> | ProductParameterCreateWithoutParameterInput[] | ProductParameterUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: ProductParameterCreateOrConnectWithoutParameterInput | ProductParameterCreateOrConnectWithoutParameterInput[]
    createMany?: ProductParameterCreateManyParameterInputEnvelope
    connect?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
  }

  export type BatchParameterValueUncheckedCreateNestedManyWithoutParameterInput = {
    create?: XOR<BatchParameterValueCreateWithoutParameterInput, BatchParameterValueUncheckedCreateWithoutParameterInput> | BatchParameterValueCreateWithoutParameterInput[] | BatchParameterValueUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutParameterInput | BatchParameterValueCreateOrConnectWithoutParameterInput[]
    createMany?: BatchParameterValueCreateManyParameterInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type StandardDefinitionUncheckedCreateNestedManyWithoutParameterInput = {
    create?: XOR<StandardDefinitionCreateWithoutParameterInput, StandardDefinitionUncheckedCreateWithoutParameterInput> | StandardDefinitionCreateWithoutParameterInput[] | StandardDefinitionUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutParameterInput | StandardDefinitionCreateOrConnectWithoutParameterInput[]
    createMany?: StandardDefinitionCreateManyParameterInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type ProductParameterUncheckedCreateNestedManyWithoutParameterInput = {
    create?: XOR<ProductParameterCreateWithoutParameterInput, ProductParameterUncheckedCreateWithoutParameterInput> | ProductParameterCreateWithoutParameterInput[] | ProductParameterUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: ProductParameterCreateOrConnectWithoutParameterInput | ProductParameterCreateOrConnectWithoutParameterInput[]
    createMany?: ProductParameterCreateManyParameterInputEnvelope
    connect?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
  }

  export type EnumParameterDataTypeFieldUpdateOperationsInput = {
    set?: $Enums.ParameterDataType
  }

  export type StandardCategoryUpdateOneRequiredWithoutParametersNestedInput = {
    create?: XOR<StandardCategoryCreateWithoutParametersInput, StandardCategoryUncheckedCreateWithoutParametersInput>
    connectOrCreate?: StandardCategoryCreateOrConnectWithoutParametersInput
    upsert?: StandardCategoryUpsertWithoutParametersInput
    connect?: StandardCategoryWhereUniqueInput
    update?: XOR<XOR<StandardCategoryUpdateToOneWithWhereWithoutParametersInput, StandardCategoryUpdateWithoutParametersInput>, StandardCategoryUncheckedUpdateWithoutParametersInput>
  }

  export type BatchParameterValueUpdateManyWithoutParameterNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutParameterInput, BatchParameterValueUncheckedCreateWithoutParameterInput> | BatchParameterValueCreateWithoutParameterInput[] | BatchParameterValueUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutParameterInput | BatchParameterValueCreateOrConnectWithoutParameterInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutParameterInput | BatchParameterValueUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: BatchParameterValueCreateManyParameterInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutParameterInput | BatchParameterValueUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutParameterInput | BatchParameterValueUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type UnitOfMeasurementUpdateOneWithoutStandardParametersNestedInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardParametersInput, UnitOfMeasurementUncheckedCreateWithoutStandardParametersInput>
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardParametersInput
    upsert?: UnitOfMeasurementUpsertWithoutStandardParametersInput
    disconnect?: UnitOfMeasurementWhereInput | boolean
    delete?: UnitOfMeasurementWhereInput | boolean
    connect?: UnitOfMeasurementWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasurementUpdateToOneWithWhereWithoutStandardParametersInput, UnitOfMeasurementUpdateWithoutStandardParametersInput>, UnitOfMeasurementUncheckedUpdateWithoutStandardParametersInput>
  }

  export type StandardDefinitionUpdateManyWithoutParameterNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutParameterInput, StandardDefinitionUncheckedCreateWithoutParameterInput> | StandardDefinitionCreateWithoutParameterInput[] | StandardDefinitionUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutParameterInput | StandardDefinitionCreateOrConnectWithoutParameterInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutParameterInput | StandardDefinitionUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: StandardDefinitionCreateManyParameterInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutParameterInput | StandardDefinitionUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutParameterInput | StandardDefinitionUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type ProductParameterUpdateManyWithoutParameterNestedInput = {
    create?: XOR<ProductParameterCreateWithoutParameterInput, ProductParameterUncheckedCreateWithoutParameterInput> | ProductParameterCreateWithoutParameterInput[] | ProductParameterUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: ProductParameterCreateOrConnectWithoutParameterInput | ProductParameterCreateOrConnectWithoutParameterInput[]
    upsert?: ProductParameterUpsertWithWhereUniqueWithoutParameterInput | ProductParameterUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: ProductParameterCreateManyParameterInputEnvelope
    set?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    disconnect?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    delete?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    connect?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    update?: ProductParameterUpdateWithWhereUniqueWithoutParameterInput | ProductParameterUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: ProductParameterUpdateManyWithWhereWithoutParameterInput | ProductParameterUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: ProductParameterScalarWhereInput | ProductParameterScalarWhereInput[]
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutParameterNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutParameterInput, BatchParameterValueUncheckedCreateWithoutParameterInput> | BatchParameterValueCreateWithoutParameterInput[] | BatchParameterValueUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutParameterInput | BatchParameterValueCreateOrConnectWithoutParameterInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutParameterInput | BatchParameterValueUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: BatchParameterValueCreateManyParameterInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutParameterInput | BatchParameterValueUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutParameterInput | BatchParameterValueUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutParameterNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutParameterInput, StandardDefinitionUncheckedCreateWithoutParameterInput> | StandardDefinitionCreateWithoutParameterInput[] | StandardDefinitionUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutParameterInput | StandardDefinitionCreateOrConnectWithoutParameterInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutParameterInput | StandardDefinitionUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: StandardDefinitionCreateManyParameterInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutParameterInput | StandardDefinitionUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutParameterInput | StandardDefinitionUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type ProductParameterUncheckedUpdateManyWithoutParameterNestedInput = {
    create?: XOR<ProductParameterCreateWithoutParameterInput, ProductParameterUncheckedCreateWithoutParameterInput> | ProductParameterCreateWithoutParameterInput[] | ProductParameterUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: ProductParameterCreateOrConnectWithoutParameterInput | ProductParameterCreateOrConnectWithoutParameterInput[]
    upsert?: ProductParameterUpsertWithWhereUniqueWithoutParameterInput | ProductParameterUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: ProductParameterCreateManyParameterInputEnvelope
    set?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    disconnect?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    delete?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    connect?: ProductParameterWhereUniqueInput | ProductParameterWhereUniqueInput[]
    update?: ProductParameterUpdateWithWhereUniqueWithoutParameterInput | ProductParameterUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: ProductParameterUpdateManyWithWhereWithoutParameterInput | ProductParameterUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: ProductParameterScalarWhereInput | ProductParameterScalarWhereInput[]
  }

  export type StandardParameterCreateNestedOneWithoutStandardsInput = {
    create?: XOR<StandardParameterCreateWithoutStandardsInput, StandardParameterUncheckedCreateWithoutStandardsInput>
    connectOrCreate?: StandardParameterCreateOrConnectWithoutStandardsInput
    connect?: StandardParameterWhereUniqueInput
  }

  export type UnitOfMeasurementCreateNestedOneWithoutStandardDefinitionsInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardDefinitionsInput, UnitOfMeasurementUncheckedCreateWithoutStandardDefinitionsInput>
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardDefinitionsInput
    connect?: UnitOfMeasurementWhereUniqueInput
  }

  export type MethodologyCreateNestedOneWithoutStandardDefinitionsInput = {
    create?: XOR<MethodologyCreateWithoutStandardDefinitionsInput, MethodologyUncheckedCreateWithoutStandardDefinitionsInput>
    connectOrCreate?: MethodologyCreateOrConnectWithoutStandardDefinitionsInput
    connect?: MethodologyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStandardDefinitionsCreatedInput = {
    create?: XOR<UserCreateWithoutStandardDefinitionsCreatedInput, UserUncheckedCreateWithoutStandardDefinitionsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardDefinitionsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStandardDefinitionsModifiedInput = {
    create?: XOR<UserCreateWithoutStandardDefinitionsModifiedInput, UserUncheckedCreateWithoutStandardDefinitionsModifiedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardDefinitionsModifiedInput
    connect?: UserWhereUniqueInput
  }

  export type StandardParameterUpdateOneRequiredWithoutStandardsNestedInput = {
    create?: XOR<StandardParameterCreateWithoutStandardsInput, StandardParameterUncheckedCreateWithoutStandardsInput>
    connectOrCreate?: StandardParameterCreateOrConnectWithoutStandardsInput
    upsert?: StandardParameterUpsertWithoutStandardsInput
    connect?: StandardParameterWhereUniqueInput
    update?: XOR<XOR<StandardParameterUpdateToOneWithWhereWithoutStandardsInput, StandardParameterUpdateWithoutStandardsInput>, StandardParameterUncheckedUpdateWithoutStandardsInput>
  }

  export type UnitOfMeasurementUpdateOneWithoutStandardDefinitionsNestedInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardDefinitionsInput, UnitOfMeasurementUncheckedCreateWithoutStandardDefinitionsInput>
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardDefinitionsInput
    upsert?: UnitOfMeasurementUpsertWithoutStandardDefinitionsInput
    disconnect?: UnitOfMeasurementWhereInput | boolean
    delete?: UnitOfMeasurementWhereInput | boolean
    connect?: UnitOfMeasurementWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasurementUpdateToOneWithWhereWithoutStandardDefinitionsInput, UnitOfMeasurementUpdateWithoutStandardDefinitionsInput>, UnitOfMeasurementUncheckedUpdateWithoutStandardDefinitionsInput>
  }

  export type MethodologyUpdateOneWithoutStandardDefinitionsNestedInput = {
    create?: XOR<MethodologyCreateWithoutStandardDefinitionsInput, MethodologyUncheckedCreateWithoutStandardDefinitionsInput>
    connectOrCreate?: MethodologyCreateOrConnectWithoutStandardDefinitionsInput
    upsert?: MethodologyUpsertWithoutStandardDefinitionsInput
    disconnect?: MethodologyWhereInput | boolean
    delete?: MethodologyWhereInput | boolean
    connect?: MethodologyWhereUniqueInput
    update?: XOR<XOR<MethodologyUpdateToOneWithWhereWithoutStandardDefinitionsInput, MethodologyUpdateWithoutStandardDefinitionsInput>, MethodologyUncheckedUpdateWithoutStandardDefinitionsInput>
  }

  export type UserUpdateOneRequiredWithoutStandardDefinitionsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutStandardDefinitionsCreatedInput, UserUncheckedCreateWithoutStandardDefinitionsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardDefinitionsCreatedInput
    upsert?: UserUpsertWithoutStandardDefinitionsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStandardDefinitionsCreatedInput, UserUpdateWithoutStandardDefinitionsCreatedInput>, UserUncheckedUpdateWithoutStandardDefinitionsCreatedInput>
  }

  export type UserUpdateOneWithoutStandardDefinitionsModifiedNestedInput = {
    create?: XOR<UserCreateWithoutStandardDefinitionsModifiedInput, UserUncheckedCreateWithoutStandardDefinitionsModifiedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardDefinitionsModifiedInput
    upsert?: UserUpsertWithoutStandardDefinitionsModifiedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStandardDefinitionsModifiedInput, UserUpdateWithoutStandardDefinitionsModifiedInput>, UserUncheckedUpdateWithoutStandardDefinitionsModifiedInput>
  }

  export type BatchCreateNestedOneWithoutParameterValuesInput = {
    create?: XOR<BatchCreateWithoutParameterValuesInput, BatchUncheckedCreateWithoutParameterValuesInput>
    connectOrCreate?: BatchCreateOrConnectWithoutParameterValuesInput
    connect?: BatchWhereUniqueInput
  }

  export type StandardParameterCreateNestedOneWithoutBatchValuesInput = {
    create?: XOR<StandardParameterCreateWithoutBatchValuesInput, StandardParameterUncheckedCreateWithoutBatchValuesInput>
    connectOrCreate?: StandardParameterCreateOrConnectWithoutBatchValuesInput
    connect?: StandardParameterWhereUniqueInput
  }

  export type UnitOfMeasurementCreateNestedOneWithoutBatchParameterValuesInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutBatchParameterValuesInput, UnitOfMeasurementUncheckedCreateWithoutBatchParameterValuesInput>
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutBatchParameterValuesInput
    connect?: UnitOfMeasurementWhereUniqueInput
  }

  export type MethodologyCreateNestedOneWithoutBatchParameterValuesInput = {
    create?: XOR<MethodologyCreateWithoutBatchParameterValuesInput, MethodologyUncheckedCreateWithoutBatchParameterValuesInput>
    connectOrCreate?: MethodologyCreateOrConnectWithoutBatchParameterValuesInput
    connect?: MethodologyWhereUniqueInput
  }

  export type BatchUpdateOneRequiredWithoutParameterValuesNestedInput = {
    create?: XOR<BatchCreateWithoutParameterValuesInput, BatchUncheckedCreateWithoutParameterValuesInput>
    connectOrCreate?: BatchCreateOrConnectWithoutParameterValuesInput
    upsert?: BatchUpsertWithoutParameterValuesInput
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutParameterValuesInput, BatchUpdateWithoutParameterValuesInput>, BatchUncheckedUpdateWithoutParameterValuesInput>
  }

  export type StandardParameterUpdateOneRequiredWithoutBatchValuesNestedInput = {
    create?: XOR<StandardParameterCreateWithoutBatchValuesInput, StandardParameterUncheckedCreateWithoutBatchValuesInput>
    connectOrCreate?: StandardParameterCreateOrConnectWithoutBatchValuesInput
    upsert?: StandardParameterUpsertWithoutBatchValuesInput
    connect?: StandardParameterWhereUniqueInput
    update?: XOR<XOR<StandardParameterUpdateToOneWithWhereWithoutBatchValuesInput, StandardParameterUpdateWithoutBatchValuesInput>, StandardParameterUncheckedUpdateWithoutBatchValuesInput>
  }

  export type UnitOfMeasurementUpdateOneWithoutBatchParameterValuesNestedInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutBatchParameterValuesInput, UnitOfMeasurementUncheckedCreateWithoutBatchParameterValuesInput>
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutBatchParameterValuesInput
    upsert?: UnitOfMeasurementUpsertWithoutBatchParameterValuesInput
    disconnect?: UnitOfMeasurementWhereInput | boolean
    delete?: UnitOfMeasurementWhereInput | boolean
    connect?: UnitOfMeasurementWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasurementUpdateToOneWithWhereWithoutBatchParameterValuesInput, UnitOfMeasurementUpdateWithoutBatchParameterValuesInput>, UnitOfMeasurementUncheckedUpdateWithoutBatchParameterValuesInput>
  }

  export type MethodologyUpdateOneWithoutBatchParameterValuesNestedInput = {
    create?: XOR<MethodologyCreateWithoutBatchParameterValuesInput, MethodologyUncheckedCreateWithoutBatchParameterValuesInput>
    connectOrCreate?: MethodologyCreateOrConnectWithoutBatchParameterValuesInput
    upsert?: MethodologyUpsertWithoutBatchParameterValuesInput
    disconnect?: MethodologyWhereInput | boolean
    delete?: MethodologyWhereInput | boolean
    connect?: MethodologyWhereUniqueInput
    update?: XOR<XOR<MethodologyUpdateToOneWithWhereWithoutBatchParameterValuesInput, MethodologyUpdateWithoutBatchParameterValuesInput>, MethodologyUncheckedUpdateWithoutBatchParameterValuesInput>
  }

  export type TrainingCreateNestedManyWithoutCalendarInput = {
    create?: XOR<TrainingCreateWithoutCalendarInput, TrainingUncheckedCreateWithoutCalendarInput> | TrainingCreateWithoutCalendarInput[] | TrainingUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCalendarInput | TrainingCreateOrConnectWithoutCalendarInput[]
    createMany?: TrainingCreateManyCalendarInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type TrainingUncheckedCreateNestedManyWithoutCalendarInput = {
    create?: XOR<TrainingCreateWithoutCalendarInput, TrainingUncheckedCreateWithoutCalendarInput> | TrainingCreateWithoutCalendarInput[] | TrainingUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCalendarInput | TrainingCreateOrConnectWithoutCalendarInput[]
    createMany?: TrainingCreateManyCalendarInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TrainingUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<TrainingCreateWithoutCalendarInput, TrainingUncheckedCreateWithoutCalendarInput> | TrainingCreateWithoutCalendarInput[] | TrainingUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCalendarInput | TrainingCreateOrConnectWithoutCalendarInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutCalendarInput | TrainingUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: TrainingCreateManyCalendarInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutCalendarInput | TrainingUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutCalendarInput | TrainingUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type TrainingUncheckedUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<TrainingCreateWithoutCalendarInput, TrainingUncheckedCreateWithoutCalendarInput> | TrainingCreateWithoutCalendarInput[] | TrainingUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCalendarInput | TrainingCreateOrConnectWithoutCalendarInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutCalendarInput | TrainingUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: TrainingCreateManyCalendarInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutCalendarInput | TrainingUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutCalendarInput | TrainingUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTrainerTrainingsInput = {
    create?: XOR<UserCreateWithoutTrainerTrainingsInput, UserUncheckedCreateWithoutTrainerTrainingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainerTrainingsInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingCalendarCreateNestedOneWithoutTrainingsInput = {
    create?: XOR<TrainingCalendarCreateWithoutTrainingsInput, TrainingCalendarUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: TrainingCalendarCreateOrConnectWithoutTrainingsInput
    connect?: TrainingCalendarWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTrainingsInput = {
    create?: XOR<UserCreateWithoutCreatedTrainingsInput, UserUncheckedCreateWithoutCreatedTrainingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTrainingsInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingSessionCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingSessionCreateWithoutTrainingInput, TrainingSessionUncheckedCreateWithoutTrainingInput> | TrainingSessionCreateWithoutTrainingInput[] | TrainingSessionUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutTrainingInput | TrainingSessionCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingSessionCreateManyTrainingInputEnvelope
    connect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
  }

  export type TrainingDocumentCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingDocumentCreateWithoutTrainingInput, TrainingDocumentUncheckedCreateWithoutTrainingInput> | TrainingDocumentCreateWithoutTrainingInput[] | TrainingDocumentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutTrainingInput | TrainingDocumentCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingDocumentCreateManyTrainingInputEnvelope
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutTrainingInput = {
    create?: XOR<AttendanceCreateWithoutTrainingInput, AttendanceUncheckedCreateWithoutTrainingInput> | AttendanceCreateWithoutTrainingInput[] | AttendanceUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTrainingInput | AttendanceCreateOrConnectWithoutTrainingInput[]
    createMany?: AttendanceCreateManyTrainingInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type TrainingParticipantCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingParticipantCreateWithoutTrainingInput, TrainingParticipantUncheckedCreateWithoutTrainingInput> | TrainingParticipantCreateWithoutTrainingInput[] | TrainingParticipantUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutTrainingInput | TrainingParticipantCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingParticipantCreateManyTrainingInputEnvelope
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
  }

  export type TrainingPhotoCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingPhotoCreateWithoutTrainingInput, TrainingPhotoUncheckedCreateWithoutTrainingInput> | TrainingPhotoCreateWithoutTrainingInput[] | TrainingPhotoUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutTrainingInput | TrainingPhotoCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingPhotoCreateManyTrainingInputEnvelope
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
  }

  export type TrainingFeedbackCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingFeedbackCreateWithoutTrainingInput, TrainingFeedbackUncheckedCreateWithoutTrainingInput> | TrainingFeedbackCreateWithoutTrainingInput[] | TrainingFeedbackUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutTrainingInput | TrainingFeedbackCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingFeedbackCreateManyTrainingInputEnvelope
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
  }

  export type TrainingFollowupCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingFollowupCreateWithoutTrainingInput, TrainingFollowupUncheckedCreateWithoutTrainingInput> | TrainingFollowupCreateWithoutTrainingInput[] | TrainingFollowupUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutTrainingInput | TrainingFollowupCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingFollowupCreateManyTrainingInputEnvelope
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
  }

  export type TrainingNotificationCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingNotificationCreateWithoutTrainingInput, TrainingNotificationUncheckedCreateWithoutTrainingInput> | TrainingNotificationCreateWithoutTrainingInput[] | TrainingNotificationUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutTrainingInput | TrainingNotificationCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingNotificationCreateManyTrainingInputEnvelope
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
  }

  export type TrainingInviteTokenCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingInviteTokenCreateWithoutTrainingInput, TrainingInviteTokenUncheckedCreateWithoutTrainingInput> | TrainingInviteTokenCreateWithoutTrainingInput[] | TrainingInviteTokenUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingInviteTokenCreateOrConnectWithoutTrainingInput | TrainingInviteTokenCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingInviteTokenCreateManyTrainingInputEnvelope
    connect?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
  }

  export type FeedbackFormCreateNestedManyWithoutTrainingInput = {
    create?: XOR<FeedbackFormCreateWithoutTrainingInput, FeedbackFormUncheckedCreateWithoutTrainingInput> | FeedbackFormCreateWithoutTrainingInput[] | FeedbackFormUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutTrainingInput | FeedbackFormCreateOrConnectWithoutTrainingInput[]
    createMany?: FeedbackFormCreateManyTrainingInputEnvelope
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
  }

  export type TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingSessionCreateWithoutTrainingInput, TrainingSessionUncheckedCreateWithoutTrainingInput> | TrainingSessionCreateWithoutTrainingInput[] | TrainingSessionUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutTrainingInput | TrainingSessionCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingSessionCreateManyTrainingInputEnvelope
    connect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
  }

  export type TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingDocumentCreateWithoutTrainingInput, TrainingDocumentUncheckedCreateWithoutTrainingInput> | TrainingDocumentCreateWithoutTrainingInput[] | TrainingDocumentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutTrainingInput | TrainingDocumentCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingDocumentCreateManyTrainingInputEnvelope
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<AttendanceCreateWithoutTrainingInput, AttendanceUncheckedCreateWithoutTrainingInput> | AttendanceCreateWithoutTrainingInput[] | AttendanceUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTrainingInput | AttendanceCreateOrConnectWithoutTrainingInput[]
    createMany?: AttendanceCreateManyTrainingInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingParticipantCreateWithoutTrainingInput, TrainingParticipantUncheckedCreateWithoutTrainingInput> | TrainingParticipantCreateWithoutTrainingInput[] | TrainingParticipantUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutTrainingInput | TrainingParticipantCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingParticipantCreateManyTrainingInputEnvelope
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
  }

  export type TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingPhotoCreateWithoutTrainingInput, TrainingPhotoUncheckedCreateWithoutTrainingInput> | TrainingPhotoCreateWithoutTrainingInput[] | TrainingPhotoUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutTrainingInput | TrainingPhotoCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingPhotoCreateManyTrainingInputEnvelope
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
  }

  export type TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingFeedbackCreateWithoutTrainingInput, TrainingFeedbackUncheckedCreateWithoutTrainingInput> | TrainingFeedbackCreateWithoutTrainingInput[] | TrainingFeedbackUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutTrainingInput | TrainingFeedbackCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingFeedbackCreateManyTrainingInputEnvelope
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
  }

  export type TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingFollowupCreateWithoutTrainingInput, TrainingFollowupUncheckedCreateWithoutTrainingInput> | TrainingFollowupCreateWithoutTrainingInput[] | TrainingFollowupUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutTrainingInput | TrainingFollowupCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingFollowupCreateManyTrainingInputEnvelope
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
  }

  export type TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingNotificationCreateWithoutTrainingInput, TrainingNotificationUncheckedCreateWithoutTrainingInput> | TrainingNotificationCreateWithoutTrainingInput[] | TrainingNotificationUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutTrainingInput | TrainingNotificationCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingNotificationCreateManyTrainingInputEnvelope
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
  }

  export type TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingInviteTokenCreateWithoutTrainingInput, TrainingInviteTokenUncheckedCreateWithoutTrainingInput> | TrainingInviteTokenCreateWithoutTrainingInput[] | TrainingInviteTokenUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingInviteTokenCreateOrConnectWithoutTrainingInput | TrainingInviteTokenCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingInviteTokenCreateManyTrainingInputEnvelope
    connect?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
  }

  export type FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<FeedbackFormCreateWithoutTrainingInput, FeedbackFormUncheckedCreateWithoutTrainingInput> | FeedbackFormCreateWithoutTrainingInput[] | FeedbackFormUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutTrainingInput | FeedbackFormCreateOrConnectWithoutTrainingInput[]
    createMany?: FeedbackFormCreateManyTrainingInputEnvelope
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
  }

  export type EnumTrainingTypeFieldUpdateOperationsInput = {
    set?: $Enums.TrainingType
  }

  export type EnumTrainingStatusFieldUpdateOperationsInput = {
    set?: $Enums.TrainingStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput = {
    create?: XOR<UserCreateWithoutTrainerTrainingsInput, UserUncheckedCreateWithoutTrainerTrainingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainerTrainingsInput
    upsert?: UserUpsertWithoutTrainerTrainingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrainerTrainingsInput, UserUpdateWithoutTrainerTrainingsInput>, UserUncheckedUpdateWithoutTrainerTrainingsInput>
  }

  export type TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput = {
    create?: XOR<TrainingCalendarCreateWithoutTrainingsInput, TrainingCalendarUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: TrainingCalendarCreateOrConnectWithoutTrainingsInput
    upsert?: TrainingCalendarUpsertWithoutTrainingsInput
    connect?: TrainingCalendarWhereUniqueInput
    update?: XOR<XOR<TrainingCalendarUpdateToOneWithWhereWithoutTrainingsInput, TrainingCalendarUpdateWithoutTrainingsInput>, TrainingCalendarUncheckedUpdateWithoutTrainingsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTrainingsInput, UserUncheckedCreateWithoutCreatedTrainingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTrainingsInput
    upsert?: UserUpsertWithoutCreatedTrainingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTrainingsInput, UserUpdateWithoutCreatedTrainingsInput>, UserUncheckedUpdateWithoutCreatedTrainingsInput>
  }

  export type TrainingSessionUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingSessionCreateWithoutTrainingInput, TrainingSessionUncheckedCreateWithoutTrainingInput> | TrainingSessionCreateWithoutTrainingInput[] | TrainingSessionUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutTrainingInput | TrainingSessionCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingSessionUpsertWithWhereUniqueWithoutTrainingInput | TrainingSessionUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingSessionCreateManyTrainingInputEnvelope
    set?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    disconnect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    delete?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    connect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    update?: TrainingSessionUpdateWithWhereUniqueWithoutTrainingInput | TrainingSessionUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingSessionUpdateManyWithWhereWithoutTrainingInput | TrainingSessionUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingSessionScalarWhereInput | TrainingSessionScalarWhereInput[]
  }

  export type TrainingDocumentUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingDocumentCreateWithoutTrainingInput, TrainingDocumentUncheckedCreateWithoutTrainingInput> | TrainingDocumentCreateWithoutTrainingInput[] | TrainingDocumentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutTrainingInput | TrainingDocumentCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingDocumentUpsertWithWhereUniqueWithoutTrainingInput | TrainingDocumentUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingDocumentCreateManyTrainingInputEnvelope
    set?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    disconnect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    delete?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    update?: TrainingDocumentUpdateWithWhereUniqueWithoutTrainingInput | TrainingDocumentUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingDocumentUpdateManyWithWhereWithoutTrainingInput | TrainingDocumentUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<AttendanceCreateWithoutTrainingInput, AttendanceUncheckedCreateWithoutTrainingInput> | AttendanceCreateWithoutTrainingInput[] | AttendanceUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTrainingInput | AttendanceCreateOrConnectWithoutTrainingInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutTrainingInput | AttendanceUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: AttendanceCreateManyTrainingInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutTrainingInput | AttendanceUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutTrainingInput | AttendanceUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TrainingParticipantUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingParticipantCreateWithoutTrainingInput, TrainingParticipantUncheckedCreateWithoutTrainingInput> | TrainingParticipantCreateWithoutTrainingInput[] | TrainingParticipantUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutTrainingInput | TrainingParticipantCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingParticipantUpsertWithWhereUniqueWithoutTrainingInput | TrainingParticipantUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingParticipantCreateManyTrainingInputEnvelope
    set?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    disconnect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    delete?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    update?: TrainingParticipantUpdateWithWhereUniqueWithoutTrainingInput | TrainingParticipantUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingParticipantUpdateManyWithWhereWithoutTrainingInput | TrainingParticipantUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingParticipantScalarWhereInput | TrainingParticipantScalarWhereInput[]
  }

  export type TrainingPhotoUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingPhotoCreateWithoutTrainingInput, TrainingPhotoUncheckedCreateWithoutTrainingInput> | TrainingPhotoCreateWithoutTrainingInput[] | TrainingPhotoUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutTrainingInput | TrainingPhotoCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingPhotoUpsertWithWhereUniqueWithoutTrainingInput | TrainingPhotoUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingPhotoCreateManyTrainingInputEnvelope
    set?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    disconnect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    delete?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    update?: TrainingPhotoUpdateWithWhereUniqueWithoutTrainingInput | TrainingPhotoUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingPhotoUpdateManyWithWhereWithoutTrainingInput | TrainingPhotoUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingPhotoScalarWhereInput | TrainingPhotoScalarWhereInput[]
  }

  export type TrainingFeedbackUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingFeedbackCreateWithoutTrainingInput, TrainingFeedbackUncheckedCreateWithoutTrainingInput> | TrainingFeedbackCreateWithoutTrainingInput[] | TrainingFeedbackUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutTrainingInput | TrainingFeedbackCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingFeedbackUpsertWithWhereUniqueWithoutTrainingInput | TrainingFeedbackUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingFeedbackCreateManyTrainingInputEnvelope
    set?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    disconnect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    delete?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    update?: TrainingFeedbackUpdateWithWhereUniqueWithoutTrainingInput | TrainingFeedbackUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingFeedbackUpdateManyWithWhereWithoutTrainingInput | TrainingFeedbackUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingFeedbackScalarWhereInput | TrainingFeedbackScalarWhereInput[]
  }

  export type TrainingFollowupUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingFollowupCreateWithoutTrainingInput, TrainingFollowupUncheckedCreateWithoutTrainingInput> | TrainingFollowupCreateWithoutTrainingInput[] | TrainingFollowupUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutTrainingInput | TrainingFollowupCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingFollowupUpsertWithWhereUniqueWithoutTrainingInput | TrainingFollowupUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingFollowupCreateManyTrainingInputEnvelope
    set?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    disconnect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    delete?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    update?: TrainingFollowupUpdateWithWhereUniqueWithoutTrainingInput | TrainingFollowupUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingFollowupUpdateManyWithWhereWithoutTrainingInput | TrainingFollowupUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
  }

  export type TrainingNotificationUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingNotificationCreateWithoutTrainingInput, TrainingNotificationUncheckedCreateWithoutTrainingInput> | TrainingNotificationCreateWithoutTrainingInput[] | TrainingNotificationUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutTrainingInput | TrainingNotificationCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingNotificationUpsertWithWhereUniqueWithoutTrainingInput | TrainingNotificationUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingNotificationCreateManyTrainingInputEnvelope
    set?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    disconnect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    delete?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    update?: TrainingNotificationUpdateWithWhereUniqueWithoutTrainingInput | TrainingNotificationUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingNotificationUpdateManyWithWhereWithoutTrainingInput | TrainingNotificationUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingNotificationScalarWhereInput | TrainingNotificationScalarWhereInput[]
  }

  export type TrainingInviteTokenUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingInviteTokenCreateWithoutTrainingInput, TrainingInviteTokenUncheckedCreateWithoutTrainingInput> | TrainingInviteTokenCreateWithoutTrainingInput[] | TrainingInviteTokenUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingInviteTokenCreateOrConnectWithoutTrainingInput | TrainingInviteTokenCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingInviteTokenUpsertWithWhereUniqueWithoutTrainingInput | TrainingInviteTokenUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingInviteTokenCreateManyTrainingInputEnvelope
    set?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    disconnect?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    delete?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    connect?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    update?: TrainingInviteTokenUpdateWithWhereUniqueWithoutTrainingInput | TrainingInviteTokenUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingInviteTokenUpdateManyWithWhereWithoutTrainingInput | TrainingInviteTokenUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingInviteTokenScalarWhereInput | TrainingInviteTokenScalarWhereInput[]
  }

  export type FeedbackFormUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<FeedbackFormCreateWithoutTrainingInput, FeedbackFormUncheckedCreateWithoutTrainingInput> | FeedbackFormCreateWithoutTrainingInput[] | FeedbackFormUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutTrainingInput | FeedbackFormCreateOrConnectWithoutTrainingInput[]
    upsert?: FeedbackFormUpsertWithWhereUniqueWithoutTrainingInput | FeedbackFormUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: FeedbackFormCreateManyTrainingInputEnvelope
    set?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    disconnect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    delete?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    update?: FeedbackFormUpdateWithWhereUniqueWithoutTrainingInput | FeedbackFormUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: FeedbackFormUpdateManyWithWhereWithoutTrainingInput | FeedbackFormUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: FeedbackFormScalarWhereInput | FeedbackFormScalarWhereInput[]
  }

  export type TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingSessionCreateWithoutTrainingInput, TrainingSessionUncheckedCreateWithoutTrainingInput> | TrainingSessionCreateWithoutTrainingInput[] | TrainingSessionUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutTrainingInput | TrainingSessionCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingSessionUpsertWithWhereUniqueWithoutTrainingInput | TrainingSessionUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingSessionCreateManyTrainingInputEnvelope
    set?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    disconnect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    delete?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    connect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    update?: TrainingSessionUpdateWithWhereUniqueWithoutTrainingInput | TrainingSessionUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingSessionUpdateManyWithWhereWithoutTrainingInput | TrainingSessionUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingSessionScalarWhereInput | TrainingSessionScalarWhereInput[]
  }

  export type TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingDocumentCreateWithoutTrainingInput, TrainingDocumentUncheckedCreateWithoutTrainingInput> | TrainingDocumentCreateWithoutTrainingInput[] | TrainingDocumentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutTrainingInput | TrainingDocumentCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingDocumentUpsertWithWhereUniqueWithoutTrainingInput | TrainingDocumentUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingDocumentCreateManyTrainingInputEnvelope
    set?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    disconnect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    delete?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    update?: TrainingDocumentUpdateWithWhereUniqueWithoutTrainingInput | TrainingDocumentUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingDocumentUpdateManyWithWhereWithoutTrainingInput | TrainingDocumentUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<AttendanceCreateWithoutTrainingInput, AttendanceUncheckedCreateWithoutTrainingInput> | AttendanceCreateWithoutTrainingInput[] | AttendanceUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTrainingInput | AttendanceCreateOrConnectWithoutTrainingInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutTrainingInput | AttendanceUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: AttendanceCreateManyTrainingInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutTrainingInput | AttendanceUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutTrainingInput | AttendanceUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingParticipantCreateWithoutTrainingInput, TrainingParticipantUncheckedCreateWithoutTrainingInput> | TrainingParticipantCreateWithoutTrainingInput[] | TrainingParticipantUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutTrainingInput | TrainingParticipantCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingParticipantUpsertWithWhereUniqueWithoutTrainingInput | TrainingParticipantUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingParticipantCreateManyTrainingInputEnvelope
    set?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    disconnect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    delete?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    update?: TrainingParticipantUpdateWithWhereUniqueWithoutTrainingInput | TrainingParticipantUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingParticipantUpdateManyWithWhereWithoutTrainingInput | TrainingParticipantUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingParticipantScalarWhereInput | TrainingParticipantScalarWhereInput[]
  }

  export type TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingPhotoCreateWithoutTrainingInput, TrainingPhotoUncheckedCreateWithoutTrainingInput> | TrainingPhotoCreateWithoutTrainingInput[] | TrainingPhotoUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutTrainingInput | TrainingPhotoCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingPhotoUpsertWithWhereUniqueWithoutTrainingInput | TrainingPhotoUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingPhotoCreateManyTrainingInputEnvelope
    set?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    disconnect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    delete?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    update?: TrainingPhotoUpdateWithWhereUniqueWithoutTrainingInput | TrainingPhotoUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingPhotoUpdateManyWithWhereWithoutTrainingInput | TrainingPhotoUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingPhotoScalarWhereInput | TrainingPhotoScalarWhereInput[]
  }

  export type TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingFeedbackCreateWithoutTrainingInput, TrainingFeedbackUncheckedCreateWithoutTrainingInput> | TrainingFeedbackCreateWithoutTrainingInput[] | TrainingFeedbackUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutTrainingInput | TrainingFeedbackCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingFeedbackUpsertWithWhereUniqueWithoutTrainingInput | TrainingFeedbackUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingFeedbackCreateManyTrainingInputEnvelope
    set?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    disconnect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    delete?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    update?: TrainingFeedbackUpdateWithWhereUniqueWithoutTrainingInput | TrainingFeedbackUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingFeedbackUpdateManyWithWhereWithoutTrainingInput | TrainingFeedbackUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingFeedbackScalarWhereInput | TrainingFeedbackScalarWhereInput[]
  }

  export type TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingFollowupCreateWithoutTrainingInput, TrainingFollowupUncheckedCreateWithoutTrainingInput> | TrainingFollowupCreateWithoutTrainingInput[] | TrainingFollowupUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutTrainingInput | TrainingFollowupCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingFollowupUpsertWithWhereUniqueWithoutTrainingInput | TrainingFollowupUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingFollowupCreateManyTrainingInputEnvelope
    set?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    disconnect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    delete?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    update?: TrainingFollowupUpdateWithWhereUniqueWithoutTrainingInput | TrainingFollowupUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingFollowupUpdateManyWithWhereWithoutTrainingInput | TrainingFollowupUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
  }

  export type TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingNotificationCreateWithoutTrainingInput, TrainingNotificationUncheckedCreateWithoutTrainingInput> | TrainingNotificationCreateWithoutTrainingInput[] | TrainingNotificationUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutTrainingInput | TrainingNotificationCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingNotificationUpsertWithWhereUniqueWithoutTrainingInput | TrainingNotificationUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingNotificationCreateManyTrainingInputEnvelope
    set?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    disconnect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    delete?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    update?: TrainingNotificationUpdateWithWhereUniqueWithoutTrainingInput | TrainingNotificationUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingNotificationUpdateManyWithWhereWithoutTrainingInput | TrainingNotificationUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingNotificationScalarWhereInput | TrainingNotificationScalarWhereInput[]
  }

  export type TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingInviteTokenCreateWithoutTrainingInput, TrainingInviteTokenUncheckedCreateWithoutTrainingInput> | TrainingInviteTokenCreateWithoutTrainingInput[] | TrainingInviteTokenUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingInviteTokenCreateOrConnectWithoutTrainingInput | TrainingInviteTokenCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingInviteTokenUpsertWithWhereUniqueWithoutTrainingInput | TrainingInviteTokenUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingInviteTokenCreateManyTrainingInputEnvelope
    set?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    disconnect?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    delete?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    connect?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    update?: TrainingInviteTokenUpdateWithWhereUniqueWithoutTrainingInput | TrainingInviteTokenUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingInviteTokenUpdateManyWithWhereWithoutTrainingInput | TrainingInviteTokenUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingInviteTokenScalarWhereInput | TrainingInviteTokenScalarWhereInput[]
  }

  export type FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<FeedbackFormCreateWithoutTrainingInput, FeedbackFormUncheckedCreateWithoutTrainingInput> | FeedbackFormCreateWithoutTrainingInput[] | FeedbackFormUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutTrainingInput | FeedbackFormCreateOrConnectWithoutTrainingInput[]
    upsert?: FeedbackFormUpsertWithWhereUniqueWithoutTrainingInput | FeedbackFormUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: FeedbackFormCreateManyTrainingInputEnvelope
    set?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    disconnect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    delete?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    update?: FeedbackFormUpdateWithWhereUniqueWithoutTrainingInput | FeedbackFormUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: FeedbackFormUpdateManyWithWhereWithoutTrainingInput | FeedbackFormUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: FeedbackFormScalarWhereInput | FeedbackFormScalarWhereInput[]
  }

  export type TrainingCreateNestedOneWithoutSessionsInput = {
    create?: XOR<TrainingCreateWithoutSessionsInput, TrainingUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutSessionsInput
    connect?: TrainingWhereUniqueInput
  }

  export type AttendanceCreateNestedManyWithoutSessionInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type FeedbackFormCreateNestedManyWithoutSessionInput = {
    create?: XOR<FeedbackFormCreateWithoutSessionInput, FeedbackFormUncheckedCreateWithoutSessionInput> | FeedbackFormCreateWithoutSessionInput[] | FeedbackFormUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutSessionInput | FeedbackFormCreateOrConnectWithoutSessionInput[]
    createMany?: FeedbackFormCreateManySessionInputEnvelope
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
  }

  export type TrainingSessionPhotoCreateNestedManyWithoutSessionInput = {
    create?: XOR<TrainingSessionPhotoCreateWithoutSessionInput, TrainingSessionPhotoUncheckedCreateWithoutSessionInput> | TrainingSessionPhotoCreateWithoutSessionInput[] | TrainingSessionPhotoUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TrainingSessionPhotoCreateOrConnectWithoutSessionInput | TrainingSessionPhotoCreateOrConnectWithoutSessionInput[]
    createMany?: TrainingSessionPhotoCreateManySessionInputEnvelope
    connect?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type FeedbackFormUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<FeedbackFormCreateWithoutSessionInput, FeedbackFormUncheckedCreateWithoutSessionInput> | FeedbackFormCreateWithoutSessionInput[] | FeedbackFormUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutSessionInput | FeedbackFormCreateOrConnectWithoutSessionInput[]
    createMany?: FeedbackFormCreateManySessionInputEnvelope
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
  }

  export type TrainingSessionPhotoUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<TrainingSessionPhotoCreateWithoutSessionInput, TrainingSessionPhotoUncheckedCreateWithoutSessionInput> | TrainingSessionPhotoCreateWithoutSessionInput[] | TrainingSessionPhotoUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TrainingSessionPhotoCreateOrConnectWithoutSessionInput | TrainingSessionPhotoCreateOrConnectWithoutSessionInput[]
    createMany?: TrainingSessionPhotoCreateManySessionInputEnvelope
    connect?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
  }

  export type TrainingUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<TrainingCreateWithoutSessionsInput, TrainingUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutSessionsInput
    upsert?: TrainingUpsertWithoutSessionsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutSessionsInput, TrainingUpdateWithoutSessionsInput>, TrainingUncheckedUpdateWithoutSessionsInput>
  }

  export type AttendanceUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutSessionInput | AttendanceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutSessionInput | AttendanceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutSessionInput | AttendanceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type FeedbackFormUpdateManyWithoutSessionNestedInput = {
    create?: XOR<FeedbackFormCreateWithoutSessionInput, FeedbackFormUncheckedCreateWithoutSessionInput> | FeedbackFormCreateWithoutSessionInput[] | FeedbackFormUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutSessionInput | FeedbackFormCreateOrConnectWithoutSessionInput[]
    upsert?: FeedbackFormUpsertWithWhereUniqueWithoutSessionInput | FeedbackFormUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: FeedbackFormCreateManySessionInputEnvelope
    set?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    disconnect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    delete?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    update?: FeedbackFormUpdateWithWhereUniqueWithoutSessionInput | FeedbackFormUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: FeedbackFormUpdateManyWithWhereWithoutSessionInput | FeedbackFormUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: FeedbackFormScalarWhereInput | FeedbackFormScalarWhereInput[]
  }

  export type TrainingSessionPhotoUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TrainingSessionPhotoCreateWithoutSessionInput, TrainingSessionPhotoUncheckedCreateWithoutSessionInput> | TrainingSessionPhotoCreateWithoutSessionInput[] | TrainingSessionPhotoUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TrainingSessionPhotoCreateOrConnectWithoutSessionInput | TrainingSessionPhotoCreateOrConnectWithoutSessionInput[]
    upsert?: TrainingSessionPhotoUpsertWithWhereUniqueWithoutSessionInput | TrainingSessionPhotoUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TrainingSessionPhotoCreateManySessionInputEnvelope
    set?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    disconnect?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    delete?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    connect?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    update?: TrainingSessionPhotoUpdateWithWhereUniqueWithoutSessionInput | TrainingSessionPhotoUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TrainingSessionPhotoUpdateManyWithWhereWithoutSessionInput | TrainingSessionPhotoUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TrainingSessionPhotoScalarWhereInput | TrainingSessionPhotoScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutSessionInput | AttendanceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutSessionInput | AttendanceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutSessionInput | AttendanceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type FeedbackFormUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<FeedbackFormCreateWithoutSessionInput, FeedbackFormUncheckedCreateWithoutSessionInput> | FeedbackFormCreateWithoutSessionInput[] | FeedbackFormUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutSessionInput | FeedbackFormCreateOrConnectWithoutSessionInput[]
    upsert?: FeedbackFormUpsertWithWhereUniqueWithoutSessionInput | FeedbackFormUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: FeedbackFormCreateManySessionInputEnvelope
    set?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    disconnect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    delete?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    update?: FeedbackFormUpdateWithWhereUniqueWithoutSessionInput | FeedbackFormUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: FeedbackFormUpdateManyWithWhereWithoutSessionInput | FeedbackFormUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: FeedbackFormScalarWhereInput | FeedbackFormScalarWhereInput[]
  }

  export type TrainingSessionPhotoUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<TrainingSessionPhotoCreateWithoutSessionInput, TrainingSessionPhotoUncheckedCreateWithoutSessionInput> | TrainingSessionPhotoCreateWithoutSessionInput[] | TrainingSessionPhotoUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: TrainingSessionPhotoCreateOrConnectWithoutSessionInput | TrainingSessionPhotoCreateOrConnectWithoutSessionInput[]
    upsert?: TrainingSessionPhotoUpsertWithWhereUniqueWithoutSessionInput | TrainingSessionPhotoUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: TrainingSessionPhotoCreateManySessionInputEnvelope
    set?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    disconnect?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    delete?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    connect?: TrainingSessionPhotoWhereUniqueInput | TrainingSessionPhotoWhereUniqueInput[]
    update?: TrainingSessionPhotoUpdateWithWhereUniqueWithoutSessionInput | TrainingSessionPhotoUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: TrainingSessionPhotoUpdateManyWithWhereWithoutSessionInput | TrainingSessionPhotoUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: TrainingSessionPhotoScalarWhereInput | TrainingSessionPhotoScalarWhereInput[]
  }

  export type TrainingCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<TrainingCreateWithoutDocumentsInput, TrainingUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutDocumentsInput
    connect?: TrainingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedDocumentsInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type TrainingUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<TrainingCreateWithoutDocumentsInput, TrainingUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutDocumentsInput
    upsert?: TrainingUpsertWithoutDocumentsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutDocumentsInput, TrainingUpdateWithoutDocumentsInput>, TrainingUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    upsert?: UserUpsertWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedDocumentsInput, UserUpdateWithoutUploadedDocumentsInput>, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type TrainingParticipantCreateNestedManyWithoutParticipantInput = {
    create?: XOR<TrainingParticipantCreateWithoutParticipantInput, TrainingParticipantUncheckedCreateWithoutParticipantInput> | TrainingParticipantCreateWithoutParticipantInput[] | TrainingParticipantUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutParticipantInput | TrainingParticipantCreateOrConnectWithoutParticipantInput[]
    createMany?: TrainingParticipantCreateManyParticipantInputEnvelope
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutParticipantInput = {
    create?: XOR<AttendanceCreateWithoutParticipantInput, AttendanceUncheckedCreateWithoutParticipantInput> | AttendanceCreateWithoutParticipantInput[] | AttendanceUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutParticipantInput | AttendanceCreateOrConnectWithoutParticipantInput[]
    createMany?: AttendanceCreateManyParticipantInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type TrainingFeedbackCreateNestedManyWithoutParticipantInput = {
    create?: XOR<TrainingFeedbackCreateWithoutParticipantInput, TrainingFeedbackUncheckedCreateWithoutParticipantInput> | TrainingFeedbackCreateWithoutParticipantInput[] | TrainingFeedbackUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutParticipantInput | TrainingFeedbackCreateOrConnectWithoutParticipantInput[]
    createMany?: TrainingFeedbackCreateManyParticipantInputEnvelope
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
  }

  export type TrainingInviteTokenCreateNestedManyWithoutParticipantInput = {
    create?: XOR<TrainingInviteTokenCreateWithoutParticipantInput, TrainingInviteTokenUncheckedCreateWithoutParticipantInput> | TrainingInviteTokenCreateWithoutParticipantInput[] | TrainingInviteTokenUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TrainingInviteTokenCreateOrConnectWithoutParticipantInput | TrainingInviteTokenCreateOrConnectWithoutParticipantInput[]
    createMany?: TrainingInviteTokenCreateManyParticipantInputEnvelope
    connect?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
  }

  export type FeedbackFormCreateNestedManyWithoutParticipantInput = {
    create?: XOR<FeedbackFormCreateWithoutParticipantInput, FeedbackFormUncheckedCreateWithoutParticipantInput> | FeedbackFormCreateWithoutParticipantInput[] | FeedbackFormUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutParticipantInput | FeedbackFormCreateOrConnectWithoutParticipantInput[]
    createMany?: FeedbackFormCreateManyParticipantInputEnvelope
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
  }

  export type TrainingParticipantUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<TrainingParticipantCreateWithoutParticipantInput, TrainingParticipantUncheckedCreateWithoutParticipantInput> | TrainingParticipantCreateWithoutParticipantInput[] | TrainingParticipantUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutParticipantInput | TrainingParticipantCreateOrConnectWithoutParticipantInput[]
    createMany?: TrainingParticipantCreateManyParticipantInputEnvelope
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<AttendanceCreateWithoutParticipantInput, AttendanceUncheckedCreateWithoutParticipantInput> | AttendanceCreateWithoutParticipantInput[] | AttendanceUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutParticipantInput | AttendanceCreateOrConnectWithoutParticipantInput[]
    createMany?: AttendanceCreateManyParticipantInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type TrainingFeedbackUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<TrainingFeedbackCreateWithoutParticipantInput, TrainingFeedbackUncheckedCreateWithoutParticipantInput> | TrainingFeedbackCreateWithoutParticipantInput[] | TrainingFeedbackUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutParticipantInput | TrainingFeedbackCreateOrConnectWithoutParticipantInput[]
    createMany?: TrainingFeedbackCreateManyParticipantInputEnvelope
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
  }

  export type TrainingInviteTokenUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<TrainingInviteTokenCreateWithoutParticipantInput, TrainingInviteTokenUncheckedCreateWithoutParticipantInput> | TrainingInviteTokenCreateWithoutParticipantInput[] | TrainingInviteTokenUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TrainingInviteTokenCreateOrConnectWithoutParticipantInput | TrainingInviteTokenCreateOrConnectWithoutParticipantInput[]
    createMany?: TrainingInviteTokenCreateManyParticipantInputEnvelope
    connect?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
  }

  export type FeedbackFormUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<FeedbackFormCreateWithoutParticipantInput, FeedbackFormUncheckedCreateWithoutParticipantInput> | FeedbackFormCreateWithoutParticipantInput[] | FeedbackFormUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutParticipantInput | FeedbackFormCreateOrConnectWithoutParticipantInput[]
    createMany?: FeedbackFormCreateManyParticipantInputEnvelope
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
  }

  export type TrainingParticipantUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<TrainingParticipantCreateWithoutParticipantInput, TrainingParticipantUncheckedCreateWithoutParticipantInput> | TrainingParticipantCreateWithoutParticipantInput[] | TrainingParticipantUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutParticipantInput | TrainingParticipantCreateOrConnectWithoutParticipantInput[]
    upsert?: TrainingParticipantUpsertWithWhereUniqueWithoutParticipantInput | TrainingParticipantUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: TrainingParticipantCreateManyParticipantInputEnvelope
    set?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    disconnect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    delete?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    update?: TrainingParticipantUpdateWithWhereUniqueWithoutParticipantInput | TrainingParticipantUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: TrainingParticipantUpdateManyWithWhereWithoutParticipantInput | TrainingParticipantUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: TrainingParticipantScalarWhereInput | TrainingParticipantScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<AttendanceCreateWithoutParticipantInput, AttendanceUncheckedCreateWithoutParticipantInput> | AttendanceCreateWithoutParticipantInput[] | AttendanceUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutParticipantInput | AttendanceCreateOrConnectWithoutParticipantInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutParticipantInput | AttendanceUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: AttendanceCreateManyParticipantInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutParticipantInput | AttendanceUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutParticipantInput | AttendanceUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TrainingFeedbackUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<TrainingFeedbackCreateWithoutParticipantInput, TrainingFeedbackUncheckedCreateWithoutParticipantInput> | TrainingFeedbackCreateWithoutParticipantInput[] | TrainingFeedbackUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutParticipantInput | TrainingFeedbackCreateOrConnectWithoutParticipantInput[]
    upsert?: TrainingFeedbackUpsertWithWhereUniqueWithoutParticipantInput | TrainingFeedbackUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: TrainingFeedbackCreateManyParticipantInputEnvelope
    set?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    disconnect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    delete?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    update?: TrainingFeedbackUpdateWithWhereUniqueWithoutParticipantInput | TrainingFeedbackUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: TrainingFeedbackUpdateManyWithWhereWithoutParticipantInput | TrainingFeedbackUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: TrainingFeedbackScalarWhereInput | TrainingFeedbackScalarWhereInput[]
  }

  export type TrainingInviteTokenUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<TrainingInviteTokenCreateWithoutParticipantInput, TrainingInviteTokenUncheckedCreateWithoutParticipantInput> | TrainingInviteTokenCreateWithoutParticipantInput[] | TrainingInviteTokenUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TrainingInviteTokenCreateOrConnectWithoutParticipantInput | TrainingInviteTokenCreateOrConnectWithoutParticipantInput[]
    upsert?: TrainingInviteTokenUpsertWithWhereUniqueWithoutParticipantInput | TrainingInviteTokenUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: TrainingInviteTokenCreateManyParticipantInputEnvelope
    set?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    disconnect?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    delete?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    connect?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    update?: TrainingInviteTokenUpdateWithWhereUniqueWithoutParticipantInput | TrainingInviteTokenUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: TrainingInviteTokenUpdateManyWithWhereWithoutParticipantInput | TrainingInviteTokenUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: TrainingInviteTokenScalarWhereInput | TrainingInviteTokenScalarWhereInput[]
  }

  export type FeedbackFormUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<FeedbackFormCreateWithoutParticipantInput, FeedbackFormUncheckedCreateWithoutParticipantInput> | FeedbackFormCreateWithoutParticipantInput[] | FeedbackFormUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutParticipantInput | FeedbackFormCreateOrConnectWithoutParticipantInput[]
    upsert?: FeedbackFormUpsertWithWhereUniqueWithoutParticipantInput | FeedbackFormUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: FeedbackFormCreateManyParticipantInputEnvelope
    set?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    disconnect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    delete?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    update?: FeedbackFormUpdateWithWhereUniqueWithoutParticipantInput | FeedbackFormUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: FeedbackFormUpdateManyWithWhereWithoutParticipantInput | FeedbackFormUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: FeedbackFormScalarWhereInput | FeedbackFormScalarWhereInput[]
  }

  export type TrainingParticipantUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<TrainingParticipantCreateWithoutParticipantInput, TrainingParticipantUncheckedCreateWithoutParticipantInput> | TrainingParticipantCreateWithoutParticipantInput[] | TrainingParticipantUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutParticipantInput | TrainingParticipantCreateOrConnectWithoutParticipantInput[]
    upsert?: TrainingParticipantUpsertWithWhereUniqueWithoutParticipantInput | TrainingParticipantUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: TrainingParticipantCreateManyParticipantInputEnvelope
    set?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    disconnect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    delete?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    update?: TrainingParticipantUpdateWithWhereUniqueWithoutParticipantInput | TrainingParticipantUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: TrainingParticipantUpdateManyWithWhereWithoutParticipantInput | TrainingParticipantUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: TrainingParticipantScalarWhereInput | TrainingParticipantScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<AttendanceCreateWithoutParticipantInput, AttendanceUncheckedCreateWithoutParticipantInput> | AttendanceCreateWithoutParticipantInput[] | AttendanceUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutParticipantInput | AttendanceCreateOrConnectWithoutParticipantInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutParticipantInput | AttendanceUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: AttendanceCreateManyParticipantInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutParticipantInput | AttendanceUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutParticipantInput | AttendanceUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TrainingFeedbackUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<TrainingFeedbackCreateWithoutParticipantInput, TrainingFeedbackUncheckedCreateWithoutParticipantInput> | TrainingFeedbackCreateWithoutParticipantInput[] | TrainingFeedbackUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutParticipantInput | TrainingFeedbackCreateOrConnectWithoutParticipantInput[]
    upsert?: TrainingFeedbackUpsertWithWhereUniqueWithoutParticipantInput | TrainingFeedbackUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: TrainingFeedbackCreateManyParticipantInputEnvelope
    set?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    disconnect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    delete?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    update?: TrainingFeedbackUpdateWithWhereUniqueWithoutParticipantInput | TrainingFeedbackUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: TrainingFeedbackUpdateManyWithWhereWithoutParticipantInput | TrainingFeedbackUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: TrainingFeedbackScalarWhereInput | TrainingFeedbackScalarWhereInput[]
  }

  export type TrainingInviteTokenUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<TrainingInviteTokenCreateWithoutParticipantInput, TrainingInviteTokenUncheckedCreateWithoutParticipantInput> | TrainingInviteTokenCreateWithoutParticipantInput[] | TrainingInviteTokenUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TrainingInviteTokenCreateOrConnectWithoutParticipantInput | TrainingInviteTokenCreateOrConnectWithoutParticipantInput[]
    upsert?: TrainingInviteTokenUpsertWithWhereUniqueWithoutParticipantInput | TrainingInviteTokenUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: TrainingInviteTokenCreateManyParticipantInputEnvelope
    set?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    disconnect?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    delete?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    connect?: TrainingInviteTokenWhereUniqueInput | TrainingInviteTokenWhereUniqueInput[]
    update?: TrainingInviteTokenUpdateWithWhereUniqueWithoutParticipantInput | TrainingInviteTokenUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: TrainingInviteTokenUpdateManyWithWhereWithoutParticipantInput | TrainingInviteTokenUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: TrainingInviteTokenScalarWhereInput | TrainingInviteTokenScalarWhereInput[]
  }

  export type FeedbackFormUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<FeedbackFormCreateWithoutParticipantInput, FeedbackFormUncheckedCreateWithoutParticipantInput> | FeedbackFormCreateWithoutParticipantInput[] | FeedbackFormUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: FeedbackFormCreateOrConnectWithoutParticipantInput | FeedbackFormCreateOrConnectWithoutParticipantInput[]
    upsert?: FeedbackFormUpsertWithWhereUniqueWithoutParticipantInput | FeedbackFormUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: FeedbackFormCreateManyParticipantInputEnvelope
    set?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    disconnect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    delete?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    connect?: FeedbackFormWhereUniqueInput | FeedbackFormWhereUniqueInput[]
    update?: FeedbackFormUpdateWithWhereUniqueWithoutParticipantInput | FeedbackFormUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: FeedbackFormUpdateManyWithWhereWithoutParticipantInput | FeedbackFormUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: FeedbackFormScalarWhereInput | FeedbackFormScalarWhereInput[]
  }

  export type TrainingCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<TrainingCreateWithoutParticipantsInput, TrainingUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutParticipantsInput
    connect?: TrainingWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutTrainingsInput = {
    create?: XOR<ParticipantCreateWithoutTrainingsInput, ParticipantUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutTrainingsInput
    connect?: ParticipantWhereUniqueInput
  }

  export type TrainingUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<TrainingCreateWithoutParticipantsInput, TrainingUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutParticipantsInput
    upsert?: TrainingUpsertWithoutParticipantsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutParticipantsInput, TrainingUpdateWithoutParticipantsInput>, TrainingUncheckedUpdateWithoutParticipantsInput>
  }

  export type ParticipantUpdateOneRequiredWithoutTrainingsNestedInput = {
    create?: XOR<ParticipantCreateWithoutTrainingsInput, ParticipantUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutTrainingsInput
    upsert?: ParticipantUpsertWithoutTrainingsInput
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutTrainingsInput, ParticipantUpdateWithoutTrainingsInput>, ParticipantUncheckedUpdateWithoutTrainingsInput>
  }

  export type TrainingCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<TrainingCreateWithoutAttendanceInput, TrainingUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutAttendanceInput
    connect?: TrainingWhereUniqueInput
  }

  export type TrainingSessionCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<TrainingSessionCreateWithoutAttendanceInput, TrainingSessionUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutAttendanceInput
    connect?: TrainingSessionWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<ParticipantCreateWithoutAttendancesInput, ParticipantUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutAttendancesInput
    connect?: ParticipantWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type TrainingUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<TrainingCreateWithoutAttendanceInput, TrainingUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutAttendanceInput
    upsert?: TrainingUpsertWithoutAttendanceInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutAttendanceInput, TrainingUpdateWithoutAttendanceInput>, TrainingUncheckedUpdateWithoutAttendanceInput>
  }

  export type TrainingSessionUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<TrainingSessionCreateWithoutAttendanceInput, TrainingSessionUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutAttendanceInput
    upsert?: TrainingSessionUpsertWithoutAttendanceInput
    connect?: TrainingSessionWhereUniqueInput
    update?: XOR<XOR<TrainingSessionUpdateToOneWithWhereWithoutAttendanceInput, TrainingSessionUpdateWithoutAttendanceInput>, TrainingSessionUncheckedUpdateWithoutAttendanceInput>
  }

  export type ParticipantUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<ParticipantCreateWithoutAttendancesInput, ParticipantUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutAttendancesInput
    upsert?: ParticipantUpsertWithoutAttendancesInput
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutAttendancesInput, ParticipantUpdateWithoutAttendancesInput>, ParticipantUncheckedUpdateWithoutAttendancesInput>
  }

  export type TrainingCreateNestedOneWithoutPhotosInput = {
    create?: XOR<TrainingCreateWithoutPhotosInput, TrainingUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutPhotosInput
    connect?: TrainingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedPhotosInput = {
    create?: XOR<UserCreateWithoutUploadedPhotosInput, UserUncheckedCreateWithoutUploadedPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedPhotosInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<TrainingCreateWithoutPhotosInput, TrainingUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutPhotosInput
    upsert?: TrainingUpsertWithoutPhotosInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutPhotosInput, TrainingUpdateWithoutPhotosInput>, TrainingUncheckedUpdateWithoutPhotosInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedPhotosNestedInput = {
    create?: XOR<UserCreateWithoutUploadedPhotosInput, UserUncheckedCreateWithoutUploadedPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedPhotosInput
    upsert?: UserUpsertWithoutUploadedPhotosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedPhotosInput, UserUpdateWithoutUploadedPhotosInput>, UserUncheckedUpdateWithoutUploadedPhotosInput>
  }

  export type TrainingCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<TrainingCreateWithoutFeedbackInput, TrainingUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutFeedbackInput
    connect?: TrainingWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<ParticipantCreateWithoutFeedbacksInput, ParticipantUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutFeedbacksInput
    connect?: ParticipantWhereUniqueInput
  }

  export type TrainingUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<TrainingCreateWithoutFeedbackInput, TrainingUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutFeedbackInput
    upsert?: TrainingUpsertWithoutFeedbackInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutFeedbackInput, TrainingUpdateWithoutFeedbackInput>, TrainingUncheckedUpdateWithoutFeedbackInput>
  }

  export type ParticipantUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<ParticipantCreateWithoutFeedbacksInput, ParticipantUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutFeedbacksInput
    upsert?: ParticipantUpsertWithoutFeedbacksInput
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutFeedbacksInput, ParticipantUpdateWithoutFeedbacksInput>, ParticipantUncheckedUpdateWithoutFeedbacksInput>
  }

  export type TrainingCreateNestedOneWithoutFeedbackFormsInput = {
    create?: XOR<TrainingCreateWithoutFeedbackFormsInput, TrainingUncheckedCreateWithoutFeedbackFormsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutFeedbackFormsInput
    connect?: TrainingWhereUniqueInput
  }

  export type TrainingSessionCreateNestedOneWithoutFeedbackFormsInput = {
    create?: XOR<TrainingSessionCreateWithoutFeedbackFormsInput, TrainingSessionUncheckedCreateWithoutFeedbackFormsInput>
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutFeedbackFormsInput
    connect?: TrainingSessionWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutFeedbackFormsInput = {
    create?: XOR<ParticipantCreateWithoutFeedbackFormsInput, ParticipantUncheckedCreateWithoutFeedbackFormsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutFeedbackFormsInput
    connect?: ParticipantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedFeedbackFormsInput = {
    create?: XOR<UserCreateWithoutUploadedFeedbackFormsInput, UserUncheckedCreateWithoutUploadedFeedbackFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedFeedbackFormsInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingUpdateOneRequiredWithoutFeedbackFormsNestedInput = {
    create?: XOR<TrainingCreateWithoutFeedbackFormsInput, TrainingUncheckedCreateWithoutFeedbackFormsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutFeedbackFormsInput
    upsert?: TrainingUpsertWithoutFeedbackFormsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutFeedbackFormsInput, TrainingUpdateWithoutFeedbackFormsInput>, TrainingUncheckedUpdateWithoutFeedbackFormsInput>
  }

  export type TrainingSessionUpdateOneRequiredWithoutFeedbackFormsNestedInput = {
    create?: XOR<TrainingSessionCreateWithoutFeedbackFormsInput, TrainingSessionUncheckedCreateWithoutFeedbackFormsInput>
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutFeedbackFormsInput
    upsert?: TrainingSessionUpsertWithoutFeedbackFormsInput
    connect?: TrainingSessionWhereUniqueInput
    update?: XOR<XOR<TrainingSessionUpdateToOneWithWhereWithoutFeedbackFormsInput, TrainingSessionUpdateWithoutFeedbackFormsInput>, TrainingSessionUncheckedUpdateWithoutFeedbackFormsInput>
  }

  export type ParticipantUpdateOneRequiredWithoutFeedbackFormsNestedInput = {
    create?: XOR<ParticipantCreateWithoutFeedbackFormsInput, ParticipantUncheckedCreateWithoutFeedbackFormsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutFeedbackFormsInput
    upsert?: ParticipantUpsertWithoutFeedbackFormsInput
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutFeedbackFormsInput, ParticipantUpdateWithoutFeedbackFormsInput>, ParticipantUncheckedUpdateWithoutFeedbackFormsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedFeedbackFormsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedFeedbackFormsInput, UserUncheckedCreateWithoutUploadedFeedbackFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedFeedbackFormsInput
    upsert?: UserUpsertWithoutUploadedFeedbackFormsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedFeedbackFormsInput, UserUpdateWithoutUploadedFeedbackFormsInput>, UserUncheckedUpdateWithoutUploadedFeedbackFormsInput>
  }

  export type TrainingCreateNestedOneWithoutFollowupsInput = {
    create?: XOR<TrainingCreateWithoutFollowupsInput, TrainingUncheckedCreateWithoutFollowupsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutFollowupsInput
    connect?: TrainingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedFollowupsInput = {
    create?: XOR<UserCreateWithoutAssignedFollowupsInput, UserUncheckedCreateWithoutAssignedFollowupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedFollowupsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedFollowupsInput = {
    create?: XOR<UserCreateWithoutCreatedFollowupsInput, UserUncheckedCreateWithoutCreatedFollowupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFollowupsInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingUpdateOneRequiredWithoutFollowupsNestedInput = {
    create?: XOR<TrainingCreateWithoutFollowupsInput, TrainingUncheckedCreateWithoutFollowupsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutFollowupsInput
    upsert?: TrainingUpsertWithoutFollowupsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutFollowupsInput, TrainingUpdateWithoutFollowupsInput>, TrainingUncheckedUpdateWithoutFollowupsInput>
  }

  export type UserUpdateOneRequiredWithoutAssignedFollowupsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedFollowupsInput, UserUncheckedCreateWithoutAssignedFollowupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedFollowupsInput
    upsert?: UserUpsertWithoutAssignedFollowupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedFollowupsInput, UserUpdateWithoutAssignedFollowupsInput>, UserUncheckedUpdateWithoutAssignedFollowupsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedFollowupsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedFollowupsInput, UserUncheckedCreateWithoutCreatedFollowupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFollowupsInput
    upsert?: UserUpsertWithoutCreatedFollowupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedFollowupsInput, UserUpdateWithoutCreatedFollowupsInput>, UserUncheckedUpdateWithoutCreatedFollowupsInput>
  }

  export type TrainingCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<TrainingCreateWithoutNotificationsInput, TrainingUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutNotificationsInput
    connect?: TrainingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTrainingNotificationsInput = {
    create?: XOR<UserCreateWithoutTrainingNotificationsInput, UserUncheckedCreateWithoutTrainingNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<TrainingCreateWithoutNotificationsInput, TrainingUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutNotificationsInput
    upsert?: TrainingUpsertWithoutNotificationsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutNotificationsInput, TrainingUpdateWithoutNotificationsInput>, TrainingUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutTrainingNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutTrainingNotificationsInput, UserUncheckedCreateWithoutTrainingNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingNotificationsInput
    upsert?: UserUpsertWithoutTrainingNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrainingNotificationsInput, UserUpdateWithoutTrainingNotificationsInput>, UserUncheckedUpdateWithoutTrainingNotificationsInput>
  }

  export type TrainingCreateNestedOneWithoutInviteTokensInput = {
    create?: XOR<TrainingCreateWithoutInviteTokensInput, TrainingUncheckedCreateWithoutInviteTokensInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutInviteTokensInput
    connect?: TrainingWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutInviteTokensInput = {
    create?: XOR<ParticipantCreateWithoutInviteTokensInput, ParticipantUncheckedCreateWithoutInviteTokensInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutInviteTokensInput
    connect?: ParticipantWhereUniqueInput
  }

  export type TrainingUpdateOneRequiredWithoutInviteTokensNestedInput = {
    create?: XOR<TrainingCreateWithoutInviteTokensInput, TrainingUncheckedCreateWithoutInviteTokensInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutInviteTokensInput
    upsert?: TrainingUpsertWithoutInviteTokensInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutInviteTokensInput, TrainingUpdateWithoutInviteTokensInput>, TrainingUncheckedUpdateWithoutInviteTokensInput>
  }

  export type ParticipantUpdateOneWithoutInviteTokensNestedInput = {
    create?: XOR<ParticipantCreateWithoutInviteTokensInput, ParticipantUncheckedCreateWithoutInviteTokensInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutInviteTokensInput
    upsert?: ParticipantUpsertWithoutInviteTokensInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutInviteTokensInput, ParticipantUpdateWithoutInviteTokensInput>, ParticipantUncheckedUpdateWithoutInviteTokensInput>
  }

  export type TrainingSessionCreateNestedOneWithoutPhotosInput = {
    create?: XOR<TrainingSessionCreateWithoutPhotosInput, TrainingSessionUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutPhotosInput
    connect?: TrainingSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedSessionPhotosInput = {
    create?: XOR<UserCreateWithoutUploadedSessionPhotosInput, UserUncheckedCreateWithoutUploadedSessionPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedSessionPhotosInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingSessionUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<TrainingSessionCreateWithoutPhotosInput, TrainingSessionUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutPhotosInput
    upsert?: TrainingSessionUpsertWithoutPhotosInput
    connect?: TrainingSessionWhereUniqueInput
    update?: XOR<XOR<TrainingSessionUpdateToOneWithWhereWithoutPhotosInput, TrainingSessionUpdateWithoutPhotosInput>, TrainingSessionUncheckedUpdateWithoutPhotosInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedSessionPhotosNestedInput = {
    create?: XOR<UserCreateWithoutUploadedSessionPhotosInput, UserUncheckedCreateWithoutUploadedSessionPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedSessionPhotosInput
    upsert?: UserUpsertWithoutUploadedSessionPhotosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedSessionPhotosInput, UserUpdateWithoutUploadedSessionPhotosInput>, UserUncheckedUpdateWithoutUploadedSessionPhotosInput>
  }

  export type UserCreateNestedOneWithoutAuditorProfileInput = {
    create?: XOR<UserCreateWithoutAuditorProfileInput, UserUncheckedCreateWithoutAuditorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditorProfileInput
    connect?: UserWhereUniqueInput
  }

  export type AuditCreateNestedManyWithoutAuditorInput = {
    create?: XOR<AuditCreateWithoutAuditorInput, AuditUncheckedCreateWithoutAuditorInput> | AuditCreateWithoutAuditorInput[] | AuditUncheckedCreateWithoutAuditorInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutAuditorInput | AuditCreateOrConnectWithoutAuditorInput[]
    createMany?: AuditCreateManyAuditorInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type AuditUncheckedCreateNestedManyWithoutAuditorInput = {
    create?: XOR<AuditCreateWithoutAuditorInput, AuditUncheckedCreateWithoutAuditorInput> | AuditCreateWithoutAuditorInput[] | AuditUncheckedCreateWithoutAuditorInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutAuditorInput | AuditCreateOrConnectWithoutAuditorInput[]
    createMany?: AuditCreateManyAuditorInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutAuditorProfileNestedInput = {
    create?: XOR<UserCreateWithoutAuditorProfileInput, UserUncheckedCreateWithoutAuditorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditorProfileInput
    upsert?: UserUpsertWithoutAuditorProfileInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditorProfileInput, UserUpdateWithoutAuditorProfileInput>, UserUncheckedUpdateWithoutAuditorProfileInput>
  }

  export type AuditUpdateManyWithoutAuditorNestedInput = {
    create?: XOR<AuditCreateWithoutAuditorInput, AuditUncheckedCreateWithoutAuditorInput> | AuditCreateWithoutAuditorInput[] | AuditUncheckedCreateWithoutAuditorInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutAuditorInput | AuditCreateOrConnectWithoutAuditorInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutAuditorInput | AuditUpsertWithWhereUniqueWithoutAuditorInput[]
    createMany?: AuditCreateManyAuditorInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutAuditorInput | AuditUpdateWithWhereUniqueWithoutAuditorInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutAuditorInput | AuditUpdateManyWithWhereWithoutAuditorInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type AuditUncheckedUpdateManyWithoutAuditorNestedInput = {
    create?: XOR<AuditCreateWithoutAuditorInput, AuditUncheckedCreateWithoutAuditorInput> | AuditCreateWithoutAuditorInput[] | AuditUncheckedCreateWithoutAuditorInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutAuditorInput | AuditCreateOrConnectWithoutAuditorInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutAuditorInput | AuditUpsertWithWhereUniqueWithoutAuditorInput[]
    createMany?: AuditCreateManyAuditorInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutAuditorInput | AuditUpdateWithWhereUniqueWithoutAuditorInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutAuditorInput | AuditUpdateManyWithWhereWithoutAuditorInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type AuditorCreateNestedOneWithoutAuditsInput = {
    create?: XOR<AuditorCreateWithoutAuditsInput, AuditorUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: AuditorCreateOrConnectWithoutAuditsInput
    connect?: AuditorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditeeAuditsInput = {
    create?: XOR<UserCreateWithoutAuditeeAuditsInput, UserUncheckedCreateWithoutAuditeeAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditeeAuditsInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutAuditsInput = {
    create?: XOR<DepartmentCreateWithoutAuditsInput, DepartmentUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAuditsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedAuditsInput = {
    create?: XOR<UserCreateWithoutCreatedAuditsInput, UserUncheckedCreateWithoutCreatedAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAuditsInput
    connect?: UserWhereUniqueInput
  }

  export type FindingCreateNestedManyWithoutAuditInput = {
    create?: XOR<FindingCreateWithoutAuditInput, FindingUncheckedCreateWithoutAuditInput> | FindingCreateWithoutAuditInput[] | FindingUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: FindingCreateOrConnectWithoutAuditInput | FindingCreateOrConnectWithoutAuditInput[]
    createMany?: FindingCreateManyAuditInputEnvelope
    connect?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
  }

  export type AuditDocumentCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditDocumentCreateWithoutAuditInput, AuditDocumentUncheckedCreateWithoutAuditInput> | AuditDocumentCreateWithoutAuditInput[] | AuditDocumentUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditDocumentCreateOrConnectWithoutAuditInput | AuditDocumentCreateOrConnectWithoutAuditInput[]
    createMany?: AuditDocumentCreateManyAuditInputEnvelope
    connect?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
  }

  export type CorrectiveActionCreateNestedManyWithoutAuditInput = {
    create?: XOR<CorrectiveActionCreateWithoutAuditInput, CorrectiveActionUncheckedCreateWithoutAuditInput> | CorrectiveActionCreateWithoutAuditInput[] | CorrectiveActionUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutAuditInput | CorrectiveActionCreateOrConnectWithoutAuditInput[]
    createMany?: CorrectiveActionCreateManyAuditInputEnvelope
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
  }

  export type AuditReminderCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditReminderCreateWithoutAuditInput, AuditReminderUncheckedCreateWithoutAuditInput> | AuditReminderCreateWithoutAuditInput[] | AuditReminderUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditReminderCreateOrConnectWithoutAuditInput | AuditReminderCreateOrConnectWithoutAuditInput[]
    createMany?: AuditReminderCreateManyAuditInputEnvelope
    connect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
  }

  export type AuditNotificationCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditNotificationCreateWithoutAuditInput, AuditNotificationUncheckedCreateWithoutAuditInput> | AuditNotificationCreateWithoutAuditInput[] | AuditNotificationUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditNotificationCreateOrConnectWithoutAuditInput | AuditNotificationCreateOrConnectWithoutAuditInput[]
    createMany?: AuditNotificationCreateManyAuditInputEnvelope
    connect?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
  }

  export type PreAuditChecklistItemCreateNestedManyWithoutAuditInput = {
    create?: XOR<PreAuditChecklistItemCreateWithoutAuditInput, PreAuditChecklistItemUncheckedCreateWithoutAuditInput> | PreAuditChecklistItemCreateWithoutAuditInput[] | PreAuditChecklistItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: PreAuditChecklistItemCreateOrConnectWithoutAuditInput | PreAuditChecklistItemCreateOrConnectWithoutAuditInput[]
    createMany?: PreAuditChecklistItemCreateManyAuditInputEnvelope
    connect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
  }

  export type AuditInspectionItemCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditInspectionItemCreateWithoutAuditInput, AuditInspectionItemUncheckedCreateWithoutAuditInput> | AuditInspectionItemCreateWithoutAuditInput[] | AuditInspectionItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditInspectionItemCreateOrConnectWithoutAuditInput | AuditInspectionItemCreateOrConnectWithoutAuditInput[]
    createMany?: AuditInspectionItemCreateManyAuditInputEnvelope
    connect?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
  }

  export type FindingUncheckedCreateNestedManyWithoutAuditInput = {
    create?: XOR<FindingCreateWithoutAuditInput, FindingUncheckedCreateWithoutAuditInput> | FindingCreateWithoutAuditInput[] | FindingUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: FindingCreateOrConnectWithoutAuditInput | FindingCreateOrConnectWithoutAuditInput[]
    createMany?: FindingCreateManyAuditInputEnvelope
    connect?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
  }

  export type AuditDocumentUncheckedCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditDocumentCreateWithoutAuditInput, AuditDocumentUncheckedCreateWithoutAuditInput> | AuditDocumentCreateWithoutAuditInput[] | AuditDocumentUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditDocumentCreateOrConnectWithoutAuditInput | AuditDocumentCreateOrConnectWithoutAuditInput[]
    createMany?: AuditDocumentCreateManyAuditInputEnvelope
    connect?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
  }

  export type CorrectiveActionUncheckedCreateNestedManyWithoutAuditInput = {
    create?: XOR<CorrectiveActionCreateWithoutAuditInput, CorrectiveActionUncheckedCreateWithoutAuditInput> | CorrectiveActionCreateWithoutAuditInput[] | CorrectiveActionUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutAuditInput | CorrectiveActionCreateOrConnectWithoutAuditInput[]
    createMany?: CorrectiveActionCreateManyAuditInputEnvelope
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
  }

  export type AuditReminderUncheckedCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditReminderCreateWithoutAuditInput, AuditReminderUncheckedCreateWithoutAuditInput> | AuditReminderCreateWithoutAuditInput[] | AuditReminderUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditReminderCreateOrConnectWithoutAuditInput | AuditReminderCreateOrConnectWithoutAuditInput[]
    createMany?: AuditReminderCreateManyAuditInputEnvelope
    connect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
  }

  export type AuditNotificationUncheckedCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditNotificationCreateWithoutAuditInput, AuditNotificationUncheckedCreateWithoutAuditInput> | AuditNotificationCreateWithoutAuditInput[] | AuditNotificationUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditNotificationCreateOrConnectWithoutAuditInput | AuditNotificationCreateOrConnectWithoutAuditInput[]
    createMany?: AuditNotificationCreateManyAuditInputEnvelope
    connect?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
  }

  export type PreAuditChecklistItemUncheckedCreateNestedManyWithoutAuditInput = {
    create?: XOR<PreAuditChecklistItemCreateWithoutAuditInput, PreAuditChecklistItemUncheckedCreateWithoutAuditInput> | PreAuditChecklistItemCreateWithoutAuditInput[] | PreAuditChecklistItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: PreAuditChecklistItemCreateOrConnectWithoutAuditInput | PreAuditChecklistItemCreateOrConnectWithoutAuditInput[]
    createMany?: PreAuditChecklistItemCreateManyAuditInputEnvelope
    connect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
  }

  export type AuditInspectionItemUncheckedCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditInspectionItemCreateWithoutAuditInput, AuditInspectionItemUncheckedCreateWithoutAuditInput> | AuditInspectionItemCreateWithoutAuditInput[] | AuditInspectionItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditInspectionItemCreateOrConnectWithoutAuditInput | AuditInspectionItemCreateOrConnectWithoutAuditInput[]
    createMany?: AuditInspectionItemCreateManyAuditInputEnvelope
    connect?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
  }

  export type EnumAuditTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuditType
  }

  export type EnumAuditStatusFieldUpdateOperationsInput = {
    set?: $Enums.AuditStatus
  }

  export type AuditorUpdateOneRequiredWithoutAuditsNestedInput = {
    create?: XOR<AuditorCreateWithoutAuditsInput, AuditorUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: AuditorCreateOrConnectWithoutAuditsInput
    upsert?: AuditorUpsertWithoutAuditsInput
    connect?: AuditorWhereUniqueInput
    update?: XOR<XOR<AuditorUpdateToOneWithWhereWithoutAuditsInput, AuditorUpdateWithoutAuditsInput>, AuditorUncheckedUpdateWithoutAuditsInput>
  }

  export type UserUpdateOneWithoutAuditeeAuditsNestedInput = {
    create?: XOR<UserCreateWithoutAuditeeAuditsInput, UserUncheckedCreateWithoutAuditeeAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditeeAuditsInput
    upsert?: UserUpsertWithoutAuditeeAuditsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditeeAuditsInput, UserUpdateWithoutAuditeeAuditsInput>, UserUncheckedUpdateWithoutAuditeeAuditsInput>
  }

  export type DepartmentUpdateOneWithoutAuditsNestedInput = {
    create?: XOR<DepartmentCreateWithoutAuditsInput, DepartmentUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAuditsInput
    upsert?: DepartmentUpsertWithoutAuditsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutAuditsInput, DepartmentUpdateWithoutAuditsInput>, DepartmentUncheckedUpdateWithoutAuditsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedAuditsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedAuditsInput, UserUncheckedCreateWithoutCreatedAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAuditsInput
    upsert?: UserUpsertWithoutCreatedAuditsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedAuditsInput, UserUpdateWithoutCreatedAuditsInput>, UserUncheckedUpdateWithoutCreatedAuditsInput>
  }

  export type FindingUpdateManyWithoutAuditNestedInput = {
    create?: XOR<FindingCreateWithoutAuditInput, FindingUncheckedCreateWithoutAuditInput> | FindingCreateWithoutAuditInput[] | FindingUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: FindingCreateOrConnectWithoutAuditInput | FindingCreateOrConnectWithoutAuditInput[]
    upsert?: FindingUpsertWithWhereUniqueWithoutAuditInput | FindingUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: FindingCreateManyAuditInputEnvelope
    set?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    disconnect?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    delete?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    connect?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    update?: FindingUpdateWithWhereUniqueWithoutAuditInput | FindingUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: FindingUpdateManyWithWhereWithoutAuditInput | FindingUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: FindingScalarWhereInput | FindingScalarWhereInput[]
  }

  export type AuditDocumentUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditDocumentCreateWithoutAuditInput, AuditDocumentUncheckedCreateWithoutAuditInput> | AuditDocumentCreateWithoutAuditInput[] | AuditDocumentUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditDocumentCreateOrConnectWithoutAuditInput | AuditDocumentCreateOrConnectWithoutAuditInput[]
    upsert?: AuditDocumentUpsertWithWhereUniqueWithoutAuditInput | AuditDocumentUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditDocumentCreateManyAuditInputEnvelope
    set?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    disconnect?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    delete?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    connect?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    update?: AuditDocumentUpdateWithWhereUniqueWithoutAuditInput | AuditDocumentUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditDocumentUpdateManyWithWhereWithoutAuditInput | AuditDocumentUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditDocumentScalarWhereInput | AuditDocumentScalarWhereInput[]
  }

  export type CorrectiveActionUpdateManyWithoutAuditNestedInput = {
    create?: XOR<CorrectiveActionCreateWithoutAuditInput, CorrectiveActionUncheckedCreateWithoutAuditInput> | CorrectiveActionCreateWithoutAuditInput[] | CorrectiveActionUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutAuditInput | CorrectiveActionCreateOrConnectWithoutAuditInput[]
    upsert?: CorrectiveActionUpsertWithWhereUniqueWithoutAuditInput | CorrectiveActionUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: CorrectiveActionCreateManyAuditInputEnvelope
    set?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    disconnect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    delete?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    update?: CorrectiveActionUpdateWithWhereUniqueWithoutAuditInput | CorrectiveActionUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: CorrectiveActionUpdateManyWithWhereWithoutAuditInput | CorrectiveActionUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: CorrectiveActionScalarWhereInput | CorrectiveActionScalarWhereInput[]
  }

  export type AuditReminderUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditReminderCreateWithoutAuditInput, AuditReminderUncheckedCreateWithoutAuditInput> | AuditReminderCreateWithoutAuditInput[] | AuditReminderUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditReminderCreateOrConnectWithoutAuditInput | AuditReminderCreateOrConnectWithoutAuditInput[]
    upsert?: AuditReminderUpsertWithWhereUniqueWithoutAuditInput | AuditReminderUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditReminderCreateManyAuditInputEnvelope
    set?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    disconnect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    delete?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    connect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    update?: AuditReminderUpdateWithWhereUniqueWithoutAuditInput | AuditReminderUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditReminderUpdateManyWithWhereWithoutAuditInput | AuditReminderUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditReminderScalarWhereInput | AuditReminderScalarWhereInput[]
  }

  export type AuditNotificationUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditNotificationCreateWithoutAuditInput, AuditNotificationUncheckedCreateWithoutAuditInput> | AuditNotificationCreateWithoutAuditInput[] | AuditNotificationUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditNotificationCreateOrConnectWithoutAuditInput | AuditNotificationCreateOrConnectWithoutAuditInput[]
    upsert?: AuditNotificationUpsertWithWhereUniqueWithoutAuditInput | AuditNotificationUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditNotificationCreateManyAuditInputEnvelope
    set?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    disconnect?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    delete?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    connect?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    update?: AuditNotificationUpdateWithWhereUniqueWithoutAuditInput | AuditNotificationUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditNotificationUpdateManyWithWhereWithoutAuditInput | AuditNotificationUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditNotificationScalarWhereInput | AuditNotificationScalarWhereInput[]
  }

  export type PreAuditChecklistItemUpdateManyWithoutAuditNestedInput = {
    create?: XOR<PreAuditChecklistItemCreateWithoutAuditInput, PreAuditChecklistItemUncheckedCreateWithoutAuditInput> | PreAuditChecklistItemCreateWithoutAuditInput[] | PreAuditChecklistItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: PreAuditChecklistItemCreateOrConnectWithoutAuditInput | PreAuditChecklistItemCreateOrConnectWithoutAuditInput[]
    upsert?: PreAuditChecklistItemUpsertWithWhereUniqueWithoutAuditInput | PreAuditChecklistItemUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: PreAuditChecklistItemCreateManyAuditInputEnvelope
    set?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    disconnect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    delete?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    connect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    update?: PreAuditChecklistItemUpdateWithWhereUniqueWithoutAuditInput | PreAuditChecklistItemUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: PreAuditChecklistItemUpdateManyWithWhereWithoutAuditInput | PreAuditChecklistItemUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: PreAuditChecklistItemScalarWhereInput | PreAuditChecklistItemScalarWhereInput[]
  }

  export type AuditInspectionItemUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditInspectionItemCreateWithoutAuditInput, AuditInspectionItemUncheckedCreateWithoutAuditInput> | AuditInspectionItemCreateWithoutAuditInput[] | AuditInspectionItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditInspectionItemCreateOrConnectWithoutAuditInput | AuditInspectionItemCreateOrConnectWithoutAuditInput[]
    upsert?: AuditInspectionItemUpsertWithWhereUniqueWithoutAuditInput | AuditInspectionItemUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditInspectionItemCreateManyAuditInputEnvelope
    set?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    disconnect?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    delete?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    connect?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    update?: AuditInspectionItemUpdateWithWhereUniqueWithoutAuditInput | AuditInspectionItemUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditInspectionItemUpdateManyWithWhereWithoutAuditInput | AuditInspectionItemUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditInspectionItemScalarWhereInput | AuditInspectionItemScalarWhereInput[]
  }

  export type FindingUncheckedUpdateManyWithoutAuditNestedInput = {
    create?: XOR<FindingCreateWithoutAuditInput, FindingUncheckedCreateWithoutAuditInput> | FindingCreateWithoutAuditInput[] | FindingUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: FindingCreateOrConnectWithoutAuditInput | FindingCreateOrConnectWithoutAuditInput[]
    upsert?: FindingUpsertWithWhereUniqueWithoutAuditInput | FindingUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: FindingCreateManyAuditInputEnvelope
    set?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    disconnect?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    delete?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    connect?: FindingWhereUniqueInput | FindingWhereUniqueInput[]
    update?: FindingUpdateWithWhereUniqueWithoutAuditInput | FindingUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: FindingUpdateManyWithWhereWithoutAuditInput | FindingUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: FindingScalarWhereInput | FindingScalarWhereInput[]
  }

  export type AuditDocumentUncheckedUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditDocumentCreateWithoutAuditInput, AuditDocumentUncheckedCreateWithoutAuditInput> | AuditDocumentCreateWithoutAuditInput[] | AuditDocumentUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditDocumentCreateOrConnectWithoutAuditInput | AuditDocumentCreateOrConnectWithoutAuditInput[]
    upsert?: AuditDocumentUpsertWithWhereUniqueWithoutAuditInput | AuditDocumentUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditDocumentCreateManyAuditInputEnvelope
    set?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    disconnect?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    delete?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    connect?: AuditDocumentWhereUniqueInput | AuditDocumentWhereUniqueInput[]
    update?: AuditDocumentUpdateWithWhereUniqueWithoutAuditInput | AuditDocumentUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditDocumentUpdateManyWithWhereWithoutAuditInput | AuditDocumentUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditDocumentScalarWhereInput | AuditDocumentScalarWhereInput[]
  }

  export type CorrectiveActionUncheckedUpdateManyWithoutAuditNestedInput = {
    create?: XOR<CorrectiveActionCreateWithoutAuditInput, CorrectiveActionUncheckedCreateWithoutAuditInput> | CorrectiveActionCreateWithoutAuditInput[] | CorrectiveActionUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutAuditInput | CorrectiveActionCreateOrConnectWithoutAuditInput[]
    upsert?: CorrectiveActionUpsertWithWhereUniqueWithoutAuditInput | CorrectiveActionUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: CorrectiveActionCreateManyAuditInputEnvelope
    set?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    disconnect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    delete?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    update?: CorrectiveActionUpdateWithWhereUniqueWithoutAuditInput | CorrectiveActionUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: CorrectiveActionUpdateManyWithWhereWithoutAuditInput | CorrectiveActionUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: CorrectiveActionScalarWhereInput | CorrectiveActionScalarWhereInput[]
  }

  export type AuditReminderUncheckedUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditReminderCreateWithoutAuditInput, AuditReminderUncheckedCreateWithoutAuditInput> | AuditReminderCreateWithoutAuditInput[] | AuditReminderUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditReminderCreateOrConnectWithoutAuditInput | AuditReminderCreateOrConnectWithoutAuditInput[]
    upsert?: AuditReminderUpsertWithWhereUniqueWithoutAuditInput | AuditReminderUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditReminderCreateManyAuditInputEnvelope
    set?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    disconnect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    delete?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    connect?: AuditReminderWhereUniqueInput | AuditReminderWhereUniqueInput[]
    update?: AuditReminderUpdateWithWhereUniqueWithoutAuditInput | AuditReminderUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditReminderUpdateManyWithWhereWithoutAuditInput | AuditReminderUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditReminderScalarWhereInput | AuditReminderScalarWhereInput[]
  }

  export type AuditNotificationUncheckedUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditNotificationCreateWithoutAuditInput, AuditNotificationUncheckedCreateWithoutAuditInput> | AuditNotificationCreateWithoutAuditInput[] | AuditNotificationUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditNotificationCreateOrConnectWithoutAuditInput | AuditNotificationCreateOrConnectWithoutAuditInput[]
    upsert?: AuditNotificationUpsertWithWhereUniqueWithoutAuditInput | AuditNotificationUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditNotificationCreateManyAuditInputEnvelope
    set?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    disconnect?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    delete?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    connect?: AuditNotificationWhereUniqueInput | AuditNotificationWhereUniqueInput[]
    update?: AuditNotificationUpdateWithWhereUniqueWithoutAuditInput | AuditNotificationUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditNotificationUpdateManyWithWhereWithoutAuditInput | AuditNotificationUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditNotificationScalarWhereInput | AuditNotificationScalarWhereInput[]
  }

  export type PreAuditChecklistItemUncheckedUpdateManyWithoutAuditNestedInput = {
    create?: XOR<PreAuditChecklistItemCreateWithoutAuditInput, PreAuditChecklistItemUncheckedCreateWithoutAuditInput> | PreAuditChecklistItemCreateWithoutAuditInput[] | PreAuditChecklistItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: PreAuditChecklistItemCreateOrConnectWithoutAuditInput | PreAuditChecklistItemCreateOrConnectWithoutAuditInput[]
    upsert?: PreAuditChecklistItemUpsertWithWhereUniqueWithoutAuditInput | PreAuditChecklistItemUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: PreAuditChecklistItemCreateManyAuditInputEnvelope
    set?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    disconnect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    delete?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    connect?: PreAuditChecklistItemWhereUniqueInput | PreAuditChecklistItemWhereUniqueInput[]
    update?: PreAuditChecklistItemUpdateWithWhereUniqueWithoutAuditInput | PreAuditChecklistItemUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: PreAuditChecklistItemUpdateManyWithWhereWithoutAuditInput | PreAuditChecklistItemUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: PreAuditChecklistItemScalarWhereInput | PreAuditChecklistItemScalarWhereInput[]
  }

  export type AuditInspectionItemUncheckedUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditInspectionItemCreateWithoutAuditInput, AuditInspectionItemUncheckedCreateWithoutAuditInput> | AuditInspectionItemCreateWithoutAuditInput[] | AuditInspectionItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditInspectionItemCreateOrConnectWithoutAuditInput | AuditInspectionItemCreateOrConnectWithoutAuditInput[]
    upsert?: AuditInspectionItemUpsertWithWhereUniqueWithoutAuditInput | AuditInspectionItemUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditInspectionItemCreateManyAuditInputEnvelope
    set?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    disconnect?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    delete?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    connect?: AuditInspectionItemWhereUniqueInput | AuditInspectionItemWhereUniqueInput[]
    update?: AuditInspectionItemUpdateWithWhereUniqueWithoutAuditInput | AuditInspectionItemUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditInspectionItemUpdateManyWithWhereWithoutAuditInput | AuditInspectionItemUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditInspectionItemScalarWhereInput | AuditInspectionItemScalarWhereInput[]
  }

  export type AuditCreateNestedOneWithoutInspectionItemsInput = {
    create?: XOR<AuditCreateWithoutInspectionItemsInput, AuditUncheckedCreateWithoutInspectionItemsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutInspectionItemsInput
    connect?: AuditWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInspectedItemsInput = {
    create?: XOR<UserCreateWithoutInspectedItemsInput, UserUncheckedCreateWithoutInspectedItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInspectedItemsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type AuditUpdateOneRequiredWithoutInspectionItemsNestedInput = {
    create?: XOR<AuditCreateWithoutInspectionItemsInput, AuditUncheckedCreateWithoutInspectionItemsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutInspectionItemsInput
    upsert?: AuditUpsertWithoutInspectionItemsInput
    connect?: AuditWhereUniqueInput
    update?: XOR<XOR<AuditUpdateToOneWithWhereWithoutInspectionItemsInput, AuditUpdateWithoutInspectionItemsInput>, AuditUncheckedUpdateWithoutInspectionItemsInput>
  }

  export type UserUpdateOneWithoutInspectedItemsNestedInput = {
    create?: XOR<UserCreateWithoutInspectedItemsInput, UserUncheckedCreateWithoutInspectedItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInspectedItemsInput
    upsert?: UserUpsertWithoutInspectedItemsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInspectedItemsInput, UserUpdateWithoutInspectedItemsInput>, UserUncheckedUpdateWithoutInspectedItemsInput>
  }

  export type AuditCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AuditCreateWithoutDepartmentInput, AuditUncheckedCreateWithoutDepartmentInput> | AuditCreateWithoutDepartmentInput[] | AuditUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutDepartmentInput | AuditCreateOrConnectWithoutDepartmentInput[]
    createMany?: AuditCreateManyDepartmentInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type AuditUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AuditCreateWithoutDepartmentInput, AuditUncheckedCreateWithoutDepartmentInput> | AuditCreateWithoutDepartmentInput[] | AuditUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutDepartmentInput | AuditCreateOrConnectWithoutDepartmentInput[]
    createMany?: AuditCreateManyDepartmentInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type AuditUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AuditCreateWithoutDepartmentInput, AuditUncheckedCreateWithoutDepartmentInput> | AuditCreateWithoutDepartmentInput[] | AuditUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutDepartmentInput | AuditCreateOrConnectWithoutDepartmentInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutDepartmentInput | AuditUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AuditCreateManyDepartmentInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutDepartmentInput | AuditUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutDepartmentInput | AuditUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type AuditUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AuditCreateWithoutDepartmentInput, AuditUncheckedCreateWithoutDepartmentInput> | AuditCreateWithoutDepartmentInput[] | AuditUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutDepartmentInput | AuditCreateOrConnectWithoutDepartmentInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutDepartmentInput | AuditUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AuditCreateManyDepartmentInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutDepartmentInput | AuditUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutDepartmentInput | AuditUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type AuditCreateNestedOneWithoutFindingsInput = {
    create?: XOR<AuditCreateWithoutFindingsInput, AuditUncheckedCreateWithoutFindingsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutFindingsInput
    connect?: AuditWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedFindingsInput = {
    create?: XOR<UserCreateWithoutAssignedFindingsInput, UserUncheckedCreateWithoutAssignedFindingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedFindingsInput
    connect?: UserWhereUniqueInput
  }

  export type CorrectiveActionCreateNestedManyWithoutFindingInput = {
    create?: XOR<CorrectiveActionCreateWithoutFindingInput, CorrectiveActionUncheckedCreateWithoutFindingInput> | CorrectiveActionCreateWithoutFindingInput[] | CorrectiveActionUncheckedCreateWithoutFindingInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutFindingInput | CorrectiveActionCreateOrConnectWithoutFindingInput[]
    createMany?: CorrectiveActionCreateManyFindingInputEnvelope
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
  }

  export type CorrectiveActionUncheckedCreateNestedManyWithoutFindingInput = {
    create?: XOR<CorrectiveActionCreateWithoutFindingInput, CorrectiveActionUncheckedCreateWithoutFindingInput> | CorrectiveActionCreateWithoutFindingInput[] | CorrectiveActionUncheckedCreateWithoutFindingInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutFindingInput | CorrectiveActionCreateOrConnectWithoutFindingInput[]
    createMany?: CorrectiveActionCreateManyFindingInputEnvelope
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
  }

  export type EnumFindingTypeFieldUpdateOperationsInput = {
    set?: $Enums.FindingType
  }

  export type EnumFindingStatusFieldUpdateOperationsInput = {
    set?: $Enums.FindingStatus
  }

  export type NullableEnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority | null
  }

  export type AuditUpdateOneRequiredWithoutFindingsNestedInput = {
    create?: XOR<AuditCreateWithoutFindingsInput, AuditUncheckedCreateWithoutFindingsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutFindingsInput
    upsert?: AuditUpsertWithoutFindingsInput
    connect?: AuditWhereUniqueInput
    update?: XOR<XOR<AuditUpdateToOneWithWhereWithoutFindingsInput, AuditUpdateWithoutFindingsInput>, AuditUncheckedUpdateWithoutFindingsInput>
  }

  export type UserUpdateOneWithoutAssignedFindingsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedFindingsInput, UserUncheckedCreateWithoutAssignedFindingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedFindingsInput
    upsert?: UserUpsertWithoutAssignedFindingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedFindingsInput, UserUpdateWithoutAssignedFindingsInput>, UserUncheckedUpdateWithoutAssignedFindingsInput>
  }

  export type CorrectiveActionUpdateManyWithoutFindingNestedInput = {
    create?: XOR<CorrectiveActionCreateWithoutFindingInput, CorrectiveActionUncheckedCreateWithoutFindingInput> | CorrectiveActionCreateWithoutFindingInput[] | CorrectiveActionUncheckedCreateWithoutFindingInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutFindingInput | CorrectiveActionCreateOrConnectWithoutFindingInput[]
    upsert?: CorrectiveActionUpsertWithWhereUniqueWithoutFindingInput | CorrectiveActionUpsertWithWhereUniqueWithoutFindingInput[]
    createMany?: CorrectiveActionCreateManyFindingInputEnvelope
    set?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    disconnect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    delete?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    update?: CorrectiveActionUpdateWithWhereUniqueWithoutFindingInput | CorrectiveActionUpdateWithWhereUniqueWithoutFindingInput[]
    updateMany?: CorrectiveActionUpdateManyWithWhereWithoutFindingInput | CorrectiveActionUpdateManyWithWhereWithoutFindingInput[]
    deleteMany?: CorrectiveActionScalarWhereInput | CorrectiveActionScalarWhereInput[]
  }

  export type CorrectiveActionUncheckedUpdateManyWithoutFindingNestedInput = {
    create?: XOR<CorrectiveActionCreateWithoutFindingInput, CorrectiveActionUncheckedCreateWithoutFindingInput> | CorrectiveActionCreateWithoutFindingInput[] | CorrectiveActionUncheckedCreateWithoutFindingInput[]
    connectOrCreate?: CorrectiveActionCreateOrConnectWithoutFindingInput | CorrectiveActionCreateOrConnectWithoutFindingInput[]
    upsert?: CorrectiveActionUpsertWithWhereUniqueWithoutFindingInput | CorrectiveActionUpsertWithWhereUniqueWithoutFindingInput[]
    createMany?: CorrectiveActionCreateManyFindingInputEnvelope
    set?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    disconnect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    delete?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    connect?: CorrectiveActionWhereUniqueInput | CorrectiveActionWhereUniqueInput[]
    update?: CorrectiveActionUpdateWithWhereUniqueWithoutFindingInput | CorrectiveActionUpdateWithWhereUniqueWithoutFindingInput[]
    updateMany?: CorrectiveActionUpdateManyWithWhereWithoutFindingInput | CorrectiveActionUpdateManyWithWhereWithoutFindingInput[]
    deleteMany?: CorrectiveActionScalarWhereInput | CorrectiveActionScalarWhereInput[]
  }

  export type AuditCreateNestedOneWithoutActionsInput = {
    create?: XOR<AuditCreateWithoutActionsInput, AuditUncheckedCreateWithoutActionsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutActionsInput
    connect?: AuditWhereUniqueInput
  }

  export type FindingCreateNestedOneWithoutActionsInput = {
    create?: XOR<FindingCreateWithoutActionsInput, FindingUncheckedCreateWithoutActionsInput>
    connectOrCreate?: FindingCreateOrConnectWithoutActionsInput
    connect?: FindingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedActionsInput = {
    create?: XOR<UserCreateWithoutAssignedActionsInput, UserUncheckedCreateWithoutAssignedActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedActionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVerifiedActionsInput = {
    create?: XOR<UserCreateWithoutVerifiedActionsInput, UserUncheckedCreateWithoutVerifiedActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedActionsInput
    connect?: UserWhereUniqueInput
  }

  export type AuditUpdateOneRequiredWithoutActionsNestedInput = {
    create?: XOR<AuditCreateWithoutActionsInput, AuditUncheckedCreateWithoutActionsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutActionsInput
    upsert?: AuditUpsertWithoutActionsInput
    connect?: AuditWhereUniqueInput
    update?: XOR<XOR<AuditUpdateToOneWithWhereWithoutActionsInput, AuditUpdateWithoutActionsInput>, AuditUncheckedUpdateWithoutActionsInput>
  }

  export type FindingUpdateOneWithoutActionsNestedInput = {
    create?: XOR<FindingCreateWithoutActionsInput, FindingUncheckedCreateWithoutActionsInput>
    connectOrCreate?: FindingCreateOrConnectWithoutActionsInput
    upsert?: FindingUpsertWithoutActionsInput
    disconnect?: FindingWhereInput | boolean
    delete?: FindingWhereInput | boolean
    connect?: FindingWhereUniqueInput
    update?: XOR<XOR<FindingUpdateToOneWithWhereWithoutActionsInput, FindingUpdateWithoutActionsInput>, FindingUncheckedUpdateWithoutActionsInput>
  }

  export type UserUpdateOneRequiredWithoutAssignedActionsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedActionsInput, UserUncheckedCreateWithoutAssignedActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedActionsInput
    upsert?: UserUpsertWithoutAssignedActionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedActionsInput, UserUpdateWithoutAssignedActionsInput>, UserUncheckedUpdateWithoutAssignedActionsInput>
  }

  export type UserUpdateOneWithoutVerifiedActionsNestedInput = {
    create?: XOR<UserCreateWithoutVerifiedActionsInput, UserUncheckedCreateWithoutVerifiedActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedActionsInput
    upsert?: UserUpsertWithoutVerifiedActionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerifiedActionsInput, UserUpdateWithoutVerifiedActionsInput>, UserUncheckedUpdateWithoutVerifiedActionsInput>
  }

  export type AuditCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<AuditCreateWithoutDocumentsInput, AuditUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutDocumentsInput
    connect?: AuditWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedAuditDocumentsInput = {
    create?: XOR<UserCreateWithoutUploadedAuditDocumentsInput, UserUncheckedCreateWithoutUploadedAuditDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedAuditDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuditDocumentType
  }

  export type AuditUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<AuditCreateWithoutDocumentsInput, AuditUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutDocumentsInput
    upsert?: AuditUpsertWithoutDocumentsInput
    connect?: AuditWhereUniqueInput
    update?: XOR<XOR<AuditUpdateToOneWithWhereWithoutDocumentsInput, AuditUpdateWithoutDocumentsInput>, AuditUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedAuditDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedAuditDocumentsInput, UserUncheckedCreateWithoutUploadedAuditDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedAuditDocumentsInput
    upsert?: UserUpsertWithoutUploadedAuditDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedAuditDocumentsInput, UserUpdateWithoutUploadedAuditDocumentsInput>, UserUncheckedUpdateWithoutUploadedAuditDocumentsInput>
  }

  export type AuditCreateNestedOneWithoutChecklistItemsInput = {
    create?: XOR<AuditCreateWithoutChecklistItemsInput, AuditUncheckedCreateWithoutChecklistItemsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutChecklistItemsInput
    connect?: AuditWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResponsibleForChecklistItemsInput = {
    create?: XOR<UserCreateWithoutResponsibleForChecklistItemsInput, UserUncheckedCreateWithoutResponsibleForChecklistItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponsibleForChecklistItemsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedChecklistItemsInput = {
    create?: XOR<UserCreateWithoutCreatedChecklistItemsInput, UserUncheckedCreateWithoutCreatedChecklistItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedChecklistItemsInput
    connect?: UserWhereUniqueInput
  }

  export type AuditUpdateOneRequiredWithoutChecklistItemsNestedInput = {
    create?: XOR<AuditCreateWithoutChecklistItemsInput, AuditUncheckedCreateWithoutChecklistItemsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutChecklistItemsInput
    upsert?: AuditUpsertWithoutChecklistItemsInput
    connect?: AuditWhereUniqueInput
    update?: XOR<XOR<AuditUpdateToOneWithWhereWithoutChecklistItemsInput, AuditUpdateWithoutChecklistItemsInput>, AuditUncheckedUpdateWithoutChecklistItemsInput>
  }

  export type UserUpdateOneRequiredWithoutResponsibleForChecklistItemsNestedInput = {
    create?: XOR<UserCreateWithoutResponsibleForChecklistItemsInput, UserUncheckedCreateWithoutResponsibleForChecklistItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponsibleForChecklistItemsInput
    upsert?: UserUpsertWithoutResponsibleForChecklistItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResponsibleForChecklistItemsInput, UserUpdateWithoutResponsibleForChecklistItemsInput>, UserUncheckedUpdateWithoutResponsibleForChecklistItemsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedChecklistItemsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedChecklistItemsInput, UserUncheckedCreateWithoutCreatedChecklistItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedChecklistItemsInput
    upsert?: UserUpsertWithoutCreatedChecklistItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedChecklistItemsInput, UserUpdateWithoutCreatedChecklistItemsInput>, UserUncheckedUpdateWithoutCreatedChecklistItemsInput>
  }

  export type AuditCreateNestedOneWithoutRemindersInput = {
    create?: XOR<AuditCreateWithoutRemindersInput, AuditUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: AuditCreateOrConnectWithoutRemindersInput
    connect?: AuditWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedRemindersInput = {
    create?: XOR<UserCreateWithoutReceivedRemindersInput, UserUncheckedCreateWithoutReceivedRemindersInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedRemindersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedRemindersInput = {
    create?: XOR<UserCreateWithoutCreatedRemindersInput, UserUncheckedCreateWithoutCreatedRemindersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRemindersInput
    connect?: UserWhereUniqueInput
  }

  export type AuditUpdateOneRequiredWithoutRemindersNestedInput = {
    create?: XOR<AuditCreateWithoutRemindersInput, AuditUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: AuditCreateOrConnectWithoutRemindersInput
    upsert?: AuditUpsertWithoutRemindersInput
    connect?: AuditWhereUniqueInput
    update?: XOR<XOR<AuditUpdateToOneWithWhereWithoutRemindersInput, AuditUpdateWithoutRemindersInput>, AuditUncheckedUpdateWithoutRemindersInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedRemindersNestedInput = {
    create?: XOR<UserCreateWithoutReceivedRemindersInput, UserUncheckedCreateWithoutReceivedRemindersInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedRemindersInput
    upsert?: UserUpsertWithoutReceivedRemindersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedRemindersInput, UserUpdateWithoutReceivedRemindersInput>, UserUncheckedUpdateWithoutReceivedRemindersInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedRemindersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedRemindersInput, UserUncheckedCreateWithoutCreatedRemindersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRemindersInput
    upsert?: UserUpsertWithoutCreatedRemindersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedRemindersInput, UserUpdateWithoutCreatedRemindersInput>, UserUncheckedUpdateWithoutCreatedRemindersInput>
  }

  export type AuditCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<AuditCreateWithoutNotificationsInput, AuditUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutNotificationsInput
    connect?: AuditWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditNotificationsInput = {
    create?: XOR<UserCreateWithoutAuditNotificationsInput, UserUncheckedCreateWithoutAuditNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type AuditUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<AuditCreateWithoutNotificationsInput, AuditUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutNotificationsInput
    upsert?: AuditUpsertWithoutNotificationsInput
    connect?: AuditWhereUniqueInput
    update?: XOR<XOR<AuditUpdateToOneWithWhereWithoutNotificationsInput, AuditUpdateWithoutNotificationsInput>, AuditUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutAuditNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutAuditNotificationsInput, UserUncheckedCreateWithoutAuditNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditNotificationsInput
    upsert?: UserUpsertWithoutAuditNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditNotificationsInput, UserUpdateWithoutAuditNotificationsInput>, UserUncheckedUpdateWithoutAuditNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSampleAnalysisStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleAnalysisStatus | EnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleAnalysisStatusFilter<$PrismaModel> | $Enums.SampleAnalysisStatus
  }

  export type NestedEnumBatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusFilter<$PrismaModel> | $Enums.BatchStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSampleAnalysisStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleAnalysisStatus | EnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleAnalysisStatusWithAggregatesFilter<$PrismaModel> | $Enums.SampleAnalysisStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSampleAnalysisStatusFilter<$PrismaModel>
    _max?: NestedEnumSampleAnalysisStatusFilter<$PrismaModel>
  }

  export type NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumStandardStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StandardStatus | EnumStandardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStandardStatusFilter<$PrismaModel> | $Enums.StandardStatus
  }

  export type NestedEnumStandardStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StandardStatus | EnumStandardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStandardStatusWithAggregatesFilter<$PrismaModel> | $Enums.StandardStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStandardStatusFilter<$PrismaModel>
    _max?: NestedEnumStandardStatusFilter<$PrismaModel>
  }

  export type NestedEnumParameterDataTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ParameterDataType | EnumParameterDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParameterDataTypeFilter<$PrismaModel> | $Enums.ParameterDataType
  }

  export type NestedEnumParameterDataTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParameterDataType | EnumParameterDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParameterDataTypeWithAggregatesFilter<$PrismaModel> | $Enums.ParameterDataType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParameterDataTypeFilter<$PrismaModel>
    _max?: NestedEnumParameterDataTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTrainingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingTypeFilter<$PrismaModel> | $Enums.TrainingType
  }

  export type NestedEnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type NestedEnumTrainingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrainingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingTypeFilter<$PrismaModel>
    _max?: NestedEnumTrainingTypeFilter<$PrismaModel>
  }

  export type NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumAuditTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditType | EnumAuditTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditType[] | ListEnumAuditTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditType[] | ListEnumAuditTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditTypeFilter<$PrismaModel> | $Enums.AuditType
  }

  export type NestedEnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type NestedEnumAuditTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditType | EnumAuditTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditType[] | ListEnumAuditTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditType[] | ListEnumAuditTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditTypeFilter<$PrismaModel>
  }

  export type NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumFindingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FindingType | EnumFindingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FindingType[] | ListEnumFindingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FindingType[] | ListEnumFindingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFindingTypeFilter<$PrismaModel> | $Enums.FindingType
  }

  export type NestedEnumFindingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FindingStatus | EnumFindingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FindingStatus[] | ListEnumFindingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FindingStatus[] | ListEnumFindingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFindingStatusFilter<$PrismaModel> | $Enums.FindingStatus
  }

  export type NestedEnumPriorityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableFilter<$PrismaModel> | $Enums.Priority | null
  }

  export type NestedEnumFindingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FindingType | EnumFindingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FindingType[] | ListEnumFindingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FindingType[] | ListEnumFindingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFindingTypeWithAggregatesFilter<$PrismaModel> | $Enums.FindingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFindingTypeFilter<$PrismaModel>
    _max?: NestedEnumFindingTypeFilter<$PrismaModel>
  }

  export type NestedEnumFindingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FindingStatus | EnumFindingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FindingStatus[] | ListEnumFindingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FindingStatus[] | ListEnumFindingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFindingStatusWithAggregatesFilter<$PrismaModel> | $Enums.FindingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFindingStatusFilter<$PrismaModel>
    _max?: NestedEnumFindingStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Priority | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPriorityNullableFilter<$PrismaModel>
    _max?: NestedEnumPriorityNullableFilter<$PrismaModel>
  }

  export type NestedEnumAuditDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditDocumentType | EnumAuditDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditDocumentType[] | ListEnumAuditDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditDocumentType[] | ListEnumAuditDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditDocumentTypeFilter<$PrismaModel> | $Enums.AuditDocumentType
  }

  export type NestedEnumAuditDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditDocumentType | EnumAuditDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditDocumentType[] | ListEnumAuditDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditDocumentType[] | ListEnumAuditDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditDocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditDocumentTypeFilter<$PrismaModel>
  }

  export type BatchCreateWithoutActivityLogInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutActivityLogInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutActivityLogInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutActivityLogInput, BatchUncheckedCreateWithoutActivityLogInput>
  }

  export type UserCreateWithoutActivityLogInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutActivityLogInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutActivityLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogInput, UserUncheckedCreateWithoutActivityLogInput>
  }

  export type BatchUpsertWithoutActivityLogInput = {
    update: XOR<BatchUpdateWithoutActivityLogInput, BatchUncheckedUpdateWithoutActivityLogInput>
    create: XOR<BatchCreateWithoutActivityLogInput, BatchUncheckedCreateWithoutActivityLogInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutActivityLogInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutActivityLogInput, BatchUncheckedUpdateWithoutActivityLogInput>
  }

  export type BatchUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type UserUpsertWithoutActivityLogInput = {
    update: XOR<UserUpdateWithoutActivityLogInput, UserUncheckedUpdateWithoutActivityLogInput>
    create: XOR<UserCreateWithoutActivityLogInput, UserUncheckedCreateWithoutActivityLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogInput, UserUncheckedUpdateWithoutActivityLogInput>
  }

  export type UserUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type ActivityLogCreateWithoutBatchInput = {
    id: string
    action: string
    details?: string | null
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutActivityLogInput
  }

  export type ActivityLogUncheckedCreateWithoutBatchInput = {
    id: string
    userId: string
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutBatchInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutBatchInput, ActivityLogUncheckedCreateWithoutBatchInput>
  }

  export type ActivityLogCreateManyBatchInputEnvelope = {
    data: ActivityLogCreateManyBatchInput | ActivityLogCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBatch_Batch_checkerIdToUserInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutBatch_Batch_checkerIdToUserInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutBatch_Batch_checkerIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBatch_Batch_checkerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_checkerIdToUserInput>
  }

  export type UserCreateWithoutBatch_Batch_makerIdToUserInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutBatch_Batch_makerIdToUserInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutBatch_Batch_makerIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBatch_Batch_makerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_makerIdToUserInput>
  }

  export type ProductCreateWithoutBatchInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    standardCategories?: ProductStandardCategoryCreateNestedManyWithoutProductInput
    parameters?: ProductParameterCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBatchInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    standardCategories?: ProductStandardCategoryUncheckedCreateNestedManyWithoutProductInput
    parameters?: ProductParameterUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBatchInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBatchInput, ProductUncheckedCreateWithoutBatchInput>
  }

  export type NotificationCreateWithoutBatchInput = {
    id: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutBatchInput = {
    id: string
    userId: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutBatchInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutBatchInput, NotificationUncheckedCreateWithoutBatchInput>
  }

  export type NotificationCreateManyBatchInputEnvelope = {
    data: NotificationCreateManyBatchInput | NotificationCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type StandardCreateWithoutBatchesInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    Category: StandardCategoryCreateNestedOneWithoutStandardsInput
    CreatedBy: UserCreateNestedOneWithoutStandardsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardsModifiedInput
    methodologies?: MethodologyCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateWithoutBatchesInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardCreateOrConnectWithoutBatchesInput = {
    where: StandardWhereUniqueInput
    create: XOR<StandardCreateWithoutBatchesInput, StandardUncheckedCreateWithoutBatchesInput>
  }

  export type MethodologyCreateWithoutBatchesInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutMethodologyInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyUncheckedCreateWithoutBatchesInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutMethodologyInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyCreateOrConnectWithoutBatchesInput = {
    where: MethodologyWhereUniqueInput
    create: XOR<MethodologyCreateWithoutBatchesInput, MethodologyUncheckedCreateWithoutBatchesInput>
  }

  export type UnitOfMeasurementCreateWithoutBatchesInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutUnitInput
    standardParameters?: StandardParameterCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutUnitInput
  }

  export type UnitOfMeasurementUncheckedCreateWithoutBatchesInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutUnitInput
    standardParameters?: StandardParameterUncheckedCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitOfMeasurementCreateOrConnectWithoutBatchesInput = {
    where: UnitOfMeasurementWhereUniqueInput
    create: XOR<UnitOfMeasurementCreateWithoutBatchesInput, UnitOfMeasurementUncheckedCreateWithoutBatchesInput>
  }

  export type BatchParameterValueCreateWithoutBatchInput = {
    id: string
    value: string
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parameter: StandardParameterCreateNestedOneWithoutBatchValuesInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutBatchParameterValuesInput
    methodology?: MethodologyCreateNestedOneWithoutBatchParameterValuesInput
  }

  export type BatchParameterValueUncheckedCreateWithoutBatchInput = {
    id: string
    parameterId: string
    value: string
    unitId?: string | null
    methodologyId?: string | null
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchParameterValueCreateOrConnectWithoutBatchInput = {
    where: BatchParameterValueWhereUniqueInput
    create: XOR<BatchParameterValueCreateWithoutBatchInput, BatchParameterValueUncheckedCreateWithoutBatchInput>
  }

  export type BatchParameterValueCreateManyBatchInputEnvelope = {
    data: BatchParameterValueCreateManyBatchInput | BatchParameterValueCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutBatchInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutBatchInput, ActivityLogUncheckedUpdateWithoutBatchInput>
    create: XOR<ActivityLogCreateWithoutBatchInput, ActivityLogUncheckedCreateWithoutBatchInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutBatchInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutBatchInput, ActivityLogUncheckedUpdateWithoutBatchInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutBatchInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutBatchInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringFilter<"ActivityLog"> | string
    batchId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: StringFilter<"ActivityLog"> | string
    details?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type UserUpsertWithoutBatch_Batch_checkerIdToUserInput = {
    update: XOR<UserUpdateWithoutBatch_Batch_checkerIdToUserInput, UserUncheckedUpdateWithoutBatch_Batch_checkerIdToUserInput>
    create: XOR<UserCreateWithoutBatch_Batch_checkerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_checkerIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBatch_Batch_checkerIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBatch_Batch_checkerIdToUserInput, UserUncheckedUpdateWithoutBatch_Batch_checkerIdToUserInput>
  }

  export type UserUpdateWithoutBatch_Batch_checkerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBatch_Batch_checkerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithoutBatch_Batch_makerIdToUserInput = {
    update: XOR<UserUpdateWithoutBatch_Batch_makerIdToUserInput, UserUncheckedUpdateWithoutBatch_Batch_makerIdToUserInput>
    create: XOR<UserCreateWithoutBatch_Batch_makerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_makerIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBatch_Batch_makerIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBatch_Batch_makerIdToUserInput, UserUncheckedUpdateWithoutBatch_Batch_makerIdToUserInput>
  }

  export type UserUpdateWithoutBatch_Batch_makerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBatch_Batch_makerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type ProductUpsertWithoutBatchInput = {
    update: XOR<ProductUpdateWithoutBatchInput, ProductUncheckedUpdateWithoutBatchInput>
    create: XOR<ProductCreateWithoutBatchInput, ProductUncheckedCreateWithoutBatchInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutBatchInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutBatchInput, ProductUncheckedUpdateWithoutBatchInput>
  }

  export type ProductUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    standardCategories?: ProductStandardCategoryUpdateManyWithoutProductNestedInput
    parameters?: ProductParameterUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    standardCategories?: ProductStandardCategoryUncheckedUpdateManyWithoutProductNestedInput
    parameters?: ProductParameterUncheckedUpdateManyWithoutProductNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutBatchInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutBatchInput, NotificationUncheckedUpdateWithoutBatchInput>
    create: XOR<NotificationCreateWithoutBatchInput, NotificationUncheckedCreateWithoutBatchInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutBatchInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutBatchInput, NotificationUncheckedUpdateWithoutBatchInput>
  }

  export type NotificationUpdateManyWithWhereWithoutBatchInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutBatchInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    batchId?: StringNullableFilter<"Notification"> | string | null
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type StandardUpsertWithWhereUniqueWithoutBatchesInput = {
    where: StandardWhereUniqueInput
    update: XOR<StandardUpdateWithoutBatchesInput, StandardUncheckedUpdateWithoutBatchesInput>
    create: XOR<StandardCreateWithoutBatchesInput, StandardUncheckedCreateWithoutBatchesInput>
  }

  export type StandardUpdateWithWhereUniqueWithoutBatchesInput = {
    where: StandardWhereUniqueInput
    data: XOR<StandardUpdateWithoutBatchesInput, StandardUncheckedUpdateWithoutBatchesInput>
  }

  export type StandardUpdateManyWithWhereWithoutBatchesInput = {
    where: StandardScalarWhereInput
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyWithoutBatchesInput>
  }

  export type StandardScalarWhereInput = {
    AND?: StandardScalarWhereInput | StandardScalarWhereInput[]
    OR?: StandardScalarWhereInput[]
    NOT?: StandardScalarWhereInput | StandardScalarWhereInput[]
    id?: StringFilter<"Standard"> | string
    name?: StringFilter<"Standard"> | string
    code?: StringFilter<"Standard"> | string
    description?: StringFilter<"Standard"> | string
    categoryId?: StringFilter<"Standard"> | string
    createdById?: StringFilter<"Standard"> | string
    modifiedById?: StringNullableFilter<"Standard"> | string | null
    status?: EnumStandardStatusFilter<"Standard"> | $Enums.StandardStatus
    createdAt?: DateTimeFilter<"Standard"> | Date | string
    updatedAt?: DateTimeFilter<"Standard"> | Date | string
  }

  export type MethodologyUpsertWithWhereUniqueWithoutBatchesInput = {
    where: MethodologyWhereUniqueInput
    update: XOR<MethodologyUpdateWithoutBatchesInput, MethodologyUncheckedUpdateWithoutBatchesInput>
    create: XOR<MethodologyCreateWithoutBatchesInput, MethodologyUncheckedCreateWithoutBatchesInput>
  }

  export type MethodologyUpdateWithWhereUniqueWithoutBatchesInput = {
    where: MethodologyWhereUniqueInput
    data: XOR<MethodologyUpdateWithoutBatchesInput, MethodologyUncheckedUpdateWithoutBatchesInput>
  }

  export type MethodologyUpdateManyWithWhereWithoutBatchesInput = {
    where: MethodologyScalarWhereInput
    data: XOR<MethodologyUpdateManyMutationInput, MethodologyUncheckedUpdateManyWithoutBatchesInput>
  }

  export type MethodologyScalarWhereInput = {
    AND?: MethodologyScalarWhereInput | MethodologyScalarWhereInput[]
    OR?: MethodologyScalarWhereInput[]
    NOT?: MethodologyScalarWhereInput | MethodologyScalarWhereInput[]
    id?: StringFilter<"Methodology"> | string
    name?: StringFilter<"Methodology"> | string
    description?: StringFilter<"Methodology"> | string
    procedure?: StringFilter<"Methodology"> | string
    createdAt?: DateTimeFilter<"Methodology"> | Date | string
    updatedAt?: DateTimeFilter<"Methodology"> | Date | string
  }

  export type UnitOfMeasurementUpsertWithWhereUniqueWithoutBatchesInput = {
    where: UnitOfMeasurementWhereUniqueInput
    update: XOR<UnitOfMeasurementUpdateWithoutBatchesInput, UnitOfMeasurementUncheckedUpdateWithoutBatchesInput>
    create: XOR<UnitOfMeasurementCreateWithoutBatchesInput, UnitOfMeasurementUncheckedCreateWithoutBatchesInput>
  }

  export type UnitOfMeasurementUpdateWithWhereUniqueWithoutBatchesInput = {
    where: UnitOfMeasurementWhereUniqueInput
    data: XOR<UnitOfMeasurementUpdateWithoutBatchesInput, UnitOfMeasurementUncheckedUpdateWithoutBatchesInput>
  }

  export type UnitOfMeasurementUpdateManyWithWhereWithoutBatchesInput = {
    where: UnitOfMeasurementScalarWhereInput
    data: XOR<UnitOfMeasurementUpdateManyMutationInput, UnitOfMeasurementUncheckedUpdateManyWithoutBatchesInput>
  }

  export type UnitOfMeasurementScalarWhereInput = {
    AND?: UnitOfMeasurementScalarWhereInput | UnitOfMeasurementScalarWhereInput[]
    OR?: UnitOfMeasurementScalarWhereInput[]
    NOT?: UnitOfMeasurementScalarWhereInput | UnitOfMeasurementScalarWhereInput[]
    id?: StringFilter<"UnitOfMeasurement"> | string
    name?: StringFilter<"UnitOfMeasurement"> | string
    symbol?: StringFilter<"UnitOfMeasurement"> | string
    description?: StringNullableFilter<"UnitOfMeasurement"> | string | null
    createdAt?: DateTimeFilter<"UnitOfMeasurement"> | Date | string
    updatedAt?: DateTimeFilter<"UnitOfMeasurement"> | Date | string
  }

  export type BatchParameterValueUpsertWithWhereUniqueWithoutBatchInput = {
    where: BatchParameterValueWhereUniqueInput
    update: XOR<BatchParameterValueUpdateWithoutBatchInput, BatchParameterValueUncheckedUpdateWithoutBatchInput>
    create: XOR<BatchParameterValueCreateWithoutBatchInput, BatchParameterValueUncheckedCreateWithoutBatchInput>
  }

  export type BatchParameterValueUpdateWithWhereUniqueWithoutBatchInput = {
    where: BatchParameterValueWhereUniqueInput
    data: XOR<BatchParameterValueUpdateWithoutBatchInput, BatchParameterValueUncheckedUpdateWithoutBatchInput>
  }

  export type BatchParameterValueUpdateManyWithWhereWithoutBatchInput = {
    where: BatchParameterValueScalarWhereInput
    data: XOR<BatchParameterValueUpdateManyMutationInput, BatchParameterValueUncheckedUpdateManyWithoutBatchInput>
  }

  export type BatchParameterValueScalarWhereInput = {
    AND?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
    OR?: BatchParameterValueScalarWhereInput[]
    NOT?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
    id?: StringFilter<"BatchParameterValue"> | string
    batchId?: StringFilter<"BatchParameterValue"> | string
    parameterId?: StringFilter<"BatchParameterValue"> | string
    value?: StringFilter<"BatchParameterValue"> | string
    unitId?: StringNullableFilter<"BatchParameterValue"> | string | null
    methodologyId?: StringNullableFilter<"BatchParameterValue"> | string | null
    verificationResult?: StringNullableFilter<"BatchParameterValue"> | string | null
    verificationRemark?: StringNullableFilter<"BatchParameterValue"> | string | null
    verifiedById?: StringNullableFilter<"BatchParameterValue"> | string | null
    verifiedAt?: DateTimeNullableFilter<"BatchParameterValue"> | Date | string | null
    createdAt?: DateTimeFilter<"BatchParameterValue"> | Date | string
    updatedAt?: DateTimeFilter<"BatchParameterValue"> | Date | string
  }

  export type StandardCreateWithoutMethodologiesInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    Category: StandardCategoryCreateNestedOneWithoutStandardsInput
    CreatedBy: UserCreateNestedOneWithoutStandardsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardsModifiedInput
    batches?: BatchCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateWithoutMethodologiesInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardCreateOrConnectWithoutMethodologiesInput = {
    where: StandardWhereUniqueInput
    create: XOR<StandardCreateWithoutMethodologiesInput, StandardUncheckedCreateWithoutMethodologiesInput>
  }

  export type BatchCreateWithoutMethodologiesInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutMethodologiesInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutMethodologiesInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutMethodologiesInput, BatchUncheckedCreateWithoutMethodologiesInput>
  }

  export type BatchParameterValueCreateWithoutMethodologyInput = {
    id: string
    value: string
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    batch: BatchCreateNestedOneWithoutParameterValuesInput
    parameter: StandardParameterCreateNestedOneWithoutBatchValuesInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutBatchParameterValuesInput
  }

  export type BatchParameterValueUncheckedCreateWithoutMethodologyInput = {
    id: string
    batchId: string
    parameterId: string
    value: string
    unitId?: string | null
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchParameterValueCreateOrConnectWithoutMethodologyInput = {
    where: BatchParameterValueWhereUniqueInput
    create: XOR<BatchParameterValueCreateWithoutMethodologyInput, BatchParameterValueUncheckedCreateWithoutMethodologyInput>
  }

  export type BatchParameterValueCreateManyMethodologyInputEnvelope = {
    data: BatchParameterValueCreateManyMethodologyInput | BatchParameterValueCreateManyMethodologyInput[]
    skipDuplicates?: boolean
  }

  export type StandardDefinitionCreateWithoutMethodologyInput = {
    id: string
    standardValue: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    parameter: StandardParameterCreateNestedOneWithoutStandardsInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardDefinitionsInput
    CreatedBy: UserCreateNestedOneWithoutStandardDefinitionsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardDefinitionsModifiedInput
  }

  export type StandardDefinitionUncheckedCreateWithoutMethodologyInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateOrConnectWithoutMethodologyInput = {
    where: StandardDefinitionWhereUniqueInput
    create: XOR<StandardDefinitionCreateWithoutMethodologyInput, StandardDefinitionUncheckedCreateWithoutMethodologyInput>
  }

  export type StandardDefinitionCreateManyMethodologyInputEnvelope = {
    data: StandardDefinitionCreateManyMethodologyInput | StandardDefinitionCreateManyMethodologyInput[]
    skipDuplicates?: boolean
  }

  export type StandardUpsertWithWhereUniqueWithoutMethodologiesInput = {
    where: StandardWhereUniqueInput
    update: XOR<StandardUpdateWithoutMethodologiesInput, StandardUncheckedUpdateWithoutMethodologiesInput>
    create: XOR<StandardCreateWithoutMethodologiesInput, StandardUncheckedCreateWithoutMethodologiesInput>
  }

  export type StandardUpdateWithWhereUniqueWithoutMethodologiesInput = {
    where: StandardWhereUniqueInput
    data: XOR<StandardUpdateWithoutMethodologiesInput, StandardUncheckedUpdateWithoutMethodologiesInput>
  }

  export type StandardUpdateManyWithWhereWithoutMethodologiesInput = {
    where: StandardScalarWhereInput
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyWithoutMethodologiesInput>
  }

  export type BatchUpsertWithWhereUniqueWithoutMethodologiesInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutMethodologiesInput, BatchUncheckedUpdateWithoutMethodologiesInput>
    create: XOR<BatchCreateWithoutMethodologiesInput, BatchUncheckedCreateWithoutMethodologiesInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutMethodologiesInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutMethodologiesInput, BatchUncheckedUpdateWithoutMethodologiesInput>
  }

  export type BatchUpdateManyWithWhereWithoutMethodologiesInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutMethodologiesInput>
  }

  export type BatchScalarWhereInput = {
    AND?: BatchScalarWhereInput | BatchScalarWhereInput[]
    OR?: BatchScalarWhereInput[]
    NOT?: BatchScalarWhereInput | BatchScalarWhereInput[]
    id?: StringFilter<"Batch"> | string
    batchNumber?: StringFilter<"Batch"> | string
    productId?: StringFilter<"Batch"> | string
    dateOfProduction?: DateTimeFilter<"Batch"> | Date | string
    bestBeforeDate?: DateTimeFilter<"Batch"> | Date | string
    sampleAnalysisStarted?: DateTimeNullableFilter<"Batch"> | Date | string | null
    sampleAnalysisCompleted?: DateTimeNullableFilter<"Batch"> | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFilter<"Batch"> | $Enums.SampleAnalysisStatus
    makerId?: StringFilter<"Batch"> | string
    checkerId?: StringNullableFilter<"Batch"> | string | null
    status?: EnumBatchStatusFilter<"Batch"> | $Enums.BatchStatus
    rejectionRemarks?: StringNullableFilter<"Batch"> | string | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
  }

  export type BatchParameterValueUpsertWithWhereUniqueWithoutMethodologyInput = {
    where: BatchParameterValueWhereUniqueInput
    update: XOR<BatchParameterValueUpdateWithoutMethodologyInput, BatchParameterValueUncheckedUpdateWithoutMethodologyInput>
    create: XOR<BatchParameterValueCreateWithoutMethodologyInput, BatchParameterValueUncheckedCreateWithoutMethodologyInput>
  }

  export type BatchParameterValueUpdateWithWhereUniqueWithoutMethodologyInput = {
    where: BatchParameterValueWhereUniqueInput
    data: XOR<BatchParameterValueUpdateWithoutMethodologyInput, BatchParameterValueUncheckedUpdateWithoutMethodologyInput>
  }

  export type BatchParameterValueUpdateManyWithWhereWithoutMethodologyInput = {
    where: BatchParameterValueScalarWhereInput
    data: XOR<BatchParameterValueUpdateManyMutationInput, BatchParameterValueUncheckedUpdateManyWithoutMethodologyInput>
  }

  export type StandardDefinitionUpsertWithWhereUniqueWithoutMethodologyInput = {
    where: StandardDefinitionWhereUniqueInput
    update: XOR<StandardDefinitionUpdateWithoutMethodologyInput, StandardDefinitionUncheckedUpdateWithoutMethodologyInput>
    create: XOR<StandardDefinitionCreateWithoutMethodologyInput, StandardDefinitionUncheckedCreateWithoutMethodologyInput>
  }

  export type StandardDefinitionUpdateWithWhereUniqueWithoutMethodologyInput = {
    where: StandardDefinitionWhereUniqueInput
    data: XOR<StandardDefinitionUpdateWithoutMethodologyInput, StandardDefinitionUncheckedUpdateWithoutMethodologyInput>
  }

  export type StandardDefinitionUpdateManyWithWhereWithoutMethodologyInput = {
    where: StandardDefinitionScalarWhereInput
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyWithoutMethodologyInput>
  }

  export type StandardDefinitionScalarWhereInput = {
    AND?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
    OR?: StandardDefinitionScalarWhereInput[]
    NOT?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
    id?: StringFilter<"StandardDefinition"> | string
    parameterId?: StringFilter<"StandardDefinition"> | string
    standardValue?: StringFilter<"StandardDefinition"> | string
    unitId?: StringNullableFilter<"StandardDefinition"> | string | null
    methodologyId?: StringNullableFilter<"StandardDefinition"> | string | null
    createdById?: StringFilter<"StandardDefinition"> | string
    modifiedById?: StringNullableFilter<"StandardDefinition"> | string | null
    status?: EnumStandardStatusFilter<"StandardDefinition"> | $Enums.StandardStatus
    createdAt?: DateTimeFilter<"StandardDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"StandardDefinition"> | Date | string
  }

  export type BatchCreateWithoutNotificationInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutNotificationInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutNotificationInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutNotificationInput, BatchUncheckedCreateWithoutNotificationInput>
  }

  export type UserCreateWithoutNotificationInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type BatchUpsertWithoutNotificationInput = {
    update: XOR<BatchUpdateWithoutNotificationInput, BatchUncheckedUpdateWithoutNotificationInput>
    create: XOR<BatchCreateWithoutNotificationInput, BatchUncheckedCreateWithoutNotificationInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutNotificationInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutNotificationInput, BatchUncheckedUpdateWithoutNotificationInput>
  }

  export type BatchUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type RoleCreateWithoutPermissionInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionInput, RoleUncheckedCreateWithoutPermissionInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutPermissionInput, RoleUncheckedUpdateWithoutPermissionInput>
    create: XOR<RoleCreateWithoutPermissionInput, RoleUncheckedCreateWithoutPermissionInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutPermissionInput, RoleUncheckedUpdateWithoutPermissionInput>
  }

  export type RoleUpdateManyWithWhereWithoutPermissionInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
  }

  export type BatchCreateWithoutProductInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutProductInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutProductInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutProductInput, BatchUncheckedCreateWithoutProductInput>
  }

  export type BatchCreateManyProductInputEnvelope = {
    data: BatchCreateManyProductInput | BatchCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductStandardCategoryCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category: StandardCategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductStandardCategoryUncheckedCreateWithoutProductInput = {
    id?: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductStandardCategoryCreateOrConnectWithoutProductInput = {
    where: ProductStandardCategoryWhereUniqueInput
    create: XOR<ProductStandardCategoryCreateWithoutProductInput, ProductStandardCategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductStandardCategoryCreateManyProductInputEnvelope = {
    data: ProductStandardCategoryCreateManyProductInput | ProductStandardCategoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductParameterCreateWithoutProductInput = {
    id?: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parameter: StandardParameterCreateNestedOneWithoutProductsInput
  }

  export type ProductParameterUncheckedCreateWithoutProductInput = {
    id?: string
    parameterId: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductParameterCreateOrConnectWithoutProductInput = {
    where: ProductParameterWhereUniqueInput
    create: XOR<ProductParameterCreateWithoutProductInput, ProductParameterUncheckedCreateWithoutProductInput>
  }

  export type ProductParameterCreateManyProductInputEnvelope = {
    data: ProductParameterCreateManyProductInput | ProductParameterCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type BatchUpsertWithWhereUniqueWithoutProductInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutProductInput, BatchUncheckedUpdateWithoutProductInput>
    create: XOR<BatchCreateWithoutProductInput, BatchUncheckedCreateWithoutProductInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutProductInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutProductInput, BatchUncheckedUpdateWithoutProductInput>
  }

  export type BatchUpdateManyWithWhereWithoutProductInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductStandardCategoryUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductStandardCategoryWhereUniqueInput
    update: XOR<ProductStandardCategoryUpdateWithoutProductInput, ProductStandardCategoryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductStandardCategoryCreateWithoutProductInput, ProductStandardCategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductStandardCategoryUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductStandardCategoryWhereUniqueInput
    data: XOR<ProductStandardCategoryUpdateWithoutProductInput, ProductStandardCategoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductStandardCategoryUpdateManyWithWhereWithoutProductInput = {
    where: ProductStandardCategoryScalarWhereInput
    data: XOR<ProductStandardCategoryUpdateManyMutationInput, ProductStandardCategoryUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductStandardCategoryScalarWhereInput = {
    AND?: ProductStandardCategoryScalarWhereInput | ProductStandardCategoryScalarWhereInput[]
    OR?: ProductStandardCategoryScalarWhereInput[]
    NOT?: ProductStandardCategoryScalarWhereInput | ProductStandardCategoryScalarWhereInput[]
    id?: StringFilter<"ProductStandardCategory"> | string
    productId?: StringFilter<"ProductStandardCategory"> | string
    categoryId?: StringFilter<"ProductStandardCategory"> | string
    createdAt?: DateTimeFilter<"ProductStandardCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductStandardCategory"> | Date | string
  }

  export type ProductParameterUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductParameterWhereUniqueInput
    update: XOR<ProductParameterUpdateWithoutProductInput, ProductParameterUncheckedUpdateWithoutProductInput>
    create: XOR<ProductParameterCreateWithoutProductInput, ProductParameterUncheckedCreateWithoutProductInput>
  }

  export type ProductParameterUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductParameterWhereUniqueInput
    data: XOR<ProductParameterUpdateWithoutProductInput, ProductParameterUncheckedUpdateWithoutProductInput>
  }

  export type ProductParameterUpdateManyWithWhereWithoutProductInput = {
    where: ProductParameterScalarWhereInput
    data: XOR<ProductParameterUpdateManyMutationInput, ProductParameterUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductParameterScalarWhereInput = {
    AND?: ProductParameterScalarWhereInput | ProductParameterScalarWhereInput[]
    OR?: ProductParameterScalarWhereInput[]
    NOT?: ProductParameterScalarWhereInput | ProductParameterScalarWhereInput[]
    id?: StringFilter<"ProductParameter"> | string
    productId?: StringFilter<"ProductParameter"> | string
    parameterId?: StringFilter<"ProductParameter"> | string
    isRequired?: BoolFilter<"ProductParameter"> | boolean
    createdAt?: DateTimeFilter<"ProductParameter"> | Date | string
    updatedAt?: DateTimeFilter<"ProductParameter"> | Date | string
  }

  export type ProductCreateWithoutParametersInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Batch?: BatchCreateNestedManyWithoutProductInput
    standardCategories?: ProductStandardCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutParametersInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Batch?: BatchUncheckedCreateNestedManyWithoutProductInput
    standardCategories?: ProductStandardCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutParametersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutParametersInput, ProductUncheckedCreateWithoutParametersInput>
  }

  export type StandardParameterCreateWithoutProductsInput = {
    id: string
    name: string
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    category: StandardCategoryCreateNestedOneWithoutParametersInput
    batchValues?: BatchParameterValueCreateNestedManyWithoutParameterInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardParametersInput
    standards?: StandardDefinitionCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterUncheckedCreateWithoutProductsInput = {
    id: string
    name: string
    categoryId: string
    unitId?: string | null
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    batchValues?: BatchParameterValueUncheckedCreateNestedManyWithoutParameterInput
    standards?: StandardDefinitionUncheckedCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterCreateOrConnectWithoutProductsInput = {
    where: StandardParameterWhereUniqueInput
    create: XOR<StandardParameterCreateWithoutProductsInput, StandardParameterUncheckedCreateWithoutProductsInput>
  }

  export type ProductUpsertWithoutParametersInput = {
    update: XOR<ProductUpdateWithoutParametersInput, ProductUncheckedUpdateWithoutParametersInput>
    create: XOR<ProductCreateWithoutParametersInput, ProductUncheckedCreateWithoutParametersInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutParametersInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutParametersInput, ProductUncheckedUpdateWithoutParametersInput>
  }

  export type ProductUpdateWithoutParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateManyWithoutProductNestedInput
    standardCategories?: ProductStandardCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUncheckedUpdateManyWithoutProductNestedInput
    standardCategories?: ProductStandardCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StandardParameterUpsertWithoutProductsInput = {
    update: XOR<StandardParameterUpdateWithoutProductsInput, StandardParameterUncheckedUpdateWithoutProductsInput>
    create: XOR<StandardParameterCreateWithoutProductsInput, StandardParameterUncheckedCreateWithoutProductsInput>
    where?: StandardParameterWhereInput
  }

  export type StandardParameterUpdateToOneWithWhereWithoutProductsInput = {
    where?: StandardParameterWhereInput
    data: XOR<StandardParameterUpdateWithoutProductsInput, StandardParameterUncheckedUpdateWithoutProductsInput>
  }

  export type StandardParameterUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StandardCategoryUpdateOneRequiredWithoutParametersNestedInput
    batchValues?: BatchParameterValueUpdateManyWithoutParameterNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutStandardParametersNestedInput
    standards?: StandardDefinitionUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchValues?: BatchParameterValueUncheckedUpdateManyWithoutParameterNestedInput
    standards?: StandardDefinitionUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type UserCreateWithoutRoleInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type PermissionCreateWithoutRoleInput = {
    id: string
    action: string
    resource: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type PermissionUncheckedCreateWithoutRoleInput = {
    id: string
    action: string
    resource: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type PermissionCreateOrConnectWithoutRoleInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput>
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type PermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutRoleInput, PermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutRoleInput, PermissionUncheckedUpdateWithoutRoleInput>
  }

  export type PermissionUpdateManyWithWhereWithoutRoleInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    OR?: PermissionScalarWhereInput[]
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    id?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
  }

  export type StandardCreateWithoutUnitsInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    Category: StandardCategoryCreateNestedOneWithoutStandardsInput
    CreatedBy: UserCreateNestedOneWithoutStandardsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardsModifiedInput
    batches?: BatchCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateWithoutUnitsInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardCreateOrConnectWithoutUnitsInput = {
    where: StandardWhereUniqueInput
    create: XOR<StandardCreateWithoutUnitsInput, StandardUncheckedCreateWithoutUnitsInput>
  }

  export type BatchParameterValueCreateWithoutUnitInput = {
    id: string
    value: string
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    batch: BatchCreateNestedOneWithoutParameterValuesInput
    parameter: StandardParameterCreateNestedOneWithoutBatchValuesInput
    methodology?: MethodologyCreateNestedOneWithoutBatchParameterValuesInput
  }

  export type BatchParameterValueUncheckedCreateWithoutUnitInput = {
    id: string
    batchId: string
    parameterId: string
    value: string
    methodologyId?: string | null
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchParameterValueCreateOrConnectWithoutUnitInput = {
    where: BatchParameterValueWhereUniqueInput
    create: XOR<BatchParameterValueCreateWithoutUnitInput, BatchParameterValueUncheckedCreateWithoutUnitInput>
  }

  export type BatchParameterValueCreateManyUnitInputEnvelope = {
    data: BatchParameterValueCreateManyUnitInput | BatchParameterValueCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type StandardParameterCreateWithoutUnitInput = {
    id: string
    name: string
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    category: StandardCategoryCreateNestedOneWithoutParametersInput
    batchValues?: BatchParameterValueCreateNestedManyWithoutParameterInput
    standards?: StandardDefinitionCreateNestedManyWithoutParameterInput
    products?: ProductParameterCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterUncheckedCreateWithoutUnitInput = {
    id: string
    name: string
    categoryId: string
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    batchValues?: BatchParameterValueUncheckedCreateNestedManyWithoutParameterInput
    standards?: StandardDefinitionUncheckedCreateNestedManyWithoutParameterInput
    products?: ProductParameterUncheckedCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterCreateOrConnectWithoutUnitInput = {
    where: StandardParameterWhereUniqueInput
    create: XOR<StandardParameterCreateWithoutUnitInput, StandardParameterUncheckedCreateWithoutUnitInput>
  }

  export type StandardParameterCreateManyUnitInputEnvelope = {
    data: StandardParameterCreateManyUnitInput | StandardParameterCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type StandardDefinitionCreateWithoutUnitInput = {
    id: string
    standardValue: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    parameter: StandardParameterCreateNestedOneWithoutStandardsInput
    methodology?: MethodologyCreateNestedOneWithoutStandardDefinitionsInput
    CreatedBy: UserCreateNestedOneWithoutStandardDefinitionsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardDefinitionsModifiedInput
  }

  export type StandardDefinitionUncheckedCreateWithoutUnitInput = {
    id: string
    parameterId: string
    standardValue: string
    methodologyId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateOrConnectWithoutUnitInput = {
    where: StandardDefinitionWhereUniqueInput
    create: XOR<StandardDefinitionCreateWithoutUnitInput, StandardDefinitionUncheckedCreateWithoutUnitInput>
  }

  export type StandardDefinitionCreateManyUnitInputEnvelope = {
    data: StandardDefinitionCreateManyUnitInput | StandardDefinitionCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type BatchCreateWithoutUnitOfMeasurementsInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutUnitOfMeasurementsInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutUnitOfMeasurementsInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutUnitOfMeasurementsInput, BatchUncheckedCreateWithoutUnitOfMeasurementsInput>
  }

  export type StandardUpsertWithWhereUniqueWithoutUnitsInput = {
    where: StandardWhereUniqueInput
    update: XOR<StandardUpdateWithoutUnitsInput, StandardUncheckedUpdateWithoutUnitsInput>
    create: XOR<StandardCreateWithoutUnitsInput, StandardUncheckedCreateWithoutUnitsInput>
  }

  export type StandardUpdateWithWhereUniqueWithoutUnitsInput = {
    where: StandardWhereUniqueInput
    data: XOR<StandardUpdateWithoutUnitsInput, StandardUncheckedUpdateWithoutUnitsInput>
  }

  export type StandardUpdateManyWithWhereWithoutUnitsInput = {
    where: StandardScalarWhereInput
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyWithoutUnitsInput>
  }

  export type BatchParameterValueUpsertWithWhereUniqueWithoutUnitInput = {
    where: BatchParameterValueWhereUniqueInput
    update: XOR<BatchParameterValueUpdateWithoutUnitInput, BatchParameterValueUncheckedUpdateWithoutUnitInput>
    create: XOR<BatchParameterValueCreateWithoutUnitInput, BatchParameterValueUncheckedCreateWithoutUnitInput>
  }

  export type BatchParameterValueUpdateWithWhereUniqueWithoutUnitInput = {
    where: BatchParameterValueWhereUniqueInput
    data: XOR<BatchParameterValueUpdateWithoutUnitInput, BatchParameterValueUncheckedUpdateWithoutUnitInput>
  }

  export type BatchParameterValueUpdateManyWithWhereWithoutUnitInput = {
    where: BatchParameterValueScalarWhereInput
    data: XOR<BatchParameterValueUpdateManyMutationInput, BatchParameterValueUncheckedUpdateManyWithoutUnitInput>
  }

  export type StandardParameterUpsertWithWhereUniqueWithoutUnitInput = {
    where: StandardParameterWhereUniqueInput
    update: XOR<StandardParameterUpdateWithoutUnitInput, StandardParameterUncheckedUpdateWithoutUnitInput>
    create: XOR<StandardParameterCreateWithoutUnitInput, StandardParameterUncheckedCreateWithoutUnitInput>
  }

  export type StandardParameterUpdateWithWhereUniqueWithoutUnitInput = {
    where: StandardParameterWhereUniqueInput
    data: XOR<StandardParameterUpdateWithoutUnitInput, StandardParameterUncheckedUpdateWithoutUnitInput>
  }

  export type StandardParameterUpdateManyWithWhereWithoutUnitInput = {
    where: StandardParameterScalarWhereInput
    data: XOR<StandardParameterUpdateManyMutationInput, StandardParameterUncheckedUpdateManyWithoutUnitInput>
  }

  export type StandardParameterScalarWhereInput = {
    AND?: StandardParameterScalarWhereInput | StandardParameterScalarWhereInput[]
    OR?: StandardParameterScalarWhereInput[]
    NOT?: StandardParameterScalarWhereInput | StandardParameterScalarWhereInput[]
    id?: StringFilter<"StandardParameter"> | string
    name?: StringFilter<"StandardParameter"> | string
    categoryId?: StringFilter<"StandardParameter"> | string
    unitId?: StringNullableFilter<"StandardParameter"> | string | null
    productType?: StringNullableFilter<"StandardParameter"> | string | null
    description?: StringNullableFilter<"StandardParameter"> | string | null
    dataType?: EnumParameterDataTypeFilter<"StandardParameter"> | $Enums.ParameterDataType
    createdAt?: DateTimeFilter<"StandardParameter"> | Date | string
    updatedAt?: DateTimeFilter<"StandardParameter"> | Date | string
  }

  export type StandardDefinitionUpsertWithWhereUniqueWithoutUnitInput = {
    where: StandardDefinitionWhereUniqueInput
    update: XOR<StandardDefinitionUpdateWithoutUnitInput, StandardDefinitionUncheckedUpdateWithoutUnitInput>
    create: XOR<StandardDefinitionCreateWithoutUnitInput, StandardDefinitionUncheckedCreateWithoutUnitInput>
  }

  export type StandardDefinitionUpdateWithWhereUniqueWithoutUnitInput = {
    where: StandardDefinitionWhereUniqueInput
    data: XOR<StandardDefinitionUpdateWithoutUnitInput, StandardDefinitionUncheckedUpdateWithoutUnitInput>
  }

  export type StandardDefinitionUpdateManyWithWhereWithoutUnitInput = {
    where: StandardDefinitionScalarWhereInput
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyWithoutUnitInput>
  }

  export type BatchUpsertWithWhereUniqueWithoutUnitOfMeasurementsInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutUnitOfMeasurementsInput, BatchUncheckedUpdateWithoutUnitOfMeasurementsInput>
    create: XOR<BatchCreateWithoutUnitOfMeasurementsInput, BatchUncheckedCreateWithoutUnitOfMeasurementsInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutUnitOfMeasurementsInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutUnitOfMeasurementsInput, BatchUncheckedUpdateWithoutUnitOfMeasurementsInput>
  }

  export type BatchUpdateManyWithWhereWithoutUnitOfMeasurementsInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutUnitOfMeasurementsInput>
  }

  export type ActivityLogCreateWithoutUserInput = {
    id: string
    action: string
    details?: string | null
    createdAt?: Date | string
    Batch?: BatchCreateNestedOneWithoutActivityLogInput
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id: string
    batchId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BatchCreateWithoutUser_Batch_checkerIdToUserInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput>
  }

  export type BatchCreateManyUser_Batch_checkerIdToUserInputEnvelope = {
    data: BatchCreateManyUser_Batch_checkerIdToUserInput | BatchCreateManyUser_Batch_checkerIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type BatchCreateWithoutUser_Batch_makerIdToUserInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput>
  }

  export type BatchCreateManyUser_Batch_makerIdToUserInputEnvelope = {
    data: BatchCreateManyUser_Batch_makerIdToUserInput | BatchCreateManyUser_Batch_makerIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    Batch?: BatchCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id: string
    batchId?: string | null
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutUserInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Permission?: PermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUserInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Permission?: PermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUserInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
  }

  export type StandardCreateWithoutCreatedByInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    Category: StandardCategoryCreateNestedOneWithoutStandardsInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardsModifiedInput
    batches?: BatchCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateWithoutCreatedByInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardCreateOrConnectWithoutCreatedByInput = {
    where: StandardWhereUniqueInput
    create: XOR<StandardCreateWithoutCreatedByInput, StandardUncheckedCreateWithoutCreatedByInput>
  }

  export type StandardCreateManyCreatedByInputEnvelope = {
    data: StandardCreateManyCreatedByInput | StandardCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type StandardCreateWithoutModifiedByInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    Category: StandardCategoryCreateNestedOneWithoutStandardsInput
    CreatedBy: UserCreateNestedOneWithoutStandardsCreatedInput
    batches?: BatchCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateWithoutModifiedByInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardCreateOrConnectWithoutModifiedByInput = {
    where: StandardWhereUniqueInput
    create: XOR<StandardCreateWithoutModifiedByInput, StandardUncheckedCreateWithoutModifiedByInput>
  }

  export type StandardCreateManyModifiedByInputEnvelope = {
    data: StandardCreateManyModifiedByInput | StandardCreateManyModifiedByInput[]
    skipDuplicates?: boolean
  }

  export type StandardDefinitionCreateWithoutCreatedByInput = {
    id: string
    standardValue: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    parameter: StandardParameterCreateNestedOneWithoutStandardsInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardDefinitionsInput
    methodology?: MethodologyCreateNestedOneWithoutStandardDefinitionsInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardDefinitionsModifiedInput
  }

  export type StandardDefinitionUncheckedCreateWithoutCreatedByInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateOrConnectWithoutCreatedByInput = {
    where: StandardDefinitionWhereUniqueInput
    create: XOR<StandardDefinitionCreateWithoutCreatedByInput, StandardDefinitionUncheckedCreateWithoutCreatedByInput>
  }

  export type StandardDefinitionCreateManyCreatedByInputEnvelope = {
    data: StandardDefinitionCreateManyCreatedByInput | StandardDefinitionCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type StandardDefinitionCreateWithoutModifiedByInput = {
    id: string
    standardValue: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    parameter: StandardParameterCreateNestedOneWithoutStandardsInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardDefinitionsInput
    methodology?: MethodologyCreateNestedOneWithoutStandardDefinitionsInput
    CreatedBy: UserCreateNestedOneWithoutStandardDefinitionsCreatedInput
  }

  export type StandardDefinitionUncheckedCreateWithoutModifiedByInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    createdById: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateOrConnectWithoutModifiedByInput = {
    where: StandardDefinitionWhereUniqueInput
    create: XOR<StandardDefinitionCreateWithoutModifiedByInput, StandardDefinitionUncheckedCreateWithoutModifiedByInput>
  }

  export type StandardDefinitionCreateManyModifiedByInputEnvelope = {
    data: StandardDefinitionCreateManyModifiedByInput | StandardDefinitionCreateManyModifiedByInput[]
    skipDuplicates?: boolean
  }

  export type TrainingCreateWithoutTrainerInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutTrainerInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutTrainerInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutTrainerInput, TrainingUncheckedCreateWithoutTrainerInput>
  }

  export type TrainingCreateManyTrainerInputEnvelope = {
    data: TrainingCreateManyTrainerInput | TrainingCreateManyTrainerInput[]
    skipDuplicates?: boolean
  }

  export type TrainingCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutCreatedByInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutCreatedByInput, TrainingUncheckedCreateWithoutCreatedByInput>
  }

  export type TrainingCreateManyCreatedByInputEnvelope = {
    data: TrainingCreateManyCreatedByInput | TrainingCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TrainingDocumentCreateWithoutUploadedByInput = {
    id?: string
    sessionId?: string | null
    title: string
    description?: string | null
    fileUrl: string
    filePath?: string | null
    documentType: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutDocumentsInput
  }

  export type TrainingDocumentUncheckedCreateWithoutUploadedByInput = {
    id?: string
    trainingId: string
    sessionId?: string | null
    title: string
    description?: string | null
    fileUrl: string
    filePath?: string | null
    documentType: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDocumentCreateOrConnectWithoutUploadedByInput = {
    where: TrainingDocumentWhereUniqueInput
    create: XOR<TrainingDocumentCreateWithoutUploadedByInput, TrainingDocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type TrainingDocumentCreateManyUploadedByInputEnvelope = {
    data: TrainingDocumentCreateManyUploadedByInput | TrainingDocumentCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type TrainingPhotoCreateWithoutUploadedByInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
    training: TrainingCreateNestedOneWithoutPhotosInput
  }

  export type TrainingPhotoUncheckedCreateWithoutUploadedByInput = {
    id?: string
    trainingId: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
  }

  export type TrainingPhotoCreateOrConnectWithoutUploadedByInput = {
    where: TrainingPhotoWhereUniqueInput
    create: XOR<TrainingPhotoCreateWithoutUploadedByInput, TrainingPhotoUncheckedCreateWithoutUploadedByInput>
  }

  export type TrainingPhotoCreateManyUploadedByInputEnvelope = {
    data: TrainingPhotoCreateManyUploadedByInput | TrainingPhotoCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type TrainingFollowupCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    training: TrainingCreateNestedOneWithoutFollowupsInput
    createdBy: UserCreateNestedOneWithoutCreatedFollowupsInput
  }

  export type TrainingFollowupUncheckedCreateWithoutAssignedToInput = {
    id?: string
    trainingId: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingFollowupCreateOrConnectWithoutAssignedToInput = {
    where: TrainingFollowupWhereUniqueInput
    create: XOR<TrainingFollowupCreateWithoutAssignedToInput, TrainingFollowupUncheckedCreateWithoutAssignedToInput>
  }

  export type TrainingFollowupCreateManyAssignedToInputEnvelope = {
    data: TrainingFollowupCreateManyAssignedToInput | TrainingFollowupCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type TrainingFollowupCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    training: TrainingCreateNestedOneWithoutFollowupsInput
    assignedTo: UserCreateNestedOneWithoutAssignedFollowupsInput
  }

  export type TrainingFollowupUncheckedCreateWithoutCreatedByInput = {
    id?: string
    trainingId: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    assignedToId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingFollowupCreateOrConnectWithoutCreatedByInput = {
    where: TrainingFollowupWhereUniqueInput
    create: XOR<TrainingFollowupCreateWithoutCreatedByInput, TrainingFollowupUncheckedCreateWithoutCreatedByInput>
  }

  export type TrainingFollowupCreateManyCreatedByInputEnvelope = {
    data: TrainingFollowupCreateManyCreatedByInput | TrainingFollowupCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TrainingNotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    training: TrainingCreateNestedOneWithoutNotificationsInput
  }

  export type TrainingNotificationUncheckedCreateWithoutUserInput = {
    id?: string
    trainingId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type TrainingNotificationCreateOrConnectWithoutUserInput = {
    where: TrainingNotificationWhereUniqueInput
    create: XOR<TrainingNotificationCreateWithoutUserInput, TrainingNotificationUncheckedCreateWithoutUserInput>
  }

  export type TrainingNotificationCreateManyUserInputEnvelope = {
    data: TrainingNotificationCreateManyUserInput | TrainingNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditorCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    isExternal?: boolean
    firmName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditCreateNestedManyWithoutAuditorInput
  }

  export type AuditorUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    isExternal?: boolean
    firmName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AuditUncheckedCreateNestedManyWithoutAuditorInput
  }

  export type AuditorCreateOrConnectWithoutUserInput = {
    where: AuditorWhereUniqueInput
    create: XOR<AuditorCreateWithoutUserInput, AuditorUncheckedCreateWithoutUserInput>
  }

  export type AuditCreateWithoutAuditeeInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditor: AuditorCreateNestedOneWithoutAuditsInput
    department?: DepartmentCreateNestedOneWithoutAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    findings?: FindingCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutAuditeeInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    findings?: FindingUncheckedCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentUncheckedCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderUncheckedCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationUncheckedCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutAuditeeInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutAuditeeInput, AuditUncheckedCreateWithoutAuditeeInput>
  }

  export type AuditCreateManyAuditeeInputEnvelope = {
    data: AuditCreateManyAuditeeInput | AuditCreateManyAuditeeInput[]
    skipDuplicates?: boolean
  }

  export type AuditCreateWithoutCreatedByInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditor: AuditorCreateNestedOneWithoutAuditsInput
    auditee?: UserCreateNestedOneWithoutAuditeeAuditsInput
    department?: DepartmentCreateNestedOneWithoutAuditsInput
    findings?: FindingCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    auditeeId?: string | null
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    findings?: FindingUncheckedCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentUncheckedCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderUncheckedCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationUncheckedCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutCreatedByInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput>
  }

  export type AuditCreateManyCreatedByInputEnvelope = {
    data: AuditCreateManyCreatedByInput | AuditCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type FindingCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    findingType: $Enums.FindingType
    status?: $Enums.FindingStatus
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    audit: AuditCreateNestedOneWithoutFindingsInput
    actions?: CorrectiveActionCreateNestedManyWithoutFindingInput
  }

  export type FindingUncheckedCreateWithoutAssignedToInput = {
    id?: string
    auditId: string
    title: string
    description: string
    findingType: $Enums.FindingType
    status?: $Enums.FindingStatus
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutFindingInput
  }

  export type FindingCreateOrConnectWithoutAssignedToInput = {
    where: FindingWhereUniqueInput
    create: XOR<FindingCreateWithoutAssignedToInput, FindingUncheckedCreateWithoutAssignedToInput>
  }

  export type FindingCreateManyAssignedToInputEnvelope = {
    data: FindingCreateManyAssignedToInput | FindingCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type CorrectiveActionCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    actionType: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutActionsInput
    finding?: FindingCreateNestedOneWithoutActionsInput
    verifiedBy?: UserCreateNestedOneWithoutVerifiedActionsInput
  }

  export type CorrectiveActionUncheckedCreateWithoutAssignedToInput = {
    id?: string
    auditId: string
    findingId?: string | null
    title: string
    description: string
    actionType: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    verifiedById?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrectiveActionCreateOrConnectWithoutAssignedToInput = {
    where: CorrectiveActionWhereUniqueInput
    create: XOR<CorrectiveActionCreateWithoutAssignedToInput, CorrectiveActionUncheckedCreateWithoutAssignedToInput>
  }

  export type CorrectiveActionCreateManyAssignedToInputEnvelope = {
    data: CorrectiveActionCreateManyAssignedToInput | CorrectiveActionCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type CorrectiveActionCreateWithoutVerifiedByInput = {
    id?: string
    title: string
    description: string
    actionType: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutActionsInput
    finding?: FindingCreateNestedOneWithoutActionsInput
    assignedTo: UserCreateNestedOneWithoutAssignedActionsInput
  }

  export type CorrectiveActionUncheckedCreateWithoutVerifiedByInput = {
    id?: string
    auditId: string
    findingId?: string | null
    title: string
    description: string
    actionType: string
    assignedToId: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrectiveActionCreateOrConnectWithoutVerifiedByInput = {
    where: CorrectiveActionWhereUniqueInput
    create: XOR<CorrectiveActionCreateWithoutVerifiedByInput, CorrectiveActionUncheckedCreateWithoutVerifiedByInput>
  }

  export type CorrectiveActionCreateManyVerifiedByInputEnvelope = {
    data: CorrectiveActionCreateManyVerifiedByInput | CorrectiveActionCreateManyVerifiedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditDocumentCreateWithoutUploadedByInput = {
    id?: string
    title: string
    description?: string | null
    documentType: $Enums.AuditDocumentType
    fileUrl: string
    filePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutDocumentsInput
  }

  export type AuditDocumentUncheckedCreateWithoutUploadedByInput = {
    id?: string
    auditId: string
    title: string
    description?: string | null
    documentType: $Enums.AuditDocumentType
    fileUrl: string
    filePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditDocumentCreateOrConnectWithoutUploadedByInput = {
    where: AuditDocumentWhereUniqueInput
    create: XOR<AuditDocumentCreateWithoutUploadedByInput, AuditDocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type AuditDocumentCreateManyUploadedByInputEnvelope = {
    data: AuditDocumentCreateManyUploadedByInput | AuditDocumentCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditReminderCreateWithoutCreatedByInput = {
    id?: string
    title: string
    message: string
    dueDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    audit: AuditCreateNestedOneWithoutRemindersInput
    recipient: UserCreateNestedOneWithoutReceivedRemindersInput
  }

  export type AuditReminderUncheckedCreateWithoutCreatedByInput = {
    id?: string
    auditId: string
    title: string
    message: string
    dueDate: Date | string
    status: string
    recipientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
  }

  export type AuditReminderCreateOrConnectWithoutCreatedByInput = {
    where: AuditReminderWhereUniqueInput
    create: XOR<AuditReminderCreateWithoutCreatedByInput, AuditReminderUncheckedCreateWithoutCreatedByInput>
  }

  export type AuditReminderCreateManyCreatedByInputEnvelope = {
    data: AuditReminderCreateManyCreatedByInput | AuditReminderCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditReminderCreateWithoutRecipientInput = {
    id?: string
    title: string
    message: string
    dueDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    audit: AuditCreateNestedOneWithoutRemindersInput
    createdBy: UserCreateNestedOneWithoutCreatedRemindersInput
  }

  export type AuditReminderUncheckedCreateWithoutRecipientInput = {
    id?: string
    auditId: string
    title: string
    message: string
    dueDate: Date | string
    status: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
  }

  export type AuditReminderCreateOrConnectWithoutRecipientInput = {
    where: AuditReminderWhereUniqueInput
    create: XOR<AuditReminderCreateWithoutRecipientInput, AuditReminderUncheckedCreateWithoutRecipientInput>
  }

  export type AuditReminderCreateManyRecipientInputEnvelope = {
    data: AuditReminderCreateManyRecipientInput | AuditReminderCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type AuditNotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    audit: AuditCreateNestedOneWithoutNotificationsInput
  }

  export type AuditNotificationUncheckedCreateWithoutUserInput = {
    id?: string
    auditId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type AuditNotificationCreateOrConnectWithoutUserInput = {
    where: AuditNotificationWhereUniqueInput
    create: XOR<AuditNotificationCreateWithoutUserInput, AuditNotificationUncheckedCreateWithoutUserInput>
  }

  export type AuditNotificationCreateManyUserInputEnvelope = {
    data: AuditNotificationCreateManyUserInput | AuditNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PreAuditChecklistItemCreateWithoutResponsibleInput = {
    id?: string
    description: string
    isCompleted?: boolean
    comments?: string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutChecklistItemsInput
    createdBy: UserCreateNestedOneWithoutCreatedChecklistItemsInput
  }

  export type PreAuditChecklistItemUncheckedCreateWithoutResponsibleInput = {
    id?: string
    auditId: string
    description: string
    isCompleted?: boolean
    comments?: string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreAuditChecklistItemCreateOrConnectWithoutResponsibleInput = {
    where: PreAuditChecklistItemWhereUniqueInput
    create: XOR<PreAuditChecklistItemCreateWithoutResponsibleInput, PreAuditChecklistItemUncheckedCreateWithoutResponsibleInput>
  }

  export type PreAuditChecklistItemCreateManyResponsibleInputEnvelope = {
    data: PreAuditChecklistItemCreateManyResponsibleInput | PreAuditChecklistItemCreateManyResponsibleInput[]
    skipDuplicates?: boolean
  }

  export type PreAuditChecklistItemCreateWithoutCreatedByInput = {
    id?: string
    description: string
    isCompleted?: boolean
    comments?: string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutChecklistItemsInput
    responsible: UserCreateNestedOneWithoutResponsibleForChecklistItemsInput
  }

  export type PreAuditChecklistItemUncheckedCreateWithoutCreatedByInput = {
    id?: string
    auditId: string
    description: string
    isCompleted?: boolean
    comments?: string | null
    responsibleId: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreAuditChecklistItemCreateOrConnectWithoutCreatedByInput = {
    where: PreAuditChecklistItemWhereUniqueInput
    create: XOR<PreAuditChecklistItemCreateWithoutCreatedByInput, PreAuditChecklistItemUncheckedCreateWithoutCreatedByInput>
  }

  export type PreAuditChecklistItemCreateManyCreatedByInputEnvelope = {
    data: PreAuditChecklistItemCreateManyCreatedByInput | PreAuditChecklistItemCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditInspectionItemCreateWithoutInspectedByInput = {
    id?: string
    areaName: string
    itemName: string
    description?: string | null
    standardReference?: string | null
    isCompliant?: boolean | null
    comments?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutInspectionItemsInput
  }

  export type AuditInspectionItemUncheckedCreateWithoutInspectedByInput = {
    id?: string
    auditId: string
    areaName: string
    itemName: string
    description?: string | null
    standardReference?: string | null
    isCompliant?: boolean | null
    comments?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditInspectionItemCreateOrConnectWithoutInspectedByInput = {
    where: AuditInspectionItemWhereUniqueInput
    create: XOR<AuditInspectionItemCreateWithoutInspectedByInput, AuditInspectionItemUncheckedCreateWithoutInspectedByInput>
  }

  export type AuditInspectionItemCreateManyInspectedByInputEnvelope = {
    data: AuditInspectionItemCreateManyInspectedByInput | AuditInspectionItemCreateManyInspectedByInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackFormCreateWithoutUploadedByInput = {
    id?: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
    training: TrainingCreateNestedOneWithoutFeedbackFormsInput
    session: TrainingSessionCreateNestedOneWithoutFeedbackFormsInput
    participant: ParticipantCreateNestedOneWithoutFeedbackFormsInput
  }

  export type FeedbackFormUncheckedCreateWithoutUploadedByInput = {
    id?: string
    trainingId: string
    sessionId: string
    participantId: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
  }

  export type FeedbackFormCreateOrConnectWithoutUploadedByInput = {
    where: FeedbackFormWhereUniqueInput
    create: XOR<FeedbackFormCreateWithoutUploadedByInput, FeedbackFormUncheckedCreateWithoutUploadedByInput>
  }

  export type FeedbackFormCreateManyUploadedByInputEnvelope = {
    data: FeedbackFormCreateManyUploadedByInput | FeedbackFormCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type TrainingSessionPhotoCreateWithoutUploadedByInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
    session: TrainingSessionCreateNestedOneWithoutPhotosInput
  }

  export type TrainingSessionPhotoUncheckedCreateWithoutUploadedByInput = {
    id?: string
    sessionId: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
  }

  export type TrainingSessionPhotoCreateOrConnectWithoutUploadedByInput = {
    where: TrainingSessionPhotoWhereUniqueInput
    create: XOR<TrainingSessionPhotoCreateWithoutUploadedByInput, TrainingSessionPhotoUncheckedCreateWithoutUploadedByInput>
  }

  export type TrainingSessionPhotoCreateManyUploadedByInputEnvelope = {
    data: TrainingSessionPhotoCreateManyUploadedByInput | TrainingSessionPhotoCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type BatchUpsertWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedUpdateWithoutUser_Batch_checkerIdToUserInput>
    create: XOR<BatchCreateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedUpdateWithoutUser_Batch_checkerIdToUserInput>
  }

  export type BatchUpdateManyWithWhereWithoutUser_Batch_checkerIdToUserInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserInput>
  }

  export type BatchUpsertWithWhereUniqueWithoutUser_Batch_makerIdToUserInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedUpdateWithoutUser_Batch_makerIdToUserInput>
    create: XOR<BatchCreateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutUser_Batch_makerIdToUserInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedUpdateWithoutUser_Batch_makerIdToUserInput>
  }

  export type BatchUpdateManyWithWhereWithoutUser_Batch_makerIdToUserInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type RoleUpsertWithoutUserInput = {
    update: XOR<RoleUpdateWithoutUserInput, RoleUncheckedUpdateWithoutUserInput>
    create: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserInput, RoleUncheckedUpdateWithoutUserInput>
  }

  export type RoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Permission?: PermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Permission?: PermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type StandardUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: StandardWhereUniqueInput
    update: XOR<StandardUpdateWithoutCreatedByInput, StandardUncheckedUpdateWithoutCreatedByInput>
    create: XOR<StandardCreateWithoutCreatedByInput, StandardUncheckedCreateWithoutCreatedByInput>
  }

  export type StandardUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: StandardWhereUniqueInput
    data: XOR<StandardUpdateWithoutCreatedByInput, StandardUncheckedUpdateWithoutCreatedByInput>
  }

  export type StandardUpdateManyWithWhereWithoutCreatedByInput = {
    where: StandardScalarWhereInput
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type StandardUpsertWithWhereUniqueWithoutModifiedByInput = {
    where: StandardWhereUniqueInput
    update: XOR<StandardUpdateWithoutModifiedByInput, StandardUncheckedUpdateWithoutModifiedByInput>
    create: XOR<StandardCreateWithoutModifiedByInput, StandardUncheckedCreateWithoutModifiedByInput>
  }

  export type StandardUpdateWithWhereUniqueWithoutModifiedByInput = {
    where: StandardWhereUniqueInput
    data: XOR<StandardUpdateWithoutModifiedByInput, StandardUncheckedUpdateWithoutModifiedByInput>
  }

  export type StandardUpdateManyWithWhereWithoutModifiedByInput = {
    where: StandardScalarWhereInput
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyWithoutModifiedByInput>
  }

  export type StandardDefinitionUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: StandardDefinitionWhereUniqueInput
    update: XOR<StandardDefinitionUpdateWithoutCreatedByInput, StandardDefinitionUncheckedUpdateWithoutCreatedByInput>
    create: XOR<StandardDefinitionCreateWithoutCreatedByInput, StandardDefinitionUncheckedCreateWithoutCreatedByInput>
  }

  export type StandardDefinitionUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: StandardDefinitionWhereUniqueInput
    data: XOR<StandardDefinitionUpdateWithoutCreatedByInput, StandardDefinitionUncheckedUpdateWithoutCreatedByInput>
  }

  export type StandardDefinitionUpdateManyWithWhereWithoutCreatedByInput = {
    where: StandardDefinitionScalarWhereInput
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type StandardDefinitionUpsertWithWhereUniqueWithoutModifiedByInput = {
    where: StandardDefinitionWhereUniqueInput
    update: XOR<StandardDefinitionUpdateWithoutModifiedByInput, StandardDefinitionUncheckedUpdateWithoutModifiedByInput>
    create: XOR<StandardDefinitionCreateWithoutModifiedByInput, StandardDefinitionUncheckedCreateWithoutModifiedByInput>
  }

  export type StandardDefinitionUpdateWithWhereUniqueWithoutModifiedByInput = {
    where: StandardDefinitionWhereUniqueInput
    data: XOR<StandardDefinitionUpdateWithoutModifiedByInput, StandardDefinitionUncheckedUpdateWithoutModifiedByInput>
  }

  export type StandardDefinitionUpdateManyWithWhereWithoutModifiedByInput = {
    where: StandardDefinitionScalarWhereInput
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyWithoutModifiedByInput>
  }

  export type TrainingUpsertWithWhereUniqueWithoutTrainerInput = {
    where: TrainingWhereUniqueInput
    update: XOR<TrainingUpdateWithoutTrainerInput, TrainingUncheckedUpdateWithoutTrainerInput>
    create: XOR<TrainingCreateWithoutTrainerInput, TrainingUncheckedCreateWithoutTrainerInput>
  }

  export type TrainingUpdateWithWhereUniqueWithoutTrainerInput = {
    where: TrainingWhereUniqueInput
    data: XOR<TrainingUpdateWithoutTrainerInput, TrainingUncheckedUpdateWithoutTrainerInput>
  }

  export type TrainingUpdateManyWithWhereWithoutTrainerInput = {
    where: TrainingScalarWhereInput
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyWithoutTrainerInput>
  }

  export type TrainingScalarWhereInput = {
    AND?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
    OR?: TrainingScalarWhereInput[]
    NOT?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
    id?: StringFilter<"Training"> | string
    title?: StringFilter<"Training"> | string
    description?: StringNullableFilter<"Training"> | string | null
    trainingType?: EnumTrainingTypeFilter<"Training"> | $Enums.TrainingType
    status?: EnumTrainingStatusFilter<"Training"> | $Enums.TrainingStatus
    startDate?: DateTimeFilter<"Training"> | Date | string
    endDate?: DateTimeFilter<"Training"> | Date | string
    location?: StringFilter<"Training"> | string
    maxParticipants?: IntNullableFilter<"Training"> | number | null
    trainerId?: StringFilter<"Training"> | string
    calendarId?: StringFilter<"Training"> | string
    createdById?: StringFilter<"Training"> | string
    createdAt?: DateTimeFilter<"Training"> | Date | string
    updatedAt?: DateTimeFilter<"Training"> | Date | string
  }

  export type TrainingUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TrainingWhereUniqueInput
    update: XOR<TrainingUpdateWithoutCreatedByInput, TrainingUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TrainingCreateWithoutCreatedByInput, TrainingUncheckedCreateWithoutCreatedByInput>
  }

  export type TrainingUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TrainingWhereUniqueInput
    data: XOR<TrainingUpdateWithoutCreatedByInput, TrainingUncheckedUpdateWithoutCreatedByInput>
  }

  export type TrainingUpdateManyWithWhereWithoutCreatedByInput = {
    where: TrainingScalarWhereInput
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TrainingDocumentUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: TrainingDocumentWhereUniqueInput
    update: XOR<TrainingDocumentUpdateWithoutUploadedByInput, TrainingDocumentUncheckedUpdateWithoutUploadedByInput>
    create: XOR<TrainingDocumentCreateWithoutUploadedByInput, TrainingDocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type TrainingDocumentUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: TrainingDocumentWhereUniqueInput
    data: XOR<TrainingDocumentUpdateWithoutUploadedByInput, TrainingDocumentUncheckedUpdateWithoutUploadedByInput>
  }

  export type TrainingDocumentUpdateManyWithWhereWithoutUploadedByInput = {
    where: TrainingDocumentScalarWhereInput
    data: XOR<TrainingDocumentUpdateManyMutationInput, TrainingDocumentUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type TrainingDocumentScalarWhereInput = {
    AND?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
    OR?: TrainingDocumentScalarWhereInput[]
    NOT?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
    id?: StringFilter<"TrainingDocument"> | string
    trainingId?: StringFilter<"TrainingDocument"> | string
    sessionId?: StringNullableFilter<"TrainingDocument"> | string | null
    title?: StringFilter<"TrainingDocument"> | string
    description?: StringNullableFilter<"TrainingDocument"> | string | null
    fileUrl?: StringFilter<"TrainingDocument"> | string
    filePath?: StringNullableFilter<"TrainingDocument"> | string | null
    documentType?: EnumDocumentTypeFilter<"TrainingDocument"> | $Enums.DocumentType
    uploadedById?: StringFilter<"TrainingDocument"> | string
    createdAt?: DateTimeFilter<"TrainingDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDocument"> | Date | string
  }

  export type TrainingPhotoUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: TrainingPhotoWhereUniqueInput
    update: XOR<TrainingPhotoUpdateWithoutUploadedByInput, TrainingPhotoUncheckedUpdateWithoutUploadedByInput>
    create: XOR<TrainingPhotoCreateWithoutUploadedByInput, TrainingPhotoUncheckedCreateWithoutUploadedByInput>
  }

  export type TrainingPhotoUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: TrainingPhotoWhereUniqueInput
    data: XOR<TrainingPhotoUpdateWithoutUploadedByInput, TrainingPhotoUncheckedUpdateWithoutUploadedByInput>
  }

  export type TrainingPhotoUpdateManyWithWhereWithoutUploadedByInput = {
    where: TrainingPhotoScalarWhereInput
    data: XOR<TrainingPhotoUpdateManyMutationInput, TrainingPhotoUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type TrainingPhotoScalarWhereInput = {
    AND?: TrainingPhotoScalarWhereInput | TrainingPhotoScalarWhereInput[]
    OR?: TrainingPhotoScalarWhereInput[]
    NOT?: TrainingPhotoScalarWhereInput | TrainingPhotoScalarWhereInput[]
    id?: StringFilter<"TrainingPhoto"> | string
    trainingId?: StringFilter<"TrainingPhoto"> | string
    photoUrl?: StringFilter<"TrainingPhoto"> | string
    caption?: StringNullableFilter<"TrainingPhoto"> | string | null
    uploadedById?: StringFilter<"TrainingPhoto"> | string
    createdAt?: DateTimeFilter<"TrainingPhoto"> | Date | string
  }

  export type TrainingFollowupUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: TrainingFollowupWhereUniqueInput
    update: XOR<TrainingFollowupUpdateWithoutAssignedToInput, TrainingFollowupUncheckedUpdateWithoutAssignedToInput>
    create: XOR<TrainingFollowupCreateWithoutAssignedToInput, TrainingFollowupUncheckedCreateWithoutAssignedToInput>
  }

  export type TrainingFollowupUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: TrainingFollowupWhereUniqueInput
    data: XOR<TrainingFollowupUpdateWithoutAssignedToInput, TrainingFollowupUncheckedUpdateWithoutAssignedToInput>
  }

  export type TrainingFollowupUpdateManyWithWhereWithoutAssignedToInput = {
    where: TrainingFollowupScalarWhereInput
    data: XOR<TrainingFollowupUpdateManyMutationInput, TrainingFollowupUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type TrainingFollowupScalarWhereInput = {
    AND?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
    OR?: TrainingFollowupScalarWhereInput[]
    NOT?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
    id?: StringFilter<"TrainingFollowup"> | string
    trainingId?: StringFilter<"TrainingFollowup"> | string
    title?: StringFilter<"TrainingFollowup"> | string
    description?: StringFilter<"TrainingFollowup"> | string
    dueDate?: DateTimeNullableFilter<"TrainingFollowup"> | Date | string | null
    isCompleted?: BoolFilter<"TrainingFollowup"> | boolean
    assignedToId?: StringFilter<"TrainingFollowup"> | string
    createdById?: StringFilter<"TrainingFollowup"> | string
    createdAt?: DateTimeFilter<"TrainingFollowup"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingFollowup"> | Date | string
    completedAt?: DateTimeNullableFilter<"TrainingFollowup"> | Date | string | null
  }

  export type TrainingFollowupUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TrainingFollowupWhereUniqueInput
    update: XOR<TrainingFollowupUpdateWithoutCreatedByInput, TrainingFollowupUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TrainingFollowupCreateWithoutCreatedByInput, TrainingFollowupUncheckedCreateWithoutCreatedByInput>
  }

  export type TrainingFollowupUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TrainingFollowupWhereUniqueInput
    data: XOR<TrainingFollowupUpdateWithoutCreatedByInput, TrainingFollowupUncheckedUpdateWithoutCreatedByInput>
  }

  export type TrainingFollowupUpdateManyWithWhereWithoutCreatedByInput = {
    where: TrainingFollowupScalarWhereInput
    data: XOR<TrainingFollowupUpdateManyMutationInput, TrainingFollowupUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TrainingNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: TrainingNotificationWhereUniqueInput
    update: XOR<TrainingNotificationUpdateWithoutUserInput, TrainingNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<TrainingNotificationCreateWithoutUserInput, TrainingNotificationUncheckedCreateWithoutUserInput>
  }

  export type TrainingNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: TrainingNotificationWhereUniqueInput
    data: XOR<TrainingNotificationUpdateWithoutUserInput, TrainingNotificationUncheckedUpdateWithoutUserInput>
  }

  export type TrainingNotificationUpdateManyWithWhereWithoutUserInput = {
    where: TrainingNotificationScalarWhereInput
    data: XOR<TrainingNotificationUpdateManyMutationInput, TrainingNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type TrainingNotificationScalarWhereInput = {
    AND?: TrainingNotificationScalarWhereInput | TrainingNotificationScalarWhereInput[]
    OR?: TrainingNotificationScalarWhereInput[]
    NOT?: TrainingNotificationScalarWhereInput | TrainingNotificationScalarWhereInput[]
    id?: StringFilter<"TrainingNotification"> | string
    trainingId?: StringFilter<"TrainingNotification"> | string
    userId?: StringFilter<"TrainingNotification"> | string
    title?: StringFilter<"TrainingNotification"> | string
    message?: StringFilter<"TrainingNotification"> | string
    isRead?: BoolFilter<"TrainingNotification"> | boolean
    sentAt?: DateTimeFilter<"TrainingNotification"> | Date | string
    readAt?: DateTimeNullableFilter<"TrainingNotification"> | Date | string | null
  }

  export type AuditorUpsertWithoutUserInput = {
    update: XOR<AuditorUpdateWithoutUserInput, AuditorUncheckedUpdateWithoutUserInput>
    create: XOR<AuditorCreateWithoutUserInput, AuditorUncheckedCreateWithoutUserInput>
    where?: AuditorWhereInput
  }

  export type AuditorUpdateToOneWithWhereWithoutUserInput = {
    where?: AuditorWhereInput
    data: XOR<AuditorUpdateWithoutUserInput, AuditorUncheckedUpdateWithoutUserInput>
  }

  export type AuditorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUpdateManyWithoutAuditorNestedInput
  }

  export type AuditorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditUncheckedUpdateManyWithoutAuditorNestedInput
  }

  export type AuditUpsertWithWhereUniqueWithoutAuditeeInput = {
    where: AuditWhereUniqueInput
    update: XOR<AuditUpdateWithoutAuditeeInput, AuditUncheckedUpdateWithoutAuditeeInput>
    create: XOR<AuditCreateWithoutAuditeeInput, AuditUncheckedCreateWithoutAuditeeInput>
  }

  export type AuditUpdateWithWhereUniqueWithoutAuditeeInput = {
    where: AuditWhereUniqueInput
    data: XOR<AuditUpdateWithoutAuditeeInput, AuditUncheckedUpdateWithoutAuditeeInput>
  }

  export type AuditUpdateManyWithWhereWithoutAuditeeInput = {
    where: AuditScalarWhereInput
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyWithoutAuditeeInput>
  }

  export type AuditScalarWhereInput = {
    AND?: AuditScalarWhereInput | AuditScalarWhereInput[]
    OR?: AuditScalarWhereInput[]
    NOT?: AuditScalarWhereInput | AuditScalarWhereInput[]
    id?: StringFilter<"Audit"> | string
    name?: StringFilter<"Audit"> | string
    auditType?: EnumAuditTypeFilter<"Audit"> | $Enums.AuditType
    status?: EnumAuditStatusFilter<"Audit"> | $Enums.AuditStatus
    startDate?: DateTimeFilter<"Audit"> | Date | string
    endDate?: DateTimeNullableFilter<"Audit"> | Date | string | null
    auditorId?: StringFilter<"Audit"> | string
    auditeeId?: StringNullableFilter<"Audit"> | string | null
    firmName?: StringNullableFilter<"Audit"> | string | null
    departmentId?: StringNullableFilter<"Audit"> | string | null
    objectives?: StringNullableFilter<"Audit"> | string | null
    scope?: StringNullableFilter<"Audit"> | string | null
    summary?: StringNullableFilter<"Audit"> | string | null
    createdById?: StringFilter<"Audit"> | string
    createdAt?: DateTimeFilter<"Audit"> | Date | string
    updatedAt?: DateTimeFilter<"Audit"> | Date | string
  }

  export type AuditUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AuditWhereUniqueInput
    update: XOR<AuditUpdateWithoutCreatedByInput, AuditUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput>
  }

  export type AuditUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AuditWhereUniqueInput
    data: XOR<AuditUpdateWithoutCreatedByInput, AuditUncheckedUpdateWithoutCreatedByInput>
  }

  export type AuditUpdateManyWithWhereWithoutCreatedByInput = {
    where: AuditScalarWhereInput
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type FindingUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: FindingWhereUniqueInput
    update: XOR<FindingUpdateWithoutAssignedToInput, FindingUncheckedUpdateWithoutAssignedToInput>
    create: XOR<FindingCreateWithoutAssignedToInput, FindingUncheckedCreateWithoutAssignedToInput>
  }

  export type FindingUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: FindingWhereUniqueInput
    data: XOR<FindingUpdateWithoutAssignedToInput, FindingUncheckedUpdateWithoutAssignedToInput>
  }

  export type FindingUpdateManyWithWhereWithoutAssignedToInput = {
    where: FindingScalarWhereInput
    data: XOR<FindingUpdateManyMutationInput, FindingUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type FindingScalarWhereInput = {
    AND?: FindingScalarWhereInput | FindingScalarWhereInput[]
    OR?: FindingScalarWhereInput[]
    NOT?: FindingScalarWhereInput | FindingScalarWhereInput[]
    id?: StringFilter<"Finding"> | string
    auditId?: StringFilter<"Finding"> | string
    title?: StringFilter<"Finding"> | string
    description?: StringFilter<"Finding"> | string
    findingType?: EnumFindingTypeFilter<"Finding"> | $Enums.FindingType
    status?: EnumFindingStatusFilter<"Finding"> | $Enums.FindingStatus
    priority?: EnumPriorityNullableFilter<"Finding"> | $Enums.Priority | null
    dueDate?: DateTimeNullableFilter<"Finding"> | Date | string | null
    assignedToId?: StringNullableFilter<"Finding"> | string | null
    evidence?: StringNullableFilter<"Finding"> | string | null
    createdAt?: DateTimeFilter<"Finding"> | Date | string
    updatedAt?: DateTimeFilter<"Finding"> | Date | string
    closedAt?: DateTimeNullableFilter<"Finding"> | Date | string | null
  }

  export type CorrectiveActionUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: CorrectiveActionWhereUniqueInput
    update: XOR<CorrectiveActionUpdateWithoutAssignedToInput, CorrectiveActionUncheckedUpdateWithoutAssignedToInput>
    create: XOR<CorrectiveActionCreateWithoutAssignedToInput, CorrectiveActionUncheckedCreateWithoutAssignedToInput>
  }

  export type CorrectiveActionUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: CorrectiveActionWhereUniqueInput
    data: XOR<CorrectiveActionUpdateWithoutAssignedToInput, CorrectiveActionUncheckedUpdateWithoutAssignedToInput>
  }

  export type CorrectiveActionUpdateManyWithWhereWithoutAssignedToInput = {
    where: CorrectiveActionScalarWhereInput
    data: XOR<CorrectiveActionUpdateManyMutationInput, CorrectiveActionUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type CorrectiveActionScalarWhereInput = {
    AND?: CorrectiveActionScalarWhereInput | CorrectiveActionScalarWhereInput[]
    OR?: CorrectiveActionScalarWhereInput[]
    NOT?: CorrectiveActionScalarWhereInput | CorrectiveActionScalarWhereInput[]
    id?: StringFilter<"CorrectiveAction"> | string
    auditId?: StringFilter<"CorrectiveAction"> | string
    findingId?: StringNullableFilter<"CorrectiveAction"> | string | null
    title?: StringFilter<"CorrectiveAction"> | string
    description?: StringFilter<"CorrectiveAction"> | string
    actionType?: StringFilter<"CorrectiveAction"> | string
    assignedToId?: StringFilter<"CorrectiveAction"> | string
    dueDate?: DateTimeFilter<"CorrectiveAction"> | Date | string
    status?: StringFilter<"CorrectiveAction"> | string
    completedAt?: DateTimeNullableFilter<"CorrectiveAction"> | Date | string | null
    verifiedAt?: DateTimeNullableFilter<"CorrectiveAction"> | Date | string | null
    verifiedById?: StringNullableFilter<"CorrectiveAction"> | string | null
    evidence?: StringNullableFilter<"CorrectiveAction"> | string | null
    createdAt?: DateTimeFilter<"CorrectiveAction"> | Date | string
    updatedAt?: DateTimeFilter<"CorrectiveAction"> | Date | string
  }

  export type CorrectiveActionUpsertWithWhereUniqueWithoutVerifiedByInput = {
    where: CorrectiveActionWhereUniqueInput
    update: XOR<CorrectiveActionUpdateWithoutVerifiedByInput, CorrectiveActionUncheckedUpdateWithoutVerifiedByInput>
    create: XOR<CorrectiveActionCreateWithoutVerifiedByInput, CorrectiveActionUncheckedCreateWithoutVerifiedByInput>
  }

  export type CorrectiveActionUpdateWithWhereUniqueWithoutVerifiedByInput = {
    where: CorrectiveActionWhereUniqueInput
    data: XOR<CorrectiveActionUpdateWithoutVerifiedByInput, CorrectiveActionUncheckedUpdateWithoutVerifiedByInput>
  }

  export type CorrectiveActionUpdateManyWithWhereWithoutVerifiedByInput = {
    where: CorrectiveActionScalarWhereInput
    data: XOR<CorrectiveActionUpdateManyMutationInput, CorrectiveActionUncheckedUpdateManyWithoutVerifiedByInput>
  }

  export type AuditDocumentUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: AuditDocumentWhereUniqueInput
    update: XOR<AuditDocumentUpdateWithoutUploadedByInput, AuditDocumentUncheckedUpdateWithoutUploadedByInput>
    create: XOR<AuditDocumentCreateWithoutUploadedByInput, AuditDocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type AuditDocumentUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: AuditDocumentWhereUniqueInput
    data: XOR<AuditDocumentUpdateWithoutUploadedByInput, AuditDocumentUncheckedUpdateWithoutUploadedByInput>
  }

  export type AuditDocumentUpdateManyWithWhereWithoutUploadedByInput = {
    where: AuditDocumentScalarWhereInput
    data: XOR<AuditDocumentUpdateManyMutationInput, AuditDocumentUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type AuditDocumentScalarWhereInput = {
    AND?: AuditDocumentScalarWhereInput | AuditDocumentScalarWhereInput[]
    OR?: AuditDocumentScalarWhereInput[]
    NOT?: AuditDocumentScalarWhereInput | AuditDocumentScalarWhereInput[]
    id?: StringFilter<"AuditDocument"> | string
    auditId?: StringFilter<"AuditDocument"> | string
    title?: StringFilter<"AuditDocument"> | string
    description?: StringNullableFilter<"AuditDocument"> | string | null
    documentType?: EnumAuditDocumentTypeFilter<"AuditDocument"> | $Enums.AuditDocumentType
    fileUrl?: StringFilter<"AuditDocument"> | string
    filePath?: StringNullableFilter<"AuditDocument"> | string | null
    uploadedById?: StringFilter<"AuditDocument"> | string
    createdAt?: DateTimeFilter<"AuditDocument"> | Date | string
    updatedAt?: DateTimeFilter<"AuditDocument"> | Date | string
  }

  export type AuditReminderUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AuditReminderWhereUniqueInput
    update: XOR<AuditReminderUpdateWithoutCreatedByInput, AuditReminderUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AuditReminderCreateWithoutCreatedByInput, AuditReminderUncheckedCreateWithoutCreatedByInput>
  }

  export type AuditReminderUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AuditReminderWhereUniqueInput
    data: XOR<AuditReminderUpdateWithoutCreatedByInput, AuditReminderUncheckedUpdateWithoutCreatedByInput>
  }

  export type AuditReminderUpdateManyWithWhereWithoutCreatedByInput = {
    where: AuditReminderScalarWhereInput
    data: XOR<AuditReminderUpdateManyMutationInput, AuditReminderUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AuditReminderScalarWhereInput = {
    AND?: AuditReminderScalarWhereInput | AuditReminderScalarWhereInput[]
    OR?: AuditReminderScalarWhereInput[]
    NOT?: AuditReminderScalarWhereInput | AuditReminderScalarWhereInput[]
    id?: StringFilter<"AuditReminder"> | string
    auditId?: StringFilter<"AuditReminder"> | string
    title?: StringFilter<"AuditReminder"> | string
    message?: StringFilter<"AuditReminder"> | string
    dueDate?: DateTimeFilter<"AuditReminder"> | Date | string
    status?: StringFilter<"AuditReminder"> | string
    recipientId?: StringFilter<"AuditReminder"> | string
    createdById?: StringFilter<"AuditReminder"> | string
    createdAt?: DateTimeFilter<"AuditReminder"> | Date | string
    updatedAt?: DateTimeFilter<"AuditReminder"> | Date | string
    sentAt?: DateTimeNullableFilter<"AuditReminder"> | Date | string | null
  }

  export type AuditReminderUpsertWithWhereUniqueWithoutRecipientInput = {
    where: AuditReminderWhereUniqueInput
    update: XOR<AuditReminderUpdateWithoutRecipientInput, AuditReminderUncheckedUpdateWithoutRecipientInput>
    create: XOR<AuditReminderCreateWithoutRecipientInput, AuditReminderUncheckedCreateWithoutRecipientInput>
  }

  export type AuditReminderUpdateWithWhereUniqueWithoutRecipientInput = {
    where: AuditReminderWhereUniqueInput
    data: XOR<AuditReminderUpdateWithoutRecipientInput, AuditReminderUncheckedUpdateWithoutRecipientInput>
  }

  export type AuditReminderUpdateManyWithWhereWithoutRecipientInput = {
    where: AuditReminderScalarWhereInput
    data: XOR<AuditReminderUpdateManyMutationInput, AuditReminderUncheckedUpdateManyWithoutRecipientInput>
  }

  export type AuditNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditNotificationWhereUniqueInput
    update: XOR<AuditNotificationUpdateWithoutUserInput, AuditNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<AuditNotificationCreateWithoutUserInput, AuditNotificationUncheckedCreateWithoutUserInput>
  }

  export type AuditNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditNotificationWhereUniqueInput
    data: XOR<AuditNotificationUpdateWithoutUserInput, AuditNotificationUncheckedUpdateWithoutUserInput>
  }

  export type AuditNotificationUpdateManyWithWhereWithoutUserInput = {
    where: AuditNotificationScalarWhereInput
    data: XOR<AuditNotificationUpdateManyMutationInput, AuditNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditNotificationScalarWhereInput = {
    AND?: AuditNotificationScalarWhereInput | AuditNotificationScalarWhereInput[]
    OR?: AuditNotificationScalarWhereInput[]
    NOT?: AuditNotificationScalarWhereInput | AuditNotificationScalarWhereInput[]
    id?: StringFilter<"AuditNotification"> | string
    auditId?: StringFilter<"AuditNotification"> | string
    userId?: StringFilter<"AuditNotification"> | string
    title?: StringFilter<"AuditNotification"> | string
    message?: StringFilter<"AuditNotification"> | string
    isRead?: BoolFilter<"AuditNotification"> | boolean
    sentAt?: DateTimeFilter<"AuditNotification"> | Date | string
    readAt?: DateTimeNullableFilter<"AuditNotification"> | Date | string | null
  }

  export type PreAuditChecklistItemUpsertWithWhereUniqueWithoutResponsibleInput = {
    where: PreAuditChecklistItemWhereUniqueInput
    update: XOR<PreAuditChecklistItemUpdateWithoutResponsibleInput, PreAuditChecklistItemUncheckedUpdateWithoutResponsibleInput>
    create: XOR<PreAuditChecklistItemCreateWithoutResponsibleInput, PreAuditChecklistItemUncheckedCreateWithoutResponsibleInput>
  }

  export type PreAuditChecklistItemUpdateWithWhereUniqueWithoutResponsibleInput = {
    where: PreAuditChecklistItemWhereUniqueInput
    data: XOR<PreAuditChecklistItemUpdateWithoutResponsibleInput, PreAuditChecklistItemUncheckedUpdateWithoutResponsibleInput>
  }

  export type PreAuditChecklistItemUpdateManyWithWhereWithoutResponsibleInput = {
    where: PreAuditChecklistItemScalarWhereInput
    data: XOR<PreAuditChecklistItemUpdateManyMutationInput, PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleInput>
  }

  export type PreAuditChecklistItemScalarWhereInput = {
    AND?: PreAuditChecklistItemScalarWhereInput | PreAuditChecklistItemScalarWhereInput[]
    OR?: PreAuditChecklistItemScalarWhereInput[]
    NOT?: PreAuditChecklistItemScalarWhereInput | PreAuditChecklistItemScalarWhereInput[]
    id?: StringFilter<"PreAuditChecklistItem"> | string
    auditId?: StringFilter<"PreAuditChecklistItem"> | string
    description?: StringFilter<"PreAuditChecklistItem"> | string
    isCompleted?: BoolFilter<"PreAuditChecklistItem"> | boolean
    comments?: StringNullableFilter<"PreAuditChecklistItem"> | string | null
    responsibleId?: StringFilter<"PreAuditChecklistItem"> | string
    dueDate?: DateTimeNullableFilter<"PreAuditChecklistItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PreAuditChecklistItem"> | Date | string | null
    createdById?: StringFilter<"PreAuditChecklistItem"> | string
    createdAt?: DateTimeFilter<"PreAuditChecklistItem"> | Date | string
    updatedAt?: DateTimeFilter<"PreAuditChecklistItem"> | Date | string
  }

  export type PreAuditChecklistItemUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PreAuditChecklistItemWhereUniqueInput
    update: XOR<PreAuditChecklistItemUpdateWithoutCreatedByInput, PreAuditChecklistItemUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PreAuditChecklistItemCreateWithoutCreatedByInput, PreAuditChecklistItemUncheckedCreateWithoutCreatedByInput>
  }

  export type PreAuditChecklistItemUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PreAuditChecklistItemWhereUniqueInput
    data: XOR<PreAuditChecklistItemUpdateWithoutCreatedByInput, PreAuditChecklistItemUncheckedUpdateWithoutCreatedByInput>
  }

  export type PreAuditChecklistItemUpdateManyWithWhereWithoutCreatedByInput = {
    where: PreAuditChecklistItemScalarWhereInput
    data: XOR<PreAuditChecklistItemUpdateManyMutationInput, PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AuditInspectionItemUpsertWithWhereUniqueWithoutInspectedByInput = {
    where: AuditInspectionItemWhereUniqueInput
    update: XOR<AuditInspectionItemUpdateWithoutInspectedByInput, AuditInspectionItemUncheckedUpdateWithoutInspectedByInput>
    create: XOR<AuditInspectionItemCreateWithoutInspectedByInput, AuditInspectionItemUncheckedCreateWithoutInspectedByInput>
  }

  export type AuditInspectionItemUpdateWithWhereUniqueWithoutInspectedByInput = {
    where: AuditInspectionItemWhereUniqueInput
    data: XOR<AuditInspectionItemUpdateWithoutInspectedByInput, AuditInspectionItemUncheckedUpdateWithoutInspectedByInput>
  }

  export type AuditInspectionItemUpdateManyWithWhereWithoutInspectedByInput = {
    where: AuditInspectionItemScalarWhereInput
    data: XOR<AuditInspectionItemUpdateManyMutationInput, AuditInspectionItemUncheckedUpdateManyWithoutInspectedByInput>
  }

  export type AuditInspectionItemScalarWhereInput = {
    AND?: AuditInspectionItemScalarWhereInput | AuditInspectionItemScalarWhereInput[]
    OR?: AuditInspectionItemScalarWhereInput[]
    NOT?: AuditInspectionItemScalarWhereInput | AuditInspectionItemScalarWhereInput[]
    id?: StringFilter<"AuditInspectionItem"> | string
    auditId?: StringFilter<"AuditInspectionItem"> | string
    areaName?: StringFilter<"AuditInspectionItem"> | string
    itemName?: StringFilter<"AuditInspectionItem"> | string
    description?: StringNullableFilter<"AuditInspectionItem"> | string | null
    standardReference?: StringNullableFilter<"AuditInspectionItem"> | string | null
    isCompliant?: BoolNullableFilter<"AuditInspectionItem"> | boolean | null
    comments?: StringNullableFilter<"AuditInspectionItem"> | string | null
    evidence?: StringNullableFilter<"AuditInspectionItem"> | string | null
    inspectedById?: StringNullableFilter<"AuditInspectionItem"> | string | null
    createdAt?: DateTimeFilter<"AuditInspectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"AuditInspectionItem"> | Date | string
  }

  export type FeedbackFormUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: FeedbackFormWhereUniqueInput
    update: XOR<FeedbackFormUpdateWithoutUploadedByInput, FeedbackFormUncheckedUpdateWithoutUploadedByInput>
    create: XOR<FeedbackFormCreateWithoutUploadedByInput, FeedbackFormUncheckedCreateWithoutUploadedByInput>
  }

  export type FeedbackFormUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: FeedbackFormWhereUniqueInput
    data: XOR<FeedbackFormUpdateWithoutUploadedByInput, FeedbackFormUncheckedUpdateWithoutUploadedByInput>
  }

  export type FeedbackFormUpdateManyWithWhereWithoutUploadedByInput = {
    where: FeedbackFormScalarWhereInput
    data: XOR<FeedbackFormUpdateManyMutationInput, FeedbackFormUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type FeedbackFormScalarWhereInput = {
    AND?: FeedbackFormScalarWhereInput | FeedbackFormScalarWhereInput[]
    OR?: FeedbackFormScalarWhereInput[]
    NOT?: FeedbackFormScalarWhereInput | FeedbackFormScalarWhereInput[]
    id?: StringFilter<"FeedbackForm"> | string
    trainingId?: StringFilter<"FeedbackForm"> | string
    sessionId?: StringFilter<"FeedbackForm"> | string
    participantId?: StringFilter<"FeedbackForm"> | string
    fileUrl?: StringFilter<"FeedbackForm"> | string
    filePath?: StringNullableFilter<"FeedbackForm"> | string | null
    submittedAt?: DateTimeFilter<"FeedbackForm"> | Date | string
    uploadedById?: StringFilter<"FeedbackForm"> | string
  }

  export type TrainingSessionPhotoUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: TrainingSessionPhotoWhereUniqueInput
    update: XOR<TrainingSessionPhotoUpdateWithoutUploadedByInput, TrainingSessionPhotoUncheckedUpdateWithoutUploadedByInput>
    create: XOR<TrainingSessionPhotoCreateWithoutUploadedByInput, TrainingSessionPhotoUncheckedCreateWithoutUploadedByInput>
  }

  export type TrainingSessionPhotoUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: TrainingSessionPhotoWhereUniqueInput
    data: XOR<TrainingSessionPhotoUpdateWithoutUploadedByInput, TrainingSessionPhotoUncheckedUpdateWithoutUploadedByInput>
  }

  export type TrainingSessionPhotoUpdateManyWithWhereWithoutUploadedByInput = {
    where: TrainingSessionPhotoScalarWhereInput
    data: XOR<TrainingSessionPhotoUpdateManyMutationInput, TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type TrainingSessionPhotoScalarWhereInput = {
    AND?: TrainingSessionPhotoScalarWhereInput | TrainingSessionPhotoScalarWhereInput[]
    OR?: TrainingSessionPhotoScalarWhereInput[]
    NOT?: TrainingSessionPhotoScalarWhereInput | TrainingSessionPhotoScalarWhereInput[]
    id?: StringFilter<"TrainingSessionPhoto"> | string
    sessionId?: StringFilter<"TrainingSessionPhoto"> | string
    photoUrl?: StringFilter<"TrainingSessionPhoto"> | string
    caption?: StringNullableFilter<"TrainingSessionPhoto"> | string | null
    uploadedById?: StringFilter<"TrainingSessionPhoto"> | string
    createdAt?: DateTimeFilter<"TrainingSessionPhoto"> | Date | string
  }

  export type StandardCategoryCreateWithoutStandardsInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parameters?: StandardParameterCreateNestedManyWithoutCategoryInput
    products?: ProductStandardCategoryCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryUncheckedCreateWithoutStandardsInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parameters?: StandardParameterUncheckedCreateNestedManyWithoutCategoryInput
    products?: ProductStandardCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryCreateOrConnectWithoutStandardsInput = {
    where: StandardCategoryWhereUniqueInput
    create: XOR<StandardCategoryCreateWithoutStandardsInput, StandardCategoryUncheckedCreateWithoutStandardsInput>
  }

  export type UserCreateWithoutStandardsCreatedInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutStandardsCreatedInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutStandardsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStandardsCreatedInput, UserUncheckedCreateWithoutStandardsCreatedInput>
  }

  export type UserCreateWithoutStandardsModifiedInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutStandardsModifiedInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutStandardsModifiedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStandardsModifiedInput, UserUncheckedCreateWithoutStandardsModifiedInput>
  }

  export type BatchCreateWithoutStandardsInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutStandardsInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutStandardsInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutStandardsInput, BatchUncheckedCreateWithoutStandardsInput>
  }

  export type MethodologyCreateWithoutStandardsInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutMethodologyInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyUncheckedCreateWithoutStandardsInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutMethodologyInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyCreateOrConnectWithoutStandardsInput = {
    where: MethodologyWhereUniqueInput
    create: XOR<MethodologyCreateWithoutStandardsInput, MethodologyUncheckedCreateWithoutStandardsInput>
  }

  export type UnitOfMeasurementCreateWithoutStandardsInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutUnitInput
    standardParameters?: StandardParameterCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutUnitInput
    batches?: BatchCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementUncheckedCreateWithoutStandardsInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutUnitInput
    standardParameters?: StandardParameterUncheckedCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutUnitInput
    batches?: BatchUncheckedCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementCreateOrConnectWithoutStandardsInput = {
    where: UnitOfMeasurementWhereUniqueInput
    create: XOR<UnitOfMeasurementCreateWithoutStandardsInput, UnitOfMeasurementUncheckedCreateWithoutStandardsInput>
  }

  export type StandardCategoryUpsertWithoutStandardsInput = {
    update: XOR<StandardCategoryUpdateWithoutStandardsInput, StandardCategoryUncheckedUpdateWithoutStandardsInput>
    create: XOR<StandardCategoryCreateWithoutStandardsInput, StandardCategoryUncheckedCreateWithoutStandardsInput>
    where?: StandardCategoryWhereInput
  }

  export type StandardCategoryUpdateToOneWithWhereWithoutStandardsInput = {
    where?: StandardCategoryWhereInput
    data: XOR<StandardCategoryUpdateWithoutStandardsInput, StandardCategoryUncheckedUpdateWithoutStandardsInput>
  }

  export type StandardCategoryUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: StandardParameterUpdateManyWithoutCategoryNestedInput
    products?: ProductStandardCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type StandardCategoryUncheckedUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: StandardParameterUncheckedUpdateManyWithoutCategoryNestedInput
    products?: ProductStandardCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type UserUpsertWithoutStandardsCreatedInput = {
    update: XOR<UserUpdateWithoutStandardsCreatedInput, UserUncheckedUpdateWithoutStandardsCreatedInput>
    create: XOR<UserCreateWithoutStandardsCreatedInput, UserUncheckedCreateWithoutStandardsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStandardsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStandardsCreatedInput, UserUncheckedUpdateWithoutStandardsCreatedInput>
  }

  export type UserUpdateWithoutStandardsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStandardsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithoutStandardsModifiedInput = {
    update: XOR<UserUpdateWithoutStandardsModifiedInput, UserUncheckedUpdateWithoutStandardsModifiedInput>
    create: XOR<UserCreateWithoutStandardsModifiedInput, UserUncheckedCreateWithoutStandardsModifiedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStandardsModifiedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStandardsModifiedInput, UserUncheckedUpdateWithoutStandardsModifiedInput>
  }

  export type UserUpdateWithoutStandardsModifiedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStandardsModifiedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type BatchUpsertWithWhereUniqueWithoutStandardsInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutStandardsInput, BatchUncheckedUpdateWithoutStandardsInput>
    create: XOR<BatchCreateWithoutStandardsInput, BatchUncheckedCreateWithoutStandardsInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutStandardsInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutStandardsInput, BatchUncheckedUpdateWithoutStandardsInput>
  }

  export type BatchUpdateManyWithWhereWithoutStandardsInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutStandardsInput>
  }

  export type MethodologyUpsertWithWhereUniqueWithoutStandardsInput = {
    where: MethodologyWhereUniqueInput
    update: XOR<MethodologyUpdateWithoutStandardsInput, MethodologyUncheckedUpdateWithoutStandardsInput>
    create: XOR<MethodologyCreateWithoutStandardsInput, MethodologyUncheckedCreateWithoutStandardsInput>
  }

  export type MethodologyUpdateWithWhereUniqueWithoutStandardsInput = {
    where: MethodologyWhereUniqueInput
    data: XOR<MethodologyUpdateWithoutStandardsInput, MethodologyUncheckedUpdateWithoutStandardsInput>
  }

  export type MethodologyUpdateManyWithWhereWithoutStandardsInput = {
    where: MethodologyScalarWhereInput
    data: XOR<MethodologyUpdateManyMutationInput, MethodologyUncheckedUpdateManyWithoutStandardsInput>
  }

  export type UnitOfMeasurementUpsertWithWhereUniqueWithoutStandardsInput = {
    where: UnitOfMeasurementWhereUniqueInput
    update: XOR<UnitOfMeasurementUpdateWithoutStandardsInput, UnitOfMeasurementUncheckedUpdateWithoutStandardsInput>
    create: XOR<UnitOfMeasurementCreateWithoutStandardsInput, UnitOfMeasurementUncheckedCreateWithoutStandardsInput>
  }

  export type UnitOfMeasurementUpdateWithWhereUniqueWithoutStandardsInput = {
    where: UnitOfMeasurementWhereUniqueInput
    data: XOR<UnitOfMeasurementUpdateWithoutStandardsInput, UnitOfMeasurementUncheckedUpdateWithoutStandardsInput>
  }

  export type UnitOfMeasurementUpdateManyWithWhereWithoutStandardsInput = {
    where: UnitOfMeasurementScalarWhereInput
    data: XOR<UnitOfMeasurementUpdateManyMutationInput, UnitOfMeasurementUncheckedUpdateManyWithoutStandardsInput>
  }

  export type StandardParameterCreateWithoutCategoryInput = {
    id: string
    name: string
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    batchValues?: BatchParameterValueCreateNestedManyWithoutParameterInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardParametersInput
    standards?: StandardDefinitionCreateNestedManyWithoutParameterInput
    products?: ProductParameterCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterUncheckedCreateWithoutCategoryInput = {
    id: string
    name: string
    unitId?: string | null
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    batchValues?: BatchParameterValueUncheckedCreateNestedManyWithoutParameterInput
    standards?: StandardDefinitionUncheckedCreateNestedManyWithoutParameterInput
    products?: ProductParameterUncheckedCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterCreateOrConnectWithoutCategoryInput = {
    where: StandardParameterWhereUniqueInput
    create: XOR<StandardParameterCreateWithoutCategoryInput, StandardParameterUncheckedCreateWithoutCategoryInput>
  }

  export type StandardParameterCreateManyCategoryInputEnvelope = {
    data: StandardParameterCreateManyCategoryInput | StandardParameterCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type StandardCreateWithoutCategoryInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    CreatedBy: UserCreateNestedOneWithoutStandardsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardsModifiedInput
    batches?: BatchCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateWithoutCategoryInput = {
    id: string
    name: string
    code: string
    description: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardCreateOrConnectWithoutCategoryInput = {
    where: StandardWhereUniqueInput
    create: XOR<StandardCreateWithoutCategoryInput, StandardUncheckedCreateWithoutCategoryInput>
  }

  export type StandardCreateManyCategoryInputEnvelope = {
    data: StandardCreateManyCategoryInput | StandardCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductStandardCategoryCreateWithoutCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutStandardCategoriesInput
  }

  export type ProductStandardCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductStandardCategoryCreateOrConnectWithoutCategoryInput = {
    where: ProductStandardCategoryWhereUniqueInput
    create: XOR<ProductStandardCategoryCreateWithoutCategoryInput, ProductStandardCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ProductStandardCategoryCreateManyCategoryInputEnvelope = {
    data: ProductStandardCategoryCreateManyCategoryInput | ProductStandardCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type StandardParameterUpsertWithWhereUniqueWithoutCategoryInput = {
    where: StandardParameterWhereUniqueInput
    update: XOR<StandardParameterUpdateWithoutCategoryInput, StandardParameterUncheckedUpdateWithoutCategoryInput>
    create: XOR<StandardParameterCreateWithoutCategoryInput, StandardParameterUncheckedCreateWithoutCategoryInput>
  }

  export type StandardParameterUpdateWithWhereUniqueWithoutCategoryInput = {
    where: StandardParameterWhereUniqueInput
    data: XOR<StandardParameterUpdateWithoutCategoryInput, StandardParameterUncheckedUpdateWithoutCategoryInput>
  }

  export type StandardParameterUpdateManyWithWhereWithoutCategoryInput = {
    where: StandardParameterScalarWhereInput
    data: XOR<StandardParameterUpdateManyMutationInput, StandardParameterUncheckedUpdateManyWithoutCategoryInput>
  }

  export type StandardUpsertWithWhereUniqueWithoutCategoryInput = {
    where: StandardWhereUniqueInput
    update: XOR<StandardUpdateWithoutCategoryInput, StandardUncheckedUpdateWithoutCategoryInput>
    create: XOR<StandardCreateWithoutCategoryInput, StandardUncheckedCreateWithoutCategoryInput>
  }

  export type StandardUpdateWithWhereUniqueWithoutCategoryInput = {
    where: StandardWhereUniqueInput
    data: XOR<StandardUpdateWithoutCategoryInput, StandardUncheckedUpdateWithoutCategoryInput>
  }

  export type StandardUpdateManyWithWhereWithoutCategoryInput = {
    where: StandardScalarWhereInput
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductStandardCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductStandardCategoryWhereUniqueInput
    update: XOR<ProductStandardCategoryUpdateWithoutCategoryInput, ProductStandardCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductStandardCategoryCreateWithoutCategoryInput, ProductStandardCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ProductStandardCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductStandardCategoryWhereUniqueInput
    data: XOR<ProductStandardCategoryUpdateWithoutCategoryInput, ProductStandardCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductStandardCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductStandardCategoryScalarWhereInput
    data: XOR<ProductStandardCategoryUpdateManyMutationInput, ProductStandardCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductCreateWithoutStandardCategoriesInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Batch?: BatchCreateNestedManyWithoutProductInput
    parameters?: ProductParameterCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStandardCategoriesInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Batch?: BatchUncheckedCreateNestedManyWithoutProductInput
    parameters?: ProductParameterUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStandardCategoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStandardCategoriesInput, ProductUncheckedCreateWithoutStandardCategoriesInput>
  }

  export type StandardCategoryCreateWithoutProductsInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parameters?: StandardParameterCreateNestedManyWithoutCategoryInput
    Standards?: StandardCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryUncheckedCreateWithoutProductsInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parameters?: StandardParameterUncheckedCreateNestedManyWithoutCategoryInput
    Standards?: StandardUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryCreateOrConnectWithoutProductsInput = {
    where: StandardCategoryWhereUniqueInput
    create: XOR<StandardCategoryCreateWithoutProductsInput, StandardCategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductUpsertWithoutStandardCategoriesInput = {
    update: XOR<ProductUpdateWithoutStandardCategoriesInput, ProductUncheckedUpdateWithoutStandardCategoriesInput>
    create: XOR<ProductCreateWithoutStandardCategoriesInput, ProductUncheckedCreateWithoutStandardCategoriesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStandardCategoriesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStandardCategoriesInput, ProductUncheckedUpdateWithoutStandardCategoriesInput>
  }

  export type ProductUpdateWithoutStandardCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateManyWithoutProductNestedInput
    parameters?: ProductParameterUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStandardCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUncheckedUpdateManyWithoutProductNestedInput
    parameters?: ProductParameterUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StandardCategoryUpsertWithoutProductsInput = {
    update: XOR<StandardCategoryUpdateWithoutProductsInput, StandardCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<StandardCategoryCreateWithoutProductsInput, StandardCategoryUncheckedCreateWithoutProductsInput>
    where?: StandardCategoryWhereInput
  }

  export type StandardCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: StandardCategoryWhereInput
    data: XOR<StandardCategoryUpdateWithoutProductsInput, StandardCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type StandardCategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: StandardParameterUpdateManyWithoutCategoryNestedInput
    Standards?: StandardUpdateManyWithoutCategoryNestedInput
  }

  export type StandardCategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: StandardParameterUncheckedUpdateManyWithoutCategoryNestedInput
    Standards?: StandardUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type StandardCategoryCreateWithoutParametersInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutCategoryInput
    products?: ProductStandardCategoryCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryUncheckedCreateWithoutParametersInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutCategoryInput
    products?: ProductStandardCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryCreateOrConnectWithoutParametersInput = {
    where: StandardCategoryWhereUniqueInput
    create: XOR<StandardCategoryCreateWithoutParametersInput, StandardCategoryUncheckedCreateWithoutParametersInput>
  }

  export type BatchParameterValueCreateWithoutParameterInput = {
    id: string
    value: string
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    batch: BatchCreateNestedOneWithoutParameterValuesInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutBatchParameterValuesInput
    methodology?: MethodologyCreateNestedOneWithoutBatchParameterValuesInput
  }

  export type BatchParameterValueUncheckedCreateWithoutParameterInput = {
    id: string
    batchId: string
    value: string
    unitId?: string | null
    methodologyId?: string | null
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchParameterValueCreateOrConnectWithoutParameterInput = {
    where: BatchParameterValueWhereUniqueInput
    create: XOR<BatchParameterValueCreateWithoutParameterInput, BatchParameterValueUncheckedCreateWithoutParameterInput>
  }

  export type BatchParameterValueCreateManyParameterInputEnvelope = {
    data: BatchParameterValueCreateManyParameterInput | BatchParameterValueCreateManyParameterInput[]
    skipDuplicates?: boolean
  }

  export type UnitOfMeasurementCreateWithoutStandardParametersInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutUnitInput
    batches?: BatchCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementUncheckedCreateWithoutStandardParametersInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutUnitInput
    batches?: BatchUncheckedCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementCreateOrConnectWithoutStandardParametersInput = {
    where: UnitOfMeasurementWhereUniqueInput
    create: XOR<UnitOfMeasurementCreateWithoutStandardParametersInput, UnitOfMeasurementUncheckedCreateWithoutStandardParametersInput>
  }

  export type StandardDefinitionCreateWithoutParameterInput = {
    id: string
    standardValue: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardDefinitionsInput
    methodology?: MethodologyCreateNestedOneWithoutStandardDefinitionsInput
    CreatedBy: UserCreateNestedOneWithoutStandardDefinitionsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardDefinitionsModifiedInput
  }

  export type StandardDefinitionUncheckedCreateWithoutParameterInput = {
    id: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateOrConnectWithoutParameterInput = {
    where: StandardDefinitionWhereUniqueInput
    create: XOR<StandardDefinitionCreateWithoutParameterInput, StandardDefinitionUncheckedCreateWithoutParameterInput>
  }

  export type StandardDefinitionCreateManyParameterInputEnvelope = {
    data: StandardDefinitionCreateManyParameterInput | StandardDefinitionCreateManyParameterInput[]
    skipDuplicates?: boolean
  }

  export type ProductParameterCreateWithoutParameterInput = {
    id?: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutParametersInput
  }

  export type ProductParameterUncheckedCreateWithoutParameterInput = {
    id?: string
    productId: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductParameterCreateOrConnectWithoutParameterInput = {
    where: ProductParameterWhereUniqueInput
    create: XOR<ProductParameterCreateWithoutParameterInput, ProductParameterUncheckedCreateWithoutParameterInput>
  }

  export type ProductParameterCreateManyParameterInputEnvelope = {
    data: ProductParameterCreateManyParameterInput | ProductParameterCreateManyParameterInput[]
    skipDuplicates?: boolean
  }

  export type StandardCategoryUpsertWithoutParametersInput = {
    update: XOR<StandardCategoryUpdateWithoutParametersInput, StandardCategoryUncheckedUpdateWithoutParametersInput>
    create: XOR<StandardCategoryCreateWithoutParametersInput, StandardCategoryUncheckedCreateWithoutParametersInput>
    where?: StandardCategoryWhereInput
  }

  export type StandardCategoryUpdateToOneWithWhereWithoutParametersInput = {
    where?: StandardCategoryWhereInput
    data: XOR<StandardCategoryUpdateWithoutParametersInput, StandardCategoryUncheckedUpdateWithoutParametersInput>
  }

  export type StandardCategoryUpdateWithoutParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutCategoryNestedInput
    products?: ProductStandardCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type StandardCategoryUncheckedUpdateWithoutParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutCategoryNestedInput
    products?: ProductStandardCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type BatchParameterValueUpsertWithWhereUniqueWithoutParameterInput = {
    where: BatchParameterValueWhereUniqueInput
    update: XOR<BatchParameterValueUpdateWithoutParameterInput, BatchParameterValueUncheckedUpdateWithoutParameterInput>
    create: XOR<BatchParameterValueCreateWithoutParameterInput, BatchParameterValueUncheckedCreateWithoutParameterInput>
  }

  export type BatchParameterValueUpdateWithWhereUniqueWithoutParameterInput = {
    where: BatchParameterValueWhereUniqueInput
    data: XOR<BatchParameterValueUpdateWithoutParameterInput, BatchParameterValueUncheckedUpdateWithoutParameterInput>
  }

  export type BatchParameterValueUpdateManyWithWhereWithoutParameterInput = {
    where: BatchParameterValueScalarWhereInput
    data: XOR<BatchParameterValueUpdateManyMutationInput, BatchParameterValueUncheckedUpdateManyWithoutParameterInput>
  }

  export type UnitOfMeasurementUpsertWithoutStandardParametersInput = {
    update: XOR<UnitOfMeasurementUpdateWithoutStandardParametersInput, UnitOfMeasurementUncheckedUpdateWithoutStandardParametersInput>
    create: XOR<UnitOfMeasurementCreateWithoutStandardParametersInput, UnitOfMeasurementUncheckedCreateWithoutStandardParametersInput>
    where?: UnitOfMeasurementWhereInput
  }

  export type UnitOfMeasurementUpdateToOneWithWhereWithoutStandardParametersInput = {
    where?: UnitOfMeasurementWhereInput
    data: XOR<UnitOfMeasurementUpdateWithoutStandardParametersInput, UnitOfMeasurementUncheckedUpdateWithoutStandardParametersInput>
  }

  export type UnitOfMeasurementUpdateWithoutStandardParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutUnitNestedInput
    batches?: BatchUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateWithoutStandardParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutUnitNestedInput
    batches?: BatchUncheckedUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type StandardDefinitionUpsertWithWhereUniqueWithoutParameterInput = {
    where: StandardDefinitionWhereUniqueInput
    update: XOR<StandardDefinitionUpdateWithoutParameterInput, StandardDefinitionUncheckedUpdateWithoutParameterInput>
    create: XOR<StandardDefinitionCreateWithoutParameterInput, StandardDefinitionUncheckedCreateWithoutParameterInput>
  }

  export type StandardDefinitionUpdateWithWhereUniqueWithoutParameterInput = {
    where: StandardDefinitionWhereUniqueInput
    data: XOR<StandardDefinitionUpdateWithoutParameterInput, StandardDefinitionUncheckedUpdateWithoutParameterInput>
  }

  export type StandardDefinitionUpdateManyWithWhereWithoutParameterInput = {
    where: StandardDefinitionScalarWhereInput
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyWithoutParameterInput>
  }

  export type ProductParameterUpsertWithWhereUniqueWithoutParameterInput = {
    where: ProductParameterWhereUniqueInput
    update: XOR<ProductParameterUpdateWithoutParameterInput, ProductParameterUncheckedUpdateWithoutParameterInput>
    create: XOR<ProductParameterCreateWithoutParameterInput, ProductParameterUncheckedCreateWithoutParameterInput>
  }

  export type ProductParameterUpdateWithWhereUniqueWithoutParameterInput = {
    where: ProductParameterWhereUniqueInput
    data: XOR<ProductParameterUpdateWithoutParameterInput, ProductParameterUncheckedUpdateWithoutParameterInput>
  }

  export type ProductParameterUpdateManyWithWhereWithoutParameterInput = {
    where: ProductParameterScalarWhereInput
    data: XOR<ProductParameterUpdateManyMutationInput, ProductParameterUncheckedUpdateManyWithoutParameterInput>
  }

  export type StandardParameterCreateWithoutStandardsInput = {
    id: string
    name: string
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    category: StandardCategoryCreateNestedOneWithoutParametersInput
    batchValues?: BatchParameterValueCreateNestedManyWithoutParameterInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardParametersInput
    products?: ProductParameterCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterUncheckedCreateWithoutStandardsInput = {
    id: string
    name: string
    categoryId: string
    unitId?: string | null
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    batchValues?: BatchParameterValueUncheckedCreateNestedManyWithoutParameterInput
    products?: ProductParameterUncheckedCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterCreateOrConnectWithoutStandardsInput = {
    where: StandardParameterWhereUniqueInput
    create: XOR<StandardParameterCreateWithoutStandardsInput, StandardParameterUncheckedCreateWithoutStandardsInput>
  }

  export type UnitOfMeasurementCreateWithoutStandardDefinitionsInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutUnitInput
    standardParameters?: StandardParameterCreateNestedManyWithoutUnitInput
    batches?: BatchCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementUncheckedCreateWithoutStandardDefinitionsInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutUnitInput
    standardParameters?: StandardParameterUncheckedCreateNestedManyWithoutUnitInput
    batches?: BatchUncheckedCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementCreateOrConnectWithoutStandardDefinitionsInput = {
    where: UnitOfMeasurementWhereUniqueInput
    create: XOR<UnitOfMeasurementCreateWithoutStandardDefinitionsInput, UnitOfMeasurementUncheckedCreateWithoutStandardDefinitionsInput>
  }

  export type MethodologyCreateWithoutStandardDefinitionsInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutMethodologiesInput
    batches?: BatchCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyUncheckedCreateWithoutStandardDefinitionsInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutMethodologiesInput
    batches?: BatchUncheckedCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyCreateOrConnectWithoutStandardDefinitionsInput = {
    where: MethodologyWhereUniqueInput
    create: XOR<MethodologyCreateWithoutStandardDefinitionsInput, MethodologyUncheckedCreateWithoutStandardDefinitionsInput>
  }

  export type UserCreateWithoutStandardDefinitionsCreatedInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutStandardDefinitionsCreatedInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutStandardDefinitionsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStandardDefinitionsCreatedInput, UserUncheckedCreateWithoutStandardDefinitionsCreatedInput>
  }

  export type UserCreateWithoutStandardDefinitionsModifiedInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutStandardDefinitionsModifiedInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutStandardDefinitionsModifiedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStandardDefinitionsModifiedInput, UserUncheckedCreateWithoutStandardDefinitionsModifiedInput>
  }

  export type StandardParameterUpsertWithoutStandardsInput = {
    update: XOR<StandardParameterUpdateWithoutStandardsInput, StandardParameterUncheckedUpdateWithoutStandardsInput>
    create: XOR<StandardParameterCreateWithoutStandardsInput, StandardParameterUncheckedCreateWithoutStandardsInput>
    where?: StandardParameterWhereInput
  }

  export type StandardParameterUpdateToOneWithWhereWithoutStandardsInput = {
    where?: StandardParameterWhereInput
    data: XOR<StandardParameterUpdateWithoutStandardsInput, StandardParameterUncheckedUpdateWithoutStandardsInput>
  }

  export type StandardParameterUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StandardCategoryUpdateOneRequiredWithoutParametersNestedInput
    batchValues?: BatchParameterValueUpdateManyWithoutParameterNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutStandardParametersNestedInput
    products?: ProductParameterUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterUncheckedUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchValues?: BatchParameterValueUncheckedUpdateManyWithoutParameterNestedInput
    products?: ProductParameterUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type UnitOfMeasurementUpsertWithoutStandardDefinitionsInput = {
    update: XOR<UnitOfMeasurementUpdateWithoutStandardDefinitionsInput, UnitOfMeasurementUncheckedUpdateWithoutStandardDefinitionsInput>
    create: XOR<UnitOfMeasurementCreateWithoutStandardDefinitionsInput, UnitOfMeasurementUncheckedCreateWithoutStandardDefinitionsInput>
    where?: UnitOfMeasurementWhereInput
  }

  export type UnitOfMeasurementUpdateToOneWithWhereWithoutStandardDefinitionsInput = {
    where?: UnitOfMeasurementWhereInput
    data: XOR<UnitOfMeasurementUpdateWithoutStandardDefinitionsInput, UnitOfMeasurementUncheckedUpdateWithoutStandardDefinitionsInput>
  }

  export type UnitOfMeasurementUpdateWithoutStandardDefinitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutUnitNestedInput
    standardParameters?: StandardParameterUpdateManyWithoutUnitNestedInput
    batches?: BatchUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateWithoutStandardDefinitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutUnitNestedInput
    standardParameters?: StandardParameterUncheckedUpdateManyWithoutUnitNestedInput
    batches?: BatchUncheckedUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type MethodologyUpsertWithoutStandardDefinitionsInput = {
    update: XOR<MethodologyUpdateWithoutStandardDefinitionsInput, MethodologyUncheckedUpdateWithoutStandardDefinitionsInput>
    create: XOR<MethodologyCreateWithoutStandardDefinitionsInput, MethodologyUncheckedCreateWithoutStandardDefinitionsInput>
    where?: MethodologyWhereInput
  }

  export type MethodologyUpdateToOneWithWhereWithoutStandardDefinitionsInput = {
    where?: MethodologyWhereInput
    data: XOR<MethodologyUpdateWithoutStandardDefinitionsInput, MethodologyUncheckedUpdateWithoutStandardDefinitionsInput>
  }

  export type MethodologyUpdateWithoutStandardDefinitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutMethodologiesNestedInput
    batches?: BatchUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateWithoutStandardDefinitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutMethodologiesNestedInput
    batches?: BatchUncheckedUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutMethodologyNestedInput
  }

  export type UserUpsertWithoutStandardDefinitionsCreatedInput = {
    update: XOR<UserUpdateWithoutStandardDefinitionsCreatedInput, UserUncheckedUpdateWithoutStandardDefinitionsCreatedInput>
    create: XOR<UserCreateWithoutStandardDefinitionsCreatedInput, UserUncheckedCreateWithoutStandardDefinitionsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStandardDefinitionsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStandardDefinitionsCreatedInput, UserUncheckedUpdateWithoutStandardDefinitionsCreatedInput>
  }

  export type UserUpdateWithoutStandardDefinitionsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStandardDefinitionsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithoutStandardDefinitionsModifiedInput = {
    update: XOR<UserUpdateWithoutStandardDefinitionsModifiedInput, UserUncheckedUpdateWithoutStandardDefinitionsModifiedInput>
    create: XOR<UserCreateWithoutStandardDefinitionsModifiedInput, UserUncheckedCreateWithoutStandardDefinitionsModifiedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStandardDefinitionsModifiedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStandardDefinitionsModifiedInput, UserUncheckedUpdateWithoutStandardDefinitionsModifiedInput>
  }

  export type UserUpdateWithoutStandardDefinitionsModifiedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStandardDefinitionsModifiedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type BatchCreateWithoutParameterValuesInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
  }

  export type BatchUncheckedCreateWithoutParameterValuesInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
  }

  export type BatchCreateOrConnectWithoutParameterValuesInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutParameterValuesInput, BatchUncheckedCreateWithoutParameterValuesInput>
  }

  export type StandardParameterCreateWithoutBatchValuesInput = {
    id: string
    name: string
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    category: StandardCategoryCreateNestedOneWithoutParametersInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardParametersInput
    standards?: StandardDefinitionCreateNestedManyWithoutParameterInput
    products?: ProductParameterCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterUncheckedCreateWithoutBatchValuesInput = {
    id: string
    name: string
    categoryId: string
    unitId?: string | null
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    standards?: StandardDefinitionUncheckedCreateNestedManyWithoutParameterInput
    products?: ProductParameterUncheckedCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterCreateOrConnectWithoutBatchValuesInput = {
    where: StandardParameterWhereUniqueInput
    create: XOR<StandardParameterCreateWithoutBatchValuesInput, StandardParameterUncheckedCreateWithoutBatchValuesInput>
  }

  export type UnitOfMeasurementCreateWithoutBatchParameterValuesInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutUnitsInput
    standardParameters?: StandardParameterCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutUnitInput
    batches?: BatchCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementUncheckedCreateWithoutBatchParameterValuesInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutUnitsInput
    standardParameters?: StandardParameterUncheckedCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutUnitInput
    batches?: BatchUncheckedCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementCreateOrConnectWithoutBatchParameterValuesInput = {
    where: UnitOfMeasurementWhereUniqueInput
    create: XOR<UnitOfMeasurementCreateWithoutBatchParameterValuesInput, UnitOfMeasurementUncheckedCreateWithoutBatchParameterValuesInput>
  }

  export type MethodologyCreateWithoutBatchParameterValuesInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutMethodologiesInput
    batches?: BatchCreateNestedManyWithoutMethodologiesInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyUncheckedCreateWithoutBatchParameterValuesInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutMethodologiesInput
    batches?: BatchUncheckedCreateNestedManyWithoutMethodologiesInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyCreateOrConnectWithoutBatchParameterValuesInput = {
    where: MethodologyWhereUniqueInput
    create: XOR<MethodologyCreateWithoutBatchParameterValuesInput, MethodologyUncheckedCreateWithoutBatchParameterValuesInput>
  }

  export type BatchUpsertWithoutParameterValuesInput = {
    update: XOR<BatchUpdateWithoutParameterValuesInput, BatchUncheckedUpdateWithoutParameterValuesInput>
    create: XOR<BatchCreateWithoutParameterValuesInput, BatchUncheckedCreateWithoutParameterValuesInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutParameterValuesInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutParameterValuesInput, BatchUncheckedUpdateWithoutParameterValuesInput>
  }

  export type BatchUpdateWithoutParameterValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
  }

  export type BatchUncheckedUpdateWithoutParameterValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
  }

  export type StandardParameterUpsertWithoutBatchValuesInput = {
    update: XOR<StandardParameterUpdateWithoutBatchValuesInput, StandardParameterUncheckedUpdateWithoutBatchValuesInput>
    create: XOR<StandardParameterCreateWithoutBatchValuesInput, StandardParameterUncheckedCreateWithoutBatchValuesInput>
    where?: StandardParameterWhereInput
  }

  export type StandardParameterUpdateToOneWithWhereWithoutBatchValuesInput = {
    where?: StandardParameterWhereInput
    data: XOR<StandardParameterUpdateWithoutBatchValuesInput, StandardParameterUncheckedUpdateWithoutBatchValuesInput>
  }

  export type StandardParameterUpdateWithoutBatchValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StandardCategoryUpdateOneRequiredWithoutParametersNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutStandardParametersNestedInput
    standards?: StandardDefinitionUpdateManyWithoutParameterNestedInput
    products?: ProductParameterUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterUncheckedUpdateWithoutBatchValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    standards?: StandardDefinitionUncheckedUpdateManyWithoutParameterNestedInput
    products?: ProductParameterUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type UnitOfMeasurementUpsertWithoutBatchParameterValuesInput = {
    update: XOR<UnitOfMeasurementUpdateWithoutBatchParameterValuesInput, UnitOfMeasurementUncheckedUpdateWithoutBatchParameterValuesInput>
    create: XOR<UnitOfMeasurementCreateWithoutBatchParameterValuesInput, UnitOfMeasurementUncheckedCreateWithoutBatchParameterValuesInput>
    where?: UnitOfMeasurementWhereInput
  }

  export type UnitOfMeasurementUpdateToOneWithWhereWithoutBatchParameterValuesInput = {
    where?: UnitOfMeasurementWhereInput
    data: XOR<UnitOfMeasurementUpdateWithoutBatchParameterValuesInput, UnitOfMeasurementUncheckedUpdateWithoutBatchParameterValuesInput>
  }

  export type UnitOfMeasurementUpdateWithoutBatchParameterValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutUnitsNestedInput
    standardParameters?: StandardParameterUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutUnitNestedInput
    batches?: BatchUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateWithoutBatchParameterValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutUnitsNestedInput
    standardParameters?: StandardParameterUncheckedUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutUnitNestedInput
    batches?: BatchUncheckedUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type MethodologyUpsertWithoutBatchParameterValuesInput = {
    update: XOR<MethodologyUpdateWithoutBatchParameterValuesInput, MethodologyUncheckedUpdateWithoutBatchParameterValuesInput>
    create: XOR<MethodologyCreateWithoutBatchParameterValuesInput, MethodologyUncheckedCreateWithoutBatchParameterValuesInput>
    where?: MethodologyWhereInput
  }

  export type MethodologyUpdateToOneWithWhereWithoutBatchParameterValuesInput = {
    where?: MethodologyWhereInput
    data: XOR<MethodologyUpdateWithoutBatchParameterValuesInput, MethodologyUncheckedUpdateWithoutBatchParameterValuesInput>
  }

  export type MethodologyUpdateWithoutBatchParameterValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutMethodologiesNestedInput
    batches?: BatchUpdateManyWithoutMethodologiesNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateWithoutBatchParameterValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutMethodologiesNestedInput
    batches?: BatchUncheckedUpdateManyWithoutMethodologiesNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutMethodologyNestedInput
  }

  export type TrainingCreateWithoutCalendarInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutCalendarInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutCalendarInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutCalendarInput, TrainingUncheckedCreateWithoutCalendarInput>
  }

  export type TrainingCreateManyCalendarInputEnvelope = {
    data: TrainingCreateManyCalendarInput | TrainingCreateManyCalendarInput[]
    skipDuplicates?: boolean
  }

  export type TrainingUpsertWithWhereUniqueWithoutCalendarInput = {
    where: TrainingWhereUniqueInput
    update: XOR<TrainingUpdateWithoutCalendarInput, TrainingUncheckedUpdateWithoutCalendarInput>
    create: XOR<TrainingCreateWithoutCalendarInput, TrainingUncheckedCreateWithoutCalendarInput>
  }

  export type TrainingUpdateWithWhereUniqueWithoutCalendarInput = {
    where: TrainingWhereUniqueInput
    data: XOR<TrainingUpdateWithoutCalendarInput, TrainingUncheckedUpdateWithoutCalendarInput>
  }

  export type TrainingUpdateManyWithWhereWithoutCalendarInput = {
    where: TrainingScalarWhereInput
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyWithoutCalendarInput>
  }

  export type UserCreateWithoutTrainerTrainingsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutTrainerTrainingsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutTrainerTrainingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrainerTrainingsInput, UserUncheckedCreateWithoutTrainerTrainingsInput>
  }

  export type TrainingCalendarCreateWithoutTrainingsInput = {
    id?: string
    month: number
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingCalendarUncheckedCreateWithoutTrainingsInput = {
    id?: string
    month: number
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingCalendarCreateOrConnectWithoutTrainingsInput = {
    where: TrainingCalendarWhereUniqueInput
    create: XOR<TrainingCalendarCreateWithoutTrainingsInput, TrainingCalendarUncheckedCreateWithoutTrainingsInput>
  }

  export type UserCreateWithoutCreatedTrainingsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutCreatedTrainingsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreatedTrainingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTrainingsInput, UserUncheckedCreateWithoutCreatedTrainingsInput>
  }

  export type TrainingSessionCreateWithoutTrainingInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutSessionInput
    photos?: TrainingSessionPhotoCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionUncheckedCreateWithoutTrainingInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutSessionInput
    photos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionCreateOrConnectWithoutTrainingInput = {
    where: TrainingSessionWhereUniqueInput
    create: XOR<TrainingSessionCreateWithoutTrainingInput, TrainingSessionUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingSessionCreateManyTrainingInputEnvelope = {
    data: TrainingSessionCreateManyTrainingInput | TrainingSessionCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingDocumentCreateWithoutTrainingInput = {
    id?: string
    sessionId?: string | null
    title: string
    description?: string | null
    fileUrl: string
    filePath?: string | null
    documentType: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutUploadedDocumentsInput
  }

  export type TrainingDocumentUncheckedCreateWithoutTrainingInput = {
    id?: string
    sessionId?: string | null
    title: string
    description?: string | null
    fileUrl: string
    filePath?: string | null
    documentType: $Enums.DocumentType
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDocumentCreateOrConnectWithoutTrainingInput = {
    where: TrainingDocumentWhereUniqueInput
    create: XOR<TrainingDocumentCreateWithoutTrainingInput, TrainingDocumentUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingDocumentCreateManyTrainingInputEnvelope = {
    data: TrainingDocumentCreateManyTrainingInput | TrainingDocumentCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutTrainingInput = {
    id?: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: TrainingSessionCreateNestedOneWithoutAttendanceInput
    participant: ParticipantCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutTrainingInput = {
    id?: string
    sessionId: string
    participantId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutTrainingInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutTrainingInput, AttendanceUncheckedCreateWithoutTrainingInput>
  }

  export type AttendanceCreateManyTrainingInputEnvelope = {
    data: AttendanceCreateManyTrainingInput | AttendanceCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingParticipantCreateWithoutTrainingInput = {
    id?: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ParticipantCreateNestedOneWithoutTrainingsInput
  }

  export type TrainingParticipantUncheckedCreateWithoutTrainingInput = {
    id?: string
    participantId: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingParticipantCreateOrConnectWithoutTrainingInput = {
    where: TrainingParticipantWhereUniqueInput
    create: XOR<TrainingParticipantCreateWithoutTrainingInput, TrainingParticipantUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingParticipantCreateManyTrainingInputEnvelope = {
    data: TrainingParticipantCreateManyTrainingInput | TrainingParticipantCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingPhotoCreateWithoutTrainingInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutUploadedPhotosInput
  }

  export type TrainingPhotoUncheckedCreateWithoutTrainingInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type TrainingPhotoCreateOrConnectWithoutTrainingInput = {
    where: TrainingPhotoWhereUniqueInput
    create: XOR<TrainingPhotoCreateWithoutTrainingInput, TrainingPhotoUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingPhotoCreateManyTrainingInputEnvelope = {
    data: TrainingPhotoCreateManyTrainingInput | TrainingPhotoCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingFeedbackCreateWithoutTrainingInput = {
    id?: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ParticipantCreateNestedOneWithoutFeedbacksInput
  }

  export type TrainingFeedbackUncheckedCreateWithoutTrainingInput = {
    id?: string
    participantId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingFeedbackCreateOrConnectWithoutTrainingInput = {
    where: TrainingFeedbackWhereUniqueInput
    create: XOR<TrainingFeedbackCreateWithoutTrainingInput, TrainingFeedbackUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingFeedbackCreateManyTrainingInputEnvelope = {
    data: TrainingFeedbackCreateManyTrainingInput | TrainingFeedbackCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingFollowupCreateWithoutTrainingInput = {
    id?: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    assignedTo: UserCreateNestedOneWithoutAssignedFollowupsInput
    createdBy: UserCreateNestedOneWithoutCreatedFollowupsInput
  }

  export type TrainingFollowupUncheckedCreateWithoutTrainingInput = {
    id?: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    assignedToId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingFollowupCreateOrConnectWithoutTrainingInput = {
    where: TrainingFollowupWhereUniqueInput
    create: XOR<TrainingFollowupCreateWithoutTrainingInput, TrainingFollowupUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingFollowupCreateManyTrainingInputEnvelope = {
    data: TrainingFollowupCreateManyTrainingInput | TrainingFollowupCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingNotificationCreateWithoutTrainingInput = {
    id?: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutTrainingNotificationsInput
  }

  export type TrainingNotificationUncheckedCreateWithoutTrainingInput = {
    id?: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type TrainingNotificationCreateOrConnectWithoutTrainingInput = {
    where: TrainingNotificationWhereUniqueInput
    create: XOR<TrainingNotificationCreateWithoutTrainingInput, TrainingNotificationUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingNotificationCreateManyTrainingInputEnvelope = {
    data: TrainingNotificationCreateManyTrainingInput | TrainingNotificationCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingInviteTokenCreateWithoutTrainingInput = {
    id?: string
    token: string
    action: string
    email: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    participant?: ParticipantCreateNestedOneWithoutInviteTokensInput
  }

  export type TrainingInviteTokenUncheckedCreateWithoutTrainingInput = {
    id?: string
    token: string
    action: string
    participantId?: string | null
    email: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type TrainingInviteTokenCreateOrConnectWithoutTrainingInput = {
    where: TrainingInviteTokenWhereUniqueInput
    create: XOR<TrainingInviteTokenCreateWithoutTrainingInput, TrainingInviteTokenUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingInviteTokenCreateManyTrainingInputEnvelope = {
    data: TrainingInviteTokenCreateManyTrainingInput | TrainingInviteTokenCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackFormCreateWithoutTrainingInput = {
    id?: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
    session: TrainingSessionCreateNestedOneWithoutFeedbackFormsInput
    participant: ParticipantCreateNestedOneWithoutFeedbackFormsInput
    uploadedBy: UserCreateNestedOneWithoutUploadedFeedbackFormsInput
  }

  export type FeedbackFormUncheckedCreateWithoutTrainingInput = {
    id?: string
    sessionId: string
    participantId: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
    uploadedById: string
  }

  export type FeedbackFormCreateOrConnectWithoutTrainingInput = {
    where: FeedbackFormWhereUniqueInput
    create: XOR<FeedbackFormCreateWithoutTrainingInput, FeedbackFormUncheckedCreateWithoutTrainingInput>
  }

  export type FeedbackFormCreateManyTrainingInputEnvelope = {
    data: FeedbackFormCreateManyTrainingInput | FeedbackFormCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTrainerTrainingsInput = {
    update: XOR<UserUpdateWithoutTrainerTrainingsInput, UserUncheckedUpdateWithoutTrainerTrainingsInput>
    create: XOR<UserCreateWithoutTrainerTrainingsInput, UserUncheckedCreateWithoutTrainerTrainingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrainerTrainingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrainerTrainingsInput, UserUncheckedUpdateWithoutTrainerTrainingsInput>
  }

  export type UserUpdateWithoutTrainerTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTrainerTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TrainingCalendarUpsertWithoutTrainingsInput = {
    update: XOR<TrainingCalendarUpdateWithoutTrainingsInput, TrainingCalendarUncheckedUpdateWithoutTrainingsInput>
    create: XOR<TrainingCalendarCreateWithoutTrainingsInput, TrainingCalendarUncheckedCreateWithoutTrainingsInput>
    where?: TrainingCalendarWhereInput
  }

  export type TrainingCalendarUpdateToOneWithWhereWithoutTrainingsInput = {
    where?: TrainingCalendarWhereInput
    data: XOR<TrainingCalendarUpdateWithoutTrainingsInput, TrainingCalendarUncheckedUpdateWithoutTrainingsInput>
  }

  export type TrainingCalendarUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingCalendarUncheckedUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedTrainingsInput = {
    update: XOR<UserUpdateWithoutCreatedTrainingsInput, UserUncheckedUpdateWithoutCreatedTrainingsInput>
    create: XOR<UserCreateWithoutCreatedTrainingsInput, UserUncheckedCreateWithoutCreatedTrainingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTrainingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTrainingsInput, UserUncheckedUpdateWithoutCreatedTrainingsInput>
  }

  export type UserUpdateWithoutCreatedTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TrainingSessionUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingSessionWhereUniqueInput
    update: XOR<TrainingSessionUpdateWithoutTrainingInput, TrainingSessionUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingSessionCreateWithoutTrainingInput, TrainingSessionUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingSessionUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingSessionWhereUniqueInput
    data: XOR<TrainingSessionUpdateWithoutTrainingInput, TrainingSessionUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingSessionUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingSessionScalarWhereInput
    data: XOR<TrainingSessionUpdateManyMutationInput, TrainingSessionUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingSessionScalarWhereInput = {
    AND?: TrainingSessionScalarWhereInput | TrainingSessionScalarWhereInput[]
    OR?: TrainingSessionScalarWhereInput[]
    NOT?: TrainingSessionScalarWhereInput | TrainingSessionScalarWhereInput[]
    id?: StringFilter<"TrainingSession"> | string
    trainingId?: StringFilter<"TrainingSession"> | string
    title?: StringFilter<"TrainingSession"> | string
    description?: StringNullableFilter<"TrainingSession"> | string | null
    startTime?: DateTimeFilter<"TrainingSession"> | Date | string
    endTime?: DateTimeFilter<"TrainingSession"> | Date | string
    venue?: StringFilter<"TrainingSession"> | string
    status?: EnumTrainingStatusFilter<"TrainingSession"> | $Enums.TrainingStatus
    createdAt?: DateTimeFilter<"TrainingSession"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingSession"> | Date | string
  }

  export type TrainingDocumentUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingDocumentWhereUniqueInput
    update: XOR<TrainingDocumentUpdateWithoutTrainingInput, TrainingDocumentUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingDocumentCreateWithoutTrainingInput, TrainingDocumentUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingDocumentUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingDocumentWhereUniqueInput
    data: XOR<TrainingDocumentUpdateWithoutTrainingInput, TrainingDocumentUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingDocumentUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingDocumentScalarWhereInput
    data: XOR<TrainingDocumentUpdateManyMutationInput, TrainingDocumentUncheckedUpdateManyWithoutTrainingInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutTrainingInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutTrainingInput, AttendanceUncheckedUpdateWithoutTrainingInput>
    create: XOR<AttendanceCreateWithoutTrainingInput, AttendanceUncheckedCreateWithoutTrainingInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutTrainingInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutTrainingInput, AttendanceUncheckedUpdateWithoutTrainingInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutTrainingInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutTrainingInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    trainingId?: StringFilter<"Attendance"> | string
    sessionId?: StringFilter<"Attendance"> | string
    participantId?: StringFilter<"Attendance"> | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    remarks?: StringNullableFilter<"Attendance"> | string | null
    signatureUrl?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type TrainingParticipantUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingParticipantWhereUniqueInput
    update: XOR<TrainingParticipantUpdateWithoutTrainingInput, TrainingParticipantUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingParticipantCreateWithoutTrainingInput, TrainingParticipantUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingParticipantUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingParticipantWhereUniqueInput
    data: XOR<TrainingParticipantUpdateWithoutTrainingInput, TrainingParticipantUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingParticipantUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingParticipantScalarWhereInput
    data: XOR<TrainingParticipantUpdateManyMutationInput, TrainingParticipantUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingParticipantScalarWhereInput = {
    AND?: TrainingParticipantScalarWhereInput | TrainingParticipantScalarWhereInput[]
    OR?: TrainingParticipantScalarWhereInput[]
    NOT?: TrainingParticipantScalarWhereInput | TrainingParticipantScalarWhereInput[]
    id?: StringFilter<"TrainingParticipant"> | string
    trainingId?: StringFilter<"TrainingParticipant"> | string
    participantId?: StringFilter<"TrainingParticipant"> | string
    inviteSent?: BoolFilter<"TrainingParticipant"> | boolean
    inviteSentAt?: DateTimeNullableFilter<"TrainingParticipant"> | Date | string | null
    inviteAccepted?: BoolFilter<"TrainingParticipant"> | boolean
    createdAt?: DateTimeFilter<"TrainingParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingParticipant"> | Date | string
  }

  export type TrainingPhotoUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingPhotoWhereUniqueInput
    update: XOR<TrainingPhotoUpdateWithoutTrainingInput, TrainingPhotoUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingPhotoCreateWithoutTrainingInput, TrainingPhotoUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingPhotoUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingPhotoWhereUniqueInput
    data: XOR<TrainingPhotoUpdateWithoutTrainingInput, TrainingPhotoUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingPhotoUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingPhotoScalarWhereInput
    data: XOR<TrainingPhotoUpdateManyMutationInput, TrainingPhotoUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingFeedbackUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingFeedbackWhereUniqueInput
    update: XOR<TrainingFeedbackUpdateWithoutTrainingInput, TrainingFeedbackUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingFeedbackCreateWithoutTrainingInput, TrainingFeedbackUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingFeedbackUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingFeedbackWhereUniqueInput
    data: XOR<TrainingFeedbackUpdateWithoutTrainingInput, TrainingFeedbackUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingFeedbackUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingFeedbackScalarWhereInput
    data: XOR<TrainingFeedbackUpdateManyMutationInput, TrainingFeedbackUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingFeedbackScalarWhereInput = {
    AND?: TrainingFeedbackScalarWhereInput | TrainingFeedbackScalarWhereInput[]
    OR?: TrainingFeedbackScalarWhereInput[]
    NOT?: TrainingFeedbackScalarWhereInput | TrainingFeedbackScalarWhereInput[]
    id?: StringFilter<"TrainingFeedback"> | string
    trainingId?: StringFilter<"TrainingFeedback"> | string
    participantId?: StringFilter<"TrainingFeedback"> | string
    contentRating?: IntFilter<"TrainingFeedback"> | number
    trainerRating?: IntFilter<"TrainingFeedback"> | number
    materialRating?: IntFilter<"TrainingFeedback"> | number
    venueRating?: IntFilter<"TrainingFeedback"> | number
    overallRating?: IntFilter<"TrainingFeedback"> | number
    comments?: StringNullableFilter<"TrainingFeedback"> | string | null
    suggestedImprovements?: StringNullableFilter<"TrainingFeedback"> | string | null
    createdAt?: DateTimeFilter<"TrainingFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingFeedback"> | Date | string
  }

  export type TrainingFollowupUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingFollowupWhereUniqueInput
    update: XOR<TrainingFollowupUpdateWithoutTrainingInput, TrainingFollowupUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingFollowupCreateWithoutTrainingInput, TrainingFollowupUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingFollowupUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingFollowupWhereUniqueInput
    data: XOR<TrainingFollowupUpdateWithoutTrainingInput, TrainingFollowupUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingFollowupUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingFollowupScalarWhereInput
    data: XOR<TrainingFollowupUpdateManyMutationInput, TrainingFollowupUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingNotificationUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingNotificationWhereUniqueInput
    update: XOR<TrainingNotificationUpdateWithoutTrainingInput, TrainingNotificationUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingNotificationCreateWithoutTrainingInput, TrainingNotificationUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingNotificationUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingNotificationWhereUniqueInput
    data: XOR<TrainingNotificationUpdateWithoutTrainingInput, TrainingNotificationUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingNotificationUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingNotificationScalarWhereInput
    data: XOR<TrainingNotificationUpdateManyMutationInput, TrainingNotificationUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingInviteTokenUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingInviteTokenWhereUniqueInput
    update: XOR<TrainingInviteTokenUpdateWithoutTrainingInput, TrainingInviteTokenUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingInviteTokenCreateWithoutTrainingInput, TrainingInviteTokenUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingInviteTokenUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingInviteTokenWhereUniqueInput
    data: XOR<TrainingInviteTokenUpdateWithoutTrainingInput, TrainingInviteTokenUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingInviteTokenUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingInviteTokenScalarWhereInput
    data: XOR<TrainingInviteTokenUpdateManyMutationInput, TrainingInviteTokenUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingInviteTokenScalarWhereInput = {
    AND?: TrainingInviteTokenScalarWhereInput | TrainingInviteTokenScalarWhereInput[]
    OR?: TrainingInviteTokenScalarWhereInput[]
    NOT?: TrainingInviteTokenScalarWhereInput | TrainingInviteTokenScalarWhereInput[]
    id?: StringFilter<"TrainingInviteToken"> | string
    token?: StringFilter<"TrainingInviteToken"> | string
    action?: StringFilter<"TrainingInviteToken"> | string
    trainingId?: StringFilter<"TrainingInviteToken"> | string
    participantId?: StringNullableFilter<"TrainingInviteToken"> | string | null
    email?: StringFilter<"TrainingInviteToken"> | string
    expiresAt?: DateTimeFilter<"TrainingInviteToken"> | Date | string
    used?: BoolFilter<"TrainingInviteToken"> | boolean
    createdAt?: DateTimeFilter<"TrainingInviteToken"> | Date | string
  }

  export type FeedbackFormUpsertWithWhereUniqueWithoutTrainingInput = {
    where: FeedbackFormWhereUniqueInput
    update: XOR<FeedbackFormUpdateWithoutTrainingInput, FeedbackFormUncheckedUpdateWithoutTrainingInput>
    create: XOR<FeedbackFormCreateWithoutTrainingInput, FeedbackFormUncheckedCreateWithoutTrainingInput>
  }

  export type FeedbackFormUpdateWithWhereUniqueWithoutTrainingInput = {
    where: FeedbackFormWhereUniqueInput
    data: XOR<FeedbackFormUpdateWithoutTrainingInput, FeedbackFormUncheckedUpdateWithoutTrainingInput>
  }

  export type FeedbackFormUpdateManyWithWhereWithoutTrainingInput = {
    where: FeedbackFormScalarWhereInput
    data: XOR<FeedbackFormUpdateManyMutationInput, FeedbackFormUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingCreateWithoutSessionsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutSessionsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutSessionsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutSessionsInput, TrainingUncheckedCreateWithoutSessionsInput>
  }

  export type AttendanceCreateWithoutSessionInput = {
    id?: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutAttendanceInput
    participant: ParticipantCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutSessionInput = {
    id?: string
    trainingId: string
    participantId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutSessionInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput>
  }

  export type AttendanceCreateManySessionInputEnvelope = {
    data: AttendanceCreateManySessionInput | AttendanceCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackFormCreateWithoutSessionInput = {
    id?: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
    training: TrainingCreateNestedOneWithoutFeedbackFormsInput
    participant: ParticipantCreateNestedOneWithoutFeedbackFormsInput
    uploadedBy: UserCreateNestedOneWithoutUploadedFeedbackFormsInput
  }

  export type FeedbackFormUncheckedCreateWithoutSessionInput = {
    id?: string
    trainingId: string
    participantId: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
    uploadedById: string
  }

  export type FeedbackFormCreateOrConnectWithoutSessionInput = {
    where: FeedbackFormWhereUniqueInput
    create: XOR<FeedbackFormCreateWithoutSessionInput, FeedbackFormUncheckedCreateWithoutSessionInput>
  }

  export type FeedbackFormCreateManySessionInputEnvelope = {
    data: FeedbackFormCreateManySessionInput | FeedbackFormCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type TrainingSessionPhotoCreateWithoutSessionInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutUploadedSessionPhotosInput
  }

  export type TrainingSessionPhotoUncheckedCreateWithoutSessionInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type TrainingSessionPhotoCreateOrConnectWithoutSessionInput = {
    where: TrainingSessionPhotoWhereUniqueInput
    create: XOR<TrainingSessionPhotoCreateWithoutSessionInput, TrainingSessionPhotoUncheckedCreateWithoutSessionInput>
  }

  export type TrainingSessionPhotoCreateManySessionInputEnvelope = {
    data: TrainingSessionPhotoCreateManySessionInput | TrainingSessionPhotoCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type TrainingUpsertWithoutSessionsInput = {
    update: XOR<TrainingUpdateWithoutSessionsInput, TrainingUncheckedUpdateWithoutSessionsInput>
    create: XOR<TrainingCreateWithoutSessionsInput, TrainingUncheckedCreateWithoutSessionsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutSessionsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutSessionsInput, TrainingUncheckedUpdateWithoutSessionsInput>
  }

  export type TrainingUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type AttendanceUpsertWithWhereUniqueWithoutSessionInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutSessionInput, AttendanceUncheckedUpdateWithoutSessionInput>
    create: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutSessionInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutSessionInput, AttendanceUncheckedUpdateWithoutSessionInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutSessionInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutSessionInput>
  }

  export type FeedbackFormUpsertWithWhereUniqueWithoutSessionInput = {
    where: FeedbackFormWhereUniqueInput
    update: XOR<FeedbackFormUpdateWithoutSessionInput, FeedbackFormUncheckedUpdateWithoutSessionInput>
    create: XOR<FeedbackFormCreateWithoutSessionInput, FeedbackFormUncheckedCreateWithoutSessionInput>
  }

  export type FeedbackFormUpdateWithWhereUniqueWithoutSessionInput = {
    where: FeedbackFormWhereUniqueInput
    data: XOR<FeedbackFormUpdateWithoutSessionInput, FeedbackFormUncheckedUpdateWithoutSessionInput>
  }

  export type FeedbackFormUpdateManyWithWhereWithoutSessionInput = {
    where: FeedbackFormScalarWhereInput
    data: XOR<FeedbackFormUpdateManyMutationInput, FeedbackFormUncheckedUpdateManyWithoutSessionInput>
  }

  export type TrainingSessionPhotoUpsertWithWhereUniqueWithoutSessionInput = {
    where: TrainingSessionPhotoWhereUniqueInput
    update: XOR<TrainingSessionPhotoUpdateWithoutSessionInput, TrainingSessionPhotoUncheckedUpdateWithoutSessionInput>
    create: XOR<TrainingSessionPhotoCreateWithoutSessionInput, TrainingSessionPhotoUncheckedCreateWithoutSessionInput>
  }

  export type TrainingSessionPhotoUpdateWithWhereUniqueWithoutSessionInput = {
    where: TrainingSessionPhotoWhereUniqueInput
    data: XOR<TrainingSessionPhotoUpdateWithoutSessionInput, TrainingSessionPhotoUncheckedUpdateWithoutSessionInput>
  }

  export type TrainingSessionPhotoUpdateManyWithWhereWithoutSessionInput = {
    where: TrainingSessionPhotoScalarWhereInput
    data: XOR<TrainingSessionPhotoUpdateManyMutationInput, TrainingSessionPhotoUncheckedUpdateManyWithoutSessionInput>
  }

  export type TrainingCreateWithoutDocumentsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutDocumentsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutDocumentsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutDocumentsInput, TrainingUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutUploadedDocumentsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutUploadedDocumentsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUploadedDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
  }

  export type TrainingUpsertWithoutDocumentsInput = {
    update: XOR<TrainingUpdateWithoutDocumentsInput, TrainingUncheckedUpdateWithoutDocumentsInput>
    create: XOR<TrainingCreateWithoutDocumentsInput, TrainingUncheckedCreateWithoutDocumentsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutDocumentsInput, TrainingUncheckedUpdateWithoutDocumentsInput>
  }

  export type TrainingUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type UserUpsertWithoutUploadedDocumentsInput = {
    update: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type UserUpdateWithoutUploadedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TrainingParticipantCreateWithoutParticipantInput = {
    id?: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutParticipantsInput
  }

  export type TrainingParticipantUncheckedCreateWithoutParticipantInput = {
    id?: string
    trainingId: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingParticipantCreateOrConnectWithoutParticipantInput = {
    where: TrainingParticipantWhereUniqueInput
    create: XOR<TrainingParticipantCreateWithoutParticipantInput, TrainingParticipantUncheckedCreateWithoutParticipantInput>
  }

  export type TrainingParticipantCreateManyParticipantInputEnvelope = {
    data: TrainingParticipantCreateManyParticipantInput | TrainingParticipantCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutParticipantInput = {
    id?: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutAttendanceInput
    session: TrainingSessionCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutParticipantInput = {
    id?: string
    trainingId: string
    sessionId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutParticipantInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutParticipantInput, AttendanceUncheckedCreateWithoutParticipantInput>
  }

  export type AttendanceCreateManyParticipantInputEnvelope = {
    data: AttendanceCreateManyParticipantInput | AttendanceCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type TrainingFeedbackCreateWithoutParticipantInput = {
    id?: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutFeedbackInput
  }

  export type TrainingFeedbackUncheckedCreateWithoutParticipantInput = {
    id?: string
    trainingId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingFeedbackCreateOrConnectWithoutParticipantInput = {
    where: TrainingFeedbackWhereUniqueInput
    create: XOR<TrainingFeedbackCreateWithoutParticipantInput, TrainingFeedbackUncheckedCreateWithoutParticipantInput>
  }

  export type TrainingFeedbackCreateManyParticipantInputEnvelope = {
    data: TrainingFeedbackCreateManyParticipantInput | TrainingFeedbackCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type TrainingInviteTokenCreateWithoutParticipantInput = {
    id?: string
    token: string
    action: string
    email: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    training: TrainingCreateNestedOneWithoutInviteTokensInput
  }

  export type TrainingInviteTokenUncheckedCreateWithoutParticipantInput = {
    id?: string
    token: string
    action: string
    trainingId: string
    email: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type TrainingInviteTokenCreateOrConnectWithoutParticipantInput = {
    where: TrainingInviteTokenWhereUniqueInput
    create: XOR<TrainingInviteTokenCreateWithoutParticipantInput, TrainingInviteTokenUncheckedCreateWithoutParticipantInput>
  }

  export type TrainingInviteTokenCreateManyParticipantInputEnvelope = {
    data: TrainingInviteTokenCreateManyParticipantInput | TrainingInviteTokenCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackFormCreateWithoutParticipantInput = {
    id?: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
    training: TrainingCreateNestedOneWithoutFeedbackFormsInput
    session: TrainingSessionCreateNestedOneWithoutFeedbackFormsInput
    uploadedBy: UserCreateNestedOneWithoutUploadedFeedbackFormsInput
  }

  export type FeedbackFormUncheckedCreateWithoutParticipantInput = {
    id?: string
    trainingId: string
    sessionId: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
    uploadedById: string
  }

  export type FeedbackFormCreateOrConnectWithoutParticipantInput = {
    where: FeedbackFormWhereUniqueInput
    create: XOR<FeedbackFormCreateWithoutParticipantInput, FeedbackFormUncheckedCreateWithoutParticipantInput>
  }

  export type FeedbackFormCreateManyParticipantInputEnvelope = {
    data: FeedbackFormCreateManyParticipantInput | FeedbackFormCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type TrainingParticipantUpsertWithWhereUniqueWithoutParticipantInput = {
    where: TrainingParticipantWhereUniqueInput
    update: XOR<TrainingParticipantUpdateWithoutParticipantInput, TrainingParticipantUncheckedUpdateWithoutParticipantInput>
    create: XOR<TrainingParticipantCreateWithoutParticipantInput, TrainingParticipantUncheckedCreateWithoutParticipantInput>
  }

  export type TrainingParticipantUpdateWithWhereUniqueWithoutParticipantInput = {
    where: TrainingParticipantWhereUniqueInput
    data: XOR<TrainingParticipantUpdateWithoutParticipantInput, TrainingParticipantUncheckedUpdateWithoutParticipantInput>
  }

  export type TrainingParticipantUpdateManyWithWhereWithoutParticipantInput = {
    where: TrainingParticipantScalarWhereInput
    data: XOR<TrainingParticipantUpdateManyMutationInput, TrainingParticipantUncheckedUpdateManyWithoutParticipantInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutParticipantInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutParticipantInput, AttendanceUncheckedUpdateWithoutParticipantInput>
    create: XOR<AttendanceCreateWithoutParticipantInput, AttendanceUncheckedCreateWithoutParticipantInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutParticipantInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutParticipantInput, AttendanceUncheckedUpdateWithoutParticipantInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutParticipantInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutParticipantInput>
  }

  export type TrainingFeedbackUpsertWithWhereUniqueWithoutParticipantInput = {
    where: TrainingFeedbackWhereUniqueInput
    update: XOR<TrainingFeedbackUpdateWithoutParticipantInput, TrainingFeedbackUncheckedUpdateWithoutParticipantInput>
    create: XOR<TrainingFeedbackCreateWithoutParticipantInput, TrainingFeedbackUncheckedCreateWithoutParticipantInput>
  }

  export type TrainingFeedbackUpdateWithWhereUniqueWithoutParticipantInput = {
    where: TrainingFeedbackWhereUniqueInput
    data: XOR<TrainingFeedbackUpdateWithoutParticipantInput, TrainingFeedbackUncheckedUpdateWithoutParticipantInput>
  }

  export type TrainingFeedbackUpdateManyWithWhereWithoutParticipantInput = {
    where: TrainingFeedbackScalarWhereInput
    data: XOR<TrainingFeedbackUpdateManyMutationInput, TrainingFeedbackUncheckedUpdateManyWithoutParticipantInput>
  }

  export type TrainingInviteTokenUpsertWithWhereUniqueWithoutParticipantInput = {
    where: TrainingInviteTokenWhereUniqueInput
    update: XOR<TrainingInviteTokenUpdateWithoutParticipantInput, TrainingInviteTokenUncheckedUpdateWithoutParticipantInput>
    create: XOR<TrainingInviteTokenCreateWithoutParticipantInput, TrainingInviteTokenUncheckedCreateWithoutParticipantInput>
  }

  export type TrainingInviteTokenUpdateWithWhereUniqueWithoutParticipantInput = {
    where: TrainingInviteTokenWhereUniqueInput
    data: XOR<TrainingInviteTokenUpdateWithoutParticipantInput, TrainingInviteTokenUncheckedUpdateWithoutParticipantInput>
  }

  export type TrainingInviteTokenUpdateManyWithWhereWithoutParticipantInput = {
    where: TrainingInviteTokenScalarWhereInput
    data: XOR<TrainingInviteTokenUpdateManyMutationInput, TrainingInviteTokenUncheckedUpdateManyWithoutParticipantInput>
  }

  export type FeedbackFormUpsertWithWhereUniqueWithoutParticipantInput = {
    where: FeedbackFormWhereUniqueInput
    update: XOR<FeedbackFormUpdateWithoutParticipantInput, FeedbackFormUncheckedUpdateWithoutParticipantInput>
    create: XOR<FeedbackFormCreateWithoutParticipantInput, FeedbackFormUncheckedCreateWithoutParticipantInput>
  }

  export type FeedbackFormUpdateWithWhereUniqueWithoutParticipantInput = {
    where: FeedbackFormWhereUniqueInput
    data: XOR<FeedbackFormUpdateWithoutParticipantInput, FeedbackFormUncheckedUpdateWithoutParticipantInput>
  }

  export type FeedbackFormUpdateManyWithWhereWithoutParticipantInput = {
    where: FeedbackFormScalarWhereInput
    data: XOR<FeedbackFormUpdateManyMutationInput, FeedbackFormUncheckedUpdateManyWithoutParticipantInput>
  }

  export type TrainingCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutParticipantsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutParticipantsInput, TrainingUncheckedCreateWithoutParticipantsInput>
  }

  export type ParticipantCreateWithoutTrainingsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    organization?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceCreateNestedManyWithoutParticipantInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutParticipantInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutParticipantInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutTrainingsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    organization?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceUncheckedCreateNestedManyWithoutParticipantInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutParticipantInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutParticipantInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutTrainingsInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutTrainingsInput, ParticipantUncheckedCreateWithoutTrainingsInput>
  }

  export type TrainingUpsertWithoutParticipantsInput = {
    update: XOR<TrainingUpdateWithoutParticipantsInput, TrainingUncheckedUpdateWithoutParticipantsInput>
    create: XOR<TrainingCreateWithoutParticipantsInput, TrainingUncheckedCreateWithoutParticipantsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutParticipantsInput, TrainingUncheckedUpdateWithoutParticipantsInput>
  }

  export type TrainingUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type ParticipantUpsertWithoutTrainingsInput = {
    update: XOR<ParticipantUpdateWithoutTrainingsInput, ParticipantUncheckedUpdateWithoutTrainingsInput>
    create: XOR<ParticipantCreateWithoutTrainingsInput, ParticipantUncheckedCreateWithoutTrainingsInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutTrainingsInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutTrainingsInput, ParticipantUncheckedUpdateWithoutTrainingsInput>
  }

  export type ParticipantUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceUpdateManyWithoutParticipantNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutParticipantNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutParticipantNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceUncheckedUpdateManyWithoutParticipantNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutParticipantNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutParticipantNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TrainingCreateWithoutAttendanceInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutAttendanceInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutAttendanceInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutAttendanceInput, TrainingUncheckedCreateWithoutAttendanceInput>
  }

  export type TrainingSessionCreateWithoutAttendanceInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutSessionsInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutSessionInput
    photos?: TrainingSessionPhotoCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionUncheckedCreateWithoutAttendanceInput = {
    id?: string
    trainingId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutSessionInput
    photos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionCreateOrConnectWithoutAttendanceInput = {
    where: TrainingSessionWhereUniqueInput
    create: XOR<TrainingSessionCreateWithoutAttendanceInput, TrainingSessionUncheckedCreateWithoutAttendanceInput>
  }

  export type ParticipantCreateWithoutAttendancesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    organization?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingParticipantCreateNestedManyWithoutParticipantInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutParticipantInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutParticipantInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutAttendancesInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    organization?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingParticipantUncheckedCreateNestedManyWithoutParticipantInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutParticipantInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutParticipantInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutAttendancesInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutAttendancesInput, ParticipantUncheckedCreateWithoutAttendancesInput>
  }

  export type TrainingUpsertWithoutAttendanceInput = {
    update: XOR<TrainingUpdateWithoutAttendanceInput, TrainingUncheckedUpdateWithoutAttendanceInput>
    create: XOR<TrainingCreateWithoutAttendanceInput, TrainingUncheckedCreateWithoutAttendanceInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutAttendanceInput, TrainingUncheckedUpdateWithoutAttendanceInput>
  }

  export type TrainingUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingSessionUpsertWithoutAttendanceInput = {
    update: XOR<TrainingSessionUpdateWithoutAttendanceInput, TrainingSessionUncheckedUpdateWithoutAttendanceInput>
    create: XOR<TrainingSessionCreateWithoutAttendanceInput, TrainingSessionUncheckedCreateWithoutAttendanceInput>
    where?: TrainingSessionWhereInput
  }

  export type TrainingSessionUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: TrainingSessionWhereInput
    data: XOR<TrainingSessionUpdateWithoutAttendanceInput, TrainingSessionUncheckedUpdateWithoutAttendanceInput>
  }

  export type TrainingSessionUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutSessionsNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutSessionNestedInput
    photos?: TrainingSessionPhotoUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutSessionNestedInput
    photos?: TrainingSessionPhotoUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ParticipantUpsertWithoutAttendancesInput = {
    update: XOR<ParticipantUpdateWithoutAttendancesInput, ParticipantUncheckedUpdateWithoutAttendancesInput>
    create: XOR<ParticipantCreateWithoutAttendancesInput, ParticipantUncheckedCreateWithoutAttendancesInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutAttendancesInput, ParticipantUncheckedUpdateWithoutAttendancesInput>
  }

  export type ParticipantUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingParticipantUpdateManyWithoutParticipantNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutParticipantNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutParticipantNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingParticipantUncheckedUpdateManyWithoutParticipantNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutParticipantNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutParticipantNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TrainingCreateWithoutPhotosInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutPhotosInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutPhotosInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutPhotosInput, TrainingUncheckedCreateWithoutPhotosInput>
  }

  export type UserCreateWithoutUploadedPhotosInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutUploadedPhotosInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUploadedPhotosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedPhotosInput, UserUncheckedCreateWithoutUploadedPhotosInput>
  }

  export type TrainingUpsertWithoutPhotosInput = {
    update: XOR<TrainingUpdateWithoutPhotosInput, TrainingUncheckedUpdateWithoutPhotosInput>
    create: XOR<TrainingCreateWithoutPhotosInput, TrainingUncheckedCreateWithoutPhotosInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutPhotosInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutPhotosInput, TrainingUncheckedUpdateWithoutPhotosInput>
  }

  export type TrainingUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type UserUpsertWithoutUploadedPhotosInput = {
    update: XOR<UserUpdateWithoutUploadedPhotosInput, UserUncheckedUpdateWithoutUploadedPhotosInput>
    create: XOR<UserCreateWithoutUploadedPhotosInput, UserUncheckedCreateWithoutUploadedPhotosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedPhotosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedPhotosInput, UserUncheckedUpdateWithoutUploadedPhotosInput>
  }

  export type UserUpdateWithoutUploadedPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TrainingCreateWithoutFeedbackInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutFeedbackInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutFeedbackInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutFeedbackInput, TrainingUncheckedCreateWithoutFeedbackInput>
  }

  export type ParticipantCreateWithoutFeedbacksInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    organization?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingParticipantCreateNestedManyWithoutParticipantInput
    attendances?: AttendanceCreateNestedManyWithoutParticipantInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutParticipantInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    organization?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingParticipantUncheckedCreateNestedManyWithoutParticipantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutParticipantInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutParticipantInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutFeedbacksInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutFeedbacksInput, ParticipantUncheckedCreateWithoutFeedbacksInput>
  }

  export type TrainingUpsertWithoutFeedbackInput = {
    update: XOR<TrainingUpdateWithoutFeedbackInput, TrainingUncheckedUpdateWithoutFeedbackInput>
    create: XOR<TrainingCreateWithoutFeedbackInput, TrainingUncheckedCreateWithoutFeedbackInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutFeedbackInput, TrainingUncheckedUpdateWithoutFeedbackInput>
  }

  export type TrainingUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type ParticipantUpsertWithoutFeedbacksInput = {
    update: XOR<ParticipantUpdateWithoutFeedbacksInput, ParticipantUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<ParticipantCreateWithoutFeedbacksInput, ParticipantUncheckedCreateWithoutFeedbacksInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutFeedbacksInput, ParticipantUncheckedUpdateWithoutFeedbacksInput>
  }

  export type ParticipantUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingParticipantUpdateManyWithoutParticipantNestedInput
    attendances?: AttendanceUpdateManyWithoutParticipantNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutParticipantNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingParticipantUncheckedUpdateManyWithoutParticipantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutParticipantNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutParticipantNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TrainingCreateWithoutFeedbackFormsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutFeedbackFormsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutFeedbackFormsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutFeedbackFormsInput, TrainingUncheckedCreateWithoutFeedbackFormsInput>
  }

  export type TrainingSessionCreateWithoutFeedbackFormsInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutSessionsInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
    photos?: TrainingSessionPhotoCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionUncheckedCreateWithoutFeedbackFormsInput = {
    id?: string
    trainingId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
    photos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionCreateOrConnectWithoutFeedbackFormsInput = {
    where: TrainingSessionWhereUniqueInput
    create: XOR<TrainingSessionCreateWithoutFeedbackFormsInput, TrainingSessionUncheckedCreateWithoutFeedbackFormsInput>
  }

  export type ParticipantCreateWithoutFeedbackFormsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    organization?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingParticipantCreateNestedManyWithoutParticipantInput
    attendances?: AttendanceCreateNestedManyWithoutParticipantInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutParticipantInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutFeedbackFormsInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    organization?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingParticipantUncheckedCreateNestedManyWithoutParticipantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutParticipantInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutParticipantInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutFeedbackFormsInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutFeedbackFormsInput, ParticipantUncheckedCreateWithoutFeedbackFormsInput>
  }

  export type UserCreateWithoutUploadedFeedbackFormsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutUploadedFeedbackFormsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUploadedFeedbackFormsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedFeedbackFormsInput, UserUncheckedCreateWithoutUploadedFeedbackFormsInput>
  }

  export type TrainingUpsertWithoutFeedbackFormsInput = {
    update: XOR<TrainingUpdateWithoutFeedbackFormsInput, TrainingUncheckedUpdateWithoutFeedbackFormsInput>
    create: XOR<TrainingCreateWithoutFeedbackFormsInput, TrainingUncheckedCreateWithoutFeedbackFormsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutFeedbackFormsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutFeedbackFormsInput, TrainingUncheckedUpdateWithoutFeedbackFormsInput>
  }

  export type TrainingUpdateWithoutFeedbackFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutFeedbackFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingSessionUpsertWithoutFeedbackFormsInput = {
    update: XOR<TrainingSessionUpdateWithoutFeedbackFormsInput, TrainingSessionUncheckedUpdateWithoutFeedbackFormsInput>
    create: XOR<TrainingSessionCreateWithoutFeedbackFormsInput, TrainingSessionUncheckedCreateWithoutFeedbackFormsInput>
    where?: TrainingSessionWhereInput
  }

  export type TrainingSessionUpdateToOneWithWhereWithoutFeedbackFormsInput = {
    where?: TrainingSessionWhereInput
    data: XOR<TrainingSessionUpdateWithoutFeedbackFormsInput, TrainingSessionUncheckedUpdateWithoutFeedbackFormsInput>
  }

  export type TrainingSessionUpdateWithoutFeedbackFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutSessionsNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
    photos?: TrainingSessionPhotoUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionUncheckedUpdateWithoutFeedbackFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
    photos?: TrainingSessionPhotoUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ParticipantUpsertWithoutFeedbackFormsInput = {
    update: XOR<ParticipantUpdateWithoutFeedbackFormsInput, ParticipantUncheckedUpdateWithoutFeedbackFormsInput>
    create: XOR<ParticipantCreateWithoutFeedbackFormsInput, ParticipantUncheckedCreateWithoutFeedbackFormsInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutFeedbackFormsInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutFeedbackFormsInput, ParticipantUncheckedUpdateWithoutFeedbackFormsInput>
  }

  export type ParticipantUpdateWithoutFeedbackFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingParticipantUpdateManyWithoutParticipantNestedInput
    attendances?: AttendanceUpdateManyWithoutParticipantNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutParticipantNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutFeedbackFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingParticipantUncheckedUpdateManyWithoutParticipantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutParticipantNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutParticipantNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type UserUpsertWithoutUploadedFeedbackFormsInput = {
    update: XOR<UserUpdateWithoutUploadedFeedbackFormsInput, UserUncheckedUpdateWithoutUploadedFeedbackFormsInput>
    create: XOR<UserCreateWithoutUploadedFeedbackFormsInput, UserUncheckedCreateWithoutUploadedFeedbackFormsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedFeedbackFormsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedFeedbackFormsInput, UserUncheckedUpdateWithoutUploadedFeedbackFormsInput>
  }

  export type UserUpdateWithoutUploadedFeedbackFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedFeedbackFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TrainingCreateWithoutFollowupsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutFollowupsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutFollowupsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutFollowupsInput, TrainingUncheckedCreateWithoutFollowupsInput>
  }

  export type UserCreateWithoutAssignedFollowupsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAssignedFollowupsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAssignedFollowupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedFollowupsInput, UserUncheckedCreateWithoutAssignedFollowupsInput>
  }

  export type UserCreateWithoutCreatedFollowupsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutCreatedFollowupsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreatedFollowupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedFollowupsInput, UserUncheckedCreateWithoutCreatedFollowupsInput>
  }

  export type TrainingUpsertWithoutFollowupsInput = {
    update: XOR<TrainingUpdateWithoutFollowupsInput, TrainingUncheckedUpdateWithoutFollowupsInput>
    create: XOR<TrainingCreateWithoutFollowupsInput, TrainingUncheckedCreateWithoutFollowupsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutFollowupsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutFollowupsInput, TrainingUncheckedUpdateWithoutFollowupsInput>
  }

  export type TrainingUpdateWithoutFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type UserUpsertWithoutAssignedFollowupsInput = {
    update: XOR<UserUpdateWithoutAssignedFollowupsInput, UserUncheckedUpdateWithoutAssignedFollowupsInput>
    create: XOR<UserCreateWithoutAssignedFollowupsInput, UserUncheckedCreateWithoutAssignedFollowupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedFollowupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedFollowupsInput, UserUncheckedUpdateWithoutAssignedFollowupsInput>
  }

  export type UserUpdateWithoutAssignedFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithoutCreatedFollowupsInput = {
    update: XOR<UserUpdateWithoutCreatedFollowupsInput, UserUncheckedUpdateWithoutCreatedFollowupsInput>
    create: XOR<UserCreateWithoutCreatedFollowupsInput, UserUncheckedCreateWithoutCreatedFollowupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedFollowupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedFollowupsInput, UserUncheckedUpdateWithoutCreatedFollowupsInput>
  }

  export type UserUpdateWithoutCreatedFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TrainingCreateWithoutNotificationsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutNotificationsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    inviteTokens?: TrainingInviteTokenUncheckedCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutNotificationsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutNotificationsInput, TrainingUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutTrainingNotificationsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutTrainingNotificationsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutTrainingNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrainingNotificationsInput, UserUncheckedCreateWithoutTrainingNotificationsInput>
  }

  export type TrainingUpsertWithoutNotificationsInput = {
    update: XOR<TrainingUpdateWithoutNotificationsInput, TrainingUncheckedUpdateWithoutNotificationsInput>
    create: XOR<TrainingCreateWithoutNotificationsInput, TrainingUncheckedCreateWithoutNotificationsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutNotificationsInput, TrainingUncheckedUpdateWithoutNotificationsInput>
  }

  export type TrainingUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type UserUpsertWithoutTrainingNotificationsInput = {
    update: XOR<UserUpdateWithoutTrainingNotificationsInput, UserUncheckedUpdateWithoutTrainingNotificationsInput>
    create: XOR<UserCreateWithoutTrainingNotificationsInput, UserUncheckedCreateWithoutTrainingNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrainingNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrainingNotificationsInput, UserUncheckedUpdateWithoutTrainingNotificationsInput>
  }

  export type UserUpdateWithoutTrainingNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTrainingNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TrainingCreateWithoutInviteTokensInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutInviteTokensInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutInviteTokensInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutInviteTokensInput, TrainingUncheckedCreateWithoutInviteTokensInput>
  }

  export type ParticipantCreateWithoutInviteTokensInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    organization?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingParticipantCreateNestedManyWithoutParticipantInput
    attendances?: AttendanceCreateNestedManyWithoutParticipantInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutParticipantInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutInviteTokensInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    organization?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingParticipantUncheckedCreateNestedManyWithoutParticipantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutParticipantInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutParticipantInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutInviteTokensInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutInviteTokensInput, ParticipantUncheckedCreateWithoutInviteTokensInput>
  }

  export type TrainingUpsertWithoutInviteTokensInput = {
    update: XOR<TrainingUpdateWithoutInviteTokensInput, TrainingUncheckedUpdateWithoutInviteTokensInput>
    create: XOR<TrainingCreateWithoutInviteTokensInput, TrainingUncheckedCreateWithoutInviteTokensInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutInviteTokensInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutInviteTokensInput, TrainingUncheckedUpdateWithoutInviteTokensInput>
  }

  export type TrainingUpdateWithoutInviteTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutInviteTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type ParticipantUpsertWithoutInviteTokensInput = {
    update: XOR<ParticipantUpdateWithoutInviteTokensInput, ParticipantUncheckedUpdateWithoutInviteTokensInput>
    create: XOR<ParticipantCreateWithoutInviteTokensInput, ParticipantUncheckedCreateWithoutInviteTokensInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutInviteTokensInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutInviteTokensInput, ParticipantUncheckedUpdateWithoutInviteTokensInput>
  }

  export type ParticipantUpdateWithoutInviteTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingParticipantUpdateManyWithoutParticipantNestedInput
    attendances?: AttendanceUpdateManyWithoutParticipantNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutParticipantNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutInviteTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingParticipantUncheckedUpdateManyWithoutParticipantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutParticipantNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutParticipantNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TrainingSessionCreateWithoutPhotosInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutSessionsInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
    feedbackForms?: FeedbackFormCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionUncheckedCreateWithoutPhotosInput = {
    id?: string
    trainingId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
    feedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionCreateOrConnectWithoutPhotosInput = {
    where: TrainingSessionWhereUniqueInput
    create: XOR<TrainingSessionCreateWithoutPhotosInput, TrainingSessionUncheckedCreateWithoutPhotosInput>
  }

  export type UserCreateWithoutUploadedSessionPhotosInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutUploadedSessionPhotosInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUploadedSessionPhotosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedSessionPhotosInput, UserUncheckedCreateWithoutUploadedSessionPhotosInput>
  }

  export type TrainingSessionUpsertWithoutPhotosInput = {
    update: XOR<TrainingSessionUpdateWithoutPhotosInput, TrainingSessionUncheckedUpdateWithoutPhotosInput>
    create: XOR<TrainingSessionCreateWithoutPhotosInput, TrainingSessionUncheckedCreateWithoutPhotosInput>
    where?: TrainingSessionWhereInput
  }

  export type TrainingSessionUpdateToOneWithWhereWithoutPhotosInput = {
    where?: TrainingSessionWhereInput
    data: XOR<TrainingSessionUpdateWithoutPhotosInput, TrainingSessionUncheckedUpdateWithoutPhotosInput>
  }

  export type TrainingSessionUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutSessionsNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserUpsertWithoutUploadedSessionPhotosInput = {
    update: XOR<UserUpdateWithoutUploadedSessionPhotosInput, UserUncheckedUpdateWithoutUploadedSessionPhotosInput>
    create: XOR<UserCreateWithoutUploadedSessionPhotosInput, UserUncheckedCreateWithoutUploadedSessionPhotosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedSessionPhotosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedSessionPhotosInput, UserUncheckedUpdateWithoutUploadedSessionPhotosInput>
  }

  export type UserUpdateWithoutUploadedSessionPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedSessionPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutAuditorProfileInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAuditorProfileInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAuditorProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditorProfileInput, UserUncheckedCreateWithoutAuditorProfileInput>
  }

  export type AuditCreateWithoutAuditorInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditee?: UserCreateNestedOneWithoutAuditeeAuditsInput
    department?: DepartmentCreateNestedOneWithoutAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    findings?: FindingCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutAuditorInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditeeId?: string | null
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    findings?: FindingUncheckedCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentUncheckedCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderUncheckedCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationUncheckedCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutAuditorInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutAuditorInput, AuditUncheckedCreateWithoutAuditorInput>
  }

  export type AuditCreateManyAuditorInputEnvelope = {
    data: AuditCreateManyAuditorInput | AuditCreateManyAuditorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAuditorProfileInput = {
    update: XOR<UserUpdateWithoutAuditorProfileInput, UserUncheckedUpdateWithoutAuditorProfileInput>
    create: XOR<UserCreateWithoutAuditorProfileInput, UserUncheckedCreateWithoutAuditorProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditorProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditorProfileInput, UserUncheckedUpdateWithoutAuditorProfileInput>
  }

  export type UserUpdateWithoutAuditorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type AuditUpsertWithWhereUniqueWithoutAuditorInput = {
    where: AuditWhereUniqueInput
    update: XOR<AuditUpdateWithoutAuditorInput, AuditUncheckedUpdateWithoutAuditorInput>
    create: XOR<AuditCreateWithoutAuditorInput, AuditUncheckedCreateWithoutAuditorInput>
  }

  export type AuditUpdateWithWhereUniqueWithoutAuditorInput = {
    where: AuditWhereUniqueInput
    data: XOR<AuditUpdateWithoutAuditorInput, AuditUncheckedUpdateWithoutAuditorInput>
  }

  export type AuditUpdateManyWithWhereWithoutAuditorInput = {
    where: AuditScalarWhereInput
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyWithoutAuditorInput>
  }

  export type AuditorCreateWithoutAuditsInput = {
    id?: string
    name: string
    email: string
    isExternal?: boolean
    firmName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditorProfileInput
  }

  export type AuditorUncheckedCreateWithoutAuditsInput = {
    id?: string
    name: string
    email: string
    userId?: string | null
    isExternal?: boolean
    firmName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditorCreateOrConnectWithoutAuditsInput = {
    where: AuditorWhereUniqueInput
    create: XOR<AuditorCreateWithoutAuditsInput, AuditorUncheckedCreateWithoutAuditsInput>
  }

  export type UserCreateWithoutAuditeeAuditsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAuditeeAuditsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAuditeeAuditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditeeAuditsInput, UserUncheckedCreateWithoutAuditeeAuditsInput>
  }

  export type DepartmentCreateWithoutAuditsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUncheckedCreateWithoutAuditsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateOrConnectWithoutAuditsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutAuditsInput, DepartmentUncheckedCreateWithoutAuditsInput>
  }

  export type UserCreateWithoutCreatedAuditsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutCreatedAuditsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreatedAuditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedAuditsInput, UserUncheckedCreateWithoutCreatedAuditsInput>
  }

  export type FindingCreateWithoutAuditInput = {
    id?: string
    title: string
    description: string
    findingType: $Enums.FindingType
    status?: $Enums.FindingStatus
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    assignedTo?: UserCreateNestedOneWithoutAssignedFindingsInput
    actions?: CorrectiveActionCreateNestedManyWithoutFindingInput
  }

  export type FindingUncheckedCreateWithoutAuditInput = {
    id?: string
    title: string
    description: string
    findingType: $Enums.FindingType
    status?: $Enums.FindingStatus
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assignedToId?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutFindingInput
  }

  export type FindingCreateOrConnectWithoutAuditInput = {
    where: FindingWhereUniqueInput
    create: XOR<FindingCreateWithoutAuditInput, FindingUncheckedCreateWithoutAuditInput>
  }

  export type FindingCreateManyAuditInputEnvelope = {
    data: FindingCreateManyAuditInput | FindingCreateManyAuditInput[]
    skipDuplicates?: boolean
  }

  export type AuditDocumentCreateWithoutAuditInput = {
    id?: string
    title: string
    description?: string | null
    documentType: $Enums.AuditDocumentType
    fileUrl: string
    filePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutUploadedAuditDocumentsInput
  }

  export type AuditDocumentUncheckedCreateWithoutAuditInput = {
    id?: string
    title: string
    description?: string | null
    documentType: $Enums.AuditDocumentType
    fileUrl: string
    filePath?: string | null
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditDocumentCreateOrConnectWithoutAuditInput = {
    where: AuditDocumentWhereUniqueInput
    create: XOR<AuditDocumentCreateWithoutAuditInput, AuditDocumentUncheckedCreateWithoutAuditInput>
  }

  export type AuditDocumentCreateManyAuditInputEnvelope = {
    data: AuditDocumentCreateManyAuditInput | AuditDocumentCreateManyAuditInput[]
    skipDuplicates?: boolean
  }

  export type CorrectiveActionCreateWithoutAuditInput = {
    id?: string
    title: string
    description: string
    actionType: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    finding?: FindingCreateNestedOneWithoutActionsInput
    assignedTo: UserCreateNestedOneWithoutAssignedActionsInput
    verifiedBy?: UserCreateNestedOneWithoutVerifiedActionsInput
  }

  export type CorrectiveActionUncheckedCreateWithoutAuditInput = {
    id?: string
    findingId?: string | null
    title: string
    description: string
    actionType: string
    assignedToId: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    verifiedById?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrectiveActionCreateOrConnectWithoutAuditInput = {
    where: CorrectiveActionWhereUniqueInput
    create: XOR<CorrectiveActionCreateWithoutAuditInput, CorrectiveActionUncheckedCreateWithoutAuditInput>
  }

  export type CorrectiveActionCreateManyAuditInputEnvelope = {
    data: CorrectiveActionCreateManyAuditInput | CorrectiveActionCreateManyAuditInput[]
    skipDuplicates?: boolean
  }

  export type AuditReminderCreateWithoutAuditInput = {
    id?: string
    title: string
    message: string
    dueDate: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
    recipient: UserCreateNestedOneWithoutReceivedRemindersInput
    createdBy: UserCreateNestedOneWithoutCreatedRemindersInput
  }

  export type AuditReminderUncheckedCreateWithoutAuditInput = {
    id?: string
    title: string
    message: string
    dueDate: Date | string
    status: string
    recipientId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
  }

  export type AuditReminderCreateOrConnectWithoutAuditInput = {
    where: AuditReminderWhereUniqueInput
    create: XOR<AuditReminderCreateWithoutAuditInput, AuditReminderUncheckedCreateWithoutAuditInput>
  }

  export type AuditReminderCreateManyAuditInputEnvelope = {
    data: AuditReminderCreateManyAuditInput | AuditReminderCreateManyAuditInput[]
    skipDuplicates?: boolean
  }

  export type AuditNotificationCreateWithoutAuditInput = {
    id?: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutAuditNotificationsInput
  }

  export type AuditNotificationUncheckedCreateWithoutAuditInput = {
    id?: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type AuditNotificationCreateOrConnectWithoutAuditInput = {
    where: AuditNotificationWhereUniqueInput
    create: XOR<AuditNotificationCreateWithoutAuditInput, AuditNotificationUncheckedCreateWithoutAuditInput>
  }

  export type AuditNotificationCreateManyAuditInputEnvelope = {
    data: AuditNotificationCreateManyAuditInput | AuditNotificationCreateManyAuditInput[]
    skipDuplicates?: boolean
  }

  export type PreAuditChecklistItemCreateWithoutAuditInput = {
    id?: string
    description: string
    isCompleted?: boolean
    comments?: string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsible: UserCreateNestedOneWithoutResponsibleForChecklistItemsInput
    createdBy: UserCreateNestedOneWithoutCreatedChecklistItemsInput
  }

  export type PreAuditChecklistItemUncheckedCreateWithoutAuditInput = {
    id?: string
    description: string
    isCompleted?: boolean
    comments?: string | null
    responsibleId: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreAuditChecklistItemCreateOrConnectWithoutAuditInput = {
    where: PreAuditChecklistItemWhereUniqueInput
    create: XOR<PreAuditChecklistItemCreateWithoutAuditInput, PreAuditChecklistItemUncheckedCreateWithoutAuditInput>
  }

  export type PreAuditChecklistItemCreateManyAuditInputEnvelope = {
    data: PreAuditChecklistItemCreateManyAuditInput | PreAuditChecklistItemCreateManyAuditInput[]
    skipDuplicates?: boolean
  }

  export type AuditInspectionItemCreateWithoutAuditInput = {
    id?: string
    areaName: string
    itemName: string
    description?: string | null
    standardReference?: string | null
    isCompliant?: boolean | null
    comments?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inspectedBy?: UserCreateNestedOneWithoutInspectedItemsInput
  }

  export type AuditInspectionItemUncheckedCreateWithoutAuditInput = {
    id?: string
    areaName: string
    itemName: string
    description?: string | null
    standardReference?: string | null
    isCompliant?: boolean | null
    comments?: string | null
    evidence?: string | null
    inspectedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditInspectionItemCreateOrConnectWithoutAuditInput = {
    where: AuditInspectionItemWhereUniqueInput
    create: XOR<AuditInspectionItemCreateWithoutAuditInput, AuditInspectionItemUncheckedCreateWithoutAuditInput>
  }

  export type AuditInspectionItemCreateManyAuditInputEnvelope = {
    data: AuditInspectionItemCreateManyAuditInput | AuditInspectionItemCreateManyAuditInput[]
    skipDuplicates?: boolean
  }

  export type AuditorUpsertWithoutAuditsInput = {
    update: XOR<AuditorUpdateWithoutAuditsInput, AuditorUncheckedUpdateWithoutAuditsInput>
    create: XOR<AuditorCreateWithoutAuditsInput, AuditorUncheckedCreateWithoutAuditsInput>
    where?: AuditorWhereInput
  }

  export type AuditorUpdateToOneWithWhereWithoutAuditsInput = {
    where?: AuditorWhereInput
    data: XOR<AuditorUpdateWithoutAuditsInput, AuditorUncheckedUpdateWithoutAuditsInput>
  }

  export type AuditorUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditorProfileNestedInput
  }

  export type AuditorUncheckedUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAuditeeAuditsInput = {
    update: XOR<UserUpdateWithoutAuditeeAuditsInput, UserUncheckedUpdateWithoutAuditeeAuditsInput>
    create: XOR<UserCreateWithoutAuditeeAuditsInput, UserUncheckedCreateWithoutAuditeeAuditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditeeAuditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditeeAuditsInput, UserUncheckedUpdateWithoutAuditeeAuditsInput>
  }

  export type UserUpdateWithoutAuditeeAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditeeAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type DepartmentUpsertWithoutAuditsInput = {
    update: XOR<DepartmentUpdateWithoutAuditsInput, DepartmentUncheckedUpdateWithoutAuditsInput>
    create: XOR<DepartmentCreateWithoutAuditsInput, DepartmentUncheckedCreateWithoutAuditsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutAuditsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutAuditsInput, DepartmentUncheckedUpdateWithoutAuditsInput>
  }

  export type DepartmentUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedAuditsInput = {
    update: XOR<UserUpdateWithoutCreatedAuditsInput, UserUncheckedUpdateWithoutCreatedAuditsInput>
    create: XOR<UserCreateWithoutCreatedAuditsInput, UserUncheckedCreateWithoutCreatedAuditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedAuditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedAuditsInput, UserUncheckedUpdateWithoutCreatedAuditsInput>
  }

  export type UserUpdateWithoutCreatedAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type FindingUpsertWithWhereUniqueWithoutAuditInput = {
    where: FindingWhereUniqueInput
    update: XOR<FindingUpdateWithoutAuditInput, FindingUncheckedUpdateWithoutAuditInput>
    create: XOR<FindingCreateWithoutAuditInput, FindingUncheckedCreateWithoutAuditInput>
  }

  export type FindingUpdateWithWhereUniqueWithoutAuditInput = {
    where: FindingWhereUniqueInput
    data: XOR<FindingUpdateWithoutAuditInput, FindingUncheckedUpdateWithoutAuditInput>
  }

  export type FindingUpdateManyWithWhereWithoutAuditInput = {
    where: FindingScalarWhereInput
    data: XOR<FindingUpdateManyMutationInput, FindingUncheckedUpdateManyWithoutAuditInput>
  }

  export type AuditDocumentUpsertWithWhereUniqueWithoutAuditInput = {
    where: AuditDocumentWhereUniqueInput
    update: XOR<AuditDocumentUpdateWithoutAuditInput, AuditDocumentUncheckedUpdateWithoutAuditInput>
    create: XOR<AuditDocumentCreateWithoutAuditInput, AuditDocumentUncheckedCreateWithoutAuditInput>
  }

  export type AuditDocumentUpdateWithWhereUniqueWithoutAuditInput = {
    where: AuditDocumentWhereUniqueInput
    data: XOR<AuditDocumentUpdateWithoutAuditInput, AuditDocumentUncheckedUpdateWithoutAuditInput>
  }

  export type AuditDocumentUpdateManyWithWhereWithoutAuditInput = {
    where: AuditDocumentScalarWhereInput
    data: XOR<AuditDocumentUpdateManyMutationInput, AuditDocumentUncheckedUpdateManyWithoutAuditInput>
  }

  export type CorrectiveActionUpsertWithWhereUniqueWithoutAuditInput = {
    where: CorrectiveActionWhereUniqueInput
    update: XOR<CorrectiveActionUpdateWithoutAuditInput, CorrectiveActionUncheckedUpdateWithoutAuditInput>
    create: XOR<CorrectiveActionCreateWithoutAuditInput, CorrectiveActionUncheckedCreateWithoutAuditInput>
  }

  export type CorrectiveActionUpdateWithWhereUniqueWithoutAuditInput = {
    where: CorrectiveActionWhereUniqueInput
    data: XOR<CorrectiveActionUpdateWithoutAuditInput, CorrectiveActionUncheckedUpdateWithoutAuditInput>
  }

  export type CorrectiveActionUpdateManyWithWhereWithoutAuditInput = {
    where: CorrectiveActionScalarWhereInput
    data: XOR<CorrectiveActionUpdateManyMutationInput, CorrectiveActionUncheckedUpdateManyWithoutAuditInput>
  }

  export type AuditReminderUpsertWithWhereUniqueWithoutAuditInput = {
    where: AuditReminderWhereUniqueInput
    update: XOR<AuditReminderUpdateWithoutAuditInput, AuditReminderUncheckedUpdateWithoutAuditInput>
    create: XOR<AuditReminderCreateWithoutAuditInput, AuditReminderUncheckedCreateWithoutAuditInput>
  }

  export type AuditReminderUpdateWithWhereUniqueWithoutAuditInput = {
    where: AuditReminderWhereUniqueInput
    data: XOR<AuditReminderUpdateWithoutAuditInput, AuditReminderUncheckedUpdateWithoutAuditInput>
  }

  export type AuditReminderUpdateManyWithWhereWithoutAuditInput = {
    where: AuditReminderScalarWhereInput
    data: XOR<AuditReminderUpdateManyMutationInput, AuditReminderUncheckedUpdateManyWithoutAuditInput>
  }

  export type AuditNotificationUpsertWithWhereUniqueWithoutAuditInput = {
    where: AuditNotificationWhereUniqueInput
    update: XOR<AuditNotificationUpdateWithoutAuditInput, AuditNotificationUncheckedUpdateWithoutAuditInput>
    create: XOR<AuditNotificationCreateWithoutAuditInput, AuditNotificationUncheckedCreateWithoutAuditInput>
  }

  export type AuditNotificationUpdateWithWhereUniqueWithoutAuditInput = {
    where: AuditNotificationWhereUniqueInput
    data: XOR<AuditNotificationUpdateWithoutAuditInput, AuditNotificationUncheckedUpdateWithoutAuditInput>
  }

  export type AuditNotificationUpdateManyWithWhereWithoutAuditInput = {
    where: AuditNotificationScalarWhereInput
    data: XOR<AuditNotificationUpdateManyMutationInput, AuditNotificationUncheckedUpdateManyWithoutAuditInput>
  }

  export type PreAuditChecklistItemUpsertWithWhereUniqueWithoutAuditInput = {
    where: PreAuditChecklistItemWhereUniqueInput
    update: XOR<PreAuditChecklistItemUpdateWithoutAuditInput, PreAuditChecklistItemUncheckedUpdateWithoutAuditInput>
    create: XOR<PreAuditChecklistItemCreateWithoutAuditInput, PreAuditChecklistItemUncheckedCreateWithoutAuditInput>
  }

  export type PreAuditChecklistItemUpdateWithWhereUniqueWithoutAuditInput = {
    where: PreAuditChecklistItemWhereUniqueInput
    data: XOR<PreAuditChecklistItemUpdateWithoutAuditInput, PreAuditChecklistItemUncheckedUpdateWithoutAuditInput>
  }

  export type PreAuditChecklistItemUpdateManyWithWhereWithoutAuditInput = {
    where: PreAuditChecklistItemScalarWhereInput
    data: XOR<PreAuditChecklistItemUpdateManyMutationInput, PreAuditChecklistItemUncheckedUpdateManyWithoutAuditInput>
  }

  export type AuditInspectionItemUpsertWithWhereUniqueWithoutAuditInput = {
    where: AuditInspectionItemWhereUniqueInput
    update: XOR<AuditInspectionItemUpdateWithoutAuditInput, AuditInspectionItemUncheckedUpdateWithoutAuditInput>
    create: XOR<AuditInspectionItemCreateWithoutAuditInput, AuditInspectionItemUncheckedCreateWithoutAuditInput>
  }

  export type AuditInspectionItemUpdateWithWhereUniqueWithoutAuditInput = {
    where: AuditInspectionItemWhereUniqueInput
    data: XOR<AuditInspectionItemUpdateWithoutAuditInput, AuditInspectionItemUncheckedUpdateWithoutAuditInput>
  }

  export type AuditInspectionItemUpdateManyWithWhereWithoutAuditInput = {
    where: AuditInspectionItemScalarWhereInput
    data: XOR<AuditInspectionItemUpdateManyMutationInput, AuditInspectionItemUncheckedUpdateManyWithoutAuditInput>
  }

  export type AuditCreateWithoutInspectionItemsInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditor: AuditorCreateNestedOneWithoutAuditsInput
    auditee?: UserCreateNestedOneWithoutAuditeeAuditsInput
    department?: DepartmentCreateNestedOneWithoutAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    findings?: FindingCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutInspectionItemsInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    auditeeId?: string | null
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    findings?: FindingUncheckedCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentUncheckedCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderUncheckedCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationUncheckedCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutInspectionItemsInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutInspectionItemsInput, AuditUncheckedCreateWithoutInspectionItemsInput>
  }

  export type UserCreateWithoutInspectedItemsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutInspectedItemsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutInspectedItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInspectedItemsInput, UserUncheckedCreateWithoutInspectedItemsInput>
  }

  export type AuditUpsertWithoutInspectionItemsInput = {
    update: XOR<AuditUpdateWithoutInspectionItemsInput, AuditUncheckedUpdateWithoutInspectionItemsInput>
    create: XOR<AuditCreateWithoutInspectionItemsInput, AuditUncheckedCreateWithoutInspectionItemsInput>
    where?: AuditWhereInput
  }

  export type AuditUpdateToOneWithWhereWithoutInspectionItemsInput = {
    where?: AuditWhereInput
    data: XOR<AuditUpdateWithoutInspectionItemsInput, AuditUncheckedUpdateWithoutInspectionItemsInput>
  }

  export type AuditUpdateWithoutInspectionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditor?: AuditorUpdateOneRequiredWithoutAuditsNestedInput
    auditee?: UserUpdateOneWithoutAuditeeAuditsNestedInput
    department?: DepartmentUpdateOneWithoutAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    findings?: FindingUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutInspectionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    findings?: FindingUncheckedUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUncheckedUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUncheckedUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUncheckedUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUncheckedUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type UserUpsertWithoutInspectedItemsInput = {
    update: XOR<UserUpdateWithoutInspectedItemsInput, UserUncheckedUpdateWithoutInspectedItemsInput>
    create: XOR<UserCreateWithoutInspectedItemsInput, UserUncheckedCreateWithoutInspectedItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInspectedItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInspectedItemsInput, UserUncheckedUpdateWithoutInspectedItemsInput>
  }

  export type UserUpdateWithoutInspectedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInspectedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type AuditCreateWithoutDepartmentInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditor: AuditorCreateNestedOneWithoutAuditsInput
    auditee?: UserCreateNestedOneWithoutAuditeeAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    findings?: FindingCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutDepartmentInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    auditeeId?: string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    findings?: FindingUncheckedCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentUncheckedCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderUncheckedCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationUncheckedCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutDepartmentInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutDepartmentInput, AuditUncheckedCreateWithoutDepartmentInput>
  }

  export type AuditCreateManyDepartmentInputEnvelope = {
    data: AuditCreateManyDepartmentInput | AuditCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type AuditUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: AuditWhereUniqueInput
    update: XOR<AuditUpdateWithoutDepartmentInput, AuditUncheckedUpdateWithoutDepartmentInput>
    create: XOR<AuditCreateWithoutDepartmentInput, AuditUncheckedCreateWithoutDepartmentInput>
  }

  export type AuditUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: AuditWhereUniqueInput
    data: XOR<AuditUpdateWithoutDepartmentInput, AuditUncheckedUpdateWithoutDepartmentInput>
  }

  export type AuditUpdateManyWithWhereWithoutDepartmentInput = {
    where: AuditScalarWhereInput
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type AuditCreateWithoutFindingsInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditor: AuditorCreateNestedOneWithoutAuditsInput
    auditee?: UserCreateNestedOneWithoutAuditeeAuditsInput
    department?: DepartmentCreateNestedOneWithoutAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    documents?: AuditDocumentCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutFindingsInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    auditeeId?: string | null
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: AuditDocumentUncheckedCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderUncheckedCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationUncheckedCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutFindingsInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutFindingsInput, AuditUncheckedCreateWithoutFindingsInput>
  }

  export type UserCreateWithoutAssignedFindingsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAssignedFindingsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAssignedFindingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedFindingsInput, UserUncheckedCreateWithoutAssignedFindingsInput>
  }

  export type CorrectiveActionCreateWithoutFindingInput = {
    id?: string
    title: string
    description: string
    actionType: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutActionsInput
    assignedTo: UserCreateNestedOneWithoutAssignedActionsInput
    verifiedBy?: UserCreateNestedOneWithoutVerifiedActionsInput
  }

  export type CorrectiveActionUncheckedCreateWithoutFindingInput = {
    id?: string
    auditId: string
    title: string
    description: string
    actionType: string
    assignedToId: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    verifiedById?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrectiveActionCreateOrConnectWithoutFindingInput = {
    where: CorrectiveActionWhereUniqueInput
    create: XOR<CorrectiveActionCreateWithoutFindingInput, CorrectiveActionUncheckedCreateWithoutFindingInput>
  }

  export type CorrectiveActionCreateManyFindingInputEnvelope = {
    data: CorrectiveActionCreateManyFindingInput | CorrectiveActionCreateManyFindingInput[]
    skipDuplicates?: boolean
  }

  export type AuditUpsertWithoutFindingsInput = {
    update: XOR<AuditUpdateWithoutFindingsInput, AuditUncheckedUpdateWithoutFindingsInput>
    create: XOR<AuditCreateWithoutFindingsInput, AuditUncheckedCreateWithoutFindingsInput>
    where?: AuditWhereInput
  }

  export type AuditUpdateToOneWithWhereWithoutFindingsInput = {
    where?: AuditWhereInput
    data: XOR<AuditUpdateWithoutFindingsInput, AuditUncheckedUpdateWithoutFindingsInput>
  }

  export type AuditUpdateWithoutFindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditor?: AuditorUpdateOneRequiredWithoutAuditsNestedInput
    auditee?: UserUpdateOneWithoutAuditeeAuditsNestedInput
    department?: DepartmentUpdateOneWithoutAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    documents?: AuditDocumentUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutFindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: AuditDocumentUncheckedUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUncheckedUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUncheckedUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUncheckedUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type UserUpsertWithoutAssignedFindingsInput = {
    update: XOR<UserUpdateWithoutAssignedFindingsInput, UserUncheckedUpdateWithoutAssignedFindingsInput>
    create: XOR<UserCreateWithoutAssignedFindingsInput, UserUncheckedCreateWithoutAssignedFindingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedFindingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedFindingsInput, UserUncheckedUpdateWithoutAssignedFindingsInput>
  }

  export type UserUpdateWithoutAssignedFindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedFindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type CorrectiveActionUpsertWithWhereUniqueWithoutFindingInput = {
    where: CorrectiveActionWhereUniqueInput
    update: XOR<CorrectiveActionUpdateWithoutFindingInput, CorrectiveActionUncheckedUpdateWithoutFindingInput>
    create: XOR<CorrectiveActionCreateWithoutFindingInput, CorrectiveActionUncheckedCreateWithoutFindingInput>
  }

  export type CorrectiveActionUpdateWithWhereUniqueWithoutFindingInput = {
    where: CorrectiveActionWhereUniqueInput
    data: XOR<CorrectiveActionUpdateWithoutFindingInput, CorrectiveActionUncheckedUpdateWithoutFindingInput>
  }

  export type CorrectiveActionUpdateManyWithWhereWithoutFindingInput = {
    where: CorrectiveActionScalarWhereInput
    data: XOR<CorrectiveActionUpdateManyMutationInput, CorrectiveActionUncheckedUpdateManyWithoutFindingInput>
  }

  export type AuditCreateWithoutActionsInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditor: AuditorCreateNestedOneWithoutAuditsInput
    auditee?: UserCreateNestedOneWithoutAuditeeAuditsInput
    department?: DepartmentCreateNestedOneWithoutAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    findings?: FindingCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutActionsInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    auditeeId?: string | null
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    findings?: FindingUncheckedCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentUncheckedCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderUncheckedCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationUncheckedCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutActionsInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutActionsInput, AuditUncheckedCreateWithoutActionsInput>
  }

  export type FindingCreateWithoutActionsInput = {
    id?: string
    title: string
    description: string
    findingType: $Enums.FindingType
    status?: $Enums.FindingStatus
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    audit: AuditCreateNestedOneWithoutFindingsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedFindingsInput
  }

  export type FindingUncheckedCreateWithoutActionsInput = {
    id?: string
    auditId: string
    title: string
    description: string
    findingType: $Enums.FindingType
    status?: $Enums.FindingStatus
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assignedToId?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type FindingCreateOrConnectWithoutActionsInput = {
    where: FindingWhereUniqueInput
    create: XOR<FindingCreateWithoutActionsInput, FindingUncheckedCreateWithoutActionsInput>
  }

  export type UserCreateWithoutAssignedActionsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAssignedActionsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAssignedActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedActionsInput, UserUncheckedCreateWithoutAssignedActionsInput>
  }

  export type UserCreateWithoutVerifiedActionsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutVerifiedActionsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutVerifiedActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerifiedActionsInput, UserUncheckedCreateWithoutVerifiedActionsInput>
  }

  export type AuditUpsertWithoutActionsInput = {
    update: XOR<AuditUpdateWithoutActionsInput, AuditUncheckedUpdateWithoutActionsInput>
    create: XOR<AuditCreateWithoutActionsInput, AuditUncheckedCreateWithoutActionsInput>
    where?: AuditWhereInput
  }

  export type AuditUpdateToOneWithWhereWithoutActionsInput = {
    where?: AuditWhereInput
    data: XOR<AuditUpdateWithoutActionsInput, AuditUncheckedUpdateWithoutActionsInput>
  }

  export type AuditUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditor?: AuditorUpdateOneRequiredWithoutAuditsNestedInput
    auditee?: UserUpdateOneWithoutAuditeeAuditsNestedInput
    department?: DepartmentUpdateOneWithoutAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    findings?: FindingUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    findings?: FindingUncheckedUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUncheckedUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUncheckedUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUncheckedUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type FindingUpsertWithoutActionsInput = {
    update: XOR<FindingUpdateWithoutActionsInput, FindingUncheckedUpdateWithoutActionsInput>
    create: XOR<FindingCreateWithoutActionsInput, FindingUncheckedCreateWithoutActionsInput>
    where?: FindingWhereInput
  }

  export type FindingUpdateToOneWithWhereWithoutActionsInput = {
    where?: FindingWhereInput
    data: XOR<FindingUpdateWithoutActionsInput, FindingUncheckedUpdateWithoutActionsInput>
  }

  export type FindingUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    findingType?: EnumFindingTypeFieldUpdateOperationsInput | $Enums.FindingType
    status?: EnumFindingStatusFieldUpdateOperationsInput | $Enums.FindingStatus
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: AuditUpdateOneRequiredWithoutFindingsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedFindingsNestedInput
  }

  export type FindingUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    findingType?: EnumFindingTypeFieldUpdateOperationsInput | $Enums.FindingType
    status?: EnumFindingStatusFieldUpdateOperationsInput | $Enums.FindingStatus
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutAssignedActionsInput = {
    update: XOR<UserUpdateWithoutAssignedActionsInput, UserUncheckedUpdateWithoutAssignedActionsInput>
    create: XOR<UserCreateWithoutAssignedActionsInput, UserUncheckedCreateWithoutAssignedActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedActionsInput, UserUncheckedUpdateWithoutAssignedActionsInput>
  }

  export type UserUpdateWithoutAssignedActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithoutVerifiedActionsInput = {
    update: XOR<UserUpdateWithoutVerifiedActionsInput, UserUncheckedUpdateWithoutVerifiedActionsInput>
    create: XOR<UserCreateWithoutVerifiedActionsInput, UserUncheckedCreateWithoutVerifiedActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerifiedActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerifiedActionsInput, UserUncheckedUpdateWithoutVerifiedActionsInput>
  }

  export type UserUpdateWithoutVerifiedActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutVerifiedActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type AuditCreateWithoutDocumentsInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditor: AuditorCreateNestedOneWithoutAuditsInput
    auditee?: UserCreateNestedOneWithoutAuditeeAuditsInput
    department?: DepartmentCreateNestedOneWithoutAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    findings?: FindingCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    auditeeId?: string | null
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    findings?: FindingUncheckedCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderUncheckedCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationUncheckedCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutDocumentsInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutDocumentsInput, AuditUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutUploadedAuditDocumentsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutUploadedAuditDocumentsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUploadedAuditDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedAuditDocumentsInput, UserUncheckedCreateWithoutUploadedAuditDocumentsInput>
  }

  export type AuditUpsertWithoutDocumentsInput = {
    update: XOR<AuditUpdateWithoutDocumentsInput, AuditUncheckedUpdateWithoutDocumentsInput>
    create: XOR<AuditCreateWithoutDocumentsInput, AuditUncheckedCreateWithoutDocumentsInput>
    where?: AuditWhereInput
  }

  export type AuditUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: AuditWhereInput
    data: XOR<AuditUpdateWithoutDocumentsInput, AuditUncheckedUpdateWithoutDocumentsInput>
  }

  export type AuditUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditor?: AuditorUpdateOneRequiredWithoutAuditsNestedInput
    auditee?: UserUpdateOneWithoutAuditeeAuditsNestedInput
    department?: DepartmentUpdateOneWithoutAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    findings?: FindingUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    findings?: FindingUncheckedUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUncheckedUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUncheckedUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUncheckedUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type UserUpsertWithoutUploadedAuditDocumentsInput = {
    update: XOR<UserUpdateWithoutUploadedAuditDocumentsInput, UserUncheckedUpdateWithoutUploadedAuditDocumentsInput>
    create: XOR<UserCreateWithoutUploadedAuditDocumentsInput, UserUncheckedCreateWithoutUploadedAuditDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedAuditDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedAuditDocumentsInput, UserUncheckedUpdateWithoutUploadedAuditDocumentsInput>
  }

  export type UserUpdateWithoutUploadedAuditDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedAuditDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type AuditCreateWithoutChecklistItemsInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditor: AuditorCreateNestedOneWithoutAuditsInput
    auditee?: UserCreateNestedOneWithoutAuditeeAuditsInput
    department?: DepartmentCreateNestedOneWithoutAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    findings?: FindingCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutChecklistItemsInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    auditeeId?: string | null
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    findings?: FindingUncheckedCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentUncheckedCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderUncheckedCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationUncheckedCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutChecklistItemsInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutChecklistItemsInput, AuditUncheckedCreateWithoutChecklistItemsInput>
  }

  export type UserCreateWithoutResponsibleForChecklistItemsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutResponsibleForChecklistItemsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutResponsibleForChecklistItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResponsibleForChecklistItemsInput, UserUncheckedCreateWithoutResponsibleForChecklistItemsInput>
  }

  export type UserCreateWithoutCreatedChecklistItemsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutCreatedChecklistItemsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreatedChecklistItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedChecklistItemsInput, UserUncheckedCreateWithoutCreatedChecklistItemsInput>
  }

  export type AuditUpsertWithoutChecklistItemsInput = {
    update: XOR<AuditUpdateWithoutChecklistItemsInput, AuditUncheckedUpdateWithoutChecklistItemsInput>
    create: XOR<AuditCreateWithoutChecklistItemsInput, AuditUncheckedCreateWithoutChecklistItemsInput>
    where?: AuditWhereInput
  }

  export type AuditUpdateToOneWithWhereWithoutChecklistItemsInput = {
    where?: AuditWhereInput
    data: XOR<AuditUpdateWithoutChecklistItemsInput, AuditUncheckedUpdateWithoutChecklistItemsInput>
  }

  export type AuditUpdateWithoutChecklistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditor?: AuditorUpdateOneRequiredWithoutAuditsNestedInput
    auditee?: UserUpdateOneWithoutAuditeeAuditsNestedInput
    department?: DepartmentUpdateOneWithoutAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    findings?: FindingUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutChecklistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    findings?: FindingUncheckedUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUncheckedUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUncheckedUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUncheckedUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUncheckedUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type UserUpsertWithoutResponsibleForChecklistItemsInput = {
    update: XOR<UserUpdateWithoutResponsibleForChecklistItemsInput, UserUncheckedUpdateWithoutResponsibleForChecklistItemsInput>
    create: XOR<UserCreateWithoutResponsibleForChecklistItemsInput, UserUncheckedCreateWithoutResponsibleForChecklistItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResponsibleForChecklistItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResponsibleForChecklistItemsInput, UserUncheckedUpdateWithoutResponsibleForChecklistItemsInput>
  }

  export type UserUpdateWithoutResponsibleForChecklistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutResponsibleForChecklistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithoutCreatedChecklistItemsInput = {
    update: XOR<UserUpdateWithoutCreatedChecklistItemsInput, UserUncheckedUpdateWithoutCreatedChecklistItemsInput>
    create: XOR<UserCreateWithoutCreatedChecklistItemsInput, UserUncheckedCreateWithoutCreatedChecklistItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedChecklistItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedChecklistItemsInput, UserUncheckedUpdateWithoutCreatedChecklistItemsInput>
  }

  export type UserUpdateWithoutCreatedChecklistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedChecklistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type AuditCreateWithoutRemindersInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditor: AuditorCreateNestedOneWithoutAuditsInput
    auditee?: UserCreateNestedOneWithoutAuditeeAuditsInput
    department?: DepartmentCreateNestedOneWithoutAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    findings?: FindingCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutRemindersInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    auditeeId?: string | null
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    findings?: FindingUncheckedCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentUncheckedCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutAuditInput
    notifications?: AuditNotificationUncheckedCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutRemindersInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutRemindersInput, AuditUncheckedCreateWithoutRemindersInput>
  }

  export type UserCreateWithoutReceivedRemindersInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutReceivedRemindersInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutReceivedRemindersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedRemindersInput, UserUncheckedCreateWithoutReceivedRemindersInput>
  }

  export type UserCreateWithoutCreatedRemindersInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutCreatedRemindersInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    auditNotifications?: AuditNotificationUncheckedCreateNestedManyWithoutUserInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreatedRemindersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedRemindersInput, UserUncheckedCreateWithoutCreatedRemindersInput>
  }

  export type AuditUpsertWithoutRemindersInput = {
    update: XOR<AuditUpdateWithoutRemindersInput, AuditUncheckedUpdateWithoutRemindersInput>
    create: XOR<AuditCreateWithoutRemindersInput, AuditUncheckedCreateWithoutRemindersInput>
    where?: AuditWhereInput
  }

  export type AuditUpdateToOneWithWhereWithoutRemindersInput = {
    where?: AuditWhereInput
    data: XOR<AuditUpdateWithoutRemindersInput, AuditUncheckedUpdateWithoutRemindersInput>
  }

  export type AuditUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditor?: AuditorUpdateOneRequiredWithoutAuditsNestedInput
    auditee?: UserUpdateOneWithoutAuditeeAuditsNestedInput
    department?: DepartmentUpdateOneWithoutAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    findings?: FindingUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    findings?: FindingUncheckedUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUncheckedUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUncheckedUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUncheckedUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type UserUpsertWithoutReceivedRemindersInput = {
    update: XOR<UserUpdateWithoutReceivedRemindersInput, UserUncheckedUpdateWithoutReceivedRemindersInput>
    create: XOR<UserCreateWithoutReceivedRemindersInput, UserUncheckedCreateWithoutReceivedRemindersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedRemindersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedRemindersInput, UserUncheckedUpdateWithoutReceivedRemindersInput>
  }

  export type UserUpdateWithoutReceivedRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithoutCreatedRemindersInput = {
    update: XOR<UserUpdateWithoutCreatedRemindersInput, UserUncheckedUpdateWithoutCreatedRemindersInput>
    create: XOR<UserCreateWithoutCreatedRemindersInput, UserUncheckedCreateWithoutCreatedRemindersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedRemindersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedRemindersInput, UserUncheckedUpdateWithoutCreatedRemindersInput>
  }

  export type UserUpdateWithoutCreatedRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type AuditCreateWithoutNotificationsInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditor: AuditorCreateNestedOneWithoutAuditsInput
    auditee?: UserCreateNestedOneWithoutAuditeeAuditsInput
    department?: DepartmentCreateNestedOneWithoutAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    findings?: FindingCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    auditeeId?: string | null
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    findings?: FindingUncheckedCreateNestedManyWithoutAuditInput
    documents?: AuditDocumentUncheckedCreateNestedManyWithoutAuditInput
    actions?: CorrectiveActionUncheckedCreateNestedManyWithoutAuditInput
    reminders?: AuditReminderUncheckedCreateNestedManyWithoutAuditInput
    checklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutAuditInput
    inspectionItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutNotificationsInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutNotificationsInput, AuditUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutAuditNotificationsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderCreateNestedManyWithoutRecipientInput
    responsibleForChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutAuditNotificationsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
    auditorProfile?: AuditorUncheckedCreateNestedOneWithoutUserInput
    auditeeAudits?: AuditUncheckedCreateNestedManyWithoutAuditeeInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    assignedFindings?: FindingUncheckedCreateNestedManyWithoutAssignedToInput
    assignedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutAssignedToInput
    verifiedActions?: CorrectiveActionUncheckedCreateNestedManyWithoutVerifiedByInput
    uploadedAuditDocuments?: AuditDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    createdReminders?: AuditReminderUncheckedCreateNestedManyWithoutCreatedByInput
    receivedReminders?: AuditReminderUncheckedCreateNestedManyWithoutRecipientInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutResponsibleInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedItems?: AuditInspectionItemUncheckedCreateNestedManyWithoutInspectedByInput
    uploadedFeedbackForms?: FeedbackFormUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAuditNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditNotificationsInput, UserUncheckedCreateWithoutAuditNotificationsInput>
  }

  export type AuditUpsertWithoutNotificationsInput = {
    update: XOR<AuditUpdateWithoutNotificationsInput, AuditUncheckedUpdateWithoutNotificationsInput>
    create: XOR<AuditCreateWithoutNotificationsInput, AuditUncheckedCreateWithoutNotificationsInput>
    where?: AuditWhereInput
  }

  export type AuditUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: AuditWhereInput
    data: XOR<AuditUpdateWithoutNotificationsInput, AuditUncheckedUpdateWithoutNotificationsInput>
  }

  export type AuditUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditor?: AuditorUpdateOneRequiredWithoutAuditsNestedInput
    auditee?: UserUpdateOneWithoutAuditeeAuditsNestedInput
    department?: DepartmentUpdateOneWithoutAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    findings?: FindingUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    findings?: FindingUncheckedUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUncheckedUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUncheckedUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUncheckedUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type UserUpsertWithoutAuditNotificationsInput = {
    update: XOR<UserUpdateWithoutAuditNotificationsInput, UserUncheckedUpdateWithoutAuditNotificationsInput>
    create: XOR<UserCreateWithoutAuditNotificationsInput, UserUncheckedCreateWithoutAuditNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditNotificationsInput, UserUncheckedUpdateWithoutAuditNotificationsInput>
  }

  export type UserUpdateWithoutAuditNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type ActivityLogCreateManyBatchInput = {
    id: string
    userId: string
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyBatchInput = {
    id: string
    userId: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type BatchParameterValueCreateManyBatchInput = {
    id: string
    parameterId: string
    value: string
    unitId?: string | null
    methodologyId?: string | null
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ActivityLogUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutActivityLogNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardsModifiedNestedInput
    methodologies?: MethodologyUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    methodologies?: MethodologyUncheckedUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateManyWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodologyUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutMethodologyNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutMethodologyNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateManyWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfMeasurementUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutUnitNestedInput
    standardParameters?: StandardParameterUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutUnitNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutUnitNestedInput
    standardParameters?: StandardParameterUncheckedUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateManyWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StandardParameterUpdateOneRequiredWithoutBatchValuesNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutBatchParameterValuesNestedInput
    methodology?: MethodologyUpdateOneWithoutBatchParameterValuesNestedInput
  }

  export type BatchParameterValueUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueCreateManyMethodologyInput = {
    id: string
    batchId: string
    parameterId: string
    value: string
    unitId?: string | null
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateManyMethodologyInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardUpdateWithoutMethodologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardsModifiedNestedInput
    batches?: BatchUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateWithoutMethodologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateManyWithoutMethodologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateWithoutMethodologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutMethodologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutMethodologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUpdateWithoutMethodologyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneRequiredWithoutParameterValuesNestedInput
    parameter?: StandardParameterUpdateOneRequiredWithoutBatchValuesNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutBatchParameterValuesNestedInput
  }

  export type BatchParameterValueUncheckedUpdateWithoutMethodologyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutMethodologyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUpdateWithoutMethodologyInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StandardParameterUpdateOneRequiredWithoutStandardsNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutStandardDefinitionsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardDefinitionsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardDefinitionsModifiedNestedInput
  }

  export type StandardDefinitionUncheckedUpdateWithoutMethodologyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutMethodologyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateManyProductInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ProductStandardCategoryCreateManyProductInput = {
    id?: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductParameterCreateManyProductInput = {
    id?: string
    parameterId: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStandardCategoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StandardCategoryUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductStandardCategoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStandardCategoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductParameterUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StandardParameterUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductParameterUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductParameterUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyRoleInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
    auditorProfile?: AuditorUncheckedUpdateOneWithoutUserNestedInput
    auditeeAudits?: AuditUncheckedUpdateManyWithoutAuditeeNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedFindings?: FindingUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedActions?: CorrectiveActionUncheckedUpdateManyWithoutAssignedToNestedInput
    verifiedActions?: CorrectiveActionUncheckedUpdateManyWithoutVerifiedByNestedInput
    uploadedAuditDocuments?: AuditDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    createdReminders?: AuditReminderUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedReminders?: AuditReminderUncheckedUpdateManyWithoutRecipientNestedInput
    auditNotifications?: AuditNotificationUncheckedUpdateManyWithoutUserNestedInput
    responsibleForChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleNestedInput
    createdChecklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedItems?: AuditInspectionItemUncheckedUpdateManyWithoutInspectedByNestedInput
    uploadedFeedbackForms?: FeedbackFormUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedSessionPhotos?: TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueCreateManyUnitInput = {
    id: string
    batchId: string
    parameterId: string
    value: string
    methodologyId?: string | null
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardParameterCreateManyUnitInput = {
    id: string
    name: string
    categoryId: string
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateManyUnitInput = {
    id: string
    parameterId: string
    standardValue: string
    methodologyId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardsModifiedNestedInput
    batches?: BatchUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateManyWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneRequiredWithoutParameterValuesNestedInput
    parameter?: StandardParameterUpdateOneRequiredWithoutBatchValuesNestedInput
    methodology?: MethodologyUpdateOneWithoutBatchParameterValuesNestedInput
  }

  export type BatchParameterValueUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardParameterUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StandardCategoryUpdateOneRequiredWithoutParametersNestedInput
    batchValues?: BatchParameterValueUpdateManyWithoutParameterNestedInput
    standards?: StandardDefinitionUpdateManyWithoutParameterNestedInput
    products?: ProductParameterUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchValues?: BatchParameterValueUncheckedUpdateManyWithoutParameterNestedInput
    standards?: StandardDefinitionUncheckedUpdateManyWithoutParameterNestedInput
    products?: ProductParameterUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StandardParameterUpdateOneRequiredWithoutStandardsNestedInput
    methodology?: MethodologyUpdateOneWithoutStandardDefinitionsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardDefinitionsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardDefinitionsModifiedNestedInput
  }

  export type StandardDefinitionUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateWithoutUnitOfMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutUnitOfMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutUnitOfMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyUserInput = {
    id: string
    batchId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type BatchCreateManyUser_Batch_checkerIdToUserInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchCreateManyUser_Batch_makerIdToUserInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id: string
    batchId?: string | null
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type StandardCreateManyCreatedByInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardCreateManyModifiedByInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateManyCreatedByInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateManyModifiedByInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    createdById: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TrainingCreateManyTrainerInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingCreateManyCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDocumentCreateManyUploadedByInput = {
    id?: string
    trainingId: string
    sessionId?: string | null
    title: string
    description?: string | null
    fileUrl: string
    filePath?: string | null
    documentType: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPhotoCreateManyUploadedByInput = {
    id?: string
    trainingId: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
  }

  export type TrainingFollowupCreateManyAssignedToInput = {
    id?: string
    trainingId: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingFollowupCreateManyCreatedByInput = {
    id?: string
    trainingId: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    assignedToId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingNotificationCreateManyUserInput = {
    id?: string
    trainingId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type AuditCreateManyAuditeeInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditCreateManyCreatedByInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    auditeeId?: string | null
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FindingCreateManyAssignedToInput = {
    id?: string
    auditId: string
    title: string
    description: string
    findingType: $Enums.FindingType
    status?: $Enums.FindingStatus
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type CorrectiveActionCreateManyAssignedToInput = {
    id?: string
    auditId: string
    findingId?: string | null
    title: string
    description: string
    actionType: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    verifiedById?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrectiveActionCreateManyVerifiedByInput = {
    id?: string
    auditId: string
    findingId?: string | null
    title: string
    description: string
    actionType: string
    assignedToId: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditDocumentCreateManyUploadedByInput = {
    id?: string
    auditId: string
    title: string
    description?: string | null
    documentType: $Enums.AuditDocumentType
    fileUrl: string
    filePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditReminderCreateManyCreatedByInput = {
    id?: string
    auditId: string
    title: string
    message: string
    dueDate: Date | string
    status: string
    recipientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
  }

  export type AuditReminderCreateManyRecipientInput = {
    id?: string
    auditId: string
    title: string
    message: string
    dueDate: Date | string
    status: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
  }

  export type AuditNotificationCreateManyUserInput = {
    id?: string
    auditId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type PreAuditChecklistItemCreateManyResponsibleInput = {
    id?: string
    auditId: string
    description: string
    isCompleted?: boolean
    comments?: string | null
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PreAuditChecklistItemCreateManyCreatedByInput = {
    id?: string
    auditId: string
    description: string
    isCompleted?: boolean
    comments?: string | null
    responsibleId: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditInspectionItemCreateManyInspectedByInput = {
    id?: string
    auditId: string
    areaName: string
    itemName: string
    description?: string | null
    standardReference?: string | null
    isCompliant?: boolean | null
    comments?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackFormCreateManyUploadedByInput = {
    id?: string
    trainingId: string
    sessionId: string
    participantId: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
  }

  export type TrainingSessionPhotoCreateManyUploadedByInput = {
    id?: string
    sessionId: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneWithoutActivityLogNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateWithoutUser_Batch_checkerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutUser_Batch_checkerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateWithoutUser_Batch_makerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutUser_Batch_makerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardsModifiedNestedInput
    batches?: BatchUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardUpdateWithoutModifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardsCreatedNestedInput
    batches?: BatchUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateWithoutModifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateManyWithoutModifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StandardParameterUpdateOneRequiredWithoutStandardsNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutStandardDefinitionsNestedInput
    methodology?: MethodologyUpdateOneWithoutStandardDefinitionsNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardDefinitionsModifiedNestedInput
  }

  export type StandardDefinitionUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUpdateWithoutModifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StandardParameterUpdateOneRequiredWithoutStandardsNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutStandardDefinitionsNestedInput
    methodology?: MethodologyUpdateOneWithoutStandardDefinitionsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardDefinitionsCreatedNestedInput
  }

  export type StandardDefinitionUncheckedUpdateWithoutModifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutModifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingUpdateWithoutTrainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutTrainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateManyWithoutTrainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type TrainingDocumentUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type TrainingPhotoUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFollowupUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training?: TrainingUpdateOneRequiredWithoutFollowupsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedFollowupsNestedInput
  }

  export type TrainingFollowupUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingFollowupUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingFollowupUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training?: TrainingUpdateOneRequiredWithoutFollowupsNestedInput
    assignedTo?: UserUpdateOneRequiredWithoutAssignedFollowupsNestedInput
  }

  export type TrainingFollowupUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingFollowupUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training?: TrainingUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type TrainingNotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditUpdateWithoutAuditeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditor?: AuditorUpdateOneRequiredWithoutAuditsNestedInput
    department?: DepartmentUpdateOneWithoutAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    findings?: FindingUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutAuditeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    findings?: FindingUncheckedUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUncheckedUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUncheckedUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUncheckedUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUncheckedUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateManyWithoutAuditeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditor?: AuditorUpdateOneRequiredWithoutAuditsNestedInput
    auditee?: UserUpdateOneWithoutAuditeeAuditsNestedInput
    department?: DepartmentUpdateOneWithoutAuditsNestedInput
    findings?: FindingUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    findings?: FindingUncheckedUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUncheckedUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUncheckedUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUncheckedUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUncheckedUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FindingUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    findingType?: EnumFindingTypeFieldUpdateOperationsInput | $Enums.FindingType
    status?: EnumFindingStatusFieldUpdateOperationsInput | $Enums.FindingStatus
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: AuditUpdateOneRequiredWithoutFindingsNestedInput
    actions?: CorrectiveActionUpdateManyWithoutFindingNestedInput
  }

  export type FindingUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    findingType?: EnumFindingTypeFieldUpdateOperationsInput | $Enums.FindingType
    status?: EnumFindingStatusFieldUpdateOperationsInput | $Enums.FindingStatus
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actions?: CorrectiveActionUncheckedUpdateManyWithoutFindingNestedInput
  }

  export type FindingUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    findingType?: EnumFindingTypeFieldUpdateOperationsInput | $Enums.FindingType
    status?: EnumFindingStatusFieldUpdateOperationsInput | $Enums.FindingStatus
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CorrectiveActionUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutActionsNestedInput
    finding?: FindingUpdateOneWithoutActionsNestedInput
    verifiedBy?: UserUpdateOneWithoutVerifiedActionsNestedInput
  }

  export type CorrectiveActionUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    findingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrectiveActionUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    findingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrectiveActionUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutActionsNestedInput
    finding?: FindingUpdateOneWithoutActionsNestedInput
    assignedTo?: UserUpdateOneRequiredWithoutAssignedActionsNestedInput
  }

  export type CorrectiveActionUncheckedUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    findingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrectiveActionUncheckedUpdateManyWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    findingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditDocumentUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumAuditDocumentTypeFieldUpdateOperationsInput | $Enums.AuditDocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type AuditDocumentUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumAuditDocumentTypeFieldUpdateOperationsInput | $Enums.AuditDocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditDocumentUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumAuditDocumentTypeFieldUpdateOperationsInput | $Enums.AuditDocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditReminderUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: AuditUpdateOneRequiredWithoutRemindersNestedInput
    recipient?: UserUpdateOneRequiredWithoutReceivedRemindersNestedInput
  }

  export type AuditReminderUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditReminderUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditReminderUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: AuditUpdateOneRequiredWithoutRemindersNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedRemindersNestedInput
  }

  export type AuditReminderUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditReminderUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditNotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    audit?: AuditUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type AuditNotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PreAuditChecklistItemUpdateWithoutResponsibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutChecklistItemsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedChecklistItemsNestedInput
  }

  export type PreAuditChecklistItemUncheckedUpdateWithoutResponsibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreAuditChecklistItemUncheckedUpdateManyWithoutResponsibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreAuditChecklistItemUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutChecklistItemsNestedInput
    responsible?: UserUpdateOneRequiredWithoutResponsibleForChecklistItemsNestedInput
  }

  export type PreAuditChecklistItemUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreAuditChecklistItemUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditInspectionItemUpdateWithoutInspectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    areaName?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standardReference?: NullableStringFieldUpdateOperationsInput | string | null
    isCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutInspectionItemsNestedInput
  }

  export type AuditInspectionItemUncheckedUpdateWithoutInspectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    areaName?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standardReference?: NullableStringFieldUpdateOperationsInput | string | null
    isCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditInspectionItemUncheckedUpdateManyWithoutInspectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    areaName?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standardReference?: NullableStringFieldUpdateOperationsInput | string | null
    isCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackFormUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutFeedbackFormsNestedInput
    session?: TrainingSessionUpdateOneRequiredWithoutFeedbackFormsNestedInput
    participant?: ParticipantUpdateOneRequiredWithoutFeedbackFormsNestedInput
  }

  export type FeedbackFormUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackFormUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionPhotoUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TrainingSessionUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type TrainingSessionPhotoUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionPhotoUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodologyUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutMethodologyNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutMethodologyNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateManyWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfMeasurementUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchParameterValues?: BatchParameterValueUpdateManyWithoutUnitNestedInput
    standardParameters?: StandardParameterUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutUnitNestedInput
    batches?: BatchUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutUnitNestedInput
    standardParameters?: StandardParameterUncheckedUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutUnitNestedInput
    batches?: BatchUncheckedUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateManyWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardParameterCreateManyCategoryInput = {
    id: string
    name: string
    unitId?: string | null
    productType?: string | null
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardCreateManyCategoryInput = {
    id: string
    name: string
    code: string
    description: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ProductStandardCategoryCreateManyCategoryInput = {
    id?: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StandardParameterUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchValues?: BatchParameterValueUpdateManyWithoutParameterNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutStandardParametersNestedInput
    standards?: StandardDefinitionUpdateManyWithoutParameterNestedInput
    products?: ProductParameterUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchValues?: BatchParameterValueUncheckedUpdateManyWithoutParameterNestedInput
    standards?: StandardDefinitionUncheckedUpdateManyWithoutParameterNestedInput
    products?: ProductParameterUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: UserUpdateOneRequiredWithoutStandardsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardsModifiedNestedInput
    batches?: BatchUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStandardCategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStandardCategoriesNestedInput
  }

  export type ProductStandardCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStandardCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueCreateManyParameterInput = {
    id: string
    batchId: string
    value: string
    unitId?: string | null
    methodologyId?: string | null
    verificationResult?: string | null
    verificationRemark?: string | null
    verifiedById?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateManyParameterInput = {
    id: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ProductParameterCreateManyParameterInput = {
    id?: string
    productId: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchParameterValueUpdateWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneRequiredWithoutParameterValuesNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutBatchParameterValuesNestedInput
    methodology?: MethodologyUpdateOneWithoutBatchParameterValuesNestedInput
  }

  export type BatchParameterValueUncheckedUpdateWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    verificationResult?: NullableStringFieldUpdateOperationsInput | string | null
    verificationRemark?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUpdateWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitOfMeasurementUpdateOneWithoutStandardDefinitionsNestedInput
    methodology?: MethodologyUpdateOneWithoutStandardDefinitionsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardDefinitionsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardDefinitionsModifiedNestedInput
  }

  export type StandardDefinitionUncheckedUpdateWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductParameterUpdateWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutParametersNestedInput
  }

  export type ProductParameterUncheckedUpdateWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductParameterUncheckedUpdateManyWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingCreateManyCalendarInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
    inviteTokens?: TrainingInviteTokenUncheckedUpdateManyWithoutTrainingNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateManyWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionCreateManyTrainingInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDocumentCreateManyTrainingInput = {
    id?: string
    sessionId?: string | null
    title: string
    description?: string | null
    fileUrl: string
    filePath?: string | null
    documentType: $Enums.DocumentType
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyTrainingInput = {
    id?: string
    sessionId: string
    participantId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingParticipantCreateManyTrainingInput = {
    id?: string
    participantId: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPhotoCreateManyTrainingInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type TrainingFeedbackCreateManyTrainingInput = {
    id?: string
    participantId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingFollowupCreateManyTrainingInput = {
    id?: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    assignedToId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingNotificationCreateManyTrainingInput = {
    id?: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type TrainingInviteTokenCreateManyTrainingInput = {
    id?: string
    token: string
    action: string
    participantId?: string | null
    email: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type FeedbackFormCreateManyTrainingInput = {
    id?: string
    sessionId: string
    participantId: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
    uploadedById: string
  }

  export type TrainingSessionUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
    feedbackForms?: FeedbackFormUpdateManyWithoutSessionNestedInput
    photos?: TrainingSessionPhotoUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
    feedbackForms?: FeedbackFormUncheckedUpdateManyWithoutSessionNestedInput
    photos?: TrainingSessionPhotoUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
  }

  export type TrainingDocumentUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TrainingSessionUpdateOneRequiredWithoutAttendanceNestedInput
    participant?: ParticipantUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ParticipantUpdateOneRequiredWithoutTrainingsNestedInput
  }

  export type TrainingParticipantUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedPhotosNestedInput
  }

  export type TrainingPhotoUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ParticipantUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type TrainingFeedbackUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFollowupUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: UserUpdateOneRequiredWithoutAssignedFollowupsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedFollowupsNestedInput
  }

  export type TrainingFollowupUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingFollowupUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTrainingNotificationsNestedInput
  }

  export type TrainingNotificationUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingInviteTokenUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ParticipantUpdateOneWithoutInviteTokensNestedInput
  }

  export type TrainingInviteTokenUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingInviteTokenUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackFormUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TrainingSessionUpdateOneRequiredWithoutFeedbackFormsNestedInput
    participant?: ParticipantUpdateOneRequiredWithoutFeedbackFormsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedFeedbackFormsNestedInput
  }

  export type FeedbackFormUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackFormUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceCreateManySessionInput = {
    id?: string
    trainingId: string
    participantId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackFormCreateManySessionInput = {
    id?: string
    trainingId: string
    participantId: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
    uploadedById: string
  }

  export type TrainingSessionPhotoCreateManySessionInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type AttendanceUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutAttendanceNestedInput
    participant?: ParticipantUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackFormUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutFeedbackFormsNestedInput
    participant?: ParticipantUpdateOneRequiredWithoutFeedbackFormsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedFeedbackFormsNestedInput
  }

  export type FeedbackFormUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackFormUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type TrainingSessionPhotoUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedSessionPhotosNestedInput
  }

  export type TrainingSessionPhotoUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionPhotoUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantCreateManyParticipantInput = {
    id?: string
    trainingId: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyParticipantInput = {
    id?: string
    trainingId: string
    sessionId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingFeedbackCreateManyParticipantInput = {
    id?: string
    trainingId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingInviteTokenCreateManyParticipantInput = {
    id?: string
    token: string
    action: string
    trainingId: string
    email: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type FeedbackFormCreateManyParticipantInput = {
    id?: string
    trainingId: string
    sessionId: string
    fileUrl: string
    filePath?: string | null
    submittedAt?: Date | string
    uploadedById: string
  }

  export type TrainingParticipantUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type TrainingParticipantUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantUncheckedUpdateManyWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutAttendanceNestedInput
    session?: TrainingSessionUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type TrainingFeedbackUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackUncheckedUpdateManyWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingInviteTokenUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutInviteTokensNestedInput
  }

  export type TrainingInviteTokenUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingInviteTokenUncheckedUpdateManyWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackFormUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutFeedbackFormsNestedInput
    session?: TrainingSessionUpdateOneRequiredWithoutFeedbackFormsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedFeedbackFormsNestedInput
  }

  export type FeedbackFormUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackFormUncheckedUpdateManyWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type AuditCreateManyAuditorInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditeeId?: string | null
    firmName?: string | null
    departmentId?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditUpdateWithoutAuditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditee?: UserUpdateOneWithoutAuditeeAuditsNestedInput
    department?: DepartmentUpdateOneWithoutAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    findings?: FindingUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutAuditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    findings?: FindingUncheckedUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUncheckedUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUncheckedUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUncheckedUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUncheckedUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateManyWithoutAuditorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FindingCreateManyAuditInput = {
    id?: string
    title: string
    description: string
    findingType: $Enums.FindingType
    status?: $Enums.FindingStatus
    priority?: $Enums.Priority | null
    dueDate?: Date | string | null
    assignedToId?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type AuditDocumentCreateManyAuditInput = {
    id?: string
    title: string
    description?: string | null
    documentType: $Enums.AuditDocumentType
    fileUrl: string
    filePath?: string | null
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrectiveActionCreateManyAuditInput = {
    id?: string
    findingId?: string | null
    title: string
    description: string
    actionType: string
    assignedToId: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    verifiedById?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditReminderCreateManyAuditInput = {
    id?: string
    title: string
    message: string
    dueDate: Date | string
    status: string
    recipientId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt?: Date | string | null
  }

  export type AuditNotificationCreateManyAuditInput = {
    id?: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type PreAuditChecklistItemCreateManyAuditInput = {
    id?: string
    description: string
    isCompleted?: boolean
    comments?: string | null
    responsibleId: string
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditInspectionItemCreateManyAuditInput = {
    id?: string
    areaName: string
    itemName: string
    description?: string | null
    standardReference?: string | null
    isCompliant?: boolean | null
    comments?: string | null
    evidence?: string | null
    inspectedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FindingUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    findingType?: EnumFindingTypeFieldUpdateOperationsInput | $Enums.FindingType
    status?: EnumFindingStatusFieldUpdateOperationsInput | $Enums.FindingStatus
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: UserUpdateOneWithoutAssignedFindingsNestedInput
    actions?: CorrectiveActionUpdateManyWithoutFindingNestedInput
  }

  export type FindingUncheckedUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    findingType?: EnumFindingTypeFieldUpdateOperationsInput | $Enums.FindingType
    status?: EnumFindingStatusFieldUpdateOperationsInput | $Enums.FindingStatus
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actions?: CorrectiveActionUncheckedUpdateManyWithoutFindingNestedInput
  }

  export type FindingUncheckedUpdateManyWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    findingType?: EnumFindingTypeFieldUpdateOperationsInput | $Enums.FindingType
    status?: EnumFindingStatusFieldUpdateOperationsInput | $Enums.FindingStatus
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditDocumentUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumAuditDocumentTypeFieldUpdateOperationsInput | $Enums.AuditDocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedAuditDocumentsNestedInput
  }

  export type AuditDocumentUncheckedUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumAuditDocumentTypeFieldUpdateOperationsInput | $Enums.AuditDocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditDocumentUncheckedUpdateManyWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: EnumAuditDocumentTypeFieldUpdateOperationsInput | $Enums.AuditDocumentType
    fileUrl?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrectiveActionUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finding?: FindingUpdateOneWithoutActionsNestedInput
    assignedTo?: UserUpdateOneRequiredWithoutAssignedActionsNestedInput
    verifiedBy?: UserUpdateOneWithoutVerifiedActionsNestedInput
  }

  export type CorrectiveActionUncheckedUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    findingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrectiveActionUncheckedUpdateManyWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    findingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditReminderUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipient?: UserUpdateOneRequiredWithoutReceivedRemindersNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedRemindersNestedInput
  }

  export type AuditReminderUncheckedUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditReminderUncheckedUpdateManyWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditNotificationUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAuditNotificationsNestedInput
  }

  export type AuditNotificationUncheckedUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditNotificationUncheckedUpdateManyWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PreAuditChecklistItemUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible?: UserUpdateOneRequiredWithoutResponsibleForChecklistItemsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedChecklistItemsNestedInput
  }

  export type PreAuditChecklistItemUncheckedUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreAuditChecklistItemUncheckedUpdateManyWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleId?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditInspectionItemUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    areaName?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standardReference?: NullableStringFieldUpdateOperationsInput | string | null
    isCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inspectedBy?: UserUpdateOneWithoutInspectedItemsNestedInput
  }

  export type AuditInspectionItemUncheckedUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    areaName?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standardReference?: NullableStringFieldUpdateOperationsInput | string | null
    isCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    inspectedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditInspectionItemUncheckedUpdateManyWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    areaName?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    standardReference?: NullableStringFieldUpdateOperationsInput | string | null
    isCompliant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    inspectedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditCreateManyDepartmentInput = {
    id?: string
    name: string
    auditType: $Enums.AuditType
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    auditorId: string
    auditeeId?: string | null
    firmName?: string | null
    objectives?: string | null
    scope?: string | null
    summary?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditor?: AuditorUpdateOneRequiredWithoutAuditsNestedInput
    auditee?: UserUpdateOneWithoutAuditeeAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    findings?: FindingUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    findings?: FindingUncheckedUpdateManyWithoutAuditNestedInput
    documents?: AuditDocumentUncheckedUpdateManyWithoutAuditNestedInput
    actions?: CorrectiveActionUncheckedUpdateManyWithoutAuditNestedInput
    reminders?: AuditReminderUncheckedUpdateManyWithoutAuditNestedInput
    notifications?: AuditNotificationUncheckedUpdateManyWithoutAuditNestedInput
    checklistItems?: PreAuditChecklistItemUncheckedUpdateManyWithoutAuditNestedInput
    inspectionItems?: AuditInspectionItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auditType?: EnumAuditTypeFieldUpdateOperationsInput | $Enums.AuditType
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditorId?: StringFieldUpdateOperationsInput | string
    auditeeId?: NullableStringFieldUpdateOperationsInput | string | null
    firmName?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrectiveActionCreateManyFindingInput = {
    id?: string
    auditId: string
    title: string
    description: string
    actionType: string
    assignedToId: string
    dueDate: Date | string
    status: string
    completedAt?: Date | string | null
    verifiedAt?: Date | string | null
    verifiedById?: string | null
    evidence?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrectiveActionUpdateWithoutFindingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutActionsNestedInput
    assignedTo?: UserUpdateOneRequiredWithoutAssignedActionsNestedInput
    verifiedBy?: UserUpdateOneWithoutVerifiedActionsNestedInput
  }

  export type CorrectiveActionUncheckedUpdateWithoutFindingInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrectiveActionUncheckedUpdateManyWithoutFindingInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}