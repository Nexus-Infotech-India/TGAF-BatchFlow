
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model Batch
 * 
 */
export type Batch = $Result.DefaultSelection<Prisma.$BatchPayload>
/**
 * Model ExportLog
 * 
 */
export type ExportLog = $Result.DefaultSelection<Prisma.$ExportLogPayload>
/**
 * Model Methodology
 * 
 */
export type Methodology = $Result.DefaultSelection<Prisma.$MethodologyPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UnitOfMeasurement
 * 
 */
export type UnitOfMeasurement = $Result.DefaultSelection<Prisma.$UnitOfMeasurementPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Standard
 * 
 */
export type Standard = $Result.DefaultSelection<Prisma.$StandardPayload>
/**
 * Model StandardCategory
 * 
 */
export type StandardCategory = $Result.DefaultSelection<Prisma.$StandardCategoryPayload>
/**
 * Model StandardParameter
 * 
 */
export type StandardParameter = $Result.DefaultSelection<Prisma.$StandardParameterPayload>
/**
 * Model StandardDefinition
 * 
 */
export type StandardDefinition = $Result.DefaultSelection<Prisma.$StandardDefinitionPayload>
/**
 * Model BatchParameterValue
 * 
 */
export type BatchParameterValue = $Result.DefaultSelection<Prisma.$BatchParameterValuePayload>
/**
 * Model TrainingCalendar
 * 
 */
export type TrainingCalendar = $Result.DefaultSelection<Prisma.$TrainingCalendarPayload>
/**
 * Model Training
 * 
 */
export type Training = $Result.DefaultSelection<Prisma.$TrainingPayload>
/**
 * Model TrainingSession
 * 
 */
export type TrainingSession = $Result.DefaultSelection<Prisma.$TrainingSessionPayload>
/**
 * Model TrainingDocument
 * 
 */
export type TrainingDocument = $Result.DefaultSelection<Prisma.$TrainingDocumentPayload>
/**
 * Model TrainingParticipant
 * 
 */
export type TrainingParticipant = $Result.DefaultSelection<Prisma.$TrainingParticipantPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model TrainingPhoto
 * 
 */
export type TrainingPhoto = $Result.DefaultSelection<Prisma.$TrainingPhotoPayload>
/**
 * Model TrainingFeedback
 * 
 */
export type TrainingFeedback = $Result.DefaultSelection<Prisma.$TrainingFeedbackPayload>
/**
 * Model TrainingFollowup
 * 
 */
export type TrainingFollowup = $Result.DefaultSelection<Prisma.$TrainingFollowupPayload>
/**
 * Model TrainingNotification
 * 
 */
export type TrainingNotification = $Result.DefaultSelection<Prisma.$TrainingNotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BatchStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type BatchStatus = (typeof BatchStatus)[keyof typeof BatchStatus]


export const NotificationType: {
  BATCH_SUBMITTED: 'BATCH_SUBMITTED',
  BATCH_APPROVED: 'BATCH_APPROVED',
  BATCH_REJECTED: 'BATCH_REJECTED',
  SYSTEM: 'SYSTEM'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const SampleAnalysisStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type SampleAnalysisStatus = (typeof SampleAnalysisStatus)[keyof typeof SampleAnalysisStatus]


export const StandardStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  DEPRECATED: 'DEPRECATED'
};

export type StandardStatus = (typeof StandardStatus)[keyof typeof StandardStatus]


export const ParameterDataType: {
  TEXT: 'TEXT',
  FLOAT: 'FLOAT',
  INTEGER: 'INTEGER',
  BOOLEAN: 'BOOLEAN',
  PERCENTAGE: 'PERCENTAGE',
  DATE: 'DATE'
};

export type ParameterDataType = (typeof ParameterDataType)[keyof typeof ParameterDataType]


export const TrainingType: {
  TECHNICAL: 'TECHNICAL',
  SAFETY: 'SAFETY',
  COMPLIANCE: 'COMPLIANCE',
  ONBOARDING: 'ONBOARDING',
  PROFESSIONAL_DEVELOPMENT: 'PROFESSIONAL_DEVELOPMENT',
  WORKSHOP: 'WORKSHOP',
  SEMINAR: 'SEMINAR'
};

export type TrainingType = (typeof TrainingType)[keyof typeof TrainingType]


export const TrainingStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  POSTPONED: 'POSTPONED'
};

export type TrainingStatus = (typeof TrainingStatus)[keyof typeof TrainingStatus]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  EXCUSED: 'EXCUSED'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const DocumentType: {
  COURSE_MATERIAL: 'COURSE_MATERIAL',
  PRESENTATION: 'PRESENTATION',
  AGENDA: 'AGENDA',
  GUIDELINE: 'GUIDELINE',
  CERTIFICATE: 'CERTIFICATE',
  ASSESSMENT: 'ASSESSMENT',
  FEEDBACK_FORM: 'FEEDBACK_FORM',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]

}

export type BatchStatus = $Enums.BatchStatus

export const BatchStatus: typeof $Enums.BatchStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type SampleAnalysisStatus = $Enums.SampleAnalysisStatus

export const SampleAnalysisStatus: typeof $Enums.SampleAnalysisStatus

export type StandardStatus = $Enums.StandardStatus

export const StandardStatus: typeof $Enums.StandardStatus

export type ParameterDataType = $Enums.ParameterDataType

export const ParameterDataType: typeof $Enums.ParameterDataType

export type TrainingType = $Enums.TrainingType

export const TrainingType: typeof $Enums.TrainingType

export type TrainingStatus = $Enums.TrainingStatus

export const TrainingStatus: typeof $Enums.TrainingStatus

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ActivityLogs
 * const activityLogs = await prisma.activityLog.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ActivityLogs
   * const activityLogs = await prisma.activityLog.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batch`: Exposes CRUD operations for the **Batch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Batches
    * const batches = await prisma.batch.findMany()
    * ```
    */
  get batch(): Prisma.BatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exportLog`: Exposes CRUD operations for the **ExportLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExportLogs
    * const exportLogs = await prisma.exportLog.findMany()
    * ```
    */
  get exportLog(): Prisma.ExportLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.methodology`: Exposes CRUD operations for the **Methodology** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Methodologies
    * const methodologies = await prisma.methodology.findMany()
    * ```
    */
  get methodology(): Prisma.MethodologyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitOfMeasurement`: Exposes CRUD operations for the **UnitOfMeasurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitOfMeasurements
    * const unitOfMeasurements = await prisma.unitOfMeasurement.findMany()
    * ```
    */
  get unitOfMeasurement(): Prisma.UnitOfMeasurementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.standard`: Exposes CRUD operations for the **Standard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Standards
    * const standards = await prisma.standard.findMany()
    * ```
    */
  get standard(): Prisma.StandardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.standardCategory`: Exposes CRUD operations for the **StandardCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StandardCategories
    * const standardCategories = await prisma.standardCategory.findMany()
    * ```
    */
  get standardCategory(): Prisma.StandardCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.standardParameter`: Exposes CRUD operations for the **StandardParameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StandardParameters
    * const standardParameters = await prisma.standardParameter.findMany()
    * ```
    */
  get standardParameter(): Prisma.StandardParameterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.standardDefinition`: Exposes CRUD operations for the **StandardDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StandardDefinitions
    * const standardDefinitions = await prisma.standardDefinition.findMany()
    * ```
    */
  get standardDefinition(): Prisma.StandardDefinitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batchParameterValue`: Exposes CRUD operations for the **BatchParameterValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BatchParameterValues
    * const batchParameterValues = await prisma.batchParameterValue.findMany()
    * ```
    */
  get batchParameterValue(): Prisma.BatchParameterValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingCalendar`: Exposes CRUD operations for the **TrainingCalendar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingCalendars
    * const trainingCalendars = await prisma.trainingCalendar.findMany()
    * ```
    */
  get trainingCalendar(): Prisma.TrainingCalendarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.training`: Exposes CRUD operations for the **Training** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trainings
    * const trainings = await prisma.training.findMany()
    * ```
    */
  get training(): Prisma.TrainingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingSession`: Exposes CRUD operations for the **TrainingSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingSessions
    * const trainingSessions = await prisma.trainingSession.findMany()
    * ```
    */
  get trainingSession(): Prisma.TrainingSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingDocument`: Exposes CRUD operations for the **TrainingDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingDocuments
    * const trainingDocuments = await prisma.trainingDocument.findMany()
    * ```
    */
  get trainingDocument(): Prisma.TrainingDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingParticipant`: Exposes CRUD operations for the **TrainingParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingParticipants
    * const trainingParticipants = await prisma.trainingParticipant.findMany()
    * ```
    */
  get trainingParticipant(): Prisma.TrainingParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingPhoto`: Exposes CRUD operations for the **TrainingPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingPhotos
    * const trainingPhotos = await prisma.trainingPhoto.findMany()
    * ```
    */
  get trainingPhoto(): Prisma.TrainingPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingFeedback`: Exposes CRUD operations for the **TrainingFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingFeedbacks
    * const trainingFeedbacks = await prisma.trainingFeedback.findMany()
    * ```
    */
  get trainingFeedback(): Prisma.TrainingFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingFollowup`: Exposes CRUD operations for the **TrainingFollowup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingFollowups
    * const trainingFollowups = await prisma.trainingFollowup.findMany()
    * ```
    */
  get trainingFollowup(): Prisma.TrainingFollowupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainingNotification`: Exposes CRUD operations for the **TrainingNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingNotifications
    * const trainingNotifications = await prisma.trainingNotification.findMany()
    * ```
    */
  get trainingNotification(): Prisma.TrainingNotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ActivityLog: 'ActivityLog',
    Batch: 'Batch',
    ExportLog: 'ExportLog',
    Methodology: 'Methodology',
    Notification: 'Notification',
    Permission: 'Permission',
    Product: 'Product',
    Role: 'Role',
    UnitOfMeasurement: 'UnitOfMeasurement',
    User: 'User',
    Standard: 'Standard',
    StandardCategory: 'StandardCategory',
    StandardParameter: 'StandardParameter',
    StandardDefinition: 'StandardDefinition',
    BatchParameterValue: 'BatchParameterValue',
    TrainingCalendar: 'TrainingCalendar',
    Training: 'Training',
    TrainingSession: 'TrainingSession',
    TrainingDocument: 'TrainingDocument',
    TrainingParticipant: 'TrainingParticipant',
    Attendance: 'Attendance',
    TrainingPhoto: 'TrainingPhoto',
    TrainingFeedback: 'TrainingFeedback',
    TrainingFollowup: 'TrainingFollowup',
    TrainingNotification: 'TrainingNotification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "activityLog" | "batch" | "exportLog" | "methodology" | "notification" | "permission" | "product" | "role" | "unitOfMeasurement" | "user" | "standard" | "standardCategory" | "standardParameter" | "standardDefinition" | "batchParameterValue" | "trainingCalendar" | "training" | "trainingSession" | "trainingDocument" | "trainingParticipant" | "attendance" | "trainingPhoto" | "trainingFeedback" | "trainingFollowup" | "trainingNotification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      Batch: {
        payload: Prisma.$BatchPayload<ExtArgs>
        fields: Prisma.BatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findFirst: {
            args: Prisma.BatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findMany: {
            args: Prisma.BatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          create: {
            args: Prisma.BatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          createMany: {
            args: Prisma.BatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          delete: {
            args: Prisma.BatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          update: {
            args: Prisma.BatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          deleteMany: {
            args: Prisma.BatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          upsert: {
            args: Prisma.BatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          aggregate: {
            args: Prisma.BatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatch>
          }
          groupBy: {
            args: Prisma.BatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchCountArgs<ExtArgs>
            result: $Utils.Optional<BatchCountAggregateOutputType> | number
          }
        }
      }
      ExportLog: {
        payload: Prisma.$ExportLogPayload<ExtArgs>
        fields: Prisma.ExportLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExportLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExportLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>
          }
          findFirst: {
            args: Prisma.ExportLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExportLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>
          }
          findMany: {
            args: Prisma.ExportLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>[]
          }
          create: {
            args: Prisma.ExportLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>
          }
          createMany: {
            args: Prisma.ExportLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExportLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>[]
          }
          delete: {
            args: Prisma.ExportLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>
          }
          update: {
            args: Prisma.ExportLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>
          }
          deleteMany: {
            args: Prisma.ExportLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExportLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExportLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>[]
          }
          upsert: {
            args: Prisma.ExportLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportLogPayload>
          }
          aggregate: {
            args: Prisma.ExportLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExportLog>
          }
          groupBy: {
            args: Prisma.ExportLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExportLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExportLogCountArgs<ExtArgs>
            result: $Utils.Optional<ExportLogCountAggregateOutputType> | number
          }
        }
      }
      Methodology: {
        payload: Prisma.$MethodologyPayload<ExtArgs>
        fields: Prisma.MethodologyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MethodologyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MethodologyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>
          }
          findFirst: {
            args: Prisma.MethodologyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MethodologyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>
          }
          findMany: {
            args: Prisma.MethodologyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>[]
          }
          create: {
            args: Prisma.MethodologyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>
          }
          createMany: {
            args: Prisma.MethodologyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MethodologyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>[]
          }
          delete: {
            args: Prisma.MethodologyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>
          }
          update: {
            args: Prisma.MethodologyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>
          }
          deleteMany: {
            args: Prisma.MethodologyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MethodologyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MethodologyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>[]
          }
          upsert: {
            args: Prisma.MethodologyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MethodologyPayload>
          }
          aggregate: {
            args: Prisma.MethodologyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMethodology>
          }
          groupBy: {
            args: Prisma.MethodologyGroupByArgs<ExtArgs>
            result: $Utils.Optional<MethodologyGroupByOutputType>[]
          }
          count: {
            args: Prisma.MethodologyCountArgs<ExtArgs>
            result: $Utils.Optional<MethodologyCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UnitOfMeasurement: {
        payload: Prisma.$UnitOfMeasurementPayload<ExtArgs>
        fields: Prisma.UnitOfMeasurementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitOfMeasurementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitOfMeasurementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>
          }
          findFirst: {
            args: Prisma.UnitOfMeasurementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitOfMeasurementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>
          }
          findMany: {
            args: Prisma.UnitOfMeasurementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>[]
          }
          create: {
            args: Prisma.UnitOfMeasurementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>
          }
          createMany: {
            args: Prisma.UnitOfMeasurementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitOfMeasurementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>[]
          }
          delete: {
            args: Prisma.UnitOfMeasurementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>
          }
          update: {
            args: Prisma.UnitOfMeasurementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>
          }
          deleteMany: {
            args: Prisma.UnitOfMeasurementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitOfMeasurementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitOfMeasurementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>[]
          }
          upsert: {
            args: Prisma.UnitOfMeasurementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitOfMeasurementPayload>
          }
          aggregate: {
            args: Prisma.UnitOfMeasurementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitOfMeasurement>
          }
          groupBy: {
            args: Prisma.UnitOfMeasurementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitOfMeasurementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitOfMeasurementCountArgs<ExtArgs>
            result: $Utils.Optional<UnitOfMeasurementCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Standard: {
        payload: Prisma.$StandardPayload<ExtArgs>
        fields: Prisma.StandardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StandardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StandardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>
          }
          findFirst: {
            args: Prisma.StandardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StandardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>
          }
          findMany: {
            args: Prisma.StandardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>[]
          }
          create: {
            args: Prisma.StandardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>
          }
          createMany: {
            args: Prisma.StandardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StandardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>[]
          }
          delete: {
            args: Prisma.StandardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>
          }
          update: {
            args: Prisma.StandardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>
          }
          deleteMany: {
            args: Prisma.StandardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StandardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StandardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>[]
          }
          upsert: {
            args: Prisma.StandardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardPayload>
          }
          aggregate: {
            args: Prisma.StandardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStandard>
          }
          groupBy: {
            args: Prisma.StandardGroupByArgs<ExtArgs>
            result: $Utils.Optional<StandardGroupByOutputType>[]
          }
          count: {
            args: Prisma.StandardCountArgs<ExtArgs>
            result: $Utils.Optional<StandardCountAggregateOutputType> | number
          }
        }
      }
      StandardCategory: {
        payload: Prisma.$StandardCategoryPayload<ExtArgs>
        fields: Prisma.StandardCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StandardCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StandardCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>
          }
          findFirst: {
            args: Prisma.StandardCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StandardCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>
          }
          findMany: {
            args: Prisma.StandardCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>[]
          }
          create: {
            args: Prisma.StandardCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>
          }
          createMany: {
            args: Prisma.StandardCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StandardCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>[]
          }
          delete: {
            args: Prisma.StandardCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>
          }
          update: {
            args: Prisma.StandardCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>
          }
          deleteMany: {
            args: Prisma.StandardCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StandardCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StandardCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>[]
          }
          upsert: {
            args: Prisma.StandardCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardCategoryPayload>
          }
          aggregate: {
            args: Prisma.StandardCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStandardCategory>
          }
          groupBy: {
            args: Prisma.StandardCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<StandardCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StandardCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<StandardCategoryCountAggregateOutputType> | number
          }
        }
      }
      StandardParameter: {
        payload: Prisma.$StandardParameterPayload<ExtArgs>
        fields: Prisma.StandardParameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StandardParameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StandardParameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>
          }
          findFirst: {
            args: Prisma.StandardParameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StandardParameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>
          }
          findMany: {
            args: Prisma.StandardParameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>[]
          }
          create: {
            args: Prisma.StandardParameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>
          }
          createMany: {
            args: Prisma.StandardParameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StandardParameterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>[]
          }
          delete: {
            args: Prisma.StandardParameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>
          }
          update: {
            args: Prisma.StandardParameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>
          }
          deleteMany: {
            args: Prisma.StandardParameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StandardParameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StandardParameterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>[]
          }
          upsert: {
            args: Prisma.StandardParameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardParameterPayload>
          }
          aggregate: {
            args: Prisma.StandardParameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStandardParameter>
          }
          groupBy: {
            args: Prisma.StandardParameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<StandardParameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.StandardParameterCountArgs<ExtArgs>
            result: $Utils.Optional<StandardParameterCountAggregateOutputType> | number
          }
        }
      }
      StandardDefinition: {
        payload: Prisma.$StandardDefinitionPayload<ExtArgs>
        fields: Prisma.StandardDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StandardDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StandardDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>
          }
          findFirst: {
            args: Prisma.StandardDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StandardDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>
          }
          findMany: {
            args: Prisma.StandardDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>[]
          }
          create: {
            args: Prisma.StandardDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>
          }
          createMany: {
            args: Prisma.StandardDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StandardDefinitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>[]
          }
          delete: {
            args: Prisma.StandardDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>
          }
          update: {
            args: Prisma.StandardDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.StandardDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StandardDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StandardDefinitionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>[]
          }
          upsert: {
            args: Prisma.StandardDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardDefinitionPayload>
          }
          aggregate: {
            args: Prisma.StandardDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStandardDefinition>
          }
          groupBy: {
            args: Prisma.StandardDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StandardDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StandardDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<StandardDefinitionCountAggregateOutputType> | number
          }
        }
      }
      BatchParameterValue: {
        payload: Prisma.$BatchParameterValuePayload<ExtArgs>
        fields: Prisma.BatchParameterValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchParameterValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchParameterValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>
          }
          findFirst: {
            args: Prisma.BatchParameterValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchParameterValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>
          }
          findMany: {
            args: Prisma.BatchParameterValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>[]
          }
          create: {
            args: Prisma.BatchParameterValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>
          }
          createMany: {
            args: Prisma.BatchParameterValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchParameterValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>[]
          }
          delete: {
            args: Prisma.BatchParameterValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>
          }
          update: {
            args: Prisma.BatchParameterValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>
          }
          deleteMany: {
            args: Prisma.BatchParameterValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchParameterValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchParameterValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>[]
          }
          upsert: {
            args: Prisma.BatchParameterValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchParameterValuePayload>
          }
          aggregate: {
            args: Prisma.BatchParameterValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchParameterValue>
          }
          groupBy: {
            args: Prisma.BatchParameterValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchParameterValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchParameterValueCountArgs<ExtArgs>
            result: $Utils.Optional<BatchParameterValueCountAggregateOutputType> | number
          }
        }
      }
      TrainingCalendar: {
        payload: Prisma.$TrainingCalendarPayload<ExtArgs>
        fields: Prisma.TrainingCalendarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingCalendarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingCalendarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>
          }
          findFirst: {
            args: Prisma.TrainingCalendarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingCalendarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>
          }
          findMany: {
            args: Prisma.TrainingCalendarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>[]
          }
          create: {
            args: Prisma.TrainingCalendarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>
          }
          createMany: {
            args: Prisma.TrainingCalendarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingCalendarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>[]
          }
          delete: {
            args: Prisma.TrainingCalendarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>
          }
          update: {
            args: Prisma.TrainingCalendarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>
          }
          deleteMany: {
            args: Prisma.TrainingCalendarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingCalendarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingCalendarUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>[]
          }
          upsert: {
            args: Prisma.TrainingCalendarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingCalendarPayload>
          }
          aggregate: {
            args: Prisma.TrainingCalendarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingCalendar>
          }
          groupBy: {
            args: Prisma.TrainingCalendarGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingCalendarGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingCalendarCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingCalendarCountAggregateOutputType> | number
          }
        }
      }
      Training: {
        payload: Prisma.$TrainingPayload<ExtArgs>
        fields: Prisma.TrainingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          findFirst: {
            args: Prisma.TrainingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          findMany: {
            args: Prisma.TrainingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>[]
          }
          create: {
            args: Prisma.TrainingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          createMany: {
            args: Prisma.TrainingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>[]
          }
          delete: {
            args: Prisma.TrainingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          update: {
            args: Prisma.TrainingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>[]
          }
          upsert: {
            args: Prisma.TrainingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          aggregate: {
            args: Prisma.TrainingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTraining>
          }
          groupBy: {
            args: Prisma.TrainingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingCountAggregateOutputType> | number
          }
        }
      }
      TrainingSession: {
        payload: Prisma.$TrainingSessionPayload<ExtArgs>
        fields: Prisma.TrainingSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          findFirst: {
            args: Prisma.TrainingSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          findMany: {
            args: Prisma.TrainingSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>[]
          }
          create: {
            args: Prisma.TrainingSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          createMany: {
            args: Prisma.TrainingSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>[]
          }
          delete: {
            args: Prisma.TrainingSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          update: {
            args: Prisma.TrainingSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          deleteMany: {
            args: Prisma.TrainingSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>[]
          }
          upsert: {
            args: Prisma.TrainingSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          aggregate: {
            args: Prisma.TrainingSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingSession>
          }
          groupBy: {
            args: Prisma.TrainingSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingSessionCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingSessionCountAggregateOutputType> | number
          }
        }
      }
      TrainingDocument: {
        payload: Prisma.$TrainingDocumentPayload<ExtArgs>
        fields: Prisma.TrainingDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          findFirst: {
            args: Prisma.TrainingDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          findMany: {
            args: Prisma.TrainingDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>[]
          }
          create: {
            args: Prisma.TrainingDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          createMany: {
            args: Prisma.TrainingDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>[]
          }
          delete: {
            args: Prisma.TrainingDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          update: {
            args: Prisma.TrainingDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>[]
          }
          upsert: {
            args: Prisma.TrainingDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          aggregate: {
            args: Prisma.TrainingDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingDocument>
          }
          groupBy: {
            args: Prisma.TrainingDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingDocumentCountAggregateOutputType> | number
          }
        }
      }
      TrainingParticipant: {
        payload: Prisma.$TrainingParticipantPayload<ExtArgs>
        fields: Prisma.TrainingParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>
          }
          findFirst: {
            args: Prisma.TrainingParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>
          }
          findMany: {
            args: Prisma.TrainingParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>[]
          }
          create: {
            args: Prisma.TrainingParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>
          }
          createMany: {
            args: Prisma.TrainingParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>[]
          }
          delete: {
            args: Prisma.TrainingParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>
          }
          update: {
            args: Prisma.TrainingParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>
          }
          deleteMany: {
            args: Prisma.TrainingParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>[]
          }
          upsert: {
            args: Prisma.TrainingParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingParticipantPayload>
          }
          aggregate: {
            args: Prisma.TrainingParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingParticipant>
          }
          groupBy: {
            args: Prisma.TrainingParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingParticipantCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      TrainingPhoto: {
        payload: Prisma.$TrainingPhotoPayload<ExtArgs>
        fields: Prisma.TrainingPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>
          }
          findFirst: {
            args: Prisma.TrainingPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>
          }
          findMany: {
            args: Prisma.TrainingPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>[]
          }
          create: {
            args: Prisma.TrainingPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>
          }
          createMany: {
            args: Prisma.TrainingPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>[]
          }
          delete: {
            args: Prisma.TrainingPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>
          }
          update: {
            args: Prisma.TrainingPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>
          }
          deleteMany: {
            args: Prisma.TrainingPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>[]
          }
          upsert: {
            args: Prisma.TrainingPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPhotoPayload>
          }
          aggregate: {
            args: Prisma.TrainingPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingPhoto>
          }
          groupBy: {
            args: Prisma.TrainingPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingPhotoCountAggregateOutputType> | number
          }
        }
      }
      TrainingFeedback: {
        payload: Prisma.$TrainingFeedbackPayload<ExtArgs>
        fields: Prisma.TrainingFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>
          }
          findFirst: {
            args: Prisma.TrainingFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>
          }
          findMany: {
            args: Prisma.TrainingFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>[]
          }
          create: {
            args: Prisma.TrainingFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>
          }
          createMany: {
            args: Prisma.TrainingFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>[]
          }
          delete: {
            args: Prisma.TrainingFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>
          }
          update: {
            args: Prisma.TrainingFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.TrainingFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingFeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>[]
          }
          upsert: {
            args: Prisma.TrainingFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFeedbackPayload>
          }
          aggregate: {
            args: Prisma.TrainingFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingFeedback>
          }
          groupBy: {
            args: Prisma.TrainingFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingFeedbackCountAggregateOutputType> | number
          }
        }
      }
      TrainingFollowup: {
        payload: Prisma.$TrainingFollowupPayload<ExtArgs>
        fields: Prisma.TrainingFollowupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingFollowupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingFollowupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>
          }
          findFirst: {
            args: Prisma.TrainingFollowupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingFollowupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>
          }
          findMany: {
            args: Prisma.TrainingFollowupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>[]
          }
          create: {
            args: Prisma.TrainingFollowupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>
          }
          createMany: {
            args: Prisma.TrainingFollowupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingFollowupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>[]
          }
          delete: {
            args: Prisma.TrainingFollowupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>
          }
          update: {
            args: Prisma.TrainingFollowupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>
          }
          deleteMany: {
            args: Prisma.TrainingFollowupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingFollowupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingFollowupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>[]
          }
          upsert: {
            args: Prisma.TrainingFollowupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingFollowupPayload>
          }
          aggregate: {
            args: Prisma.TrainingFollowupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingFollowup>
          }
          groupBy: {
            args: Prisma.TrainingFollowupGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingFollowupGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingFollowupCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingFollowupCountAggregateOutputType> | number
          }
        }
      }
      TrainingNotification: {
        payload: Prisma.$TrainingNotificationPayload<ExtArgs>
        fields: Prisma.TrainingNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>
          }
          findFirst: {
            args: Prisma.TrainingNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>
          }
          findMany: {
            args: Prisma.TrainingNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>[]
          }
          create: {
            args: Prisma.TrainingNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>
          }
          createMany: {
            args: Prisma.TrainingNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>[]
          }
          delete: {
            args: Prisma.TrainingNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>
          }
          update: {
            args: Prisma.TrainingNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>
          }
          deleteMany: {
            args: Prisma.TrainingNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrainingNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>[]
          }
          upsert: {
            args: Prisma.TrainingNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingNotificationPayload>
          }
          aggregate: {
            args: Prisma.TrainingNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingNotification>
          }
          groupBy: {
            args: Prisma.TrainingNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingNotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    activityLog?: ActivityLogOmit
    batch?: BatchOmit
    exportLog?: ExportLogOmit
    methodology?: MethodologyOmit
    notification?: NotificationOmit
    permission?: PermissionOmit
    product?: ProductOmit
    role?: RoleOmit
    unitOfMeasurement?: UnitOfMeasurementOmit
    user?: UserOmit
    standard?: StandardOmit
    standardCategory?: StandardCategoryOmit
    standardParameter?: StandardParameterOmit
    standardDefinition?: StandardDefinitionOmit
    batchParameterValue?: BatchParameterValueOmit
    trainingCalendar?: TrainingCalendarOmit
    training?: TrainingOmit
    trainingSession?: TrainingSessionOmit
    trainingDocument?: TrainingDocumentOmit
    trainingParticipant?: TrainingParticipantOmit
    attendance?: AttendanceOmit
    trainingPhoto?: TrainingPhotoOmit
    trainingFeedback?: TrainingFeedbackOmit
    trainingFollowup?: TrainingFollowupOmit
    trainingNotification?: TrainingNotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BatchCountOutputType
   */

  export type BatchCountOutputType = {
    ActivityLog: number
    Notification: number
    standards: number
    methodologies: number
    unitOfMeasurements: number
    parameterValues: number
  }

  export type BatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActivityLog?: boolean | BatchCountOutputTypeCountActivityLogArgs
    Notification?: boolean | BatchCountOutputTypeCountNotificationArgs
    standards?: boolean | BatchCountOutputTypeCountStandardsArgs
    methodologies?: boolean | BatchCountOutputTypeCountMethodologiesArgs
    unitOfMeasurements?: boolean | BatchCountOutputTypeCountUnitOfMeasurementsArgs
    parameterValues?: boolean | BatchCountOutputTypeCountParameterValuesArgs
  }

  // Custom InputTypes
  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCountOutputType
     */
    select?: BatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountMethodologiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MethodologyWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountUnitOfMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfMeasurementWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountParameterValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchParameterValueWhereInput
  }


  /**
   * Count Type MethodologyCountOutputType
   */

  export type MethodologyCountOutputType = {
    Standards: number
    batches: number
    batchParameterValues: number
    standardDefinitions: number
  }

  export type MethodologyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Standards?: boolean | MethodologyCountOutputTypeCountStandardsArgs
    batches?: boolean | MethodologyCountOutputTypeCountBatchesArgs
    batchParameterValues?: boolean | MethodologyCountOutputTypeCountBatchParameterValuesArgs
    standardDefinitions?: boolean | MethodologyCountOutputTypeCountStandardDefinitionsArgs
  }

  // Custom InputTypes
  /**
   * MethodologyCountOutputType without action
   */
  export type MethodologyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MethodologyCountOutputType
     */
    select?: MethodologyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MethodologyCountOutputType without action
   */
  export type MethodologyCountOutputTypeCountStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
  }

  /**
   * MethodologyCountOutputType without action
   */
  export type MethodologyCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * MethodologyCountOutputType without action
   */
  export type MethodologyCountOutputTypeCountBatchParameterValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchParameterValueWhereInput
  }

  /**
   * MethodologyCountOutputType without action
   */
  export type MethodologyCountOutputTypeCountStandardDefinitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardDefinitionWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    Role: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | PermissionCountOutputTypeCountRoleArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    Batch: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | ProductCountOutputTypeCountBatchArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    User: number
    Permission: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | RoleCountOutputTypeCountUserArgs
    Permission?: boolean | RoleCountOutputTypeCountPermissionArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }


  /**
   * Count Type UnitOfMeasurementCountOutputType
   */

  export type UnitOfMeasurementCountOutputType = {
    Standards: number
    batchParameterValues: number
    standardDefinitions: number
    batches: number
  }

  export type UnitOfMeasurementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Standards?: boolean | UnitOfMeasurementCountOutputTypeCountStandardsArgs
    batchParameterValues?: boolean | UnitOfMeasurementCountOutputTypeCountBatchParameterValuesArgs
    standardDefinitions?: boolean | UnitOfMeasurementCountOutputTypeCountStandardDefinitionsArgs
    batches?: boolean | UnitOfMeasurementCountOutputTypeCountBatchesArgs
  }

  // Custom InputTypes
  /**
   * UnitOfMeasurementCountOutputType without action
   */
  export type UnitOfMeasurementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurementCountOutputType
     */
    select?: UnitOfMeasurementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitOfMeasurementCountOutputType without action
   */
  export type UnitOfMeasurementCountOutputTypeCountStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
  }

  /**
   * UnitOfMeasurementCountOutputType without action
   */
  export type UnitOfMeasurementCountOutputTypeCountBatchParameterValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchParameterValueWhereInput
  }

  /**
   * UnitOfMeasurementCountOutputType without action
   */
  export type UnitOfMeasurementCountOutputTypeCountStandardDefinitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardDefinitionWhereInput
  }

  /**
   * UnitOfMeasurementCountOutputType without action
   */
  export type UnitOfMeasurementCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ActivityLog: number
    Batch_Batch_checkerIdToUser: number
    Batch_Batch_makerIdToUser: number
    Notification: number
    StandardsCreated: number
    StandardsModified: number
    standardDefinitionsCreated: number
    standardDefinitionsModified: number
    trainerTrainings: number
    createdTrainings: number
    trainingParticipations: number
    attendances: number
    uploadedDocuments: number
    uploadedPhotos: number
    feedbacks: number
    assignedFollowups: number
    createdFollowups: number
    trainingNotifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActivityLog?: boolean | UserCountOutputTypeCountActivityLogArgs
    Batch_Batch_checkerIdToUser?: boolean | UserCountOutputTypeCountBatch_Batch_checkerIdToUserArgs
    Batch_Batch_makerIdToUser?: boolean | UserCountOutputTypeCountBatch_Batch_makerIdToUserArgs
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs
    StandardsCreated?: boolean | UserCountOutputTypeCountStandardsCreatedArgs
    StandardsModified?: boolean | UserCountOutputTypeCountStandardsModifiedArgs
    standardDefinitionsCreated?: boolean | UserCountOutputTypeCountStandardDefinitionsCreatedArgs
    standardDefinitionsModified?: boolean | UserCountOutputTypeCountStandardDefinitionsModifiedArgs
    trainerTrainings?: boolean | UserCountOutputTypeCountTrainerTrainingsArgs
    createdTrainings?: boolean | UserCountOutputTypeCountCreatedTrainingsArgs
    trainingParticipations?: boolean | UserCountOutputTypeCountTrainingParticipationsArgs
    attendances?: boolean | UserCountOutputTypeCountAttendancesArgs
    uploadedDocuments?: boolean | UserCountOutputTypeCountUploadedDocumentsArgs
    uploadedPhotos?: boolean | UserCountOutputTypeCountUploadedPhotosArgs
    feedbacks?: boolean | UserCountOutputTypeCountFeedbacksArgs
    assignedFollowups?: boolean | UserCountOutputTypeCountAssignedFollowupsArgs
    createdFollowups?: boolean | UserCountOutputTypeCountCreatedFollowupsArgs
    trainingNotifications?: boolean | UserCountOutputTypeCountTrainingNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBatch_Batch_checkerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBatch_Batch_makerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStandardsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStandardsModifiedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStandardDefinitionsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardDefinitionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStandardDefinitionsModifiedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardDefinitionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrainerTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrainingParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPhotoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFollowupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFollowupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrainingNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingNotificationWhereInput
  }


  /**
   * Count Type StandardCountOutputType
   */

  export type StandardCountOutputType = {
    batches: number
    methodologies: number
    units: number
  }

  export type StandardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | StandardCountOutputTypeCountBatchesArgs
    methodologies?: boolean | StandardCountOutputTypeCountMethodologiesArgs
    units?: boolean | StandardCountOutputTypeCountUnitsArgs
  }

  // Custom InputTypes
  /**
   * StandardCountOutputType without action
   */
  export type StandardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCountOutputType
     */
    select?: StandardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StandardCountOutputType without action
   */
  export type StandardCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * StandardCountOutputType without action
   */
  export type StandardCountOutputTypeCountMethodologiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MethodologyWhereInput
  }

  /**
   * StandardCountOutputType without action
   */
  export type StandardCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfMeasurementWhereInput
  }


  /**
   * Count Type StandardCategoryCountOutputType
   */

  export type StandardCategoryCountOutputType = {
    parameters: number
    Standards: number
  }

  export type StandardCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameters?: boolean | StandardCategoryCountOutputTypeCountParametersArgs
    Standards?: boolean | StandardCategoryCountOutputTypeCountStandardsArgs
  }

  // Custom InputTypes
  /**
   * StandardCategoryCountOutputType without action
   */
  export type StandardCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategoryCountOutputType
     */
    select?: StandardCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StandardCategoryCountOutputType without action
   */
  export type StandardCategoryCountOutputTypeCountParametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardParameterWhereInput
  }

  /**
   * StandardCategoryCountOutputType without action
   */
  export type StandardCategoryCountOutputTypeCountStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
  }


  /**
   * Count Type StandardParameterCountOutputType
   */

  export type StandardParameterCountOutputType = {
    batchValues: number
    standards: number
  }

  export type StandardParameterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batchValues?: boolean | StandardParameterCountOutputTypeCountBatchValuesArgs
    standards?: boolean | StandardParameterCountOutputTypeCountStandardsArgs
  }

  // Custom InputTypes
  /**
   * StandardParameterCountOutputType without action
   */
  export type StandardParameterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameterCountOutputType
     */
    select?: StandardParameterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StandardParameterCountOutputType without action
   */
  export type StandardParameterCountOutputTypeCountBatchValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchParameterValueWhereInput
  }

  /**
   * StandardParameterCountOutputType without action
   */
  export type StandardParameterCountOutputTypeCountStandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardDefinitionWhereInput
  }


  /**
   * Count Type TrainingCalendarCountOutputType
   */

  export type TrainingCalendarCountOutputType = {
    trainings: number
  }

  export type TrainingCalendarCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | TrainingCalendarCountOutputTypeCountTrainingsArgs
  }

  // Custom InputTypes
  /**
   * TrainingCalendarCountOutputType without action
   */
  export type TrainingCalendarCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendarCountOutputType
     */
    select?: TrainingCalendarCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingCalendarCountOutputType without action
   */
  export type TrainingCalendarCountOutputTypeCountTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWhereInput
  }


  /**
   * Count Type TrainingCountOutputType
   */

  export type TrainingCountOutputType = {
    sessions: number
    documents: number
    attendance: number
    participants: number
    photos: number
    feedback: number
    followups: number
    notifications: number
  }

  export type TrainingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | TrainingCountOutputTypeCountSessionsArgs
    documents?: boolean | TrainingCountOutputTypeCountDocumentsArgs
    attendance?: boolean | TrainingCountOutputTypeCountAttendanceArgs
    participants?: boolean | TrainingCountOutputTypeCountParticipantsArgs
    photos?: boolean | TrainingCountOutputTypeCountPhotosArgs
    feedback?: boolean | TrainingCountOutputTypeCountFeedbackArgs
    followups?: boolean | TrainingCountOutputTypeCountFollowupsArgs
    notifications?: boolean | TrainingCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCountOutputType
     */
    select?: TrainingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingSessionWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDocumentWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingParticipantWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPhotoWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFeedbackWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFollowupWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingNotificationWhereInput
  }


  /**
   * Count Type TrainingSessionCountOutputType
   */

  export type TrainingSessionCountOutputType = {
    attendance: number
  }

  export type TrainingSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | TrainingSessionCountOutputTypeCountAttendanceArgs
  }

  // Custom InputTypes
  /**
   * TrainingSessionCountOutputType without action
   */
  export type TrainingSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionCountOutputType
     */
    select?: TrainingSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingSessionCountOutputType without action
   */
  export type TrainingSessionCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    batchId: string | null
    action: string | null
    details: string | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    batchId: string | null
    action: string | null
    details: string | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    batchId: number
    action: number
    details: number
    createdAt: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    batchId?: true
    action?: true
    details?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    batchId?: true
    action?: true
    details?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    batchId?: true
    action?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    userId: string
    batchId: string | null
    action: string
    details: string | null
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    batchId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    Batch?: boolean | ActivityLog$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    batchId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    Batch?: boolean | ActivityLog$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    batchId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    Batch?: boolean | ActivityLog$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    batchId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "batchId" | "action" | "details" | "createdAt", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | ActivityLog$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | ActivityLog$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | ActivityLog$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      Batch: Prisma.$BatchPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      batchId: string | null
      action: string
      details: string | null
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Batch<T extends ActivityLog$BatchArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$BatchArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly userId: FieldRef<"ActivityLog", 'String'>
    readonly batchId: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly details: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog.Batch
   */
  export type ActivityLog$BatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model Batch
   */

  export type AggregateBatch = {
    _count: BatchCountAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  export type BatchMinAggregateOutputType = {
    id: string | null
    batchNumber: string | null
    productId: string | null
    dateOfProduction: Date | null
    bestBeforeDate: Date | null
    sampleAnalysisStarted: Date | null
    sampleAnalysisCompleted: Date | null
    sampleAnalysisStatus: $Enums.SampleAnalysisStatus | null
    makerId: string | null
    checkerId: string | null
    status: $Enums.BatchStatus | null
    rejectionRemarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchMaxAggregateOutputType = {
    id: string | null
    batchNumber: string | null
    productId: string | null
    dateOfProduction: Date | null
    bestBeforeDate: Date | null
    sampleAnalysisStarted: Date | null
    sampleAnalysisCompleted: Date | null
    sampleAnalysisStatus: $Enums.SampleAnalysisStatus | null
    makerId: string | null
    checkerId: string | null
    status: $Enums.BatchStatus | null
    rejectionRemarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchCountAggregateOutputType = {
    id: number
    batchNumber: number
    productId: number
    dateOfProduction: number
    bestBeforeDate: number
    sampleAnalysisStarted: number
    sampleAnalysisCompleted: number
    sampleAnalysisStatus: number
    makerId: number
    checkerId: number
    status: number
    rejectionRemarks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BatchMinAggregateInputType = {
    id?: true
    batchNumber?: true
    productId?: true
    dateOfProduction?: true
    bestBeforeDate?: true
    sampleAnalysisStarted?: true
    sampleAnalysisCompleted?: true
    sampleAnalysisStatus?: true
    makerId?: true
    checkerId?: true
    status?: true
    rejectionRemarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchMaxAggregateInputType = {
    id?: true
    batchNumber?: true
    productId?: true
    dateOfProduction?: true
    bestBeforeDate?: true
    sampleAnalysisStarted?: true
    sampleAnalysisCompleted?: true
    sampleAnalysisStatus?: true
    makerId?: true
    checkerId?: true
    status?: true
    rejectionRemarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchCountAggregateInputType = {
    id?: true
    batchNumber?: true
    productId?: true
    dateOfProduction?: true
    bestBeforeDate?: true
    sampleAnalysisStarted?: true
    sampleAnalysisCompleted?: true
    sampleAnalysisStatus?: true
    makerId?: true
    checkerId?: true
    status?: true
    rejectionRemarks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batch to aggregate.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Batches
    **/
    _count?: true | BatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchMaxAggregateInputType
  }

  export type GetBatchAggregateType<T extends BatchAggregateArgs> = {
        [P in keyof T & keyof AggregateBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatch[P]>
      : GetScalarType<T[P], AggregateBatch[P]>
  }




  export type BatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithAggregationInput | BatchOrderByWithAggregationInput[]
    by: BatchScalarFieldEnum[] | BatchScalarFieldEnum
    having?: BatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchCountAggregateInputType | true
    _min?: BatchMinAggregateInputType
    _max?: BatchMaxAggregateInputType
  }

  export type BatchGroupByOutputType = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date
    bestBeforeDate: Date
    sampleAnalysisStarted: Date | null
    sampleAnalysisCompleted: Date | null
    sampleAnalysisStatus: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId: string | null
    status: $Enums.BatchStatus
    rejectionRemarks: string | null
    createdAt: Date
    updatedAt: Date
    _count: BatchCountAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  type GetBatchGroupByPayload<T extends BatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchGroupByOutputType[P]>
            : GetScalarType<T[P], BatchGroupByOutputType[P]>
        }
      >
    >


  export type BatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchNumber?: boolean
    productId?: boolean
    dateOfProduction?: boolean
    bestBeforeDate?: boolean
    sampleAnalysisStarted?: boolean
    sampleAnalysisCompleted?: boolean
    sampleAnalysisStatus?: boolean
    makerId?: boolean
    checkerId?: boolean
    status?: boolean
    rejectionRemarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ActivityLog?: boolean | Batch$ActivityLogArgs<ExtArgs>
    User_Batch_checkerIdToUser?: boolean | Batch$User_Batch_checkerIdToUserArgs<ExtArgs>
    User_Batch_makerIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    Notification?: boolean | Batch$NotificationArgs<ExtArgs>
    standards?: boolean | Batch$standardsArgs<ExtArgs>
    methodologies?: boolean | Batch$methodologiesArgs<ExtArgs>
    unitOfMeasurements?: boolean | Batch$unitOfMeasurementsArgs<ExtArgs>
    parameterValues?: boolean | Batch$parameterValuesArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchNumber?: boolean
    productId?: boolean
    dateOfProduction?: boolean
    bestBeforeDate?: boolean
    sampleAnalysisStarted?: boolean
    sampleAnalysisCompleted?: boolean
    sampleAnalysisStatus?: boolean
    makerId?: boolean
    checkerId?: boolean
    status?: boolean
    rejectionRemarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User_Batch_checkerIdToUser?: boolean | Batch$User_Batch_checkerIdToUserArgs<ExtArgs>
    User_Batch_makerIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchNumber?: boolean
    productId?: boolean
    dateOfProduction?: boolean
    bestBeforeDate?: boolean
    sampleAnalysisStarted?: boolean
    sampleAnalysisCompleted?: boolean
    sampleAnalysisStatus?: boolean
    makerId?: boolean
    checkerId?: boolean
    status?: boolean
    rejectionRemarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User_Batch_checkerIdToUser?: boolean | Batch$User_Batch_checkerIdToUserArgs<ExtArgs>
    User_Batch_makerIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectScalar = {
    id?: boolean
    batchNumber?: boolean
    productId?: boolean
    dateOfProduction?: boolean
    bestBeforeDate?: boolean
    sampleAnalysisStarted?: boolean
    sampleAnalysisCompleted?: boolean
    sampleAnalysisStatus?: boolean
    makerId?: boolean
    checkerId?: boolean
    status?: boolean
    rejectionRemarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "batchNumber" | "productId" | "dateOfProduction" | "bestBeforeDate" | "sampleAnalysisStarted" | "sampleAnalysisCompleted" | "sampleAnalysisStatus" | "makerId" | "checkerId" | "status" | "rejectionRemarks" | "createdAt" | "updatedAt", ExtArgs["result"]["batch"]>
  export type BatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActivityLog?: boolean | Batch$ActivityLogArgs<ExtArgs>
    User_Batch_checkerIdToUser?: boolean | Batch$User_Batch_checkerIdToUserArgs<ExtArgs>
    User_Batch_makerIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    Notification?: boolean | Batch$NotificationArgs<ExtArgs>
    standards?: boolean | Batch$standardsArgs<ExtArgs>
    methodologies?: boolean | Batch$methodologiesArgs<ExtArgs>
    unitOfMeasurements?: boolean | Batch$unitOfMeasurementsArgs<ExtArgs>
    parameterValues?: boolean | Batch$parameterValuesArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Batch_checkerIdToUser?: boolean | Batch$User_Batch_checkerIdToUserArgs<ExtArgs>
    User_Batch_makerIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type BatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Batch_checkerIdToUser?: boolean | Batch$User_Batch_checkerIdToUserArgs<ExtArgs>
    User_Batch_makerIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $BatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Batch"
    objects: {
      ActivityLog: Prisma.$ActivityLogPayload<ExtArgs>[]
      User_Batch_checkerIdToUser: Prisma.$UserPayload<ExtArgs> | null
      User_Batch_makerIdToUser: Prisma.$UserPayload<ExtArgs>
      Product: Prisma.$ProductPayload<ExtArgs>
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
      standards: Prisma.$StandardPayload<ExtArgs>[]
      methodologies: Prisma.$MethodologyPayload<ExtArgs>[]
      unitOfMeasurements: Prisma.$UnitOfMeasurementPayload<ExtArgs>[]
      parameterValues: Prisma.$BatchParameterValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      batchNumber: string
      productId: string
      dateOfProduction: Date
      bestBeforeDate: Date
      sampleAnalysisStarted: Date | null
      sampleAnalysisCompleted: Date | null
      sampleAnalysisStatus: $Enums.SampleAnalysisStatus
      makerId: string
      checkerId: string | null
      status: $Enums.BatchStatus
      rejectionRemarks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["batch"]>
    composites: {}
  }

  type BatchGetPayload<S extends boolean | null | undefined | BatchDefaultArgs> = $Result.GetResult<Prisma.$BatchPayload, S>

  type BatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchCountAggregateInputType | true
    }

  export interface BatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Batch'], meta: { name: 'Batch' } }
    /**
     * Find zero or one Batch that matches the filter.
     * @param {BatchFindUniqueArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchFindUniqueArgs>(args: SelectSubset<T, BatchFindUniqueArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Batch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchFindUniqueOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchFindFirstArgs>(args?: SelectSubset<T, BatchFindFirstArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Batches
     * const batches = await prisma.batch.findMany()
     * 
     * // Get first 10 Batches
     * const batches = await prisma.batch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchWithIdOnly = await prisma.batch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchFindManyArgs>(args?: SelectSubset<T, BatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Batch.
     * @param {BatchCreateArgs} args - Arguments to create a Batch.
     * @example
     * // Create one Batch
     * const Batch = await prisma.batch.create({
     *   data: {
     *     // ... data to create a Batch
     *   }
     * })
     * 
     */
    create<T extends BatchCreateArgs>(args: SelectSubset<T, BatchCreateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Batches.
     * @param {BatchCreateManyArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchCreateManyArgs>(args?: SelectSubset<T, BatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Batches and returns the data saved in the database.
     * @param {BatchCreateManyAndReturnArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Batch.
     * @param {BatchDeleteArgs} args - Arguments to delete one Batch.
     * @example
     * // Delete one Batch
     * const Batch = await prisma.batch.delete({
     *   where: {
     *     // ... filter to delete one Batch
     *   }
     * })
     * 
     */
    delete<T extends BatchDeleteArgs>(args: SelectSubset<T, BatchDeleteArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Batch.
     * @param {BatchUpdateArgs} args - Arguments to update one Batch.
     * @example
     * // Update one Batch
     * const batch = await prisma.batch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchUpdateArgs>(args: SelectSubset<T, BatchUpdateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Batches.
     * @param {BatchDeleteManyArgs} args - Arguments to filter Batches to delete.
     * @example
     * // Delete a few Batches
     * const { count } = await prisma.batch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchDeleteManyArgs>(args?: SelectSubset<T, BatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchUpdateManyArgs>(args: SelectSubset<T, BatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches and returns the data updated in the database.
     * @param {BatchUpdateManyAndReturnArgs} args - Arguments to update many Batches.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Batch.
     * @param {BatchUpsertArgs} args - Arguments to update or create a Batch.
     * @example
     * // Update or create a Batch
     * const batch = await prisma.batch.upsert({
     *   create: {
     *     // ... data to create a Batch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Batch we want to update
     *   }
     * })
     */
    upsert<T extends BatchUpsertArgs>(args: SelectSubset<T, BatchUpsertArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCountArgs} args - Arguments to filter Batches to count.
     * @example
     * // Count the number of Batches
     * const count = await prisma.batch.count({
     *   where: {
     *     // ... the filter for the Batches we want to count
     *   }
     * })
    **/
    count<T extends BatchCountArgs>(
      args?: Subset<T, BatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchAggregateArgs>(args: Subset<T, BatchAggregateArgs>): Prisma.PrismaPromise<GetBatchAggregateType<T>>

    /**
     * Group by Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchGroupByArgs['orderBy'] }
        : { orderBy?: BatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Batch model
   */
  readonly fields: BatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Batch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ActivityLog<T extends Batch$ActivityLogArgs<ExtArgs> = {}>(args?: Subset<T, Batch$ActivityLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User_Batch_checkerIdToUser<T extends Batch$User_Batch_checkerIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, Batch$User_Batch_checkerIdToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User_Batch_makerIdToUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Notification<T extends Batch$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, Batch$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standards<T extends Batch$standardsArgs<ExtArgs> = {}>(args?: Subset<T, Batch$standardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    methodologies<T extends Batch$methodologiesArgs<ExtArgs> = {}>(args?: Subset<T, Batch$methodologiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unitOfMeasurements<T extends Batch$unitOfMeasurementsArgs<ExtArgs> = {}>(args?: Subset<T, Batch$unitOfMeasurementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parameterValues<T extends Batch$parameterValuesArgs<ExtArgs> = {}>(args?: Subset<T, Batch$parameterValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Batch model
   */
  interface BatchFieldRefs {
    readonly id: FieldRef<"Batch", 'String'>
    readonly batchNumber: FieldRef<"Batch", 'String'>
    readonly productId: FieldRef<"Batch", 'String'>
    readonly dateOfProduction: FieldRef<"Batch", 'DateTime'>
    readonly bestBeforeDate: FieldRef<"Batch", 'DateTime'>
    readonly sampleAnalysisStarted: FieldRef<"Batch", 'DateTime'>
    readonly sampleAnalysisCompleted: FieldRef<"Batch", 'DateTime'>
    readonly sampleAnalysisStatus: FieldRef<"Batch", 'SampleAnalysisStatus'>
    readonly makerId: FieldRef<"Batch", 'String'>
    readonly checkerId: FieldRef<"Batch", 'String'>
    readonly status: FieldRef<"Batch", 'BatchStatus'>
    readonly rejectionRemarks: FieldRef<"Batch", 'String'>
    readonly createdAt: FieldRef<"Batch", 'DateTime'>
    readonly updatedAt: FieldRef<"Batch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Batch findUnique
   */
  export type BatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findUniqueOrThrow
   */
  export type BatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findFirst
   */
  export type BatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findFirstOrThrow
   */
  export type BatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findMany
   */
  export type BatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batches to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch create
   */
  export type BatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Batch.
     */
    data: XOR<BatchCreateInput, BatchUncheckedCreateInput>
  }

  /**
   * Batch createMany
   */
  export type BatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Batch createManyAndReturn
   */
  export type BatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Batch update
   */
  export type BatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Batch.
     */
    data: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
    /**
     * Choose, which Batch to update.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch updateMany
   */
  export type BatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
  }

  /**
   * Batch updateManyAndReturn
   */
  export type BatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Batch upsert
   */
  export type BatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Batch to update in case it exists.
     */
    where: BatchWhereUniqueInput
    /**
     * In case the Batch found by the `where` argument doesn't exist, create a new Batch with this data.
     */
    create: XOR<BatchCreateInput, BatchUncheckedCreateInput>
    /**
     * In case the Batch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
  }

  /**
   * Batch delete
   */
  export type BatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter which Batch to delete.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch deleteMany
   */
  export type BatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batches to delete
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to delete.
     */
    limit?: number
  }

  /**
   * Batch.ActivityLog
   */
  export type Batch$ActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Batch.User_Batch_checkerIdToUser
   */
  export type Batch$User_Batch_checkerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Batch.Notification
   */
  export type Batch$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Batch.standards
   */
  export type Batch$standardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    cursor?: StandardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * Batch.methodologies
   */
  export type Batch$methodologiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    where?: MethodologyWhereInput
    orderBy?: MethodologyOrderByWithRelationInput | MethodologyOrderByWithRelationInput[]
    cursor?: MethodologyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MethodologyScalarFieldEnum | MethodologyScalarFieldEnum[]
  }

  /**
   * Batch.unitOfMeasurements
   */
  export type Batch$unitOfMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    where?: UnitOfMeasurementWhereInput
    orderBy?: UnitOfMeasurementOrderByWithRelationInput | UnitOfMeasurementOrderByWithRelationInput[]
    cursor?: UnitOfMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitOfMeasurementScalarFieldEnum | UnitOfMeasurementScalarFieldEnum[]
  }

  /**
   * Batch.parameterValues
   */
  export type Batch$parameterValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    where?: BatchParameterValueWhereInput
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    cursor?: BatchParameterValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * Batch without action
   */
  export type BatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
  }


  /**
   * Model ExportLog
   */

  export type AggregateExportLog = {
    _count: ExportLogCountAggregateOutputType | null
    _min: ExportLogMinAggregateOutputType | null
    _max: ExportLogMaxAggregateOutputType | null
  }

  export type ExportLogMinAggregateOutputType = {
    id: string | null
    fileName: string | null
    exportType: string | null
    exportedBy: string | null
    exportedAt: Date | null
  }

  export type ExportLogMaxAggregateOutputType = {
    id: string | null
    fileName: string | null
    exportType: string | null
    exportedBy: string | null
    exportedAt: Date | null
  }

  export type ExportLogCountAggregateOutputType = {
    id: number
    fileName: number
    exportType: number
    exportedBy: number
    exportedAt: number
    _all: number
  }


  export type ExportLogMinAggregateInputType = {
    id?: true
    fileName?: true
    exportType?: true
    exportedBy?: true
    exportedAt?: true
  }

  export type ExportLogMaxAggregateInputType = {
    id?: true
    fileName?: true
    exportType?: true
    exportedBy?: true
    exportedAt?: true
  }

  export type ExportLogCountAggregateInputType = {
    id?: true
    fileName?: true
    exportType?: true
    exportedBy?: true
    exportedAt?: true
    _all?: true
  }

  export type ExportLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportLog to aggregate.
     */
    where?: ExportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportLogs to fetch.
     */
    orderBy?: ExportLogOrderByWithRelationInput | ExportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExportLogs
    **/
    _count?: true | ExportLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExportLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExportLogMaxAggregateInputType
  }

  export type GetExportLogAggregateType<T extends ExportLogAggregateArgs> = {
        [P in keyof T & keyof AggregateExportLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExportLog[P]>
      : GetScalarType<T[P], AggregateExportLog[P]>
  }




  export type ExportLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportLogWhereInput
    orderBy?: ExportLogOrderByWithAggregationInput | ExportLogOrderByWithAggregationInput[]
    by: ExportLogScalarFieldEnum[] | ExportLogScalarFieldEnum
    having?: ExportLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExportLogCountAggregateInputType | true
    _min?: ExportLogMinAggregateInputType
    _max?: ExportLogMaxAggregateInputType
  }

  export type ExportLogGroupByOutputType = {
    id: string
    fileName: string
    exportType: string
    exportedBy: string
    exportedAt: Date
    _count: ExportLogCountAggregateOutputType | null
    _min: ExportLogMinAggregateOutputType | null
    _max: ExportLogMaxAggregateOutputType | null
  }

  type GetExportLogGroupByPayload<T extends ExportLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExportLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExportLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExportLogGroupByOutputType[P]>
            : GetScalarType<T[P], ExportLogGroupByOutputType[P]>
        }
      >
    >


  export type ExportLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    exportType?: boolean
    exportedBy?: boolean
    exportedAt?: boolean
  }, ExtArgs["result"]["exportLog"]>

  export type ExportLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    exportType?: boolean
    exportedBy?: boolean
    exportedAt?: boolean
  }, ExtArgs["result"]["exportLog"]>

  export type ExportLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    exportType?: boolean
    exportedBy?: boolean
    exportedAt?: boolean
  }, ExtArgs["result"]["exportLog"]>

  export type ExportLogSelectScalar = {
    id?: boolean
    fileName?: boolean
    exportType?: boolean
    exportedBy?: boolean
    exportedAt?: boolean
  }

  export type ExportLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fileName" | "exportType" | "exportedBy" | "exportedAt", ExtArgs["result"]["exportLog"]>

  export type $ExportLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExportLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileName: string
      exportType: string
      exportedBy: string
      exportedAt: Date
    }, ExtArgs["result"]["exportLog"]>
    composites: {}
  }

  type ExportLogGetPayload<S extends boolean | null | undefined | ExportLogDefaultArgs> = $Result.GetResult<Prisma.$ExportLogPayload, S>

  type ExportLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExportLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExportLogCountAggregateInputType | true
    }

  export interface ExportLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExportLog'], meta: { name: 'ExportLog' } }
    /**
     * Find zero or one ExportLog that matches the filter.
     * @param {ExportLogFindUniqueArgs} args - Arguments to find a ExportLog
     * @example
     * // Get one ExportLog
     * const exportLog = await prisma.exportLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExportLogFindUniqueArgs>(args: SelectSubset<T, ExportLogFindUniqueArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExportLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExportLogFindUniqueOrThrowArgs} args - Arguments to find a ExportLog
     * @example
     * // Get one ExportLog
     * const exportLog = await prisma.exportLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExportLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ExportLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExportLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogFindFirstArgs} args - Arguments to find a ExportLog
     * @example
     * // Get one ExportLog
     * const exportLog = await prisma.exportLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExportLogFindFirstArgs>(args?: SelectSubset<T, ExportLogFindFirstArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExportLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogFindFirstOrThrowArgs} args - Arguments to find a ExportLog
     * @example
     * // Get one ExportLog
     * const exportLog = await prisma.exportLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExportLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ExportLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExportLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExportLogs
     * const exportLogs = await prisma.exportLog.findMany()
     * 
     * // Get first 10 ExportLogs
     * const exportLogs = await prisma.exportLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exportLogWithIdOnly = await prisma.exportLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExportLogFindManyArgs>(args?: SelectSubset<T, ExportLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExportLog.
     * @param {ExportLogCreateArgs} args - Arguments to create a ExportLog.
     * @example
     * // Create one ExportLog
     * const ExportLog = await prisma.exportLog.create({
     *   data: {
     *     // ... data to create a ExportLog
     *   }
     * })
     * 
     */
    create<T extends ExportLogCreateArgs>(args: SelectSubset<T, ExportLogCreateArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExportLogs.
     * @param {ExportLogCreateManyArgs} args - Arguments to create many ExportLogs.
     * @example
     * // Create many ExportLogs
     * const exportLog = await prisma.exportLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExportLogCreateManyArgs>(args?: SelectSubset<T, ExportLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExportLogs and returns the data saved in the database.
     * @param {ExportLogCreateManyAndReturnArgs} args - Arguments to create many ExportLogs.
     * @example
     * // Create many ExportLogs
     * const exportLog = await prisma.exportLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExportLogs and only return the `id`
     * const exportLogWithIdOnly = await prisma.exportLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExportLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ExportLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExportLog.
     * @param {ExportLogDeleteArgs} args - Arguments to delete one ExportLog.
     * @example
     * // Delete one ExportLog
     * const ExportLog = await prisma.exportLog.delete({
     *   where: {
     *     // ... filter to delete one ExportLog
     *   }
     * })
     * 
     */
    delete<T extends ExportLogDeleteArgs>(args: SelectSubset<T, ExportLogDeleteArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExportLog.
     * @param {ExportLogUpdateArgs} args - Arguments to update one ExportLog.
     * @example
     * // Update one ExportLog
     * const exportLog = await prisma.exportLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExportLogUpdateArgs>(args: SelectSubset<T, ExportLogUpdateArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExportLogs.
     * @param {ExportLogDeleteManyArgs} args - Arguments to filter ExportLogs to delete.
     * @example
     * // Delete a few ExportLogs
     * const { count } = await prisma.exportLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExportLogDeleteManyArgs>(args?: SelectSubset<T, ExportLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExportLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExportLogs
     * const exportLog = await prisma.exportLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExportLogUpdateManyArgs>(args: SelectSubset<T, ExportLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExportLogs and returns the data updated in the database.
     * @param {ExportLogUpdateManyAndReturnArgs} args - Arguments to update many ExportLogs.
     * @example
     * // Update many ExportLogs
     * const exportLog = await prisma.exportLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExportLogs and only return the `id`
     * const exportLogWithIdOnly = await prisma.exportLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExportLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ExportLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExportLog.
     * @param {ExportLogUpsertArgs} args - Arguments to update or create a ExportLog.
     * @example
     * // Update or create a ExportLog
     * const exportLog = await prisma.exportLog.upsert({
     *   create: {
     *     // ... data to create a ExportLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExportLog we want to update
     *   }
     * })
     */
    upsert<T extends ExportLogUpsertArgs>(args: SelectSubset<T, ExportLogUpsertArgs<ExtArgs>>): Prisma__ExportLogClient<$Result.GetResult<Prisma.$ExportLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExportLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogCountArgs} args - Arguments to filter ExportLogs to count.
     * @example
     * // Count the number of ExportLogs
     * const count = await prisma.exportLog.count({
     *   where: {
     *     // ... the filter for the ExportLogs we want to count
     *   }
     * })
    **/
    count<T extends ExportLogCountArgs>(
      args?: Subset<T, ExportLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExportLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExportLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExportLogAggregateArgs>(args: Subset<T, ExportLogAggregateArgs>): Prisma.PrismaPromise<GetExportLogAggregateType<T>>

    /**
     * Group by ExportLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExportLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExportLogGroupByArgs['orderBy'] }
        : { orderBy?: ExportLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExportLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExportLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExportLog model
   */
  readonly fields: ExportLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExportLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExportLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExportLog model
   */
  interface ExportLogFieldRefs {
    readonly id: FieldRef<"ExportLog", 'String'>
    readonly fileName: FieldRef<"ExportLog", 'String'>
    readonly exportType: FieldRef<"ExportLog", 'String'>
    readonly exportedBy: FieldRef<"ExportLog", 'String'>
    readonly exportedAt: FieldRef<"ExportLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExportLog findUnique
   */
  export type ExportLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * Filter, which ExportLog to fetch.
     */
    where: ExportLogWhereUniqueInput
  }

  /**
   * ExportLog findUniqueOrThrow
   */
  export type ExportLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * Filter, which ExportLog to fetch.
     */
    where: ExportLogWhereUniqueInput
  }

  /**
   * ExportLog findFirst
   */
  export type ExportLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * Filter, which ExportLog to fetch.
     */
    where?: ExportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportLogs to fetch.
     */
    orderBy?: ExportLogOrderByWithRelationInput | ExportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportLogs.
     */
    cursor?: ExportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportLogs.
     */
    distinct?: ExportLogScalarFieldEnum | ExportLogScalarFieldEnum[]
  }

  /**
   * ExportLog findFirstOrThrow
   */
  export type ExportLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * Filter, which ExportLog to fetch.
     */
    where?: ExportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportLogs to fetch.
     */
    orderBy?: ExportLogOrderByWithRelationInput | ExportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportLogs.
     */
    cursor?: ExportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportLogs.
     */
    distinct?: ExportLogScalarFieldEnum | ExportLogScalarFieldEnum[]
  }

  /**
   * ExportLog findMany
   */
  export type ExportLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * Filter, which ExportLogs to fetch.
     */
    where?: ExportLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportLogs to fetch.
     */
    orderBy?: ExportLogOrderByWithRelationInput | ExportLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExportLogs.
     */
    cursor?: ExportLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportLogs.
     */
    skip?: number
    distinct?: ExportLogScalarFieldEnum | ExportLogScalarFieldEnum[]
  }

  /**
   * ExportLog create
   */
  export type ExportLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * The data needed to create a ExportLog.
     */
    data: XOR<ExportLogCreateInput, ExportLogUncheckedCreateInput>
  }

  /**
   * ExportLog createMany
   */
  export type ExportLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExportLogs.
     */
    data: ExportLogCreateManyInput | ExportLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExportLog createManyAndReturn
   */
  export type ExportLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * The data used to create many ExportLogs.
     */
    data: ExportLogCreateManyInput | ExportLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExportLog update
   */
  export type ExportLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * The data needed to update a ExportLog.
     */
    data: XOR<ExportLogUpdateInput, ExportLogUncheckedUpdateInput>
    /**
     * Choose, which ExportLog to update.
     */
    where: ExportLogWhereUniqueInput
  }

  /**
   * ExportLog updateMany
   */
  export type ExportLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExportLogs.
     */
    data: XOR<ExportLogUpdateManyMutationInput, ExportLogUncheckedUpdateManyInput>
    /**
     * Filter which ExportLogs to update
     */
    where?: ExportLogWhereInput
    /**
     * Limit how many ExportLogs to update.
     */
    limit?: number
  }

  /**
   * ExportLog updateManyAndReturn
   */
  export type ExportLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * The data used to update ExportLogs.
     */
    data: XOR<ExportLogUpdateManyMutationInput, ExportLogUncheckedUpdateManyInput>
    /**
     * Filter which ExportLogs to update
     */
    where?: ExportLogWhereInput
    /**
     * Limit how many ExportLogs to update.
     */
    limit?: number
  }

  /**
   * ExportLog upsert
   */
  export type ExportLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * The filter to search for the ExportLog to update in case it exists.
     */
    where: ExportLogWhereUniqueInput
    /**
     * In case the ExportLog found by the `where` argument doesn't exist, create a new ExportLog with this data.
     */
    create: XOR<ExportLogCreateInput, ExportLogUncheckedCreateInput>
    /**
     * In case the ExportLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExportLogUpdateInput, ExportLogUncheckedUpdateInput>
  }

  /**
   * ExportLog delete
   */
  export type ExportLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
    /**
     * Filter which ExportLog to delete.
     */
    where: ExportLogWhereUniqueInput
  }

  /**
   * ExportLog deleteMany
   */
  export type ExportLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportLogs to delete
     */
    where?: ExportLogWhereInput
    /**
     * Limit how many ExportLogs to delete.
     */
    limit?: number
  }

  /**
   * ExportLog without action
   */
  export type ExportLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportLog
     */
    select?: ExportLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExportLog
     */
    omit?: ExportLogOmit<ExtArgs> | null
  }


  /**
   * Model Methodology
   */

  export type AggregateMethodology = {
    _count: MethodologyCountAggregateOutputType | null
    _min: MethodologyMinAggregateOutputType | null
    _max: MethodologyMaxAggregateOutputType | null
  }

  export type MethodologyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    procedure: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MethodologyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    procedure: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MethodologyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    procedure: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MethodologyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    procedure?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MethodologyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    procedure?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MethodologyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    procedure?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MethodologyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Methodology to aggregate.
     */
    where?: MethodologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Methodologies to fetch.
     */
    orderBy?: MethodologyOrderByWithRelationInput | MethodologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MethodologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Methodologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Methodologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Methodologies
    **/
    _count?: true | MethodologyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MethodologyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MethodologyMaxAggregateInputType
  }

  export type GetMethodologyAggregateType<T extends MethodologyAggregateArgs> = {
        [P in keyof T & keyof AggregateMethodology]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMethodology[P]>
      : GetScalarType<T[P], AggregateMethodology[P]>
  }




  export type MethodologyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MethodologyWhereInput
    orderBy?: MethodologyOrderByWithAggregationInput | MethodologyOrderByWithAggregationInput[]
    by: MethodologyScalarFieldEnum[] | MethodologyScalarFieldEnum
    having?: MethodologyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MethodologyCountAggregateInputType | true
    _min?: MethodologyMinAggregateInputType
    _max?: MethodologyMaxAggregateInputType
  }

  export type MethodologyGroupByOutputType = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt: Date
    updatedAt: Date
    _count: MethodologyCountAggregateOutputType | null
    _min: MethodologyMinAggregateOutputType | null
    _max: MethodologyMaxAggregateOutputType | null
  }

  type GetMethodologyGroupByPayload<T extends MethodologyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MethodologyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MethodologyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MethodologyGroupByOutputType[P]>
            : GetScalarType<T[P], MethodologyGroupByOutputType[P]>
        }
      >
    >


  export type MethodologySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    procedure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Standards?: boolean | Methodology$StandardsArgs<ExtArgs>
    batches?: boolean | Methodology$batchesArgs<ExtArgs>
    batchParameterValues?: boolean | Methodology$batchParameterValuesArgs<ExtArgs>
    standardDefinitions?: boolean | Methodology$standardDefinitionsArgs<ExtArgs>
    _count?: boolean | MethodologyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["methodology"]>

  export type MethodologySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    procedure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["methodology"]>

  export type MethodologySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    procedure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["methodology"]>

  export type MethodologySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    procedure?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MethodologyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "procedure" | "createdAt" | "updatedAt", ExtArgs["result"]["methodology"]>
  export type MethodologyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Standards?: boolean | Methodology$StandardsArgs<ExtArgs>
    batches?: boolean | Methodology$batchesArgs<ExtArgs>
    batchParameterValues?: boolean | Methodology$batchParameterValuesArgs<ExtArgs>
    standardDefinitions?: boolean | Methodology$standardDefinitionsArgs<ExtArgs>
    _count?: boolean | MethodologyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MethodologyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MethodologyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MethodologyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Methodology"
    objects: {
      Standards: Prisma.$StandardPayload<ExtArgs>[]
      batches: Prisma.$BatchPayload<ExtArgs>[]
      batchParameterValues: Prisma.$BatchParameterValuePayload<ExtArgs>[]
      standardDefinitions: Prisma.$StandardDefinitionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      procedure: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["methodology"]>
    composites: {}
  }

  type MethodologyGetPayload<S extends boolean | null | undefined | MethodologyDefaultArgs> = $Result.GetResult<Prisma.$MethodologyPayload, S>

  type MethodologyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MethodologyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MethodologyCountAggregateInputType | true
    }

  export interface MethodologyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Methodology'], meta: { name: 'Methodology' } }
    /**
     * Find zero or one Methodology that matches the filter.
     * @param {MethodologyFindUniqueArgs} args - Arguments to find a Methodology
     * @example
     * // Get one Methodology
     * const methodology = await prisma.methodology.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MethodologyFindUniqueArgs>(args: SelectSubset<T, MethodologyFindUniqueArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Methodology that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MethodologyFindUniqueOrThrowArgs} args - Arguments to find a Methodology
     * @example
     * // Get one Methodology
     * const methodology = await prisma.methodology.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MethodologyFindUniqueOrThrowArgs>(args: SelectSubset<T, MethodologyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Methodology that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyFindFirstArgs} args - Arguments to find a Methodology
     * @example
     * // Get one Methodology
     * const methodology = await prisma.methodology.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MethodologyFindFirstArgs>(args?: SelectSubset<T, MethodologyFindFirstArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Methodology that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyFindFirstOrThrowArgs} args - Arguments to find a Methodology
     * @example
     * // Get one Methodology
     * const methodology = await prisma.methodology.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MethodologyFindFirstOrThrowArgs>(args?: SelectSubset<T, MethodologyFindFirstOrThrowArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Methodologies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Methodologies
     * const methodologies = await prisma.methodology.findMany()
     * 
     * // Get first 10 Methodologies
     * const methodologies = await prisma.methodology.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const methodologyWithIdOnly = await prisma.methodology.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MethodologyFindManyArgs>(args?: SelectSubset<T, MethodologyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Methodology.
     * @param {MethodologyCreateArgs} args - Arguments to create a Methodology.
     * @example
     * // Create one Methodology
     * const Methodology = await prisma.methodology.create({
     *   data: {
     *     // ... data to create a Methodology
     *   }
     * })
     * 
     */
    create<T extends MethodologyCreateArgs>(args: SelectSubset<T, MethodologyCreateArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Methodologies.
     * @param {MethodologyCreateManyArgs} args - Arguments to create many Methodologies.
     * @example
     * // Create many Methodologies
     * const methodology = await prisma.methodology.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MethodologyCreateManyArgs>(args?: SelectSubset<T, MethodologyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Methodologies and returns the data saved in the database.
     * @param {MethodologyCreateManyAndReturnArgs} args - Arguments to create many Methodologies.
     * @example
     * // Create many Methodologies
     * const methodology = await prisma.methodology.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Methodologies and only return the `id`
     * const methodologyWithIdOnly = await prisma.methodology.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MethodologyCreateManyAndReturnArgs>(args?: SelectSubset<T, MethodologyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Methodology.
     * @param {MethodologyDeleteArgs} args - Arguments to delete one Methodology.
     * @example
     * // Delete one Methodology
     * const Methodology = await prisma.methodology.delete({
     *   where: {
     *     // ... filter to delete one Methodology
     *   }
     * })
     * 
     */
    delete<T extends MethodologyDeleteArgs>(args: SelectSubset<T, MethodologyDeleteArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Methodology.
     * @param {MethodologyUpdateArgs} args - Arguments to update one Methodology.
     * @example
     * // Update one Methodology
     * const methodology = await prisma.methodology.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MethodologyUpdateArgs>(args: SelectSubset<T, MethodologyUpdateArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Methodologies.
     * @param {MethodologyDeleteManyArgs} args - Arguments to filter Methodologies to delete.
     * @example
     * // Delete a few Methodologies
     * const { count } = await prisma.methodology.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MethodologyDeleteManyArgs>(args?: SelectSubset<T, MethodologyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Methodologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Methodologies
     * const methodology = await prisma.methodology.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MethodologyUpdateManyArgs>(args: SelectSubset<T, MethodologyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Methodologies and returns the data updated in the database.
     * @param {MethodologyUpdateManyAndReturnArgs} args - Arguments to update many Methodologies.
     * @example
     * // Update many Methodologies
     * const methodology = await prisma.methodology.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Methodologies and only return the `id`
     * const methodologyWithIdOnly = await prisma.methodology.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MethodologyUpdateManyAndReturnArgs>(args: SelectSubset<T, MethodologyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Methodology.
     * @param {MethodologyUpsertArgs} args - Arguments to update or create a Methodology.
     * @example
     * // Update or create a Methodology
     * const methodology = await prisma.methodology.upsert({
     *   create: {
     *     // ... data to create a Methodology
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Methodology we want to update
     *   }
     * })
     */
    upsert<T extends MethodologyUpsertArgs>(args: SelectSubset<T, MethodologyUpsertArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Methodologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyCountArgs} args - Arguments to filter Methodologies to count.
     * @example
     * // Count the number of Methodologies
     * const count = await prisma.methodology.count({
     *   where: {
     *     // ... the filter for the Methodologies we want to count
     *   }
     * })
    **/
    count<T extends MethodologyCountArgs>(
      args?: Subset<T, MethodologyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MethodologyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Methodology.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MethodologyAggregateArgs>(args: Subset<T, MethodologyAggregateArgs>): Prisma.PrismaPromise<GetMethodologyAggregateType<T>>

    /**
     * Group by Methodology.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodologyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MethodologyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MethodologyGroupByArgs['orderBy'] }
        : { orderBy?: MethodologyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MethodologyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMethodologyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Methodology model
   */
  readonly fields: MethodologyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Methodology.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MethodologyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Standards<T extends Methodology$StandardsArgs<ExtArgs> = {}>(args?: Subset<T, Methodology$StandardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    batches<T extends Methodology$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Methodology$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    batchParameterValues<T extends Methodology$batchParameterValuesArgs<ExtArgs> = {}>(args?: Subset<T, Methodology$batchParameterValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standardDefinitions<T extends Methodology$standardDefinitionsArgs<ExtArgs> = {}>(args?: Subset<T, Methodology$standardDefinitionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Methodology model
   */
  interface MethodologyFieldRefs {
    readonly id: FieldRef<"Methodology", 'String'>
    readonly name: FieldRef<"Methodology", 'String'>
    readonly description: FieldRef<"Methodology", 'String'>
    readonly procedure: FieldRef<"Methodology", 'String'>
    readonly createdAt: FieldRef<"Methodology", 'DateTime'>
    readonly updatedAt: FieldRef<"Methodology", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Methodology findUnique
   */
  export type MethodologyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * Filter, which Methodology to fetch.
     */
    where: MethodologyWhereUniqueInput
  }

  /**
   * Methodology findUniqueOrThrow
   */
  export type MethodologyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * Filter, which Methodology to fetch.
     */
    where: MethodologyWhereUniqueInput
  }

  /**
   * Methodology findFirst
   */
  export type MethodologyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * Filter, which Methodology to fetch.
     */
    where?: MethodologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Methodologies to fetch.
     */
    orderBy?: MethodologyOrderByWithRelationInput | MethodologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Methodologies.
     */
    cursor?: MethodologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Methodologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Methodologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Methodologies.
     */
    distinct?: MethodologyScalarFieldEnum | MethodologyScalarFieldEnum[]
  }

  /**
   * Methodology findFirstOrThrow
   */
  export type MethodologyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * Filter, which Methodology to fetch.
     */
    where?: MethodologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Methodologies to fetch.
     */
    orderBy?: MethodologyOrderByWithRelationInput | MethodologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Methodologies.
     */
    cursor?: MethodologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Methodologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Methodologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Methodologies.
     */
    distinct?: MethodologyScalarFieldEnum | MethodologyScalarFieldEnum[]
  }

  /**
   * Methodology findMany
   */
  export type MethodologyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * Filter, which Methodologies to fetch.
     */
    where?: MethodologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Methodologies to fetch.
     */
    orderBy?: MethodologyOrderByWithRelationInput | MethodologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Methodologies.
     */
    cursor?: MethodologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Methodologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Methodologies.
     */
    skip?: number
    distinct?: MethodologyScalarFieldEnum | MethodologyScalarFieldEnum[]
  }

  /**
   * Methodology create
   */
  export type MethodologyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * The data needed to create a Methodology.
     */
    data: XOR<MethodologyCreateInput, MethodologyUncheckedCreateInput>
  }

  /**
   * Methodology createMany
   */
  export type MethodologyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Methodologies.
     */
    data: MethodologyCreateManyInput | MethodologyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Methodology createManyAndReturn
   */
  export type MethodologyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * The data used to create many Methodologies.
     */
    data: MethodologyCreateManyInput | MethodologyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Methodology update
   */
  export type MethodologyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * The data needed to update a Methodology.
     */
    data: XOR<MethodologyUpdateInput, MethodologyUncheckedUpdateInput>
    /**
     * Choose, which Methodology to update.
     */
    where: MethodologyWhereUniqueInput
  }

  /**
   * Methodology updateMany
   */
  export type MethodologyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Methodologies.
     */
    data: XOR<MethodologyUpdateManyMutationInput, MethodologyUncheckedUpdateManyInput>
    /**
     * Filter which Methodologies to update
     */
    where?: MethodologyWhereInput
    /**
     * Limit how many Methodologies to update.
     */
    limit?: number
  }

  /**
   * Methodology updateManyAndReturn
   */
  export type MethodologyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * The data used to update Methodologies.
     */
    data: XOR<MethodologyUpdateManyMutationInput, MethodologyUncheckedUpdateManyInput>
    /**
     * Filter which Methodologies to update
     */
    where?: MethodologyWhereInput
    /**
     * Limit how many Methodologies to update.
     */
    limit?: number
  }

  /**
   * Methodology upsert
   */
  export type MethodologyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * The filter to search for the Methodology to update in case it exists.
     */
    where: MethodologyWhereUniqueInput
    /**
     * In case the Methodology found by the `where` argument doesn't exist, create a new Methodology with this data.
     */
    create: XOR<MethodologyCreateInput, MethodologyUncheckedCreateInput>
    /**
     * In case the Methodology was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MethodologyUpdateInput, MethodologyUncheckedUpdateInput>
  }

  /**
   * Methodology delete
   */
  export type MethodologyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    /**
     * Filter which Methodology to delete.
     */
    where: MethodologyWhereUniqueInput
  }

  /**
   * Methodology deleteMany
   */
  export type MethodologyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Methodologies to delete
     */
    where?: MethodologyWhereInput
    /**
     * Limit how many Methodologies to delete.
     */
    limit?: number
  }

  /**
   * Methodology.Standards
   */
  export type Methodology$StandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    cursor?: StandardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * Methodology.batches
   */
  export type Methodology$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Methodology.batchParameterValues
   */
  export type Methodology$batchParameterValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    where?: BatchParameterValueWhereInput
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    cursor?: BatchParameterValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * Methodology.standardDefinitions
   */
  export type Methodology$standardDefinitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    where?: StandardDefinitionWhereInput
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    cursor?: StandardDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * Methodology without action
   */
  export type MethodologyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    batchId: string | null
    message: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    batchId: string | null
    message: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    batchId: number
    message: number
    type: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    batchId?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    batchId?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    batchId?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    batchId: string | null
    message: string
    type: $Enums.NotificationType
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    batchId?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    Batch?: boolean | Notification$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    batchId?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    Batch?: boolean | Notification$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    batchId?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    Batch?: boolean | Notification$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    batchId?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "batchId" | "message" | "type" | "isRead" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | Notification$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | Notification$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | Notification$BatchArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      Batch: Prisma.$BatchPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      batchId: string | null
      message: string
      type: $Enums.NotificationType
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Batch<T extends Notification$BatchArgs<ExtArgs> = {}>(args?: Subset<T, Notification$BatchArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly batchId: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.Batch
   */
  export type Notification$BatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    action: string | null
    resource: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    action: string | null
    resource: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    action: number
    resource: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    action?: true
    resource?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    action?: true
    resource?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    action?: true
    resource?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    action: string
    resource: string
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    resource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Role?: boolean | Permission$RoleArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    resource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    resource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    action?: boolean
    resource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "resource" | "createdAt" | "updatedAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | Permission$RoleArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      Role: Prisma.$RolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      resource: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Role<T extends Permission$RoleArgs<ExtArgs> = {}>(args?: Subset<T, Permission$RoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly resource: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.Role
   */
  export type Permission$RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    code: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    code: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Batch?: boolean | Product$BatchArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | Product$BatchArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      Batch: Prisma.$BatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Batch<T extends Product$BatchArgs<ExtArgs> = {}>(args?: Subset<T, Product$BatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly code: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.Batch
   */
  export type Product$BatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | Role$UserArgs<ExtArgs>
    Permission?: boolean | Role$PermissionArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Role$UserArgs<ExtArgs>
    Permission?: boolean | Role$PermissionArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>[]
      Permission: Prisma.$PermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Role$UserArgs<ExtArgs> = {}>(args?: Subset<T, Role$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Permission<T extends Role$PermissionArgs<ExtArgs> = {}>(args?: Subset<T, Role$PermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.User
   */
  export type Role$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role.Permission
   */
  export type Role$PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UnitOfMeasurement
   */

  export type AggregateUnitOfMeasurement = {
    _count: UnitOfMeasurementCountAggregateOutputType | null
    _min: UnitOfMeasurementMinAggregateOutputType | null
    _max: UnitOfMeasurementMaxAggregateOutputType | null
  }

  export type UnitOfMeasurementMinAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitOfMeasurementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitOfMeasurementCountAggregateOutputType = {
    id: number
    name: number
    symbol: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitOfMeasurementMinAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitOfMeasurementMaxAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitOfMeasurementCountAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitOfMeasurementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitOfMeasurement to aggregate.
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasurements to fetch.
     */
    orderBy?: UnitOfMeasurementOrderByWithRelationInput | UnitOfMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitOfMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitOfMeasurements
    **/
    _count?: true | UnitOfMeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitOfMeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitOfMeasurementMaxAggregateInputType
  }

  export type GetUnitOfMeasurementAggregateType<T extends UnitOfMeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitOfMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitOfMeasurement[P]>
      : GetScalarType<T[P], AggregateUnitOfMeasurement[P]>
  }




  export type UnitOfMeasurementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitOfMeasurementWhereInput
    orderBy?: UnitOfMeasurementOrderByWithAggregationInput | UnitOfMeasurementOrderByWithAggregationInput[]
    by: UnitOfMeasurementScalarFieldEnum[] | UnitOfMeasurementScalarFieldEnum
    having?: UnitOfMeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitOfMeasurementCountAggregateInputType | true
    _min?: UnitOfMeasurementMinAggregateInputType
    _max?: UnitOfMeasurementMaxAggregateInputType
  }

  export type UnitOfMeasurementGroupByOutputType = {
    id: string
    name: string
    symbol: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: UnitOfMeasurementCountAggregateOutputType | null
    _min: UnitOfMeasurementMinAggregateOutputType | null
    _max: UnitOfMeasurementMaxAggregateOutputType | null
  }

  type GetUnitOfMeasurementGroupByPayload<T extends UnitOfMeasurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitOfMeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitOfMeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitOfMeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], UnitOfMeasurementGroupByOutputType[P]>
        }
      >
    >


  export type UnitOfMeasurementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Standards?: boolean | UnitOfMeasurement$StandardsArgs<ExtArgs>
    batchParameterValues?: boolean | UnitOfMeasurement$batchParameterValuesArgs<ExtArgs>
    standardDefinitions?: boolean | UnitOfMeasurement$standardDefinitionsArgs<ExtArgs>
    batches?: boolean | UnitOfMeasurement$batchesArgs<ExtArgs>
    _count?: boolean | UnitOfMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitOfMeasurement"]>

  export type UnitOfMeasurementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unitOfMeasurement"]>

  export type UnitOfMeasurementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unitOfMeasurement"]>

  export type UnitOfMeasurementSelectScalar = {
    id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitOfMeasurementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "symbol" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["unitOfMeasurement"]>
  export type UnitOfMeasurementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Standards?: boolean | UnitOfMeasurement$StandardsArgs<ExtArgs>
    batchParameterValues?: boolean | UnitOfMeasurement$batchParameterValuesArgs<ExtArgs>
    standardDefinitions?: boolean | UnitOfMeasurement$standardDefinitionsArgs<ExtArgs>
    batches?: boolean | UnitOfMeasurement$batchesArgs<ExtArgs>
    _count?: boolean | UnitOfMeasurementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitOfMeasurementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UnitOfMeasurementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnitOfMeasurementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitOfMeasurement"
    objects: {
      Standards: Prisma.$StandardPayload<ExtArgs>[]
      batchParameterValues: Prisma.$BatchParameterValuePayload<ExtArgs>[]
      standardDefinitions: Prisma.$StandardDefinitionPayload<ExtArgs>[]
      batches: Prisma.$BatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      symbol: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitOfMeasurement"]>
    composites: {}
  }

  type UnitOfMeasurementGetPayload<S extends boolean | null | undefined | UnitOfMeasurementDefaultArgs> = $Result.GetResult<Prisma.$UnitOfMeasurementPayload, S>

  type UnitOfMeasurementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitOfMeasurementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitOfMeasurementCountAggregateInputType | true
    }

  export interface UnitOfMeasurementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitOfMeasurement'], meta: { name: 'UnitOfMeasurement' } }
    /**
     * Find zero or one UnitOfMeasurement that matches the filter.
     * @param {UnitOfMeasurementFindUniqueArgs} args - Arguments to find a UnitOfMeasurement
     * @example
     * // Get one UnitOfMeasurement
     * const unitOfMeasurement = await prisma.unitOfMeasurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitOfMeasurementFindUniqueArgs>(args: SelectSubset<T, UnitOfMeasurementFindUniqueArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitOfMeasurement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitOfMeasurementFindUniqueOrThrowArgs} args - Arguments to find a UnitOfMeasurement
     * @example
     * // Get one UnitOfMeasurement
     * const unitOfMeasurement = await prisma.unitOfMeasurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitOfMeasurementFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitOfMeasurementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitOfMeasurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementFindFirstArgs} args - Arguments to find a UnitOfMeasurement
     * @example
     * // Get one UnitOfMeasurement
     * const unitOfMeasurement = await prisma.unitOfMeasurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitOfMeasurementFindFirstArgs>(args?: SelectSubset<T, UnitOfMeasurementFindFirstArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitOfMeasurement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementFindFirstOrThrowArgs} args - Arguments to find a UnitOfMeasurement
     * @example
     * // Get one UnitOfMeasurement
     * const unitOfMeasurement = await prisma.unitOfMeasurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitOfMeasurementFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitOfMeasurementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitOfMeasurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitOfMeasurements
     * const unitOfMeasurements = await prisma.unitOfMeasurement.findMany()
     * 
     * // Get first 10 UnitOfMeasurements
     * const unitOfMeasurements = await prisma.unitOfMeasurement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitOfMeasurementWithIdOnly = await prisma.unitOfMeasurement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitOfMeasurementFindManyArgs>(args?: SelectSubset<T, UnitOfMeasurementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitOfMeasurement.
     * @param {UnitOfMeasurementCreateArgs} args - Arguments to create a UnitOfMeasurement.
     * @example
     * // Create one UnitOfMeasurement
     * const UnitOfMeasurement = await prisma.unitOfMeasurement.create({
     *   data: {
     *     // ... data to create a UnitOfMeasurement
     *   }
     * })
     * 
     */
    create<T extends UnitOfMeasurementCreateArgs>(args: SelectSubset<T, UnitOfMeasurementCreateArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitOfMeasurements.
     * @param {UnitOfMeasurementCreateManyArgs} args - Arguments to create many UnitOfMeasurements.
     * @example
     * // Create many UnitOfMeasurements
     * const unitOfMeasurement = await prisma.unitOfMeasurement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitOfMeasurementCreateManyArgs>(args?: SelectSubset<T, UnitOfMeasurementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitOfMeasurements and returns the data saved in the database.
     * @param {UnitOfMeasurementCreateManyAndReturnArgs} args - Arguments to create many UnitOfMeasurements.
     * @example
     * // Create many UnitOfMeasurements
     * const unitOfMeasurement = await prisma.unitOfMeasurement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitOfMeasurements and only return the `id`
     * const unitOfMeasurementWithIdOnly = await prisma.unitOfMeasurement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitOfMeasurementCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitOfMeasurementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitOfMeasurement.
     * @param {UnitOfMeasurementDeleteArgs} args - Arguments to delete one UnitOfMeasurement.
     * @example
     * // Delete one UnitOfMeasurement
     * const UnitOfMeasurement = await prisma.unitOfMeasurement.delete({
     *   where: {
     *     // ... filter to delete one UnitOfMeasurement
     *   }
     * })
     * 
     */
    delete<T extends UnitOfMeasurementDeleteArgs>(args: SelectSubset<T, UnitOfMeasurementDeleteArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitOfMeasurement.
     * @param {UnitOfMeasurementUpdateArgs} args - Arguments to update one UnitOfMeasurement.
     * @example
     * // Update one UnitOfMeasurement
     * const unitOfMeasurement = await prisma.unitOfMeasurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitOfMeasurementUpdateArgs>(args: SelectSubset<T, UnitOfMeasurementUpdateArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitOfMeasurements.
     * @param {UnitOfMeasurementDeleteManyArgs} args - Arguments to filter UnitOfMeasurements to delete.
     * @example
     * // Delete a few UnitOfMeasurements
     * const { count } = await prisma.unitOfMeasurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitOfMeasurementDeleteManyArgs>(args?: SelectSubset<T, UnitOfMeasurementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitOfMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitOfMeasurements
     * const unitOfMeasurement = await prisma.unitOfMeasurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitOfMeasurementUpdateManyArgs>(args: SelectSubset<T, UnitOfMeasurementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitOfMeasurements and returns the data updated in the database.
     * @param {UnitOfMeasurementUpdateManyAndReturnArgs} args - Arguments to update many UnitOfMeasurements.
     * @example
     * // Update many UnitOfMeasurements
     * const unitOfMeasurement = await prisma.unitOfMeasurement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitOfMeasurements and only return the `id`
     * const unitOfMeasurementWithIdOnly = await prisma.unitOfMeasurement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitOfMeasurementUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitOfMeasurementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitOfMeasurement.
     * @param {UnitOfMeasurementUpsertArgs} args - Arguments to update or create a UnitOfMeasurement.
     * @example
     * // Update or create a UnitOfMeasurement
     * const unitOfMeasurement = await prisma.unitOfMeasurement.upsert({
     *   create: {
     *     // ... data to create a UnitOfMeasurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitOfMeasurement we want to update
     *   }
     * })
     */
    upsert<T extends UnitOfMeasurementUpsertArgs>(args: SelectSubset<T, UnitOfMeasurementUpsertArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitOfMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementCountArgs} args - Arguments to filter UnitOfMeasurements to count.
     * @example
     * // Count the number of UnitOfMeasurements
     * const count = await prisma.unitOfMeasurement.count({
     *   where: {
     *     // ... the filter for the UnitOfMeasurements we want to count
     *   }
     * })
    **/
    count<T extends UnitOfMeasurementCountArgs>(
      args?: Subset<T, UnitOfMeasurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitOfMeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitOfMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitOfMeasurementAggregateArgs>(args: Subset<T, UnitOfMeasurementAggregateArgs>): Prisma.PrismaPromise<GetUnitOfMeasurementAggregateType<T>>

    /**
     * Group by UnitOfMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitOfMeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitOfMeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitOfMeasurementGroupByArgs['orderBy'] }
        : { orderBy?: UnitOfMeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitOfMeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitOfMeasurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitOfMeasurement model
   */
  readonly fields: UnitOfMeasurementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitOfMeasurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitOfMeasurementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Standards<T extends UnitOfMeasurement$StandardsArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasurement$StandardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    batchParameterValues<T extends UnitOfMeasurement$batchParameterValuesArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasurement$batchParameterValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standardDefinitions<T extends UnitOfMeasurement$standardDefinitionsArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasurement$standardDefinitionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    batches<T extends UnitOfMeasurement$batchesArgs<ExtArgs> = {}>(args?: Subset<T, UnitOfMeasurement$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitOfMeasurement model
   */
  interface UnitOfMeasurementFieldRefs {
    readonly id: FieldRef<"UnitOfMeasurement", 'String'>
    readonly name: FieldRef<"UnitOfMeasurement", 'String'>
    readonly symbol: FieldRef<"UnitOfMeasurement", 'String'>
    readonly description: FieldRef<"UnitOfMeasurement", 'String'>
    readonly createdAt: FieldRef<"UnitOfMeasurement", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitOfMeasurement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitOfMeasurement findUnique
   */
  export type UnitOfMeasurementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasurement to fetch.
     */
    where: UnitOfMeasurementWhereUniqueInput
  }

  /**
   * UnitOfMeasurement findUniqueOrThrow
   */
  export type UnitOfMeasurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasurement to fetch.
     */
    where: UnitOfMeasurementWhereUniqueInput
  }

  /**
   * UnitOfMeasurement findFirst
   */
  export type UnitOfMeasurementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasurement to fetch.
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasurements to fetch.
     */
    orderBy?: UnitOfMeasurementOrderByWithRelationInput | UnitOfMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitOfMeasurements.
     */
    cursor?: UnitOfMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitOfMeasurements.
     */
    distinct?: UnitOfMeasurementScalarFieldEnum | UnitOfMeasurementScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement findFirstOrThrow
   */
  export type UnitOfMeasurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasurement to fetch.
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasurements to fetch.
     */
    orderBy?: UnitOfMeasurementOrderByWithRelationInput | UnitOfMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitOfMeasurements.
     */
    cursor?: UnitOfMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitOfMeasurements.
     */
    distinct?: UnitOfMeasurementScalarFieldEnum | UnitOfMeasurementScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement findMany
   */
  export type UnitOfMeasurementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which UnitOfMeasurements to fetch.
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitOfMeasurements to fetch.
     */
    orderBy?: UnitOfMeasurementOrderByWithRelationInput | UnitOfMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitOfMeasurements.
     */
    cursor?: UnitOfMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitOfMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitOfMeasurements.
     */
    skip?: number
    distinct?: UnitOfMeasurementScalarFieldEnum | UnitOfMeasurementScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement create
   */
  export type UnitOfMeasurementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitOfMeasurement.
     */
    data: XOR<UnitOfMeasurementCreateInput, UnitOfMeasurementUncheckedCreateInput>
  }

  /**
   * UnitOfMeasurement createMany
   */
  export type UnitOfMeasurementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitOfMeasurements.
     */
    data: UnitOfMeasurementCreateManyInput | UnitOfMeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitOfMeasurement createManyAndReturn
   */
  export type UnitOfMeasurementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * The data used to create many UnitOfMeasurements.
     */
    data: UnitOfMeasurementCreateManyInput | UnitOfMeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitOfMeasurement update
   */
  export type UnitOfMeasurementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitOfMeasurement.
     */
    data: XOR<UnitOfMeasurementUpdateInput, UnitOfMeasurementUncheckedUpdateInput>
    /**
     * Choose, which UnitOfMeasurement to update.
     */
    where: UnitOfMeasurementWhereUniqueInput
  }

  /**
   * UnitOfMeasurement updateMany
   */
  export type UnitOfMeasurementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitOfMeasurements.
     */
    data: XOR<UnitOfMeasurementUpdateManyMutationInput, UnitOfMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which UnitOfMeasurements to update
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * Limit how many UnitOfMeasurements to update.
     */
    limit?: number
  }

  /**
   * UnitOfMeasurement updateManyAndReturn
   */
  export type UnitOfMeasurementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * The data used to update UnitOfMeasurements.
     */
    data: XOR<UnitOfMeasurementUpdateManyMutationInput, UnitOfMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which UnitOfMeasurements to update
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * Limit how many UnitOfMeasurements to update.
     */
    limit?: number
  }

  /**
   * UnitOfMeasurement upsert
   */
  export type UnitOfMeasurementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitOfMeasurement to update in case it exists.
     */
    where: UnitOfMeasurementWhereUniqueInput
    /**
     * In case the UnitOfMeasurement found by the `where` argument doesn't exist, create a new UnitOfMeasurement with this data.
     */
    create: XOR<UnitOfMeasurementCreateInput, UnitOfMeasurementUncheckedCreateInput>
    /**
     * In case the UnitOfMeasurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitOfMeasurementUpdateInput, UnitOfMeasurementUncheckedUpdateInput>
  }

  /**
   * UnitOfMeasurement delete
   */
  export type UnitOfMeasurementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    /**
     * Filter which UnitOfMeasurement to delete.
     */
    where: UnitOfMeasurementWhereUniqueInput
  }

  /**
   * UnitOfMeasurement deleteMany
   */
  export type UnitOfMeasurementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitOfMeasurements to delete
     */
    where?: UnitOfMeasurementWhereInput
    /**
     * Limit how many UnitOfMeasurements to delete.
     */
    limit?: number
  }

  /**
   * UnitOfMeasurement.Standards
   */
  export type UnitOfMeasurement$StandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    cursor?: StandardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement.batchParameterValues
   */
  export type UnitOfMeasurement$batchParameterValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    where?: BatchParameterValueWhereInput
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    cursor?: BatchParameterValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement.standardDefinitions
   */
  export type UnitOfMeasurement$standardDefinitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    where?: StandardDefinitionWhereInput
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    cursor?: StandardDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement.batches
   */
  export type UnitOfMeasurement$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * UnitOfMeasurement without action
   */
  export type UnitOfMeasurementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    roleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    roleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    roleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ActivityLog?: boolean | User$ActivityLogArgs<ExtArgs>
    Batch_Batch_checkerIdToUser?: boolean | User$Batch_Batch_checkerIdToUserArgs<ExtArgs>
    Batch_Batch_makerIdToUser?: boolean | User$Batch_Batch_makerIdToUserArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    StandardsCreated?: boolean | User$StandardsCreatedArgs<ExtArgs>
    StandardsModified?: boolean | User$StandardsModifiedArgs<ExtArgs>
    standardDefinitionsCreated?: boolean | User$standardDefinitionsCreatedArgs<ExtArgs>
    standardDefinitionsModified?: boolean | User$standardDefinitionsModifiedArgs<ExtArgs>
    trainerTrainings?: boolean | User$trainerTrainingsArgs<ExtArgs>
    createdTrainings?: boolean | User$createdTrainingsArgs<ExtArgs>
    trainingParticipations?: boolean | User$trainingParticipationsArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    uploadedPhotos?: boolean | User$uploadedPhotosArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    assignedFollowups?: boolean | User$assignedFollowupsArgs<ExtArgs>
    createdFollowups?: boolean | User$createdFollowupsArgs<ExtArgs>
    trainingNotifications?: boolean | User$trainingNotificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "roleId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ActivityLog?: boolean | User$ActivityLogArgs<ExtArgs>
    Batch_Batch_checkerIdToUser?: boolean | User$Batch_Batch_checkerIdToUserArgs<ExtArgs>
    Batch_Batch_makerIdToUser?: boolean | User$Batch_Batch_makerIdToUserArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    StandardsCreated?: boolean | User$StandardsCreatedArgs<ExtArgs>
    StandardsModified?: boolean | User$StandardsModifiedArgs<ExtArgs>
    standardDefinitionsCreated?: boolean | User$standardDefinitionsCreatedArgs<ExtArgs>
    standardDefinitionsModified?: boolean | User$standardDefinitionsModifiedArgs<ExtArgs>
    trainerTrainings?: boolean | User$trainerTrainingsArgs<ExtArgs>
    createdTrainings?: boolean | User$createdTrainingsArgs<ExtArgs>
    trainingParticipations?: boolean | User$trainingParticipationsArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    uploadedPhotos?: boolean | User$uploadedPhotosArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    assignedFollowups?: boolean | User$assignedFollowupsArgs<ExtArgs>
    createdFollowups?: boolean | User$createdFollowupsArgs<ExtArgs>
    trainingNotifications?: boolean | User$trainingNotificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      ActivityLog: Prisma.$ActivityLogPayload<ExtArgs>[]
      Batch_Batch_checkerIdToUser: Prisma.$BatchPayload<ExtArgs>[]
      Batch_Batch_makerIdToUser: Prisma.$BatchPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
      Role: Prisma.$RolePayload<ExtArgs>
      StandardsCreated: Prisma.$StandardPayload<ExtArgs>[]
      StandardsModified: Prisma.$StandardPayload<ExtArgs>[]
      standardDefinitionsCreated: Prisma.$StandardDefinitionPayload<ExtArgs>[]
      standardDefinitionsModified: Prisma.$StandardDefinitionPayload<ExtArgs>[]
      trainerTrainings: Prisma.$TrainingPayload<ExtArgs>[]
      createdTrainings: Prisma.$TrainingPayload<ExtArgs>[]
      trainingParticipations: Prisma.$TrainingParticipantPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      uploadedDocuments: Prisma.$TrainingDocumentPayload<ExtArgs>[]
      uploadedPhotos: Prisma.$TrainingPhotoPayload<ExtArgs>[]
      feedbacks: Prisma.$TrainingFeedbackPayload<ExtArgs>[]
      assignedFollowups: Prisma.$TrainingFollowupPayload<ExtArgs>[]
      createdFollowups: Prisma.$TrainingFollowupPayload<ExtArgs>[]
      trainingNotifications: Prisma.$TrainingNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      roleId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ActivityLog<T extends User$ActivityLogArgs<ExtArgs> = {}>(args?: Subset<T, User$ActivityLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Batch_Batch_checkerIdToUser<T extends User$Batch_Batch_checkerIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Batch_Batch_checkerIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Batch_Batch_makerIdToUser<T extends User$Batch_Batch_makerIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Batch_Batch_makerIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    StandardsCreated<T extends User$StandardsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$StandardsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StandardsModified<T extends User$StandardsModifiedArgs<ExtArgs> = {}>(args?: Subset<T, User$StandardsModifiedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standardDefinitionsCreated<T extends User$standardDefinitionsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$standardDefinitionsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standardDefinitionsModified<T extends User$standardDefinitionsModifiedArgs<ExtArgs> = {}>(args?: Subset<T, User$standardDefinitionsModifiedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainerTrainings<T extends User$trainerTrainingsArgs<ExtArgs> = {}>(args?: Subset<T, User$trainerTrainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdTrainings<T extends User$createdTrainingsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTrainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainingParticipations<T extends User$trainingParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, User$trainingParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends User$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, User$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedDocuments<T extends User$uploadedDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedPhotos<T extends User$uploadedPhotosArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends User$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedFollowups<T extends User$assignedFollowupsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedFollowupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdFollowups<T extends User$createdFollowupsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdFollowupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainingNotifications<T extends User$trainingNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$trainingNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.ActivityLog
   */
  export type User$ActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.Batch_Batch_checkerIdToUser
   */
  export type User$Batch_Batch_checkerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * User.Batch_Batch_makerIdToUser
   */
  export type User$Batch_Batch_makerIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * User.Notification
   */
  export type User$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.StandardsCreated
   */
  export type User$StandardsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    cursor?: StandardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * User.StandardsModified
   */
  export type User$StandardsModifiedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    cursor?: StandardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * User.standardDefinitionsCreated
   */
  export type User$standardDefinitionsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    where?: StandardDefinitionWhereInput
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    cursor?: StandardDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * User.standardDefinitionsModified
   */
  export type User$standardDefinitionsModifiedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    where?: StandardDefinitionWhereInput
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    cursor?: StandardDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * User.trainerTrainings
   */
  export type User$trainerTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    where?: TrainingWhereInput
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    cursor?: TrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * User.createdTrainings
   */
  export type User$createdTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    where?: TrainingWhereInput
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    cursor?: TrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * User.trainingParticipations
   */
  export type User$trainingParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    where?: TrainingParticipantWhereInput
    orderBy?: TrainingParticipantOrderByWithRelationInput | TrainingParticipantOrderByWithRelationInput[]
    cursor?: TrainingParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingParticipantScalarFieldEnum | TrainingParticipantScalarFieldEnum[]
  }

  /**
   * User.attendances
   */
  export type User$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * User.uploadedDocuments
   */
  export type User$uploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    where?: TrainingDocumentWhereInput
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    cursor?: TrainingDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * User.uploadedPhotos
   */
  export type User$uploadedPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    where?: TrainingPhotoWhereInput
    orderBy?: TrainingPhotoOrderByWithRelationInput | TrainingPhotoOrderByWithRelationInput[]
    cursor?: TrainingPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingPhotoScalarFieldEnum | TrainingPhotoScalarFieldEnum[]
  }

  /**
   * User.feedbacks
   */
  export type User$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    where?: TrainingFeedbackWhereInput
    orderBy?: TrainingFeedbackOrderByWithRelationInput | TrainingFeedbackOrderByWithRelationInput[]
    cursor?: TrainingFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingFeedbackScalarFieldEnum | TrainingFeedbackScalarFieldEnum[]
  }

  /**
   * User.assignedFollowups
   */
  export type User$assignedFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    where?: TrainingFollowupWhereInput
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    cursor?: TrainingFollowupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingFollowupScalarFieldEnum | TrainingFollowupScalarFieldEnum[]
  }

  /**
   * User.createdFollowups
   */
  export type User$createdFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    where?: TrainingFollowupWhereInput
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    cursor?: TrainingFollowupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingFollowupScalarFieldEnum | TrainingFollowupScalarFieldEnum[]
  }

  /**
   * User.trainingNotifications
   */
  export type User$trainingNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    where?: TrainingNotificationWhereInput
    orderBy?: TrainingNotificationOrderByWithRelationInput | TrainingNotificationOrderByWithRelationInput[]
    cursor?: TrainingNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingNotificationScalarFieldEnum | TrainingNotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Standard
   */

  export type AggregateStandard = {
    _count: StandardCountAggregateOutputType | null
    _min: StandardMinAggregateOutputType | null
    _max: StandardMaxAggregateOutputType | null
  }

  export type StandardMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    categoryId: string | null
    createdById: string | null
    modifiedById: string | null
    status: $Enums.StandardStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    categoryId: string | null
    createdById: string | null
    modifiedById: string | null
    status: $Enums.StandardStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    categoryId: number
    createdById: number
    modifiedById: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StandardMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    categoryId?: true
    createdById?: true
    modifiedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    categoryId?: true
    createdById?: true
    modifiedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    categoryId?: true
    createdById?: true
    modifiedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StandardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Standard to aggregate.
     */
    where?: StandardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standards to fetch.
     */
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StandardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Standards
    **/
    _count?: true | StandardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StandardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StandardMaxAggregateInputType
  }

  export type GetStandardAggregateType<T extends StandardAggregateArgs> = {
        [P in keyof T & keyof AggregateStandard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStandard[P]>
      : GetScalarType<T[P], AggregateStandard[P]>
  }




  export type StandardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithAggregationInput | StandardOrderByWithAggregationInput[]
    by: StandardScalarFieldEnum[] | StandardScalarFieldEnum
    having?: StandardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StandardCountAggregateInputType | true
    _min?: StandardMinAggregateInputType
    _max?: StandardMaxAggregateInputType
  }

  export type StandardGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    modifiedById: string | null
    status: $Enums.StandardStatus
    createdAt: Date
    updatedAt: Date
    _count: StandardCountAggregateOutputType | null
    _min: StandardMinAggregateOutputType | null
    _max: StandardMaxAggregateOutputType | null
  }

  type GetStandardGroupByPayload<T extends StandardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StandardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StandardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StandardGroupByOutputType[P]>
            : GetScalarType<T[P], StandardGroupByOutputType[P]>
        }
      >
    >


  export type StandardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | Standard$ModifiedByArgs<ExtArgs>
    batches?: boolean | Standard$batchesArgs<ExtArgs>
    methodologies?: boolean | Standard$methodologiesArgs<ExtArgs>
    units?: boolean | Standard$unitsArgs<ExtArgs>
    _count?: boolean | StandardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["standard"]>

  export type StandardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | Standard$ModifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["standard"]>

  export type StandardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | Standard$ModifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["standard"]>

  export type StandardSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    categoryId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StandardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "categoryId" | "createdById" | "modifiedById" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["standard"]>
  export type StandardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | Standard$ModifiedByArgs<ExtArgs>
    batches?: boolean | Standard$batchesArgs<ExtArgs>
    methodologies?: boolean | Standard$methodologiesArgs<ExtArgs>
    units?: boolean | Standard$unitsArgs<ExtArgs>
    _count?: boolean | StandardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StandardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | Standard$ModifiedByArgs<ExtArgs>
  }
  export type StandardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | Standard$ModifiedByArgs<ExtArgs>
  }

  export type $StandardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Standard"
    objects: {
      Category: Prisma.$StandardCategoryPayload<ExtArgs>
      CreatedBy: Prisma.$UserPayload<ExtArgs>
      ModifiedBy: Prisma.$UserPayload<ExtArgs> | null
      batches: Prisma.$BatchPayload<ExtArgs>[]
      methodologies: Prisma.$MethodologyPayload<ExtArgs>[]
      units: Prisma.$UnitOfMeasurementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string
      categoryId: string
      createdById: string
      modifiedById: string | null
      status: $Enums.StandardStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["standard"]>
    composites: {}
  }

  type StandardGetPayload<S extends boolean | null | undefined | StandardDefaultArgs> = $Result.GetResult<Prisma.$StandardPayload, S>

  type StandardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StandardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StandardCountAggregateInputType | true
    }

  export interface StandardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Standard'], meta: { name: 'Standard' } }
    /**
     * Find zero or one Standard that matches the filter.
     * @param {StandardFindUniqueArgs} args - Arguments to find a Standard
     * @example
     * // Get one Standard
     * const standard = await prisma.standard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StandardFindUniqueArgs>(args: SelectSubset<T, StandardFindUniqueArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Standard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StandardFindUniqueOrThrowArgs} args - Arguments to find a Standard
     * @example
     * // Get one Standard
     * const standard = await prisma.standard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StandardFindUniqueOrThrowArgs>(args: SelectSubset<T, StandardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Standard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardFindFirstArgs} args - Arguments to find a Standard
     * @example
     * // Get one Standard
     * const standard = await prisma.standard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StandardFindFirstArgs>(args?: SelectSubset<T, StandardFindFirstArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Standard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardFindFirstOrThrowArgs} args - Arguments to find a Standard
     * @example
     * // Get one Standard
     * const standard = await prisma.standard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StandardFindFirstOrThrowArgs>(args?: SelectSubset<T, StandardFindFirstOrThrowArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Standards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Standards
     * const standards = await prisma.standard.findMany()
     * 
     * // Get first 10 Standards
     * const standards = await prisma.standard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const standardWithIdOnly = await prisma.standard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StandardFindManyArgs>(args?: SelectSubset<T, StandardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Standard.
     * @param {StandardCreateArgs} args - Arguments to create a Standard.
     * @example
     * // Create one Standard
     * const Standard = await prisma.standard.create({
     *   data: {
     *     // ... data to create a Standard
     *   }
     * })
     * 
     */
    create<T extends StandardCreateArgs>(args: SelectSubset<T, StandardCreateArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Standards.
     * @param {StandardCreateManyArgs} args - Arguments to create many Standards.
     * @example
     * // Create many Standards
     * const standard = await prisma.standard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StandardCreateManyArgs>(args?: SelectSubset<T, StandardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Standards and returns the data saved in the database.
     * @param {StandardCreateManyAndReturnArgs} args - Arguments to create many Standards.
     * @example
     * // Create many Standards
     * const standard = await prisma.standard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Standards and only return the `id`
     * const standardWithIdOnly = await prisma.standard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StandardCreateManyAndReturnArgs>(args?: SelectSubset<T, StandardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Standard.
     * @param {StandardDeleteArgs} args - Arguments to delete one Standard.
     * @example
     * // Delete one Standard
     * const Standard = await prisma.standard.delete({
     *   where: {
     *     // ... filter to delete one Standard
     *   }
     * })
     * 
     */
    delete<T extends StandardDeleteArgs>(args: SelectSubset<T, StandardDeleteArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Standard.
     * @param {StandardUpdateArgs} args - Arguments to update one Standard.
     * @example
     * // Update one Standard
     * const standard = await prisma.standard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StandardUpdateArgs>(args: SelectSubset<T, StandardUpdateArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Standards.
     * @param {StandardDeleteManyArgs} args - Arguments to filter Standards to delete.
     * @example
     * // Delete a few Standards
     * const { count } = await prisma.standard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StandardDeleteManyArgs>(args?: SelectSubset<T, StandardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Standards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Standards
     * const standard = await prisma.standard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StandardUpdateManyArgs>(args: SelectSubset<T, StandardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Standards and returns the data updated in the database.
     * @param {StandardUpdateManyAndReturnArgs} args - Arguments to update many Standards.
     * @example
     * // Update many Standards
     * const standard = await prisma.standard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Standards and only return the `id`
     * const standardWithIdOnly = await prisma.standard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StandardUpdateManyAndReturnArgs>(args: SelectSubset<T, StandardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Standard.
     * @param {StandardUpsertArgs} args - Arguments to update or create a Standard.
     * @example
     * // Update or create a Standard
     * const standard = await prisma.standard.upsert({
     *   create: {
     *     // ... data to create a Standard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Standard we want to update
     *   }
     * })
     */
    upsert<T extends StandardUpsertArgs>(args: SelectSubset<T, StandardUpsertArgs<ExtArgs>>): Prisma__StandardClient<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Standards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCountArgs} args - Arguments to filter Standards to count.
     * @example
     * // Count the number of Standards
     * const count = await prisma.standard.count({
     *   where: {
     *     // ... the filter for the Standards we want to count
     *   }
     * })
    **/
    count<T extends StandardCountArgs>(
      args?: Subset<T, StandardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StandardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Standard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StandardAggregateArgs>(args: Subset<T, StandardAggregateArgs>): Prisma.PrismaPromise<GetStandardAggregateType<T>>

    /**
     * Group by Standard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StandardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StandardGroupByArgs['orderBy'] }
        : { orderBy?: StandardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StandardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStandardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Standard model
   */
  readonly fields: StandardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Standard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StandardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Category<T extends StandardCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StandardCategoryDefaultArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CreatedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ModifiedBy<T extends Standard$ModifiedByArgs<ExtArgs> = {}>(args?: Subset<T, Standard$ModifiedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    batches<T extends Standard$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Standard$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    methodologies<T extends Standard$methodologiesArgs<ExtArgs> = {}>(args?: Subset<T, Standard$methodologiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    units<T extends Standard$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Standard$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Standard model
   */
  interface StandardFieldRefs {
    readonly id: FieldRef<"Standard", 'String'>
    readonly name: FieldRef<"Standard", 'String'>
    readonly code: FieldRef<"Standard", 'String'>
    readonly description: FieldRef<"Standard", 'String'>
    readonly categoryId: FieldRef<"Standard", 'String'>
    readonly createdById: FieldRef<"Standard", 'String'>
    readonly modifiedById: FieldRef<"Standard", 'String'>
    readonly status: FieldRef<"Standard", 'StandardStatus'>
    readonly createdAt: FieldRef<"Standard", 'DateTime'>
    readonly updatedAt: FieldRef<"Standard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Standard findUnique
   */
  export type StandardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * Filter, which Standard to fetch.
     */
    where: StandardWhereUniqueInput
  }

  /**
   * Standard findUniqueOrThrow
   */
  export type StandardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * Filter, which Standard to fetch.
     */
    where: StandardWhereUniqueInput
  }

  /**
   * Standard findFirst
   */
  export type StandardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * Filter, which Standard to fetch.
     */
    where?: StandardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standards to fetch.
     */
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Standards.
     */
    cursor?: StandardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Standards.
     */
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * Standard findFirstOrThrow
   */
  export type StandardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * Filter, which Standard to fetch.
     */
    where?: StandardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standards to fetch.
     */
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Standards.
     */
    cursor?: StandardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Standards.
     */
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * Standard findMany
   */
  export type StandardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * Filter, which Standards to fetch.
     */
    where?: StandardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standards to fetch.
     */
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Standards.
     */
    cursor?: StandardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standards.
     */
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * Standard create
   */
  export type StandardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * The data needed to create a Standard.
     */
    data: XOR<StandardCreateInput, StandardUncheckedCreateInput>
  }

  /**
   * Standard createMany
   */
  export type StandardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Standards.
     */
    data: StandardCreateManyInput | StandardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Standard createManyAndReturn
   */
  export type StandardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * The data used to create many Standards.
     */
    data: StandardCreateManyInput | StandardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Standard update
   */
  export type StandardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * The data needed to update a Standard.
     */
    data: XOR<StandardUpdateInput, StandardUncheckedUpdateInput>
    /**
     * Choose, which Standard to update.
     */
    where: StandardWhereUniqueInput
  }

  /**
   * Standard updateMany
   */
  export type StandardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Standards.
     */
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyInput>
    /**
     * Filter which Standards to update
     */
    where?: StandardWhereInput
    /**
     * Limit how many Standards to update.
     */
    limit?: number
  }

  /**
   * Standard updateManyAndReturn
   */
  export type StandardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * The data used to update Standards.
     */
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyInput>
    /**
     * Filter which Standards to update
     */
    where?: StandardWhereInput
    /**
     * Limit how many Standards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Standard upsert
   */
  export type StandardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * The filter to search for the Standard to update in case it exists.
     */
    where: StandardWhereUniqueInput
    /**
     * In case the Standard found by the `where` argument doesn't exist, create a new Standard with this data.
     */
    create: XOR<StandardCreateInput, StandardUncheckedCreateInput>
    /**
     * In case the Standard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StandardUpdateInput, StandardUncheckedUpdateInput>
  }

  /**
   * Standard delete
   */
  export type StandardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    /**
     * Filter which Standard to delete.
     */
    where: StandardWhereUniqueInput
  }

  /**
   * Standard deleteMany
   */
  export type StandardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Standards to delete
     */
    where?: StandardWhereInput
    /**
     * Limit how many Standards to delete.
     */
    limit?: number
  }

  /**
   * Standard.ModifiedBy
   */
  export type Standard$ModifiedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Standard.batches
   */
  export type Standard$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Standard.methodologies
   */
  export type Standard$methodologiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    where?: MethodologyWhereInput
    orderBy?: MethodologyOrderByWithRelationInput | MethodologyOrderByWithRelationInput[]
    cursor?: MethodologyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MethodologyScalarFieldEnum | MethodologyScalarFieldEnum[]
  }

  /**
   * Standard.units
   */
  export type Standard$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    where?: UnitOfMeasurementWhereInput
    orderBy?: UnitOfMeasurementOrderByWithRelationInput | UnitOfMeasurementOrderByWithRelationInput[]
    cursor?: UnitOfMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitOfMeasurementScalarFieldEnum | UnitOfMeasurementScalarFieldEnum[]
  }

  /**
   * Standard without action
   */
  export type StandardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
  }


  /**
   * Model StandardCategory
   */

  export type AggregateStandardCategory = {
    _count: StandardCategoryCountAggregateOutputType | null
    _min: StandardCategoryMinAggregateOutputType | null
    _max: StandardCategoryMaxAggregateOutputType | null
  }

  export type StandardCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StandardCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StandardCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardCategory to aggregate.
     */
    where?: StandardCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardCategories to fetch.
     */
    orderBy?: StandardCategoryOrderByWithRelationInput | StandardCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StandardCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StandardCategories
    **/
    _count?: true | StandardCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StandardCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StandardCategoryMaxAggregateInputType
  }

  export type GetStandardCategoryAggregateType<T extends StandardCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStandardCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStandardCategory[P]>
      : GetScalarType<T[P], AggregateStandardCategory[P]>
  }




  export type StandardCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardCategoryWhereInput
    orderBy?: StandardCategoryOrderByWithAggregationInput | StandardCategoryOrderByWithAggregationInput[]
    by: StandardCategoryScalarFieldEnum[] | StandardCategoryScalarFieldEnum
    having?: StandardCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StandardCategoryCountAggregateInputType | true
    _min?: StandardCategoryMinAggregateInputType
    _max?: StandardCategoryMaxAggregateInputType
  }

  export type StandardCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: StandardCategoryCountAggregateOutputType | null
    _min: StandardCategoryMinAggregateOutputType | null
    _max: StandardCategoryMaxAggregateOutputType | null
  }

  type GetStandardCategoryGroupByPayload<T extends StandardCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StandardCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StandardCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StandardCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], StandardCategoryGroupByOutputType[P]>
        }
      >
    >


  export type StandardCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parameters?: boolean | StandardCategory$parametersArgs<ExtArgs>
    Standards?: boolean | StandardCategory$StandardsArgs<ExtArgs>
    _count?: boolean | StandardCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["standardCategory"]>

  export type StandardCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["standardCategory"]>

  export type StandardCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["standardCategory"]>

  export type StandardCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StandardCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["standardCategory"]>
  export type StandardCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameters?: boolean | StandardCategory$parametersArgs<ExtArgs>
    Standards?: boolean | StandardCategory$StandardsArgs<ExtArgs>
    _count?: boolean | StandardCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StandardCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StandardCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StandardCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StandardCategory"
    objects: {
      parameters: Prisma.$StandardParameterPayload<ExtArgs>[]
      Standards: Prisma.$StandardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["standardCategory"]>
    composites: {}
  }

  type StandardCategoryGetPayload<S extends boolean | null | undefined | StandardCategoryDefaultArgs> = $Result.GetResult<Prisma.$StandardCategoryPayload, S>

  type StandardCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StandardCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StandardCategoryCountAggregateInputType | true
    }

  export interface StandardCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StandardCategory'], meta: { name: 'StandardCategory' } }
    /**
     * Find zero or one StandardCategory that matches the filter.
     * @param {StandardCategoryFindUniqueArgs} args - Arguments to find a StandardCategory
     * @example
     * // Get one StandardCategory
     * const standardCategory = await prisma.standardCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StandardCategoryFindUniqueArgs>(args: SelectSubset<T, StandardCategoryFindUniqueArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StandardCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StandardCategoryFindUniqueOrThrowArgs} args - Arguments to find a StandardCategory
     * @example
     * // Get one StandardCategory
     * const standardCategory = await prisma.standardCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StandardCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, StandardCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StandardCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryFindFirstArgs} args - Arguments to find a StandardCategory
     * @example
     * // Get one StandardCategory
     * const standardCategory = await prisma.standardCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StandardCategoryFindFirstArgs>(args?: SelectSubset<T, StandardCategoryFindFirstArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StandardCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryFindFirstOrThrowArgs} args - Arguments to find a StandardCategory
     * @example
     * // Get one StandardCategory
     * const standardCategory = await prisma.standardCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StandardCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, StandardCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StandardCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StandardCategories
     * const standardCategories = await prisma.standardCategory.findMany()
     * 
     * // Get first 10 StandardCategories
     * const standardCategories = await prisma.standardCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const standardCategoryWithIdOnly = await prisma.standardCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StandardCategoryFindManyArgs>(args?: SelectSubset<T, StandardCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StandardCategory.
     * @param {StandardCategoryCreateArgs} args - Arguments to create a StandardCategory.
     * @example
     * // Create one StandardCategory
     * const StandardCategory = await prisma.standardCategory.create({
     *   data: {
     *     // ... data to create a StandardCategory
     *   }
     * })
     * 
     */
    create<T extends StandardCategoryCreateArgs>(args: SelectSubset<T, StandardCategoryCreateArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StandardCategories.
     * @param {StandardCategoryCreateManyArgs} args - Arguments to create many StandardCategories.
     * @example
     * // Create many StandardCategories
     * const standardCategory = await prisma.standardCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StandardCategoryCreateManyArgs>(args?: SelectSubset<T, StandardCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StandardCategories and returns the data saved in the database.
     * @param {StandardCategoryCreateManyAndReturnArgs} args - Arguments to create many StandardCategories.
     * @example
     * // Create many StandardCategories
     * const standardCategory = await prisma.standardCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StandardCategories and only return the `id`
     * const standardCategoryWithIdOnly = await prisma.standardCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StandardCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, StandardCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StandardCategory.
     * @param {StandardCategoryDeleteArgs} args - Arguments to delete one StandardCategory.
     * @example
     * // Delete one StandardCategory
     * const StandardCategory = await prisma.standardCategory.delete({
     *   where: {
     *     // ... filter to delete one StandardCategory
     *   }
     * })
     * 
     */
    delete<T extends StandardCategoryDeleteArgs>(args: SelectSubset<T, StandardCategoryDeleteArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StandardCategory.
     * @param {StandardCategoryUpdateArgs} args - Arguments to update one StandardCategory.
     * @example
     * // Update one StandardCategory
     * const standardCategory = await prisma.standardCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StandardCategoryUpdateArgs>(args: SelectSubset<T, StandardCategoryUpdateArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StandardCategories.
     * @param {StandardCategoryDeleteManyArgs} args - Arguments to filter StandardCategories to delete.
     * @example
     * // Delete a few StandardCategories
     * const { count } = await prisma.standardCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StandardCategoryDeleteManyArgs>(args?: SelectSubset<T, StandardCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StandardCategories
     * const standardCategory = await prisma.standardCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StandardCategoryUpdateManyArgs>(args: SelectSubset<T, StandardCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardCategories and returns the data updated in the database.
     * @param {StandardCategoryUpdateManyAndReturnArgs} args - Arguments to update many StandardCategories.
     * @example
     * // Update many StandardCategories
     * const standardCategory = await prisma.standardCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StandardCategories and only return the `id`
     * const standardCategoryWithIdOnly = await prisma.standardCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StandardCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, StandardCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StandardCategory.
     * @param {StandardCategoryUpsertArgs} args - Arguments to update or create a StandardCategory.
     * @example
     * // Update or create a StandardCategory
     * const standardCategory = await prisma.standardCategory.upsert({
     *   create: {
     *     // ... data to create a StandardCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StandardCategory we want to update
     *   }
     * })
     */
    upsert<T extends StandardCategoryUpsertArgs>(args: SelectSubset<T, StandardCategoryUpsertArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StandardCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryCountArgs} args - Arguments to filter StandardCategories to count.
     * @example
     * // Count the number of StandardCategories
     * const count = await prisma.standardCategory.count({
     *   where: {
     *     // ... the filter for the StandardCategories we want to count
     *   }
     * })
    **/
    count<T extends StandardCategoryCountArgs>(
      args?: Subset<T, StandardCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StandardCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StandardCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StandardCategoryAggregateArgs>(args: Subset<T, StandardCategoryAggregateArgs>): Prisma.PrismaPromise<GetStandardCategoryAggregateType<T>>

    /**
     * Group by StandardCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StandardCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StandardCategoryGroupByArgs['orderBy'] }
        : { orderBy?: StandardCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StandardCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStandardCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StandardCategory model
   */
  readonly fields: StandardCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StandardCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StandardCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parameters<T extends StandardCategory$parametersArgs<ExtArgs> = {}>(args?: Subset<T, StandardCategory$parametersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Standards<T extends StandardCategory$StandardsArgs<ExtArgs> = {}>(args?: Subset<T, StandardCategory$StandardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StandardCategory model
   */
  interface StandardCategoryFieldRefs {
    readonly id: FieldRef<"StandardCategory", 'String'>
    readonly name: FieldRef<"StandardCategory", 'String'>
    readonly description: FieldRef<"StandardCategory", 'String'>
    readonly createdAt: FieldRef<"StandardCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"StandardCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StandardCategory findUnique
   */
  export type StandardCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which StandardCategory to fetch.
     */
    where: StandardCategoryWhereUniqueInput
  }

  /**
   * StandardCategory findUniqueOrThrow
   */
  export type StandardCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which StandardCategory to fetch.
     */
    where: StandardCategoryWhereUniqueInput
  }

  /**
   * StandardCategory findFirst
   */
  export type StandardCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which StandardCategory to fetch.
     */
    where?: StandardCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardCategories to fetch.
     */
    orderBy?: StandardCategoryOrderByWithRelationInput | StandardCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardCategories.
     */
    cursor?: StandardCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardCategories.
     */
    distinct?: StandardCategoryScalarFieldEnum | StandardCategoryScalarFieldEnum[]
  }

  /**
   * StandardCategory findFirstOrThrow
   */
  export type StandardCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which StandardCategory to fetch.
     */
    where?: StandardCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardCategories to fetch.
     */
    orderBy?: StandardCategoryOrderByWithRelationInput | StandardCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardCategories.
     */
    cursor?: StandardCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardCategories.
     */
    distinct?: StandardCategoryScalarFieldEnum | StandardCategoryScalarFieldEnum[]
  }

  /**
   * StandardCategory findMany
   */
  export type StandardCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * Filter, which StandardCategories to fetch.
     */
    where?: StandardCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardCategories to fetch.
     */
    orderBy?: StandardCategoryOrderByWithRelationInput | StandardCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StandardCategories.
     */
    cursor?: StandardCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardCategories.
     */
    skip?: number
    distinct?: StandardCategoryScalarFieldEnum | StandardCategoryScalarFieldEnum[]
  }

  /**
   * StandardCategory create
   */
  export type StandardCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a StandardCategory.
     */
    data: XOR<StandardCategoryCreateInput, StandardCategoryUncheckedCreateInput>
  }

  /**
   * StandardCategory createMany
   */
  export type StandardCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StandardCategories.
     */
    data: StandardCategoryCreateManyInput | StandardCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StandardCategory createManyAndReturn
   */
  export type StandardCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many StandardCategories.
     */
    data: StandardCategoryCreateManyInput | StandardCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StandardCategory update
   */
  export type StandardCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a StandardCategory.
     */
    data: XOR<StandardCategoryUpdateInput, StandardCategoryUncheckedUpdateInput>
    /**
     * Choose, which StandardCategory to update.
     */
    where: StandardCategoryWhereUniqueInput
  }

  /**
   * StandardCategory updateMany
   */
  export type StandardCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StandardCategories.
     */
    data: XOR<StandardCategoryUpdateManyMutationInput, StandardCategoryUncheckedUpdateManyInput>
    /**
     * Filter which StandardCategories to update
     */
    where?: StandardCategoryWhereInput
    /**
     * Limit how many StandardCategories to update.
     */
    limit?: number
  }

  /**
   * StandardCategory updateManyAndReturn
   */
  export type StandardCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * The data used to update StandardCategories.
     */
    data: XOR<StandardCategoryUpdateManyMutationInput, StandardCategoryUncheckedUpdateManyInput>
    /**
     * Filter which StandardCategories to update
     */
    where?: StandardCategoryWhereInput
    /**
     * Limit how many StandardCategories to update.
     */
    limit?: number
  }

  /**
   * StandardCategory upsert
   */
  export type StandardCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the StandardCategory to update in case it exists.
     */
    where: StandardCategoryWhereUniqueInput
    /**
     * In case the StandardCategory found by the `where` argument doesn't exist, create a new StandardCategory with this data.
     */
    create: XOR<StandardCategoryCreateInput, StandardCategoryUncheckedCreateInput>
    /**
     * In case the StandardCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StandardCategoryUpdateInput, StandardCategoryUncheckedUpdateInput>
  }

  /**
   * StandardCategory delete
   */
  export type StandardCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
    /**
     * Filter which StandardCategory to delete.
     */
    where: StandardCategoryWhereUniqueInput
  }

  /**
   * StandardCategory deleteMany
   */
  export type StandardCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardCategories to delete
     */
    where?: StandardCategoryWhereInput
    /**
     * Limit how many StandardCategories to delete.
     */
    limit?: number
  }

  /**
   * StandardCategory.parameters
   */
  export type StandardCategory$parametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    where?: StandardParameterWhereInput
    orderBy?: StandardParameterOrderByWithRelationInput | StandardParameterOrderByWithRelationInput[]
    cursor?: StandardParameterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardParameterScalarFieldEnum | StandardParameterScalarFieldEnum[]
  }

  /**
   * StandardCategory.Standards
   */
  export type StandardCategory$StandardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standard
     */
    select?: StandardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Standard
     */
    omit?: StandardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardInclude<ExtArgs> | null
    where?: StandardWhereInput
    orderBy?: StandardOrderByWithRelationInput | StandardOrderByWithRelationInput[]
    cursor?: StandardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardScalarFieldEnum | StandardScalarFieldEnum[]
  }

  /**
   * StandardCategory without action
   */
  export type StandardCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardCategory
     */
    select?: StandardCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardCategory
     */
    omit?: StandardCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardCategoryInclude<ExtArgs> | null
  }


  /**
   * Model StandardParameter
   */

  export type AggregateStandardParameter = {
    _count: StandardParameterCountAggregateOutputType | null
    _min: StandardParameterMinAggregateOutputType | null
    _max: StandardParameterMaxAggregateOutputType | null
  }

  export type StandardParameterMinAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    description: string | null
    dataType: $Enums.ParameterDataType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardParameterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    description: string | null
    dataType: $Enums.ParameterDataType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardParameterCountAggregateOutputType = {
    id: number
    name: number
    categoryId: number
    description: number
    dataType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StandardParameterMinAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    description?: true
    dataType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardParameterMaxAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    description?: true
    dataType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardParameterCountAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    description?: true
    dataType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StandardParameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardParameter to aggregate.
     */
    where?: StandardParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardParameters to fetch.
     */
    orderBy?: StandardParameterOrderByWithRelationInput | StandardParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StandardParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StandardParameters
    **/
    _count?: true | StandardParameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StandardParameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StandardParameterMaxAggregateInputType
  }

  export type GetStandardParameterAggregateType<T extends StandardParameterAggregateArgs> = {
        [P in keyof T & keyof AggregateStandardParameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStandardParameter[P]>
      : GetScalarType<T[P], AggregateStandardParameter[P]>
  }




  export type StandardParameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardParameterWhereInput
    orderBy?: StandardParameterOrderByWithAggregationInput | StandardParameterOrderByWithAggregationInput[]
    by: StandardParameterScalarFieldEnum[] | StandardParameterScalarFieldEnum
    having?: StandardParameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StandardParameterCountAggregateInputType | true
    _min?: StandardParameterMinAggregateInputType
    _max?: StandardParameterMaxAggregateInputType
  }

  export type StandardParameterGroupByOutputType = {
    id: string
    name: string
    categoryId: string
    description: string | null
    dataType: $Enums.ParameterDataType
    createdAt: Date
    updatedAt: Date
    _count: StandardParameterCountAggregateOutputType | null
    _min: StandardParameterMinAggregateOutputType | null
    _max: StandardParameterMaxAggregateOutputType | null
  }

  type GetStandardParameterGroupByPayload<T extends StandardParameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StandardParameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StandardParameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StandardParameterGroupByOutputType[P]>
            : GetScalarType<T[P], StandardParameterGroupByOutputType[P]>
        }
      >
    >


  export type StandardParameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    description?: boolean
    dataType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    batchValues?: boolean | StandardParameter$batchValuesArgs<ExtArgs>
    standards?: boolean | StandardParameter$standardsArgs<ExtArgs>
    _count?: boolean | StandardParameterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["standardParameter"]>

  export type StandardParameterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    description?: boolean
    dataType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["standardParameter"]>

  export type StandardParameterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    description?: boolean
    dataType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["standardParameter"]>

  export type StandardParameterSelectScalar = {
    id?: boolean
    name?: boolean
    categoryId?: boolean
    description?: boolean
    dataType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StandardParameterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "categoryId" | "description" | "dataType" | "createdAt" | "updatedAt", ExtArgs["result"]["standardParameter"]>
  export type StandardParameterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
    batchValues?: boolean | StandardParameter$batchValuesArgs<ExtArgs>
    standards?: boolean | StandardParameter$standardsArgs<ExtArgs>
    _count?: boolean | StandardParameterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StandardParameterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
  }
  export type StandardParameterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | StandardCategoryDefaultArgs<ExtArgs>
  }

  export type $StandardParameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StandardParameter"
    objects: {
      category: Prisma.$StandardCategoryPayload<ExtArgs>
      batchValues: Prisma.$BatchParameterValuePayload<ExtArgs>[]
      standards: Prisma.$StandardDefinitionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      categoryId: string
      description: string | null
      dataType: $Enums.ParameterDataType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["standardParameter"]>
    composites: {}
  }

  type StandardParameterGetPayload<S extends boolean | null | undefined | StandardParameterDefaultArgs> = $Result.GetResult<Prisma.$StandardParameterPayload, S>

  type StandardParameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StandardParameterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StandardParameterCountAggregateInputType | true
    }

  export interface StandardParameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StandardParameter'], meta: { name: 'StandardParameter' } }
    /**
     * Find zero or one StandardParameter that matches the filter.
     * @param {StandardParameterFindUniqueArgs} args - Arguments to find a StandardParameter
     * @example
     * // Get one StandardParameter
     * const standardParameter = await prisma.standardParameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StandardParameterFindUniqueArgs>(args: SelectSubset<T, StandardParameterFindUniqueArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StandardParameter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StandardParameterFindUniqueOrThrowArgs} args - Arguments to find a StandardParameter
     * @example
     * // Get one StandardParameter
     * const standardParameter = await prisma.standardParameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StandardParameterFindUniqueOrThrowArgs>(args: SelectSubset<T, StandardParameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StandardParameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterFindFirstArgs} args - Arguments to find a StandardParameter
     * @example
     * // Get one StandardParameter
     * const standardParameter = await prisma.standardParameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StandardParameterFindFirstArgs>(args?: SelectSubset<T, StandardParameterFindFirstArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StandardParameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterFindFirstOrThrowArgs} args - Arguments to find a StandardParameter
     * @example
     * // Get one StandardParameter
     * const standardParameter = await prisma.standardParameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StandardParameterFindFirstOrThrowArgs>(args?: SelectSubset<T, StandardParameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StandardParameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StandardParameters
     * const standardParameters = await prisma.standardParameter.findMany()
     * 
     * // Get first 10 StandardParameters
     * const standardParameters = await prisma.standardParameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const standardParameterWithIdOnly = await prisma.standardParameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StandardParameterFindManyArgs>(args?: SelectSubset<T, StandardParameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StandardParameter.
     * @param {StandardParameterCreateArgs} args - Arguments to create a StandardParameter.
     * @example
     * // Create one StandardParameter
     * const StandardParameter = await prisma.standardParameter.create({
     *   data: {
     *     // ... data to create a StandardParameter
     *   }
     * })
     * 
     */
    create<T extends StandardParameterCreateArgs>(args: SelectSubset<T, StandardParameterCreateArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StandardParameters.
     * @param {StandardParameterCreateManyArgs} args - Arguments to create many StandardParameters.
     * @example
     * // Create many StandardParameters
     * const standardParameter = await prisma.standardParameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StandardParameterCreateManyArgs>(args?: SelectSubset<T, StandardParameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StandardParameters and returns the data saved in the database.
     * @param {StandardParameterCreateManyAndReturnArgs} args - Arguments to create many StandardParameters.
     * @example
     * // Create many StandardParameters
     * const standardParameter = await prisma.standardParameter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StandardParameters and only return the `id`
     * const standardParameterWithIdOnly = await prisma.standardParameter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StandardParameterCreateManyAndReturnArgs>(args?: SelectSubset<T, StandardParameterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StandardParameter.
     * @param {StandardParameterDeleteArgs} args - Arguments to delete one StandardParameter.
     * @example
     * // Delete one StandardParameter
     * const StandardParameter = await prisma.standardParameter.delete({
     *   where: {
     *     // ... filter to delete one StandardParameter
     *   }
     * })
     * 
     */
    delete<T extends StandardParameterDeleteArgs>(args: SelectSubset<T, StandardParameterDeleteArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StandardParameter.
     * @param {StandardParameterUpdateArgs} args - Arguments to update one StandardParameter.
     * @example
     * // Update one StandardParameter
     * const standardParameter = await prisma.standardParameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StandardParameterUpdateArgs>(args: SelectSubset<T, StandardParameterUpdateArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StandardParameters.
     * @param {StandardParameterDeleteManyArgs} args - Arguments to filter StandardParameters to delete.
     * @example
     * // Delete a few StandardParameters
     * const { count } = await prisma.standardParameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StandardParameterDeleteManyArgs>(args?: SelectSubset<T, StandardParameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StandardParameters
     * const standardParameter = await prisma.standardParameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StandardParameterUpdateManyArgs>(args: SelectSubset<T, StandardParameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardParameters and returns the data updated in the database.
     * @param {StandardParameterUpdateManyAndReturnArgs} args - Arguments to update many StandardParameters.
     * @example
     * // Update many StandardParameters
     * const standardParameter = await prisma.standardParameter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StandardParameters and only return the `id`
     * const standardParameterWithIdOnly = await prisma.standardParameter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StandardParameterUpdateManyAndReturnArgs>(args: SelectSubset<T, StandardParameterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StandardParameter.
     * @param {StandardParameterUpsertArgs} args - Arguments to update or create a StandardParameter.
     * @example
     * // Update or create a StandardParameter
     * const standardParameter = await prisma.standardParameter.upsert({
     *   create: {
     *     // ... data to create a StandardParameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StandardParameter we want to update
     *   }
     * })
     */
    upsert<T extends StandardParameterUpsertArgs>(args: SelectSubset<T, StandardParameterUpsertArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StandardParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterCountArgs} args - Arguments to filter StandardParameters to count.
     * @example
     * // Count the number of StandardParameters
     * const count = await prisma.standardParameter.count({
     *   where: {
     *     // ... the filter for the StandardParameters we want to count
     *   }
     * })
    **/
    count<T extends StandardParameterCountArgs>(
      args?: Subset<T, StandardParameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StandardParameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StandardParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StandardParameterAggregateArgs>(args: Subset<T, StandardParameterAggregateArgs>): Prisma.PrismaPromise<GetStandardParameterAggregateType<T>>

    /**
     * Group by StandardParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardParameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StandardParameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StandardParameterGroupByArgs['orderBy'] }
        : { orderBy?: StandardParameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StandardParameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStandardParameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StandardParameter model
   */
  readonly fields: StandardParameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StandardParameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StandardParameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends StandardCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StandardCategoryDefaultArgs<ExtArgs>>): Prisma__StandardCategoryClient<$Result.GetResult<Prisma.$StandardCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batchValues<T extends StandardParameter$batchValuesArgs<ExtArgs> = {}>(args?: Subset<T, StandardParameter$batchValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    standards<T extends StandardParameter$standardsArgs<ExtArgs> = {}>(args?: Subset<T, StandardParameter$standardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StandardParameter model
   */
  interface StandardParameterFieldRefs {
    readonly id: FieldRef<"StandardParameter", 'String'>
    readonly name: FieldRef<"StandardParameter", 'String'>
    readonly categoryId: FieldRef<"StandardParameter", 'String'>
    readonly description: FieldRef<"StandardParameter", 'String'>
    readonly dataType: FieldRef<"StandardParameter", 'ParameterDataType'>
    readonly createdAt: FieldRef<"StandardParameter", 'DateTime'>
    readonly updatedAt: FieldRef<"StandardParameter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StandardParameter findUnique
   */
  export type StandardParameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * Filter, which StandardParameter to fetch.
     */
    where: StandardParameterWhereUniqueInput
  }

  /**
   * StandardParameter findUniqueOrThrow
   */
  export type StandardParameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * Filter, which StandardParameter to fetch.
     */
    where: StandardParameterWhereUniqueInput
  }

  /**
   * StandardParameter findFirst
   */
  export type StandardParameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * Filter, which StandardParameter to fetch.
     */
    where?: StandardParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardParameters to fetch.
     */
    orderBy?: StandardParameterOrderByWithRelationInput | StandardParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardParameters.
     */
    cursor?: StandardParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardParameters.
     */
    distinct?: StandardParameterScalarFieldEnum | StandardParameterScalarFieldEnum[]
  }

  /**
   * StandardParameter findFirstOrThrow
   */
  export type StandardParameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * Filter, which StandardParameter to fetch.
     */
    where?: StandardParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardParameters to fetch.
     */
    orderBy?: StandardParameterOrderByWithRelationInput | StandardParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardParameters.
     */
    cursor?: StandardParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardParameters.
     */
    distinct?: StandardParameterScalarFieldEnum | StandardParameterScalarFieldEnum[]
  }

  /**
   * StandardParameter findMany
   */
  export type StandardParameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * Filter, which StandardParameters to fetch.
     */
    where?: StandardParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardParameters to fetch.
     */
    orderBy?: StandardParameterOrderByWithRelationInput | StandardParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StandardParameters.
     */
    cursor?: StandardParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardParameters.
     */
    skip?: number
    distinct?: StandardParameterScalarFieldEnum | StandardParameterScalarFieldEnum[]
  }

  /**
   * StandardParameter create
   */
  export type StandardParameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * The data needed to create a StandardParameter.
     */
    data: XOR<StandardParameterCreateInput, StandardParameterUncheckedCreateInput>
  }

  /**
   * StandardParameter createMany
   */
  export type StandardParameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StandardParameters.
     */
    data: StandardParameterCreateManyInput | StandardParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StandardParameter createManyAndReturn
   */
  export type StandardParameterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * The data used to create many StandardParameters.
     */
    data: StandardParameterCreateManyInput | StandardParameterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StandardParameter update
   */
  export type StandardParameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * The data needed to update a StandardParameter.
     */
    data: XOR<StandardParameterUpdateInput, StandardParameterUncheckedUpdateInput>
    /**
     * Choose, which StandardParameter to update.
     */
    where: StandardParameterWhereUniqueInput
  }

  /**
   * StandardParameter updateMany
   */
  export type StandardParameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StandardParameters.
     */
    data: XOR<StandardParameterUpdateManyMutationInput, StandardParameterUncheckedUpdateManyInput>
    /**
     * Filter which StandardParameters to update
     */
    where?: StandardParameterWhereInput
    /**
     * Limit how many StandardParameters to update.
     */
    limit?: number
  }

  /**
   * StandardParameter updateManyAndReturn
   */
  export type StandardParameterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * The data used to update StandardParameters.
     */
    data: XOR<StandardParameterUpdateManyMutationInput, StandardParameterUncheckedUpdateManyInput>
    /**
     * Filter which StandardParameters to update
     */
    where?: StandardParameterWhereInput
    /**
     * Limit how many StandardParameters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StandardParameter upsert
   */
  export type StandardParameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * The filter to search for the StandardParameter to update in case it exists.
     */
    where: StandardParameterWhereUniqueInput
    /**
     * In case the StandardParameter found by the `where` argument doesn't exist, create a new StandardParameter with this data.
     */
    create: XOR<StandardParameterCreateInput, StandardParameterUncheckedCreateInput>
    /**
     * In case the StandardParameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StandardParameterUpdateInput, StandardParameterUncheckedUpdateInput>
  }

  /**
   * StandardParameter delete
   */
  export type StandardParameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
    /**
     * Filter which StandardParameter to delete.
     */
    where: StandardParameterWhereUniqueInput
  }

  /**
   * StandardParameter deleteMany
   */
  export type StandardParameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardParameters to delete
     */
    where?: StandardParameterWhereInput
    /**
     * Limit how many StandardParameters to delete.
     */
    limit?: number
  }

  /**
   * StandardParameter.batchValues
   */
  export type StandardParameter$batchValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    where?: BatchParameterValueWhereInput
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    cursor?: BatchParameterValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * StandardParameter.standards
   */
  export type StandardParameter$standardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    where?: StandardDefinitionWhereInput
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    cursor?: StandardDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * StandardParameter without action
   */
  export type StandardParameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardParameter
     */
    select?: StandardParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardParameter
     */
    omit?: StandardParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardParameterInclude<ExtArgs> | null
  }


  /**
   * Model StandardDefinition
   */

  export type AggregateStandardDefinition = {
    _count: StandardDefinitionCountAggregateOutputType | null
    _min: StandardDefinitionMinAggregateOutputType | null
    _max: StandardDefinitionMaxAggregateOutputType | null
  }

  export type StandardDefinitionMinAggregateOutputType = {
    id: string | null
    parameterId: string | null
    standardValue: string | null
    unitId: string | null
    methodologyId: string | null
    createdById: string | null
    modifiedById: string | null
    status: $Enums.StandardStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardDefinitionMaxAggregateOutputType = {
    id: string | null
    parameterId: string | null
    standardValue: string | null
    unitId: string | null
    methodologyId: string | null
    createdById: string | null
    modifiedById: string | null
    status: $Enums.StandardStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardDefinitionCountAggregateOutputType = {
    id: number
    parameterId: number
    standardValue: number
    unitId: number
    methodologyId: number
    createdById: number
    modifiedById: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StandardDefinitionMinAggregateInputType = {
    id?: true
    parameterId?: true
    standardValue?: true
    unitId?: true
    methodologyId?: true
    createdById?: true
    modifiedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardDefinitionMaxAggregateInputType = {
    id?: true
    parameterId?: true
    standardValue?: true
    unitId?: true
    methodologyId?: true
    createdById?: true
    modifiedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardDefinitionCountAggregateInputType = {
    id?: true
    parameterId?: true
    standardValue?: true
    unitId?: true
    methodologyId?: true
    createdById?: true
    modifiedById?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StandardDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardDefinition to aggregate.
     */
    where?: StandardDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardDefinitions to fetch.
     */
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StandardDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StandardDefinitions
    **/
    _count?: true | StandardDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StandardDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StandardDefinitionMaxAggregateInputType
  }

  export type GetStandardDefinitionAggregateType<T extends StandardDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateStandardDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStandardDefinition[P]>
      : GetScalarType<T[P], AggregateStandardDefinition[P]>
  }




  export type StandardDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardDefinitionWhereInput
    orderBy?: StandardDefinitionOrderByWithAggregationInput | StandardDefinitionOrderByWithAggregationInput[]
    by: StandardDefinitionScalarFieldEnum[] | StandardDefinitionScalarFieldEnum
    having?: StandardDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StandardDefinitionCountAggregateInputType | true
    _min?: StandardDefinitionMinAggregateInputType
    _max?: StandardDefinitionMaxAggregateInputType
  }

  export type StandardDefinitionGroupByOutputType = {
    id: string
    parameterId: string
    standardValue: string
    unitId: string | null
    methodologyId: string | null
    createdById: string
    modifiedById: string | null
    status: $Enums.StandardStatus
    createdAt: Date
    updatedAt: Date
    _count: StandardDefinitionCountAggregateOutputType | null
    _min: StandardDefinitionMinAggregateOutputType | null
    _max: StandardDefinitionMaxAggregateOutputType | null
  }

  type GetStandardDefinitionGroupByPayload<T extends StandardDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StandardDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StandardDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StandardDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], StandardDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type StandardDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parameterId?: boolean
    standardValue?: boolean
    unitId?: boolean
    methodologyId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | StandardDefinition$unitArgs<ExtArgs>
    methodology?: boolean | StandardDefinition$methodologyArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | StandardDefinition$ModifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["standardDefinition"]>

  export type StandardDefinitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parameterId?: boolean
    standardValue?: boolean
    unitId?: boolean
    methodologyId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | StandardDefinition$unitArgs<ExtArgs>
    methodology?: boolean | StandardDefinition$methodologyArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | StandardDefinition$ModifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["standardDefinition"]>

  export type StandardDefinitionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parameterId?: boolean
    standardValue?: boolean
    unitId?: boolean
    methodologyId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | StandardDefinition$unitArgs<ExtArgs>
    methodology?: boolean | StandardDefinition$methodologyArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | StandardDefinition$ModifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["standardDefinition"]>

  export type StandardDefinitionSelectScalar = {
    id?: boolean
    parameterId?: boolean
    standardValue?: boolean
    unitId?: boolean
    methodologyId?: boolean
    createdById?: boolean
    modifiedById?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StandardDefinitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "parameterId" | "standardValue" | "unitId" | "methodologyId" | "createdById" | "modifiedById" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["standardDefinition"]>
  export type StandardDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | StandardDefinition$unitArgs<ExtArgs>
    methodology?: boolean | StandardDefinition$methodologyArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | StandardDefinition$ModifiedByArgs<ExtArgs>
  }
  export type StandardDefinitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | StandardDefinition$unitArgs<ExtArgs>
    methodology?: boolean | StandardDefinition$methodologyArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | StandardDefinition$ModifiedByArgs<ExtArgs>
  }
  export type StandardDefinitionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | StandardDefinition$unitArgs<ExtArgs>
    methodology?: boolean | StandardDefinition$methodologyArgs<ExtArgs>
    CreatedBy?: boolean | UserDefaultArgs<ExtArgs>
    ModifiedBy?: boolean | StandardDefinition$ModifiedByArgs<ExtArgs>
  }

  export type $StandardDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StandardDefinition"
    objects: {
      parameter: Prisma.$StandardParameterPayload<ExtArgs>
      unit: Prisma.$UnitOfMeasurementPayload<ExtArgs> | null
      methodology: Prisma.$MethodologyPayload<ExtArgs> | null
      CreatedBy: Prisma.$UserPayload<ExtArgs>
      ModifiedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      parameterId: string
      standardValue: string
      unitId: string | null
      methodologyId: string | null
      createdById: string
      modifiedById: string | null
      status: $Enums.StandardStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["standardDefinition"]>
    composites: {}
  }

  type StandardDefinitionGetPayload<S extends boolean | null | undefined | StandardDefinitionDefaultArgs> = $Result.GetResult<Prisma.$StandardDefinitionPayload, S>

  type StandardDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StandardDefinitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StandardDefinitionCountAggregateInputType | true
    }

  export interface StandardDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StandardDefinition'], meta: { name: 'StandardDefinition' } }
    /**
     * Find zero or one StandardDefinition that matches the filter.
     * @param {StandardDefinitionFindUniqueArgs} args - Arguments to find a StandardDefinition
     * @example
     * // Get one StandardDefinition
     * const standardDefinition = await prisma.standardDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StandardDefinitionFindUniqueArgs>(args: SelectSubset<T, StandardDefinitionFindUniqueArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StandardDefinition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StandardDefinitionFindUniqueOrThrowArgs} args - Arguments to find a StandardDefinition
     * @example
     * // Get one StandardDefinition
     * const standardDefinition = await prisma.standardDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StandardDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, StandardDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StandardDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionFindFirstArgs} args - Arguments to find a StandardDefinition
     * @example
     * // Get one StandardDefinition
     * const standardDefinition = await prisma.standardDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StandardDefinitionFindFirstArgs>(args?: SelectSubset<T, StandardDefinitionFindFirstArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StandardDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionFindFirstOrThrowArgs} args - Arguments to find a StandardDefinition
     * @example
     * // Get one StandardDefinition
     * const standardDefinition = await prisma.standardDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StandardDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, StandardDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StandardDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StandardDefinitions
     * const standardDefinitions = await prisma.standardDefinition.findMany()
     * 
     * // Get first 10 StandardDefinitions
     * const standardDefinitions = await prisma.standardDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const standardDefinitionWithIdOnly = await prisma.standardDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StandardDefinitionFindManyArgs>(args?: SelectSubset<T, StandardDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StandardDefinition.
     * @param {StandardDefinitionCreateArgs} args - Arguments to create a StandardDefinition.
     * @example
     * // Create one StandardDefinition
     * const StandardDefinition = await prisma.standardDefinition.create({
     *   data: {
     *     // ... data to create a StandardDefinition
     *   }
     * })
     * 
     */
    create<T extends StandardDefinitionCreateArgs>(args: SelectSubset<T, StandardDefinitionCreateArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StandardDefinitions.
     * @param {StandardDefinitionCreateManyArgs} args - Arguments to create many StandardDefinitions.
     * @example
     * // Create many StandardDefinitions
     * const standardDefinition = await prisma.standardDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StandardDefinitionCreateManyArgs>(args?: SelectSubset<T, StandardDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StandardDefinitions and returns the data saved in the database.
     * @param {StandardDefinitionCreateManyAndReturnArgs} args - Arguments to create many StandardDefinitions.
     * @example
     * // Create many StandardDefinitions
     * const standardDefinition = await prisma.standardDefinition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StandardDefinitions and only return the `id`
     * const standardDefinitionWithIdOnly = await prisma.standardDefinition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StandardDefinitionCreateManyAndReturnArgs>(args?: SelectSubset<T, StandardDefinitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StandardDefinition.
     * @param {StandardDefinitionDeleteArgs} args - Arguments to delete one StandardDefinition.
     * @example
     * // Delete one StandardDefinition
     * const StandardDefinition = await prisma.standardDefinition.delete({
     *   where: {
     *     // ... filter to delete one StandardDefinition
     *   }
     * })
     * 
     */
    delete<T extends StandardDefinitionDeleteArgs>(args: SelectSubset<T, StandardDefinitionDeleteArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StandardDefinition.
     * @param {StandardDefinitionUpdateArgs} args - Arguments to update one StandardDefinition.
     * @example
     * // Update one StandardDefinition
     * const standardDefinition = await prisma.standardDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StandardDefinitionUpdateArgs>(args: SelectSubset<T, StandardDefinitionUpdateArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StandardDefinitions.
     * @param {StandardDefinitionDeleteManyArgs} args - Arguments to filter StandardDefinitions to delete.
     * @example
     * // Delete a few StandardDefinitions
     * const { count } = await prisma.standardDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StandardDefinitionDeleteManyArgs>(args?: SelectSubset<T, StandardDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StandardDefinitions
     * const standardDefinition = await prisma.standardDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StandardDefinitionUpdateManyArgs>(args: SelectSubset<T, StandardDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardDefinitions and returns the data updated in the database.
     * @param {StandardDefinitionUpdateManyAndReturnArgs} args - Arguments to update many StandardDefinitions.
     * @example
     * // Update many StandardDefinitions
     * const standardDefinition = await prisma.standardDefinition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StandardDefinitions and only return the `id`
     * const standardDefinitionWithIdOnly = await prisma.standardDefinition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StandardDefinitionUpdateManyAndReturnArgs>(args: SelectSubset<T, StandardDefinitionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StandardDefinition.
     * @param {StandardDefinitionUpsertArgs} args - Arguments to update or create a StandardDefinition.
     * @example
     * // Update or create a StandardDefinition
     * const standardDefinition = await prisma.standardDefinition.upsert({
     *   create: {
     *     // ... data to create a StandardDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StandardDefinition we want to update
     *   }
     * })
     */
    upsert<T extends StandardDefinitionUpsertArgs>(args: SelectSubset<T, StandardDefinitionUpsertArgs<ExtArgs>>): Prisma__StandardDefinitionClient<$Result.GetResult<Prisma.$StandardDefinitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StandardDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionCountArgs} args - Arguments to filter StandardDefinitions to count.
     * @example
     * // Count the number of StandardDefinitions
     * const count = await prisma.standardDefinition.count({
     *   where: {
     *     // ... the filter for the StandardDefinitions we want to count
     *   }
     * })
    **/
    count<T extends StandardDefinitionCountArgs>(
      args?: Subset<T, StandardDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StandardDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StandardDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StandardDefinitionAggregateArgs>(args: Subset<T, StandardDefinitionAggregateArgs>): Prisma.PrismaPromise<GetStandardDefinitionAggregateType<T>>

    /**
     * Group by StandardDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StandardDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StandardDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: StandardDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StandardDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStandardDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StandardDefinition model
   */
  readonly fields: StandardDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StandardDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StandardDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parameter<T extends StandardParameterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StandardParameterDefaultArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends StandardDefinition$unitArgs<ExtArgs> = {}>(args?: Subset<T, StandardDefinition$unitArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    methodology<T extends StandardDefinition$methodologyArgs<ExtArgs> = {}>(args?: Subset<T, StandardDefinition$methodologyArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    CreatedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ModifiedBy<T extends StandardDefinition$ModifiedByArgs<ExtArgs> = {}>(args?: Subset<T, StandardDefinition$ModifiedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StandardDefinition model
   */
  interface StandardDefinitionFieldRefs {
    readonly id: FieldRef<"StandardDefinition", 'String'>
    readonly parameterId: FieldRef<"StandardDefinition", 'String'>
    readonly standardValue: FieldRef<"StandardDefinition", 'String'>
    readonly unitId: FieldRef<"StandardDefinition", 'String'>
    readonly methodologyId: FieldRef<"StandardDefinition", 'String'>
    readonly createdById: FieldRef<"StandardDefinition", 'String'>
    readonly modifiedById: FieldRef<"StandardDefinition", 'String'>
    readonly status: FieldRef<"StandardDefinition", 'StandardStatus'>
    readonly createdAt: FieldRef<"StandardDefinition", 'DateTime'>
    readonly updatedAt: FieldRef<"StandardDefinition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StandardDefinition findUnique
   */
  export type StandardDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which StandardDefinition to fetch.
     */
    where: StandardDefinitionWhereUniqueInput
  }

  /**
   * StandardDefinition findUniqueOrThrow
   */
  export type StandardDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which StandardDefinition to fetch.
     */
    where: StandardDefinitionWhereUniqueInput
  }

  /**
   * StandardDefinition findFirst
   */
  export type StandardDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which StandardDefinition to fetch.
     */
    where?: StandardDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardDefinitions to fetch.
     */
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardDefinitions.
     */
    cursor?: StandardDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardDefinitions.
     */
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * StandardDefinition findFirstOrThrow
   */
  export type StandardDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which StandardDefinition to fetch.
     */
    where?: StandardDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardDefinitions to fetch.
     */
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardDefinitions.
     */
    cursor?: StandardDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardDefinitions.
     */
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * StandardDefinition findMany
   */
  export type StandardDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which StandardDefinitions to fetch.
     */
    where?: StandardDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardDefinitions to fetch.
     */
    orderBy?: StandardDefinitionOrderByWithRelationInput | StandardDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StandardDefinitions.
     */
    cursor?: StandardDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardDefinitions.
     */
    skip?: number
    distinct?: StandardDefinitionScalarFieldEnum | StandardDefinitionScalarFieldEnum[]
  }

  /**
   * StandardDefinition create
   */
  export type StandardDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a StandardDefinition.
     */
    data: XOR<StandardDefinitionCreateInput, StandardDefinitionUncheckedCreateInput>
  }

  /**
   * StandardDefinition createMany
   */
  export type StandardDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StandardDefinitions.
     */
    data: StandardDefinitionCreateManyInput | StandardDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StandardDefinition createManyAndReturn
   */
  export type StandardDefinitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * The data used to create many StandardDefinitions.
     */
    data: StandardDefinitionCreateManyInput | StandardDefinitionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StandardDefinition update
   */
  export type StandardDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a StandardDefinition.
     */
    data: XOR<StandardDefinitionUpdateInput, StandardDefinitionUncheckedUpdateInput>
    /**
     * Choose, which StandardDefinition to update.
     */
    where: StandardDefinitionWhereUniqueInput
  }

  /**
   * StandardDefinition updateMany
   */
  export type StandardDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StandardDefinitions.
     */
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which StandardDefinitions to update
     */
    where?: StandardDefinitionWhereInput
    /**
     * Limit how many StandardDefinitions to update.
     */
    limit?: number
  }

  /**
   * StandardDefinition updateManyAndReturn
   */
  export type StandardDefinitionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * The data used to update StandardDefinitions.
     */
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which StandardDefinitions to update
     */
    where?: StandardDefinitionWhereInput
    /**
     * Limit how many StandardDefinitions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StandardDefinition upsert
   */
  export type StandardDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the StandardDefinition to update in case it exists.
     */
    where: StandardDefinitionWhereUniqueInput
    /**
     * In case the StandardDefinition found by the `where` argument doesn't exist, create a new StandardDefinition with this data.
     */
    create: XOR<StandardDefinitionCreateInput, StandardDefinitionUncheckedCreateInput>
    /**
     * In case the StandardDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StandardDefinitionUpdateInput, StandardDefinitionUncheckedUpdateInput>
  }

  /**
   * StandardDefinition delete
   */
  export type StandardDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
    /**
     * Filter which StandardDefinition to delete.
     */
    where: StandardDefinitionWhereUniqueInput
  }

  /**
   * StandardDefinition deleteMany
   */
  export type StandardDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardDefinitions to delete
     */
    where?: StandardDefinitionWhereInput
    /**
     * Limit how many StandardDefinitions to delete.
     */
    limit?: number
  }

  /**
   * StandardDefinition.unit
   */
  export type StandardDefinition$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    where?: UnitOfMeasurementWhereInput
  }

  /**
   * StandardDefinition.methodology
   */
  export type StandardDefinition$methodologyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    where?: MethodologyWhereInput
  }

  /**
   * StandardDefinition.ModifiedBy
   */
  export type StandardDefinition$ModifiedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StandardDefinition without action
   */
  export type StandardDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardDefinition
     */
    select?: StandardDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StandardDefinition
     */
    omit?: StandardDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandardDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model BatchParameterValue
   */

  export type AggregateBatchParameterValue = {
    _count: BatchParameterValueCountAggregateOutputType | null
    _min: BatchParameterValueMinAggregateOutputType | null
    _max: BatchParameterValueMaxAggregateOutputType | null
  }

  export type BatchParameterValueMinAggregateOutputType = {
    id: string | null
    batchId: string | null
    parameterId: string | null
    value: string | null
    unitId: string | null
    methodologyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchParameterValueMaxAggregateOutputType = {
    id: string | null
    batchId: string | null
    parameterId: string | null
    value: string | null
    unitId: string | null
    methodologyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchParameterValueCountAggregateOutputType = {
    id: number
    batchId: number
    parameterId: number
    value: number
    unitId: number
    methodologyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BatchParameterValueMinAggregateInputType = {
    id?: true
    batchId?: true
    parameterId?: true
    value?: true
    unitId?: true
    methodologyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchParameterValueMaxAggregateInputType = {
    id?: true
    batchId?: true
    parameterId?: true
    value?: true
    unitId?: true
    methodologyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchParameterValueCountAggregateInputType = {
    id?: true
    batchId?: true
    parameterId?: true
    value?: true
    unitId?: true
    methodologyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BatchParameterValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchParameterValue to aggregate.
     */
    where?: BatchParameterValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchParameterValues to fetch.
     */
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchParameterValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchParameterValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchParameterValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BatchParameterValues
    **/
    _count?: true | BatchParameterValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchParameterValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchParameterValueMaxAggregateInputType
  }

  export type GetBatchParameterValueAggregateType<T extends BatchParameterValueAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchParameterValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchParameterValue[P]>
      : GetScalarType<T[P], AggregateBatchParameterValue[P]>
  }




  export type BatchParameterValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchParameterValueWhereInput
    orderBy?: BatchParameterValueOrderByWithAggregationInput | BatchParameterValueOrderByWithAggregationInput[]
    by: BatchParameterValueScalarFieldEnum[] | BatchParameterValueScalarFieldEnum
    having?: BatchParameterValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchParameterValueCountAggregateInputType | true
    _min?: BatchParameterValueMinAggregateInputType
    _max?: BatchParameterValueMaxAggregateInputType
  }

  export type BatchParameterValueGroupByOutputType = {
    id: string
    batchId: string
    parameterId: string
    value: string
    unitId: string | null
    methodologyId: string | null
    createdAt: Date
    updatedAt: Date
    _count: BatchParameterValueCountAggregateOutputType | null
    _min: BatchParameterValueMinAggregateOutputType | null
    _max: BatchParameterValueMaxAggregateOutputType | null
  }

  type GetBatchParameterValueGroupByPayload<T extends BatchParameterValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchParameterValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchParameterValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchParameterValueGroupByOutputType[P]>
            : GetScalarType<T[P], BatchParameterValueGroupByOutputType[P]>
        }
      >
    >


  export type BatchParameterValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    parameterId?: boolean
    value?: boolean
    unitId?: boolean
    methodologyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | BatchParameterValue$unitArgs<ExtArgs>
    methodology?: boolean | BatchParameterValue$methodologyArgs<ExtArgs>
  }, ExtArgs["result"]["batchParameterValue"]>

  export type BatchParameterValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    parameterId?: boolean
    value?: boolean
    unitId?: boolean
    methodologyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | BatchParameterValue$unitArgs<ExtArgs>
    methodology?: boolean | BatchParameterValue$methodologyArgs<ExtArgs>
  }, ExtArgs["result"]["batchParameterValue"]>

  export type BatchParameterValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    parameterId?: boolean
    value?: boolean
    unitId?: boolean
    methodologyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | BatchParameterValue$unitArgs<ExtArgs>
    methodology?: boolean | BatchParameterValue$methodologyArgs<ExtArgs>
  }, ExtArgs["result"]["batchParameterValue"]>

  export type BatchParameterValueSelectScalar = {
    id?: boolean
    batchId?: boolean
    parameterId?: boolean
    value?: boolean
    unitId?: boolean
    methodologyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BatchParameterValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "batchId" | "parameterId" | "value" | "unitId" | "methodologyId" | "createdAt" | "updatedAt", ExtArgs["result"]["batchParameterValue"]>
  export type BatchParameterValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | BatchParameterValue$unitArgs<ExtArgs>
    methodology?: boolean | BatchParameterValue$methodologyArgs<ExtArgs>
  }
  export type BatchParameterValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | BatchParameterValue$unitArgs<ExtArgs>
    methodology?: boolean | BatchParameterValue$methodologyArgs<ExtArgs>
  }
  export type BatchParameterValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    parameter?: boolean | StandardParameterDefaultArgs<ExtArgs>
    unit?: boolean | BatchParameterValue$unitArgs<ExtArgs>
    methodology?: boolean | BatchParameterValue$methodologyArgs<ExtArgs>
  }

  export type $BatchParameterValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BatchParameterValue"
    objects: {
      batch: Prisma.$BatchPayload<ExtArgs>
      parameter: Prisma.$StandardParameterPayload<ExtArgs>
      unit: Prisma.$UnitOfMeasurementPayload<ExtArgs> | null
      methodology: Prisma.$MethodologyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      batchId: string
      parameterId: string
      value: string
      unitId: string | null
      methodologyId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["batchParameterValue"]>
    composites: {}
  }

  type BatchParameterValueGetPayload<S extends boolean | null | undefined | BatchParameterValueDefaultArgs> = $Result.GetResult<Prisma.$BatchParameterValuePayload, S>

  type BatchParameterValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchParameterValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchParameterValueCountAggregateInputType | true
    }

  export interface BatchParameterValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BatchParameterValue'], meta: { name: 'BatchParameterValue' } }
    /**
     * Find zero or one BatchParameterValue that matches the filter.
     * @param {BatchParameterValueFindUniqueArgs} args - Arguments to find a BatchParameterValue
     * @example
     * // Get one BatchParameterValue
     * const batchParameterValue = await prisma.batchParameterValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchParameterValueFindUniqueArgs>(args: SelectSubset<T, BatchParameterValueFindUniqueArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BatchParameterValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchParameterValueFindUniqueOrThrowArgs} args - Arguments to find a BatchParameterValue
     * @example
     * // Get one BatchParameterValue
     * const batchParameterValue = await prisma.batchParameterValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchParameterValueFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchParameterValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchParameterValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueFindFirstArgs} args - Arguments to find a BatchParameterValue
     * @example
     * // Get one BatchParameterValue
     * const batchParameterValue = await prisma.batchParameterValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchParameterValueFindFirstArgs>(args?: SelectSubset<T, BatchParameterValueFindFirstArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchParameterValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueFindFirstOrThrowArgs} args - Arguments to find a BatchParameterValue
     * @example
     * // Get one BatchParameterValue
     * const batchParameterValue = await prisma.batchParameterValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchParameterValueFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchParameterValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BatchParameterValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BatchParameterValues
     * const batchParameterValues = await prisma.batchParameterValue.findMany()
     * 
     * // Get first 10 BatchParameterValues
     * const batchParameterValues = await prisma.batchParameterValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchParameterValueWithIdOnly = await prisma.batchParameterValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchParameterValueFindManyArgs>(args?: SelectSubset<T, BatchParameterValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BatchParameterValue.
     * @param {BatchParameterValueCreateArgs} args - Arguments to create a BatchParameterValue.
     * @example
     * // Create one BatchParameterValue
     * const BatchParameterValue = await prisma.batchParameterValue.create({
     *   data: {
     *     // ... data to create a BatchParameterValue
     *   }
     * })
     * 
     */
    create<T extends BatchParameterValueCreateArgs>(args: SelectSubset<T, BatchParameterValueCreateArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BatchParameterValues.
     * @param {BatchParameterValueCreateManyArgs} args - Arguments to create many BatchParameterValues.
     * @example
     * // Create many BatchParameterValues
     * const batchParameterValue = await prisma.batchParameterValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchParameterValueCreateManyArgs>(args?: SelectSubset<T, BatchParameterValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BatchParameterValues and returns the data saved in the database.
     * @param {BatchParameterValueCreateManyAndReturnArgs} args - Arguments to create many BatchParameterValues.
     * @example
     * // Create many BatchParameterValues
     * const batchParameterValue = await prisma.batchParameterValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BatchParameterValues and only return the `id`
     * const batchParameterValueWithIdOnly = await prisma.batchParameterValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchParameterValueCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchParameterValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BatchParameterValue.
     * @param {BatchParameterValueDeleteArgs} args - Arguments to delete one BatchParameterValue.
     * @example
     * // Delete one BatchParameterValue
     * const BatchParameterValue = await prisma.batchParameterValue.delete({
     *   where: {
     *     // ... filter to delete one BatchParameterValue
     *   }
     * })
     * 
     */
    delete<T extends BatchParameterValueDeleteArgs>(args: SelectSubset<T, BatchParameterValueDeleteArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BatchParameterValue.
     * @param {BatchParameterValueUpdateArgs} args - Arguments to update one BatchParameterValue.
     * @example
     * // Update one BatchParameterValue
     * const batchParameterValue = await prisma.batchParameterValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchParameterValueUpdateArgs>(args: SelectSubset<T, BatchParameterValueUpdateArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BatchParameterValues.
     * @param {BatchParameterValueDeleteManyArgs} args - Arguments to filter BatchParameterValues to delete.
     * @example
     * // Delete a few BatchParameterValues
     * const { count } = await prisma.batchParameterValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchParameterValueDeleteManyArgs>(args?: SelectSubset<T, BatchParameterValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchParameterValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BatchParameterValues
     * const batchParameterValue = await prisma.batchParameterValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchParameterValueUpdateManyArgs>(args: SelectSubset<T, BatchParameterValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchParameterValues and returns the data updated in the database.
     * @param {BatchParameterValueUpdateManyAndReturnArgs} args - Arguments to update many BatchParameterValues.
     * @example
     * // Update many BatchParameterValues
     * const batchParameterValue = await prisma.batchParameterValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BatchParameterValues and only return the `id`
     * const batchParameterValueWithIdOnly = await prisma.batchParameterValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchParameterValueUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchParameterValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BatchParameterValue.
     * @param {BatchParameterValueUpsertArgs} args - Arguments to update or create a BatchParameterValue.
     * @example
     * // Update or create a BatchParameterValue
     * const batchParameterValue = await prisma.batchParameterValue.upsert({
     *   create: {
     *     // ... data to create a BatchParameterValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BatchParameterValue we want to update
     *   }
     * })
     */
    upsert<T extends BatchParameterValueUpsertArgs>(args: SelectSubset<T, BatchParameterValueUpsertArgs<ExtArgs>>): Prisma__BatchParameterValueClient<$Result.GetResult<Prisma.$BatchParameterValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BatchParameterValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueCountArgs} args - Arguments to filter BatchParameterValues to count.
     * @example
     * // Count the number of BatchParameterValues
     * const count = await prisma.batchParameterValue.count({
     *   where: {
     *     // ... the filter for the BatchParameterValues we want to count
     *   }
     * })
    **/
    count<T extends BatchParameterValueCountArgs>(
      args?: Subset<T, BatchParameterValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchParameterValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BatchParameterValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchParameterValueAggregateArgs>(args: Subset<T, BatchParameterValueAggregateArgs>): Prisma.PrismaPromise<GetBatchParameterValueAggregateType<T>>

    /**
     * Group by BatchParameterValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchParameterValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchParameterValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchParameterValueGroupByArgs['orderBy'] }
        : { orderBy?: BatchParameterValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchParameterValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchParameterValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BatchParameterValue model
   */
  readonly fields: BatchParameterValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BatchParameterValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchParameterValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends BatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatchDefaultArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parameter<T extends StandardParameterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StandardParameterDefaultArgs<ExtArgs>>): Prisma__StandardParameterClient<$Result.GetResult<Prisma.$StandardParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends BatchParameterValue$unitArgs<ExtArgs> = {}>(args?: Subset<T, BatchParameterValue$unitArgs<ExtArgs>>): Prisma__UnitOfMeasurementClient<$Result.GetResult<Prisma.$UnitOfMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    methodology<T extends BatchParameterValue$methodologyArgs<ExtArgs> = {}>(args?: Subset<T, BatchParameterValue$methodologyArgs<ExtArgs>>): Prisma__MethodologyClient<$Result.GetResult<Prisma.$MethodologyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BatchParameterValue model
   */
  interface BatchParameterValueFieldRefs {
    readonly id: FieldRef<"BatchParameterValue", 'String'>
    readonly batchId: FieldRef<"BatchParameterValue", 'String'>
    readonly parameterId: FieldRef<"BatchParameterValue", 'String'>
    readonly value: FieldRef<"BatchParameterValue", 'String'>
    readonly unitId: FieldRef<"BatchParameterValue", 'String'>
    readonly methodologyId: FieldRef<"BatchParameterValue", 'String'>
    readonly createdAt: FieldRef<"BatchParameterValue", 'DateTime'>
    readonly updatedAt: FieldRef<"BatchParameterValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BatchParameterValue findUnique
   */
  export type BatchParameterValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * Filter, which BatchParameterValue to fetch.
     */
    where: BatchParameterValueWhereUniqueInput
  }

  /**
   * BatchParameterValue findUniqueOrThrow
   */
  export type BatchParameterValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * Filter, which BatchParameterValue to fetch.
     */
    where: BatchParameterValueWhereUniqueInput
  }

  /**
   * BatchParameterValue findFirst
   */
  export type BatchParameterValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * Filter, which BatchParameterValue to fetch.
     */
    where?: BatchParameterValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchParameterValues to fetch.
     */
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchParameterValues.
     */
    cursor?: BatchParameterValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchParameterValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchParameterValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchParameterValues.
     */
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * BatchParameterValue findFirstOrThrow
   */
  export type BatchParameterValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * Filter, which BatchParameterValue to fetch.
     */
    where?: BatchParameterValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchParameterValues to fetch.
     */
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchParameterValues.
     */
    cursor?: BatchParameterValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchParameterValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchParameterValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchParameterValues.
     */
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * BatchParameterValue findMany
   */
  export type BatchParameterValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * Filter, which BatchParameterValues to fetch.
     */
    where?: BatchParameterValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchParameterValues to fetch.
     */
    orderBy?: BatchParameterValueOrderByWithRelationInput | BatchParameterValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BatchParameterValues.
     */
    cursor?: BatchParameterValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchParameterValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchParameterValues.
     */
    skip?: number
    distinct?: BatchParameterValueScalarFieldEnum | BatchParameterValueScalarFieldEnum[]
  }

  /**
   * BatchParameterValue create
   */
  export type BatchParameterValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * The data needed to create a BatchParameterValue.
     */
    data: XOR<BatchParameterValueCreateInput, BatchParameterValueUncheckedCreateInput>
  }

  /**
   * BatchParameterValue createMany
   */
  export type BatchParameterValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BatchParameterValues.
     */
    data: BatchParameterValueCreateManyInput | BatchParameterValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BatchParameterValue createManyAndReturn
   */
  export type BatchParameterValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * The data used to create many BatchParameterValues.
     */
    data: BatchParameterValueCreateManyInput | BatchParameterValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchParameterValue update
   */
  export type BatchParameterValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * The data needed to update a BatchParameterValue.
     */
    data: XOR<BatchParameterValueUpdateInput, BatchParameterValueUncheckedUpdateInput>
    /**
     * Choose, which BatchParameterValue to update.
     */
    where: BatchParameterValueWhereUniqueInput
  }

  /**
   * BatchParameterValue updateMany
   */
  export type BatchParameterValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BatchParameterValues.
     */
    data: XOR<BatchParameterValueUpdateManyMutationInput, BatchParameterValueUncheckedUpdateManyInput>
    /**
     * Filter which BatchParameterValues to update
     */
    where?: BatchParameterValueWhereInput
    /**
     * Limit how many BatchParameterValues to update.
     */
    limit?: number
  }

  /**
   * BatchParameterValue updateManyAndReturn
   */
  export type BatchParameterValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * The data used to update BatchParameterValues.
     */
    data: XOR<BatchParameterValueUpdateManyMutationInput, BatchParameterValueUncheckedUpdateManyInput>
    /**
     * Filter which BatchParameterValues to update
     */
    where?: BatchParameterValueWhereInput
    /**
     * Limit how many BatchParameterValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchParameterValue upsert
   */
  export type BatchParameterValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * The filter to search for the BatchParameterValue to update in case it exists.
     */
    where: BatchParameterValueWhereUniqueInput
    /**
     * In case the BatchParameterValue found by the `where` argument doesn't exist, create a new BatchParameterValue with this data.
     */
    create: XOR<BatchParameterValueCreateInput, BatchParameterValueUncheckedCreateInput>
    /**
     * In case the BatchParameterValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchParameterValueUpdateInput, BatchParameterValueUncheckedUpdateInput>
  }

  /**
   * BatchParameterValue delete
   */
  export type BatchParameterValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
    /**
     * Filter which BatchParameterValue to delete.
     */
    where: BatchParameterValueWhereUniqueInput
  }

  /**
   * BatchParameterValue deleteMany
   */
  export type BatchParameterValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchParameterValues to delete
     */
    where?: BatchParameterValueWhereInput
    /**
     * Limit how many BatchParameterValues to delete.
     */
    limit?: number
  }

  /**
   * BatchParameterValue.unit
   */
  export type BatchParameterValue$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitOfMeasurement
     */
    select?: UnitOfMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitOfMeasurement
     */
    omit?: UnitOfMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitOfMeasurementInclude<ExtArgs> | null
    where?: UnitOfMeasurementWhereInput
  }

  /**
   * BatchParameterValue.methodology
   */
  export type BatchParameterValue$methodologyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Methodology
     */
    select?: MethodologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Methodology
     */
    omit?: MethodologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MethodologyInclude<ExtArgs> | null
    where?: MethodologyWhereInput
  }

  /**
   * BatchParameterValue without action
   */
  export type BatchParameterValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchParameterValue
     */
    select?: BatchParameterValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchParameterValue
     */
    omit?: BatchParameterValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchParameterValueInclude<ExtArgs> | null
  }


  /**
   * Model TrainingCalendar
   */

  export type AggregateTrainingCalendar = {
    _count: TrainingCalendarCountAggregateOutputType | null
    _avg: TrainingCalendarAvgAggregateOutputType | null
    _sum: TrainingCalendarSumAggregateOutputType | null
    _min: TrainingCalendarMinAggregateOutputType | null
    _max: TrainingCalendarMaxAggregateOutputType | null
  }

  export type TrainingCalendarAvgAggregateOutputType = {
    month: number | null
    year: number | null
  }

  export type TrainingCalendarSumAggregateOutputType = {
    month: number | null
    year: number | null
  }

  export type TrainingCalendarMinAggregateOutputType = {
    id: string | null
    month: number | null
    year: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingCalendarMaxAggregateOutputType = {
    id: string | null
    month: number | null
    year: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingCalendarCountAggregateOutputType = {
    id: number
    month: number
    year: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingCalendarAvgAggregateInputType = {
    month?: true
    year?: true
  }

  export type TrainingCalendarSumAggregateInputType = {
    month?: true
    year?: true
  }

  export type TrainingCalendarMinAggregateInputType = {
    id?: true
    month?: true
    year?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingCalendarMaxAggregateInputType = {
    id?: true
    month?: true
    year?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingCalendarCountAggregateInputType = {
    id?: true
    month?: true
    year?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingCalendarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingCalendar to aggregate.
     */
    where?: TrainingCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingCalendars to fetch.
     */
    orderBy?: TrainingCalendarOrderByWithRelationInput | TrainingCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingCalendars
    **/
    _count?: true | TrainingCalendarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingCalendarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingCalendarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingCalendarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingCalendarMaxAggregateInputType
  }

  export type GetTrainingCalendarAggregateType<T extends TrainingCalendarAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingCalendar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingCalendar[P]>
      : GetScalarType<T[P], AggregateTrainingCalendar[P]>
  }




  export type TrainingCalendarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingCalendarWhereInput
    orderBy?: TrainingCalendarOrderByWithAggregationInput | TrainingCalendarOrderByWithAggregationInput[]
    by: TrainingCalendarScalarFieldEnum[] | TrainingCalendarScalarFieldEnum
    having?: TrainingCalendarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingCalendarCountAggregateInputType | true
    _avg?: TrainingCalendarAvgAggregateInputType
    _sum?: TrainingCalendarSumAggregateInputType
    _min?: TrainingCalendarMinAggregateInputType
    _max?: TrainingCalendarMaxAggregateInputType
  }

  export type TrainingCalendarGroupByOutputType = {
    id: string
    month: number
    year: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TrainingCalendarCountAggregateOutputType | null
    _avg: TrainingCalendarAvgAggregateOutputType | null
    _sum: TrainingCalendarSumAggregateOutputType | null
    _min: TrainingCalendarMinAggregateOutputType | null
    _max: TrainingCalendarMaxAggregateOutputType | null
  }

  type GetTrainingCalendarGroupByPayload<T extends TrainingCalendarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingCalendarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingCalendarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingCalendarGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingCalendarGroupByOutputType[P]>
        }
      >
    >


  export type TrainingCalendarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    year?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainings?: boolean | TrainingCalendar$trainingsArgs<ExtArgs>
    _count?: boolean | TrainingCalendarCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingCalendar"]>

  export type TrainingCalendarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    year?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingCalendar"]>

  export type TrainingCalendarSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    year?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingCalendar"]>

  export type TrainingCalendarSelectScalar = {
    id?: boolean
    month?: boolean
    year?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingCalendarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "year" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingCalendar"]>
  export type TrainingCalendarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | TrainingCalendar$trainingsArgs<ExtArgs>
    _count?: boolean | TrainingCalendarCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingCalendarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TrainingCalendarIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TrainingCalendarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingCalendar"
    objects: {
      trainings: Prisma.$TrainingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      month: number
      year: number
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingCalendar"]>
    composites: {}
  }

  type TrainingCalendarGetPayload<S extends boolean | null | undefined | TrainingCalendarDefaultArgs> = $Result.GetResult<Prisma.$TrainingCalendarPayload, S>

  type TrainingCalendarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingCalendarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingCalendarCountAggregateInputType | true
    }

  export interface TrainingCalendarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingCalendar'], meta: { name: 'TrainingCalendar' } }
    /**
     * Find zero or one TrainingCalendar that matches the filter.
     * @param {TrainingCalendarFindUniqueArgs} args - Arguments to find a TrainingCalendar
     * @example
     * // Get one TrainingCalendar
     * const trainingCalendar = await prisma.trainingCalendar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingCalendarFindUniqueArgs>(args: SelectSubset<T, TrainingCalendarFindUniqueArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingCalendar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingCalendarFindUniqueOrThrowArgs} args - Arguments to find a TrainingCalendar
     * @example
     * // Get one TrainingCalendar
     * const trainingCalendar = await prisma.trainingCalendar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingCalendarFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingCalendarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingCalendar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarFindFirstArgs} args - Arguments to find a TrainingCalendar
     * @example
     * // Get one TrainingCalendar
     * const trainingCalendar = await prisma.trainingCalendar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingCalendarFindFirstArgs>(args?: SelectSubset<T, TrainingCalendarFindFirstArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingCalendar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarFindFirstOrThrowArgs} args - Arguments to find a TrainingCalendar
     * @example
     * // Get one TrainingCalendar
     * const trainingCalendar = await prisma.trainingCalendar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingCalendarFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingCalendarFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingCalendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingCalendars
     * const trainingCalendars = await prisma.trainingCalendar.findMany()
     * 
     * // Get first 10 TrainingCalendars
     * const trainingCalendars = await prisma.trainingCalendar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingCalendarWithIdOnly = await prisma.trainingCalendar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingCalendarFindManyArgs>(args?: SelectSubset<T, TrainingCalendarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingCalendar.
     * @param {TrainingCalendarCreateArgs} args - Arguments to create a TrainingCalendar.
     * @example
     * // Create one TrainingCalendar
     * const TrainingCalendar = await prisma.trainingCalendar.create({
     *   data: {
     *     // ... data to create a TrainingCalendar
     *   }
     * })
     * 
     */
    create<T extends TrainingCalendarCreateArgs>(args: SelectSubset<T, TrainingCalendarCreateArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingCalendars.
     * @param {TrainingCalendarCreateManyArgs} args - Arguments to create many TrainingCalendars.
     * @example
     * // Create many TrainingCalendars
     * const trainingCalendar = await prisma.trainingCalendar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingCalendarCreateManyArgs>(args?: SelectSubset<T, TrainingCalendarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingCalendars and returns the data saved in the database.
     * @param {TrainingCalendarCreateManyAndReturnArgs} args - Arguments to create many TrainingCalendars.
     * @example
     * // Create many TrainingCalendars
     * const trainingCalendar = await prisma.trainingCalendar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingCalendars and only return the `id`
     * const trainingCalendarWithIdOnly = await prisma.trainingCalendar.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingCalendarCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingCalendarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingCalendar.
     * @param {TrainingCalendarDeleteArgs} args - Arguments to delete one TrainingCalendar.
     * @example
     * // Delete one TrainingCalendar
     * const TrainingCalendar = await prisma.trainingCalendar.delete({
     *   where: {
     *     // ... filter to delete one TrainingCalendar
     *   }
     * })
     * 
     */
    delete<T extends TrainingCalendarDeleteArgs>(args: SelectSubset<T, TrainingCalendarDeleteArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingCalendar.
     * @param {TrainingCalendarUpdateArgs} args - Arguments to update one TrainingCalendar.
     * @example
     * // Update one TrainingCalendar
     * const trainingCalendar = await prisma.trainingCalendar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingCalendarUpdateArgs>(args: SelectSubset<T, TrainingCalendarUpdateArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingCalendars.
     * @param {TrainingCalendarDeleteManyArgs} args - Arguments to filter TrainingCalendars to delete.
     * @example
     * // Delete a few TrainingCalendars
     * const { count } = await prisma.trainingCalendar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingCalendarDeleteManyArgs>(args?: SelectSubset<T, TrainingCalendarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingCalendars
     * const trainingCalendar = await prisma.trainingCalendar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingCalendarUpdateManyArgs>(args: SelectSubset<T, TrainingCalendarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingCalendars and returns the data updated in the database.
     * @param {TrainingCalendarUpdateManyAndReturnArgs} args - Arguments to update many TrainingCalendars.
     * @example
     * // Update many TrainingCalendars
     * const trainingCalendar = await prisma.trainingCalendar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingCalendars and only return the `id`
     * const trainingCalendarWithIdOnly = await prisma.trainingCalendar.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingCalendarUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingCalendarUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingCalendar.
     * @param {TrainingCalendarUpsertArgs} args - Arguments to update or create a TrainingCalendar.
     * @example
     * // Update or create a TrainingCalendar
     * const trainingCalendar = await prisma.trainingCalendar.upsert({
     *   create: {
     *     // ... data to create a TrainingCalendar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingCalendar we want to update
     *   }
     * })
     */
    upsert<T extends TrainingCalendarUpsertArgs>(args: SelectSubset<T, TrainingCalendarUpsertArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingCalendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarCountArgs} args - Arguments to filter TrainingCalendars to count.
     * @example
     * // Count the number of TrainingCalendars
     * const count = await prisma.trainingCalendar.count({
     *   where: {
     *     // ... the filter for the TrainingCalendars we want to count
     *   }
     * })
    **/
    count<T extends TrainingCalendarCountArgs>(
      args?: Subset<T, TrainingCalendarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingCalendarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingCalendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingCalendarAggregateArgs>(args: Subset<T, TrainingCalendarAggregateArgs>): Prisma.PrismaPromise<GetTrainingCalendarAggregateType<T>>

    /**
     * Group by TrainingCalendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCalendarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingCalendarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingCalendarGroupByArgs['orderBy'] }
        : { orderBy?: TrainingCalendarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingCalendarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingCalendarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingCalendar model
   */
  readonly fields: TrainingCalendarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingCalendar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingCalendarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainings<T extends TrainingCalendar$trainingsArgs<ExtArgs> = {}>(args?: Subset<T, TrainingCalendar$trainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingCalendar model
   */
  interface TrainingCalendarFieldRefs {
    readonly id: FieldRef<"TrainingCalendar", 'String'>
    readonly month: FieldRef<"TrainingCalendar", 'Int'>
    readonly year: FieldRef<"TrainingCalendar", 'Int'>
    readonly description: FieldRef<"TrainingCalendar", 'String'>
    readonly createdAt: FieldRef<"TrainingCalendar", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingCalendar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingCalendar findUnique
   */
  export type TrainingCalendarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * Filter, which TrainingCalendar to fetch.
     */
    where: TrainingCalendarWhereUniqueInput
  }

  /**
   * TrainingCalendar findUniqueOrThrow
   */
  export type TrainingCalendarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * Filter, which TrainingCalendar to fetch.
     */
    where: TrainingCalendarWhereUniqueInput
  }

  /**
   * TrainingCalendar findFirst
   */
  export type TrainingCalendarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * Filter, which TrainingCalendar to fetch.
     */
    where?: TrainingCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingCalendars to fetch.
     */
    orderBy?: TrainingCalendarOrderByWithRelationInput | TrainingCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingCalendars.
     */
    cursor?: TrainingCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingCalendars.
     */
    distinct?: TrainingCalendarScalarFieldEnum | TrainingCalendarScalarFieldEnum[]
  }

  /**
   * TrainingCalendar findFirstOrThrow
   */
  export type TrainingCalendarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * Filter, which TrainingCalendar to fetch.
     */
    where?: TrainingCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingCalendars to fetch.
     */
    orderBy?: TrainingCalendarOrderByWithRelationInput | TrainingCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingCalendars.
     */
    cursor?: TrainingCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingCalendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingCalendars.
     */
    distinct?: TrainingCalendarScalarFieldEnum | TrainingCalendarScalarFieldEnum[]
  }

  /**
   * TrainingCalendar findMany
   */
  export type TrainingCalendarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * Filter, which TrainingCalendars to fetch.
     */
    where?: TrainingCalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingCalendars to fetch.
     */
    orderBy?: TrainingCalendarOrderByWithRelationInput | TrainingCalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingCalendars.
     */
    cursor?: TrainingCalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingCalendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingCalendars.
     */
    skip?: number
    distinct?: TrainingCalendarScalarFieldEnum | TrainingCalendarScalarFieldEnum[]
  }

  /**
   * TrainingCalendar create
   */
  export type TrainingCalendarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingCalendar.
     */
    data: XOR<TrainingCalendarCreateInput, TrainingCalendarUncheckedCreateInput>
  }

  /**
   * TrainingCalendar createMany
   */
  export type TrainingCalendarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingCalendars.
     */
    data: TrainingCalendarCreateManyInput | TrainingCalendarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingCalendar createManyAndReturn
   */
  export type TrainingCalendarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingCalendars.
     */
    data: TrainingCalendarCreateManyInput | TrainingCalendarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingCalendar update
   */
  export type TrainingCalendarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingCalendar.
     */
    data: XOR<TrainingCalendarUpdateInput, TrainingCalendarUncheckedUpdateInput>
    /**
     * Choose, which TrainingCalendar to update.
     */
    where: TrainingCalendarWhereUniqueInput
  }

  /**
   * TrainingCalendar updateMany
   */
  export type TrainingCalendarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingCalendars.
     */
    data: XOR<TrainingCalendarUpdateManyMutationInput, TrainingCalendarUncheckedUpdateManyInput>
    /**
     * Filter which TrainingCalendars to update
     */
    where?: TrainingCalendarWhereInput
    /**
     * Limit how many TrainingCalendars to update.
     */
    limit?: number
  }

  /**
   * TrainingCalendar updateManyAndReturn
   */
  export type TrainingCalendarUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * The data used to update TrainingCalendars.
     */
    data: XOR<TrainingCalendarUpdateManyMutationInput, TrainingCalendarUncheckedUpdateManyInput>
    /**
     * Filter which TrainingCalendars to update
     */
    where?: TrainingCalendarWhereInput
    /**
     * Limit how many TrainingCalendars to update.
     */
    limit?: number
  }

  /**
   * TrainingCalendar upsert
   */
  export type TrainingCalendarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingCalendar to update in case it exists.
     */
    where: TrainingCalendarWhereUniqueInput
    /**
     * In case the TrainingCalendar found by the `where` argument doesn't exist, create a new TrainingCalendar with this data.
     */
    create: XOR<TrainingCalendarCreateInput, TrainingCalendarUncheckedCreateInput>
    /**
     * In case the TrainingCalendar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingCalendarUpdateInput, TrainingCalendarUncheckedUpdateInput>
  }

  /**
   * TrainingCalendar delete
   */
  export type TrainingCalendarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
    /**
     * Filter which TrainingCalendar to delete.
     */
    where: TrainingCalendarWhereUniqueInput
  }

  /**
   * TrainingCalendar deleteMany
   */
  export type TrainingCalendarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingCalendars to delete
     */
    where?: TrainingCalendarWhereInput
    /**
     * Limit how many TrainingCalendars to delete.
     */
    limit?: number
  }

  /**
   * TrainingCalendar.trainings
   */
  export type TrainingCalendar$trainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    where?: TrainingWhereInput
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    cursor?: TrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * TrainingCalendar without action
   */
  export type TrainingCalendarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCalendar
     */
    select?: TrainingCalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingCalendar
     */
    omit?: TrainingCalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingCalendarInclude<ExtArgs> | null
  }


  /**
   * Model Training
   */

  export type AggregateTraining = {
    _count: TrainingCountAggregateOutputType | null
    _avg: TrainingAvgAggregateOutputType | null
    _sum: TrainingSumAggregateOutputType | null
    _min: TrainingMinAggregateOutputType | null
    _max: TrainingMaxAggregateOutputType | null
  }

  export type TrainingAvgAggregateOutputType = {
    maxParticipants: number | null
  }

  export type TrainingSumAggregateOutputType = {
    maxParticipants: number | null
  }

  export type TrainingMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    trainingType: $Enums.TrainingType | null
    status: $Enums.TrainingStatus | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    maxParticipants: number | null
    trainerId: string | null
    calendarId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    trainingType: $Enums.TrainingType | null
    status: $Enums.TrainingStatus | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    maxParticipants: number | null
    trainerId: string | null
    calendarId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingCountAggregateOutputType = {
    id: number
    title: number
    description: number
    trainingType: number
    status: number
    startDate: number
    endDate: number
    location: number
    maxParticipants: number
    trainerId: number
    calendarId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingAvgAggregateInputType = {
    maxParticipants?: true
  }

  export type TrainingSumAggregateInputType = {
    maxParticipants?: true
  }

  export type TrainingMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    trainingType?: true
    status?: true
    startDate?: true
    endDate?: true
    location?: true
    maxParticipants?: true
    trainerId?: true
    calendarId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    trainingType?: true
    status?: true
    startDate?: true
    endDate?: true
    location?: true
    maxParticipants?: true
    trainerId?: true
    calendarId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    trainingType?: true
    status?: true
    startDate?: true
    endDate?: true
    location?: true
    maxParticipants?: true
    trainerId?: true
    calendarId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Training to aggregate.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trainings
    **/
    _count?: true | TrainingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingMaxAggregateInputType
  }

  export type GetTrainingAggregateType<T extends TrainingAggregateArgs> = {
        [P in keyof T & keyof AggregateTraining]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraining[P]>
      : GetScalarType<T[P], AggregateTraining[P]>
  }




  export type TrainingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWhereInput
    orderBy?: TrainingOrderByWithAggregationInput | TrainingOrderByWithAggregationInput[]
    by: TrainingScalarFieldEnum[] | TrainingScalarFieldEnum
    having?: TrainingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingCountAggregateInputType | true
    _avg?: TrainingAvgAggregateInputType
    _sum?: TrainingSumAggregateInputType
    _min?: TrainingMinAggregateInputType
    _max?: TrainingMaxAggregateInputType
  }

  export type TrainingGroupByOutputType = {
    id: string
    title: string
    description: string | null
    trainingType: $Enums.TrainingType
    status: $Enums.TrainingStatus
    startDate: Date
    endDate: Date
    location: string
    maxParticipants: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: TrainingCountAggregateOutputType | null
    _avg: TrainingAvgAggregateOutputType | null
    _sum: TrainingSumAggregateOutputType | null
    _min: TrainingMinAggregateOutputType | null
    _max: TrainingMaxAggregateOutputType | null
  }

  type GetTrainingGroupByPayload<T extends TrainingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingGroupByOutputType[P]>
        }
      >
    >


  export type TrainingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    trainingType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    maxParticipants?: boolean
    trainerId?: boolean
    calendarId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    calendar?: boolean | TrainingCalendarDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    sessions?: boolean | Training$sessionsArgs<ExtArgs>
    documents?: boolean | Training$documentsArgs<ExtArgs>
    attendance?: boolean | Training$attendanceArgs<ExtArgs>
    participants?: boolean | Training$participantsArgs<ExtArgs>
    photos?: boolean | Training$photosArgs<ExtArgs>
    feedback?: boolean | Training$feedbackArgs<ExtArgs>
    followups?: boolean | Training$followupsArgs<ExtArgs>
    notifications?: boolean | Training$notificationsArgs<ExtArgs>
    _count?: boolean | TrainingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["training"]>

  export type TrainingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    trainingType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    maxParticipants?: boolean
    trainerId?: boolean
    calendarId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    calendar?: boolean | TrainingCalendarDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["training"]>

  export type TrainingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    trainingType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    maxParticipants?: boolean
    trainerId?: boolean
    calendarId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    calendar?: boolean | TrainingCalendarDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["training"]>

  export type TrainingSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    trainingType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    maxParticipants?: boolean
    trainerId?: boolean
    calendarId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "trainingType" | "status" | "startDate" | "endDate" | "location" | "maxParticipants" | "trainerId" | "calendarId" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["training"]>
  export type TrainingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    calendar?: boolean | TrainingCalendarDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    sessions?: boolean | Training$sessionsArgs<ExtArgs>
    documents?: boolean | Training$documentsArgs<ExtArgs>
    attendance?: boolean | Training$attendanceArgs<ExtArgs>
    participants?: boolean | Training$participantsArgs<ExtArgs>
    photos?: boolean | Training$photosArgs<ExtArgs>
    feedback?: boolean | Training$feedbackArgs<ExtArgs>
    followups?: boolean | Training$followupsArgs<ExtArgs>
    notifications?: boolean | Training$notificationsArgs<ExtArgs>
    _count?: boolean | TrainingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    calendar?: boolean | TrainingCalendarDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainer?: boolean | UserDefaultArgs<ExtArgs>
    calendar?: boolean | TrainingCalendarDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Training"
    objects: {
      trainer: Prisma.$UserPayload<ExtArgs>
      calendar: Prisma.$TrainingCalendarPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      sessions: Prisma.$TrainingSessionPayload<ExtArgs>[]
      documents: Prisma.$TrainingDocumentPayload<ExtArgs>[]
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
      participants: Prisma.$TrainingParticipantPayload<ExtArgs>[]
      photos: Prisma.$TrainingPhotoPayload<ExtArgs>[]
      feedback: Prisma.$TrainingFeedbackPayload<ExtArgs>[]
      followups: Prisma.$TrainingFollowupPayload<ExtArgs>[]
      notifications: Prisma.$TrainingNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      trainingType: $Enums.TrainingType
      status: $Enums.TrainingStatus
      startDate: Date
      endDate: Date
      location: string
      maxParticipants: number | null
      trainerId: string
      calendarId: string
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["training"]>
    composites: {}
  }

  type TrainingGetPayload<S extends boolean | null | undefined | TrainingDefaultArgs> = $Result.GetResult<Prisma.$TrainingPayload, S>

  type TrainingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingCountAggregateInputType | true
    }

  export interface TrainingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Training'], meta: { name: 'Training' } }
    /**
     * Find zero or one Training that matches the filter.
     * @param {TrainingFindUniqueArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingFindUniqueArgs>(args: SelectSubset<T, TrainingFindUniqueArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Training that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingFindUniqueOrThrowArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Training that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindFirstArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingFindFirstArgs>(args?: SelectSubset<T, TrainingFindFirstArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Training that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindFirstOrThrowArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trainings
     * const trainings = await prisma.training.findMany()
     * 
     * // Get first 10 Trainings
     * const trainings = await prisma.training.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingWithIdOnly = await prisma.training.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingFindManyArgs>(args?: SelectSubset<T, TrainingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Training.
     * @param {TrainingCreateArgs} args - Arguments to create a Training.
     * @example
     * // Create one Training
     * const Training = await prisma.training.create({
     *   data: {
     *     // ... data to create a Training
     *   }
     * })
     * 
     */
    create<T extends TrainingCreateArgs>(args: SelectSubset<T, TrainingCreateArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trainings.
     * @param {TrainingCreateManyArgs} args - Arguments to create many Trainings.
     * @example
     * // Create many Trainings
     * const training = await prisma.training.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingCreateManyArgs>(args?: SelectSubset<T, TrainingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trainings and returns the data saved in the database.
     * @param {TrainingCreateManyAndReturnArgs} args - Arguments to create many Trainings.
     * @example
     * // Create many Trainings
     * const training = await prisma.training.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trainings and only return the `id`
     * const trainingWithIdOnly = await prisma.training.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Training.
     * @param {TrainingDeleteArgs} args - Arguments to delete one Training.
     * @example
     * // Delete one Training
     * const Training = await prisma.training.delete({
     *   where: {
     *     // ... filter to delete one Training
     *   }
     * })
     * 
     */
    delete<T extends TrainingDeleteArgs>(args: SelectSubset<T, TrainingDeleteArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Training.
     * @param {TrainingUpdateArgs} args - Arguments to update one Training.
     * @example
     * // Update one Training
     * const training = await prisma.training.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingUpdateArgs>(args: SelectSubset<T, TrainingUpdateArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trainings.
     * @param {TrainingDeleteManyArgs} args - Arguments to filter Trainings to delete.
     * @example
     * // Delete a few Trainings
     * const { count } = await prisma.training.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingDeleteManyArgs>(args?: SelectSubset<T, TrainingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trainings
     * const training = await prisma.training.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingUpdateManyArgs>(args: SelectSubset<T, TrainingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings and returns the data updated in the database.
     * @param {TrainingUpdateManyAndReturnArgs} args - Arguments to update many Trainings.
     * @example
     * // Update many Trainings
     * const training = await prisma.training.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trainings and only return the `id`
     * const trainingWithIdOnly = await prisma.training.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Training.
     * @param {TrainingUpsertArgs} args - Arguments to update or create a Training.
     * @example
     * // Update or create a Training
     * const training = await prisma.training.upsert({
     *   create: {
     *     // ... data to create a Training
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Training we want to update
     *   }
     * })
     */
    upsert<T extends TrainingUpsertArgs>(args: SelectSubset<T, TrainingUpsertArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCountArgs} args - Arguments to filter Trainings to count.
     * @example
     * // Count the number of Trainings
     * const count = await prisma.training.count({
     *   where: {
     *     // ... the filter for the Trainings we want to count
     *   }
     * })
    **/
    count<T extends TrainingCountArgs>(
      args?: Subset<T, TrainingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingAggregateArgs>(args: Subset<T, TrainingAggregateArgs>): Prisma.PrismaPromise<GetTrainingAggregateType<T>>

    /**
     * Group by Training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingGroupByArgs['orderBy'] }
        : { orderBy?: TrainingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Training model
   */
  readonly fields: TrainingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Training.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    calendar<T extends TrainingCalendarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingCalendarDefaultArgs<ExtArgs>>): Prisma__TrainingCalendarClient<$Result.GetResult<Prisma.$TrainingCalendarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessions<T extends Training$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Training$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Training$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Training$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends Training$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Training$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    participants<T extends Training$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Training$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos<T extends Training$photosArgs<ExtArgs> = {}>(args?: Subset<T, Training$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedback<T extends Training$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, Training$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followups<T extends Training$followupsArgs<ExtArgs> = {}>(args?: Subset<T, Training$followupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Training$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Training$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Training model
   */
  interface TrainingFieldRefs {
    readonly id: FieldRef<"Training", 'String'>
    readonly title: FieldRef<"Training", 'String'>
    readonly description: FieldRef<"Training", 'String'>
    readonly trainingType: FieldRef<"Training", 'TrainingType'>
    readonly status: FieldRef<"Training", 'TrainingStatus'>
    readonly startDate: FieldRef<"Training", 'DateTime'>
    readonly endDate: FieldRef<"Training", 'DateTime'>
    readonly location: FieldRef<"Training", 'String'>
    readonly maxParticipants: FieldRef<"Training", 'Int'>
    readonly trainerId: FieldRef<"Training", 'String'>
    readonly calendarId: FieldRef<"Training", 'String'>
    readonly createdById: FieldRef<"Training", 'String'>
    readonly createdAt: FieldRef<"Training", 'DateTime'>
    readonly updatedAt: FieldRef<"Training", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Training findUnique
   */
  export type TrainingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training findUniqueOrThrow
   */
  export type TrainingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training findFirst
   */
  export type TrainingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainings.
     */
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * Training findFirstOrThrow
   */
  export type TrainingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainings.
     */
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * Training findMany
   */
  export type TrainingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Trainings to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * Training create
   */
  export type TrainingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The data needed to create a Training.
     */
    data: XOR<TrainingCreateInput, TrainingUncheckedCreateInput>
  }

  /**
   * Training createMany
   */
  export type TrainingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trainings.
     */
    data: TrainingCreateManyInput | TrainingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Training createManyAndReturn
   */
  export type TrainingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * The data used to create many Trainings.
     */
    data: TrainingCreateManyInput | TrainingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Training update
   */
  export type TrainingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The data needed to update a Training.
     */
    data: XOR<TrainingUpdateInput, TrainingUncheckedUpdateInput>
    /**
     * Choose, which Training to update.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training updateMany
   */
  export type TrainingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trainings.
     */
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyInput>
    /**
     * Filter which Trainings to update
     */
    where?: TrainingWhereInput
    /**
     * Limit how many Trainings to update.
     */
    limit?: number
  }

  /**
   * Training updateManyAndReturn
   */
  export type TrainingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * The data used to update Trainings.
     */
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyInput>
    /**
     * Filter which Trainings to update
     */
    where?: TrainingWhereInput
    /**
     * Limit how many Trainings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Training upsert
   */
  export type TrainingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The filter to search for the Training to update in case it exists.
     */
    where: TrainingWhereUniqueInput
    /**
     * In case the Training found by the `where` argument doesn't exist, create a new Training with this data.
     */
    create: XOR<TrainingCreateInput, TrainingUncheckedCreateInput>
    /**
     * In case the Training was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingUpdateInput, TrainingUncheckedUpdateInput>
  }

  /**
   * Training delete
   */
  export type TrainingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter which Training to delete.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training deleteMany
   */
  export type TrainingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trainings to delete
     */
    where?: TrainingWhereInput
    /**
     * Limit how many Trainings to delete.
     */
    limit?: number
  }

  /**
   * Training.sessions
   */
  export type Training$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    where?: TrainingSessionWhereInput
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    cursor?: TrainingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingSessionScalarFieldEnum | TrainingSessionScalarFieldEnum[]
  }

  /**
   * Training.documents
   */
  export type Training$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    where?: TrainingDocumentWhereInput
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    cursor?: TrainingDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * Training.attendance
   */
  export type Training$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Training.participants
   */
  export type Training$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    where?: TrainingParticipantWhereInput
    orderBy?: TrainingParticipantOrderByWithRelationInput | TrainingParticipantOrderByWithRelationInput[]
    cursor?: TrainingParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingParticipantScalarFieldEnum | TrainingParticipantScalarFieldEnum[]
  }

  /**
   * Training.photos
   */
  export type Training$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    where?: TrainingPhotoWhereInput
    orderBy?: TrainingPhotoOrderByWithRelationInput | TrainingPhotoOrderByWithRelationInput[]
    cursor?: TrainingPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingPhotoScalarFieldEnum | TrainingPhotoScalarFieldEnum[]
  }

  /**
   * Training.feedback
   */
  export type Training$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    where?: TrainingFeedbackWhereInput
    orderBy?: TrainingFeedbackOrderByWithRelationInput | TrainingFeedbackOrderByWithRelationInput[]
    cursor?: TrainingFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingFeedbackScalarFieldEnum | TrainingFeedbackScalarFieldEnum[]
  }

  /**
   * Training.followups
   */
  export type Training$followupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    where?: TrainingFollowupWhereInput
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    cursor?: TrainingFollowupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingFollowupScalarFieldEnum | TrainingFollowupScalarFieldEnum[]
  }

  /**
   * Training.notifications
   */
  export type Training$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    where?: TrainingNotificationWhereInput
    orderBy?: TrainingNotificationOrderByWithRelationInput | TrainingNotificationOrderByWithRelationInput[]
    cursor?: TrainingNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingNotificationScalarFieldEnum | TrainingNotificationScalarFieldEnum[]
  }

  /**
   * Training without action
   */
  export type TrainingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Training
     */
    omit?: TrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
  }


  /**
   * Model TrainingSession
   */

  export type AggregateTrainingSession = {
    _count: TrainingSessionCountAggregateOutputType | null
    _min: TrainingSessionMinAggregateOutputType | null
    _max: TrainingSessionMaxAggregateOutputType | null
  }

  export type TrainingSessionMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    venue: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingSessionMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    venue: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingSessionCountAggregateOutputType = {
    id: number
    trainingId: number
    title: number
    description: number
    startTime: number
    endTime: number
    venue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingSessionMinAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    venue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingSessionMaxAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    venue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingSessionCountAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    venue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingSession to aggregate.
     */
    where?: TrainingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessions to fetch.
     */
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingSessions
    **/
    _count?: true | TrainingSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingSessionMaxAggregateInputType
  }

  export type GetTrainingSessionAggregateType<T extends TrainingSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingSession[P]>
      : GetScalarType<T[P], AggregateTrainingSession[P]>
  }




  export type TrainingSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingSessionWhereInput
    orderBy?: TrainingSessionOrderByWithAggregationInput | TrainingSessionOrderByWithAggregationInput[]
    by: TrainingSessionScalarFieldEnum[] | TrainingSessionScalarFieldEnum
    having?: TrainingSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingSessionCountAggregateInputType | true
    _min?: TrainingSessionMinAggregateInputType
    _max?: TrainingSessionMaxAggregateInputType
  }

  export type TrainingSessionGroupByOutputType = {
    id: string
    trainingId: string
    title: string
    description: string | null
    startTime: Date
    endTime: Date
    venue: string
    createdAt: Date
    updatedAt: Date
    _count: TrainingSessionCountAggregateOutputType | null
    _min: TrainingSessionMinAggregateOutputType | null
    _max: TrainingSessionMaxAggregateOutputType | null
  }

  type GetTrainingSessionGroupByPayload<T extends TrainingSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingSessionGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingSessionGroupByOutputType[P]>
        }
      >
    >


  export type TrainingSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    venue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    attendance?: boolean | TrainingSession$attendanceArgs<ExtArgs>
    _count?: boolean | TrainingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingSession"]>

  export type TrainingSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    venue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingSession"]>

  export type TrainingSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    venue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingSession"]>

  export type TrainingSessionSelectScalar = {
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    venue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "title" | "description" | "startTime" | "endTime" | "venue" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingSession"]>
  export type TrainingSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    attendance?: boolean | TrainingSession$attendanceArgs<ExtArgs>
    _count?: boolean | TrainingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
  }
  export type TrainingSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
  }

  export type $TrainingSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingSession"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      title: string
      description: string | null
      startTime: Date
      endTime: Date
      venue: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingSession"]>
    composites: {}
  }

  type TrainingSessionGetPayload<S extends boolean | null | undefined | TrainingSessionDefaultArgs> = $Result.GetResult<Prisma.$TrainingSessionPayload, S>

  type TrainingSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingSessionCountAggregateInputType | true
    }

  export interface TrainingSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingSession'], meta: { name: 'TrainingSession' } }
    /**
     * Find zero or one TrainingSession that matches the filter.
     * @param {TrainingSessionFindUniqueArgs} args - Arguments to find a TrainingSession
     * @example
     * // Get one TrainingSession
     * const trainingSession = await prisma.trainingSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingSessionFindUniqueArgs>(args: SelectSubset<T, TrainingSessionFindUniqueArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingSessionFindUniqueOrThrowArgs} args - Arguments to find a TrainingSession
     * @example
     * // Get one TrainingSession
     * const trainingSession = await prisma.trainingSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionFindFirstArgs} args - Arguments to find a TrainingSession
     * @example
     * // Get one TrainingSession
     * const trainingSession = await prisma.trainingSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingSessionFindFirstArgs>(args?: SelectSubset<T, TrainingSessionFindFirstArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionFindFirstOrThrowArgs} args - Arguments to find a TrainingSession
     * @example
     * // Get one TrainingSession
     * const trainingSession = await prisma.trainingSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingSessions
     * const trainingSessions = await prisma.trainingSession.findMany()
     * 
     * // Get first 10 TrainingSessions
     * const trainingSessions = await prisma.trainingSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingSessionWithIdOnly = await prisma.trainingSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingSessionFindManyArgs>(args?: SelectSubset<T, TrainingSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingSession.
     * @param {TrainingSessionCreateArgs} args - Arguments to create a TrainingSession.
     * @example
     * // Create one TrainingSession
     * const TrainingSession = await prisma.trainingSession.create({
     *   data: {
     *     // ... data to create a TrainingSession
     *   }
     * })
     * 
     */
    create<T extends TrainingSessionCreateArgs>(args: SelectSubset<T, TrainingSessionCreateArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingSessions.
     * @param {TrainingSessionCreateManyArgs} args - Arguments to create many TrainingSessions.
     * @example
     * // Create many TrainingSessions
     * const trainingSession = await prisma.trainingSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingSessionCreateManyArgs>(args?: SelectSubset<T, TrainingSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingSessions and returns the data saved in the database.
     * @param {TrainingSessionCreateManyAndReturnArgs} args - Arguments to create many TrainingSessions.
     * @example
     * // Create many TrainingSessions
     * const trainingSession = await prisma.trainingSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingSessions and only return the `id`
     * const trainingSessionWithIdOnly = await prisma.trainingSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingSession.
     * @param {TrainingSessionDeleteArgs} args - Arguments to delete one TrainingSession.
     * @example
     * // Delete one TrainingSession
     * const TrainingSession = await prisma.trainingSession.delete({
     *   where: {
     *     // ... filter to delete one TrainingSession
     *   }
     * })
     * 
     */
    delete<T extends TrainingSessionDeleteArgs>(args: SelectSubset<T, TrainingSessionDeleteArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingSession.
     * @param {TrainingSessionUpdateArgs} args - Arguments to update one TrainingSession.
     * @example
     * // Update one TrainingSession
     * const trainingSession = await prisma.trainingSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingSessionUpdateArgs>(args: SelectSubset<T, TrainingSessionUpdateArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingSessions.
     * @param {TrainingSessionDeleteManyArgs} args - Arguments to filter TrainingSessions to delete.
     * @example
     * // Delete a few TrainingSessions
     * const { count } = await prisma.trainingSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingSessionDeleteManyArgs>(args?: SelectSubset<T, TrainingSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingSessions
     * const trainingSession = await prisma.trainingSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingSessionUpdateManyArgs>(args: SelectSubset<T, TrainingSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingSessions and returns the data updated in the database.
     * @param {TrainingSessionUpdateManyAndReturnArgs} args - Arguments to update many TrainingSessions.
     * @example
     * // Update many TrainingSessions
     * const trainingSession = await prisma.trainingSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingSessions and only return the `id`
     * const trainingSessionWithIdOnly = await prisma.trainingSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingSession.
     * @param {TrainingSessionUpsertArgs} args - Arguments to update or create a TrainingSession.
     * @example
     * // Update or create a TrainingSession
     * const trainingSession = await prisma.trainingSession.upsert({
     *   create: {
     *     // ... data to create a TrainingSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingSession we want to update
     *   }
     * })
     */
    upsert<T extends TrainingSessionUpsertArgs>(args: SelectSubset<T, TrainingSessionUpsertArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionCountArgs} args - Arguments to filter TrainingSessions to count.
     * @example
     * // Count the number of TrainingSessions
     * const count = await prisma.trainingSession.count({
     *   where: {
     *     // ... the filter for the TrainingSessions we want to count
     *   }
     * })
    **/
    count<T extends TrainingSessionCountArgs>(
      args?: Subset<T, TrainingSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingSessionAggregateArgs>(args: Subset<T, TrainingSessionAggregateArgs>): Prisma.PrismaPromise<GetTrainingSessionAggregateType<T>>

    /**
     * Group by TrainingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingSessionGroupByArgs['orderBy'] }
        : { orderBy?: TrainingSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingSession model
   */
  readonly fields: TrainingSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attendance<T extends TrainingSession$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, TrainingSession$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingSession model
   */
  interface TrainingSessionFieldRefs {
    readonly id: FieldRef<"TrainingSession", 'String'>
    readonly trainingId: FieldRef<"TrainingSession", 'String'>
    readonly title: FieldRef<"TrainingSession", 'String'>
    readonly description: FieldRef<"TrainingSession", 'String'>
    readonly startTime: FieldRef<"TrainingSession", 'DateTime'>
    readonly endTime: FieldRef<"TrainingSession", 'DateTime'>
    readonly venue: FieldRef<"TrainingSession", 'String'>
    readonly createdAt: FieldRef<"TrainingSession", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingSession findUnique
   */
  export type TrainingSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSession to fetch.
     */
    where: TrainingSessionWhereUniqueInput
  }

  /**
   * TrainingSession findUniqueOrThrow
   */
  export type TrainingSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSession to fetch.
     */
    where: TrainingSessionWhereUniqueInput
  }

  /**
   * TrainingSession findFirst
   */
  export type TrainingSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSession to fetch.
     */
    where?: TrainingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessions to fetch.
     */
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingSessions.
     */
    cursor?: TrainingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingSessions.
     */
    distinct?: TrainingSessionScalarFieldEnum | TrainingSessionScalarFieldEnum[]
  }

  /**
   * TrainingSession findFirstOrThrow
   */
  export type TrainingSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSession to fetch.
     */
    where?: TrainingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessions to fetch.
     */
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingSessions.
     */
    cursor?: TrainingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingSessions.
     */
    distinct?: TrainingSessionScalarFieldEnum | TrainingSessionScalarFieldEnum[]
  }

  /**
   * TrainingSession findMany
   */
  export type TrainingSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSessions to fetch.
     */
    where?: TrainingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessions to fetch.
     */
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingSessions.
     */
    cursor?: TrainingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessions.
     */
    skip?: number
    distinct?: TrainingSessionScalarFieldEnum | TrainingSessionScalarFieldEnum[]
  }

  /**
   * TrainingSession create
   */
  export type TrainingSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingSession.
     */
    data: XOR<TrainingSessionCreateInput, TrainingSessionUncheckedCreateInput>
  }

  /**
   * TrainingSession createMany
   */
  export type TrainingSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingSessions.
     */
    data: TrainingSessionCreateManyInput | TrainingSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingSession createManyAndReturn
   */
  export type TrainingSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingSessions.
     */
    data: TrainingSessionCreateManyInput | TrainingSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingSession update
   */
  export type TrainingSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingSession.
     */
    data: XOR<TrainingSessionUpdateInput, TrainingSessionUncheckedUpdateInput>
    /**
     * Choose, which TrainingSession to update.
     */
    where: TrainingSessionWhereUniqueInput
  }

  /**
   * TrainingSession updateMany
   */
  export type TrainingSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingSessions.
     */
    data: XOR<TrainingSessionUpdateManyMutationInput, TrainingSessionUncheckedUpdateManyInput>
    /**
     * Filter which TrainingSessions to update
     */
    where?: TrainingSessionWhereInput
    /**
     * Limit how many TrainingSessions to update.
     */
    limit?: number
  }

  /**
   * TrainingSession updateManyAndReturn
   */
  export type TrainingSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * The data used to update TrainingSessions.
     */
    data: XOR<TrainingSessionUpdateManyMutationInput, TrainingSessionUncheckedUpdateManyInput>
    /**
     * Filter which TrainingSessions to update
     */
    where?: TrainingSessionWhereInput
    /**
     * Limit how many TrainingSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingSession upsert
   */
  export type TrainingSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingSession to update in case it exists.
     */
    where: TrainingSessionWhereUniqueInput
    /**
     * In case the TrainingSession found by the `where` argument doesn't exist, create a new TrainingSession with this data.
     */
    create: XOR<TrainingSessionCreateInput, TrainingSessionUncheckedCreateInput>
    /**
     * In case the TrainingSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingSessionUpdateInput, TrainingSessionUncheckedUpdateInput>
  }

  /**
   * TrainingSession delete
   */
  export type TrainingSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter which TrainingSession to delete.
     */
    where: TrainingSessionWhereUniqueInput
  }

  /**
   * TrainingSession deleteMany
   */
  export type TrainingSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingSessions to delete
     */
    where?: TrainingSessionWhereInput
    /**
     * Limit how many TrainingSessions to delete.
     */
    limit?: number
  }

  /**
   * TrainingSession.attendance
   */
  export type TrainingSession$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * TrainingSession without action
   */
  export type TrainingSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingSession
     */
    omit?: TrainingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
  }


  /**
   * Model TrainingDocument
   */

  export type AggregateTrainingDocument = {
    _count: TrainingDocumentCountAggregateOutputType | null
    _min: TrainingDocumentMinAggregateOutputType | null
    _max: TrainingDocumentMaxAggregateOutputType | null
  }

  export type TrainingDocumentMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    documentType: $Enums.DocumentType | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingDocumentMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    documentType: $Enums.DocumentType | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingDocumentCountAggregateOutputType = {
    id: number
    trainingId: number
    title: number
    description: number
    fileUrl: number
    documentType: number
    uploadedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingDocumentMinAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    fileUrl?: true
    documentType?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingDocumentMaxAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    fileUrl?: true
    documentType?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingDocumentCountAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    fileUrl?: true
    documentType?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDocument to aggregate.
     */
    where?: TrainingDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDocuments to fetch.
     */
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingDocuments
    **/
    _count?: true | TrainingDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingDocumentMaxAggregateInputType
  }

  export type GetTrainingDocumentAggregateType<T extends TrainingDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingDocument[P]>
      : GetScalarType<T[P], AggregateTrainingDocument[P]>
  }




  export type TrainingDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDocumentWhereInput
    orderBy?: TrainingDocumentOrderByWithAggregationInput | TrainingDocumentOrderByWithAggregationInput[]
    by: TrainingDocumentScalarFieldEnum[] | TrainingDocumentScalarFieldEnum
    having?: TrainingDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingDocumentCountAggregateInputType | true
    _min?: TrainingDocumentMinAggregateInputType
    _max?: TrainingDocumentMaxAggregateInputType
  }

  export type TrainingDocumentGroupByOutputType = {
    id: string
    trainingId: string
    title: string
    description: string | null
    fileUrl: string
    documentType: $Enums.DocumentType
    uploadedById: string
    createdAt: Date
    updatedAt: Date
    _count: TrainingDocumentCountAggregateOutputType | null
    _min: TrainingDocumentMinAggregateOutputType | null
    _max: TrainingDocumentMaxAggregateOutputType | null
  }

  type GetTrainingDocumentGroupByPayload<T extends TrainingDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingDocumentGroupByOutputType[P]>
        }
      >
    >


  export type TrainingDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    documentType?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDocument"]>

  export type TrainingDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    documentType?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDocument"]>

  export type TrainingDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    documentType?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDocument"]>

  export type TrainingDocumentSelectScalar = {
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    documentType?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "title" | "description" | "fileUrl" | "documentType" | "uploadedById" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingDocument"]>
  export type TrainingDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingDocument"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      title: string
      description: string | null
      fileUrl: string
      documentType: $Enums.DocumentType
      uploadedById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingDocument"]>
    composites: {}
  }

  type TrainingDocumentGetPayload<S extends boolean | null | undefined | TrainingDocumentDefaultArgs> = $Result.GetResult<Prisma.$TrainingDocumentPayload, S>

  type TrainingDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingDocumentCountAggregateInputType | true
    }

  export interface TrainingDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingDocument'], meta: { name: 'TrainingDocument' } }
    /**
     * Find zero or one TrainingDocument that matches the filter.
     * @param {TrainingDocumentFindUniqueArgs} args - Arguments to find a TrainingDocument
     * @example
     * // Get one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingDocumentFindUniqueArgs>(args: SelectSubset<T, TrainingDocumentFindUniqueArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingDocumentFindUniqueOrThrowArgs} args - Arguments to find a TrainingDocument
     * @example
     * // Get one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentFindFirstArgs} args - Arguments to find a TrainingDocument
     * @example
     * // Get one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingDocumentFindFirstArgs>(args?: SelectSubset<T, TrainingDocumentFindFirstArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentFindFirstOrThrowArgs} args - Arguments to find a TrainingDocument
     * @example
     * // Get one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingDocuments
     * const trainingDocuments = await prisma.trainingDocument.findMany()
     * 
     * // Get first 10 TrainingDocuments
     * const trainingDocuments = await prisma.trainingDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingDocumentWithIdOnly = await prisma.trainingDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingDocumentFindManyArgs>(args?: SelectSubset<T, TrainingDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingDocument.
     * @param {TrainingDocumentCreateArgs} args - Arguments to create a TrainingDocument.
     * @example
     * // Create one TrainingDocument
     * const TrainingDocument = await prisma.trainingDocument.create({
     *   data: {
     *     // ... data to create a TrainingDocument
     *   }
     * })
     * 
     */
    create<T extends TrainingDocumentCreateArgs>(args: SelectSubset<T, TrainingDocumentCreateArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingDocuments.
     * @param {TrainingDocumentCreateManyArgs} args - Arguments to create many TrainingDocuments.
     * @example
     * // Create many TrainingDocuments
     * const trainingDocument = await prisma.trainingDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingDocumentCreateManyArgs>(args?: SelectSubset<T, TrainingDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingDocuments and returns the data saved in the database.
     * @param {TrainingDocumentCreateManyAndReturnArgs} args - Arguments to create many TrainingDocuments.
     * @example
     * // Create many TrainingDocuments
     * const trainingDocument = await prisma.trainingDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingDocuments and only return the `id`
     * const trainingDocumentWithIdOnly = await prisma.trainingDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingDocument.
     * @param {TrainingDocumentDeleteArgs} args - Arguments to delete one TrainingDocument.
     * @example
     * // Delete one TrainingDocument
     * const TrainingDocument = await prisma.trainingDocument.delete({
     *   where: {
     *     // ... filter to delete one TrainingDocument
     *   }
     * })
     * 
     */
    delete<T extends TrainingDocumentDeleteArgs>(args: SelectSubset<T, TrainingDocumentDeleteArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingDocument.
     * @param {TrainingDocumentUpdateArgs} args - Arguments to update one TrainingDocument.
     * @example
     * // Update one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingDocumentUpdateArgs>(args: SelectSubset<T, TrainingDocumentUpdateArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingDocuments.
     * @param {TrainingDocumentDeleteManyArgs} args - Arguments to filter TrainingDocuments to delete.
     * @example
     * // Delete a few TrainingDocuments
     * const { count } = await prisma.trainingDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingDocumentDeleteManyArgs>(args?: SelectSubset<T, TrainingDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingDocuments
     * const trainingDocument = await prisma.trainingDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingDocumentUpdateManyArgs>(args: SelectSubset<T, TrainingDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingDocuments and returns the data updated in the database.
     * @param {TrainingDocumentUpdateManyAndReturnArgs} args - Arguments to update many TrainingDocuments.
     * @example
     * // Update many TrainingDocuments
     * const trainingDocument = await prisma.trainingDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingDocuments and only return the `id`
     * const trainingDocumentWithIdOnly = await prisma.trainingDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingDocument.
     * @param {TrainingDocumentUpsertArgs} args - Arguments to update or create a TrainingDocument.
     * @example
     * // Update or create a TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.upsert({
     *   create: {
     *     // ... data to create a TrainingDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingDocument we want to update
     *   }
     * })
     */
    upsert<T extends TrainingDocumentUpsertArgs>(args: SelectSubset<T, TrainingDocumentUpsertArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentCountArgs} args - Arguments to filter TrainingDocuments to count.
     * @example
     * // Count the number of TrainingDocuments
     * const count = await prisma.trainingDocument.count({
     *   where: {
     *     // ... the filter for the TrainingDocuments we want to count
     *   }
     * })
    **/
    count<T extends TrainingDocumentCountArgs>(
      args?: Subset<T, TrainingDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingDocumentAggregateArgs>(args: Subset<T, TrainingDocumentAggregateArgs>): Prisma.PrismaPromise<GetTrainingDocumentAggregateType<T>>

    /**
     * Group by TrainingDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingDocumentGroupByArgs['orderBy'] }
        : { orderBy?: TrainingDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingDocument model
   */
  readonly fields: TrainingDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingDocument model
   */
  interface TrainingDocumentFieldRefs {
    readonly id: FieldRef<"TrainingDocument", 'String'>
    readonly trainingId: FieldRef<"TrainingDocument", 'String'>
    readonly title: FieldRef<"TrainingDocument", 'String'>
    readonly description: FieldRef<"TrainingDocument", 'String'>
    readonly fileUrl: FieldRef<"TrainingDocument", 'String'>
    readonly documentType: FieldRef<"TrainingDocument", 'DocumentType'>
    readonly uploadedById: FieldRef<"TrainingDocument", 'String'>
    readonly createdAt: FieldRef<"TrainingDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingDocument findUnique
   */
  export type TrainingDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocument to fetch.
     */
    where: TrainingDocumentWhereUniqueInput
  }

  /**
   * TrainingDocument findUniqueOrThrow
   */
  export type TrainingDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocument to fetch.
     */
    where: TrainingDocumentWhereUniqueInput
  }

  /**
   * TrainingDocument findFirst
   */
  export type TrainingDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocument to fetch.
     */
    where?: TrainingDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDocuments to fetch.
     */
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDocuments.
     */
    cursor?: TrainingDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDocuments.
     */
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * TrainingDocument findFirstOrThrow
   */
  export type TrainingDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocument to fetch.
     */
    where?: TrainingDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDocuments to fetch.
     */
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDocuments.
     */
    cursor?: TrainingDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDocuments.
     */
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * TrainingDocument findMany
   */
  export type TrainingDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocuments to fetch.
     */
    where?: TrainingDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDocuments to fetch.
     */
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingDocuments.
     */
    cursor?: TrainingDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDocuments.
     */
    skip?: number
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * TrainingDocument create
   */
  export type TrainingDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingDocument.
     */
    data: XOR<TrainingDocumentCreateInput, TrainingDocumentUncheckedCreateInput>
  }

  /**
   * TrainingDocument createMany
   */
  export type TrainingDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingDocuments.
     */
    data: TrainingDocumentCreateManyInput | TrainingDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingDocument createManyAndReturn
   */
  export type TrainingDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingDocuments.
     */
    data: TrainingDocumentCreateManyInput | TrainingDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingDocument update
   */
  export type TrainingDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingDocument.
     */
    data: XOR<TrainingDocumentUpdateInput, TrainingDocumentUncheckedUpdateInput>
    /**
     * Choose, which TrainingDocument to update.
     */
    where: TrainingDocumentWhereUniqueInput
  }

  /**
   * TrainingDocument updateMany
   */
  export type TrainingDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingDocuments.
     */
    data: XOR<TrainingDocumentUpdateManyMutationInput, TrainingDocumentUncheckedUpdateManyInput>
    /**
     * Filter which TrainingDocuments to update
     */
    where?: TrainingDocumentWhereInput
    /**
     * Limit how many TrainingDocuments to update.
     */
    limit?: number
  }

  /**
   * TrainingDocument updateManyAndReturn
   */
  export type TrainingDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * The data used to update TrainingDocuments.
     */
    data: XOR<TrainingDocumentUpdateManyMutationInput, TrainingDocumentUncheckedUpdateManyInput>
    /**
     * Filter which TrainingDocuments to update
     */
    where?: TrainingDocumentWhereInput
    /**
     * Limit how many TrainingDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingDocument upsert
   */
  export type TrainingDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingDocument to update in case it exists.
     */
    where: TrainingDocumentWhereUniqueInput
    /**
     * In case the TrainingDocument found by the `where` argument doesn't exist, create a new TrainingDocument with this data.
     */
    create: XOR<TrainingDocumentCreateInput, TrainingDocumentUncheckedCreateInput>
    /**
     * In case the TrainingDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingDocumentUpdateInput, TrainingDocumentUncheckedUpdateInput>
  }

  /**
   * TrainingDocument delete
   */
  export type TrainingDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter which TrainingDocument to delete.
     */
    where: TrainingDocumentWhereUniqueInput
  }

  /**
   * TrainingDocument deleteMany
   */
  export type TrainingDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDocuments to delete
     */
    where?: TrainingDocumentWhereInput
    /**
     * Limit how many TrainingDocuments to delete.
     */
    limit?: number
  }

  /**
   * TrainingDocument without action
   */
  export type TrainingDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingDocument
     */
    omit?: TrainingDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
  }


  /**
   * Model TrainingParticipant
   */

  export type AggregateTrainingParticipant = {
    _count: TrainingParticipantCountAggregateOutputType | null
    _min: TrainingParticipantMinAggregateOutputType | null
    _max: TrainingParticipantMaxAggregateOutputType | null
  }

  export type TrainingParticipantMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    userId: string | null
    inviteSent: boolean | null
    inviteSentAt: Date | null
    inviteAccepted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingParticipantMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    userId: string | null
    inviteSent: boolean | null
    inviteSentAt: Date | null
    inviteAccepted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingParticipantCountAggregateOutputType = {
    id: number
    trainingId: number
    userId: number
    inviteSent: number
    inviteSentAt: number
    inviteAccepted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingParticipantMinAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    inviteSent?: true
    inviteSentAt?: true
    inviteAccepted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingParticipantMaxAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    inviteSent?: true
    inviteSentAt?: true
    inviteAccepted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingParticipantCountAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    inviteSent?: true
    inviteSentAt?: true
    inviteAccepted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingParticipant to aggregate.
     */
    where?: TrainingParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingParticipants to fetch.
     */
    orderBy?: TrainingParticipantOrderByWithRelationInput | TrainingParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingParticipants
    **/
    _count?: true | TrainingParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingParticipantMaxAggregateInputType
  }

  export type GetTrainingParticipantAggregateType<T extends TrainingParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingParticipant[P]>
      : GetScalarType<T[P], AggregateTrainingParticipant[P]>
  }




  export type TrainingParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingParticipantWhereInput
    orderBy?: TrainingParticipantOrderByWithAggregationInput | TrainingParticipantOrderByWithAggregationInput[]
    by: TrainingParticipantScalarFieldEnum[] | TrainingParticipantScalarFieldEnum
    having?: TrainingParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingParticipantCountAggregateInputType | true
    _min?: TrainingParticipantMinAggregateInputType
    _max?: TrainingParticipantMaxAggregateInputType
  }

  export type TrainingParticipantGroupByOutputType = {
    id: string
    trainingId: string
    userId: string
    inviteSent: boolean
    inviteSentAt: Date | null
    inviteAccepted: boolean
    createdAt: Date
    updatedAt: Date
    _count: TrainingParticipantCountAggregateOutputType | null
    _min: TrainingParticipantMinAggregateOutputType | null
    _max: TrainingParticipantMaxAggregateOutputType | null
  }

  type GetTrainingParticipantGroupByPayload<T extends TrainingParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingParticipantGroupByOutputType[P]>
        }
      >
    >


  export type TrainingParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    inviteSent?: boolean
    inviteSentAt?: boolean
    inviteAccepted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingParticipant"]>

  export type TrainingParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    inviteSent?: boolean
    inviteSentAt?: boolean
    inviteAccepted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingParticipant"]>

  export type TrainingParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    inviteSent?: boolean
    inviteSentAt?: boolean
    inviteAccepted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingParticipant"]>

  export type TrainingParticipantSelectScalar = {
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    inviteSent?: boolean
    inviteSentAt?: boolean
    inviteAccepted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "userId" | "inviteSent" | "inviteSentAt" | "inviteAccepted" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingParticipant"]>
  export type TrainingParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingParticipant"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      userId: string
      inviteSent: boolean
      inviteSentAt: Date | null
      inviteAccepted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingParticipant"]>
    composites: {}
  }

  type TrainingParticipantGetPayload<S extends boolean | null | undefined | TrainingParticipantDefaultArgs> = $Result.GetResult<Prisma.$TrainingParticipantPayload, S>

  type TrainingParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingParticipantCountAggregateInputType | true
    }

  export interface TrainingParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingParticipant'], meta: { name: 'TrainingParticipant' } }
    /**
     * Find zero or one TrainingParticipant that matches the filter.
     * @param {TrainingParticipantFindUniqueArgs} args - Arguments to find a TrainingParticipant
     * @example
     * // Get one TrainingParticipant
     * const trainingParticipant = await prisma.trainingParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingParticipantFindUniqueArgs>(args: SelectSubset<T, TrainingParticipantFindUniqueArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingParticipantFindUniqueOrThrowArgs} args - Arguments to find a TrainingParticipant
     * @example
     * // Get one TrainingParticipant
     * const trainingParticipant = await prisma.trainingParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantFindFirstArgs} args - Arguments to find a TrainingParticipant
     * @example
     * // Get one TrainingParticipant
     * const trainingParticipant = await prisma.trainingParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingParticipantFindFirstArgs>(args?: SelectSubset<T, TrainingParticipantFindFirstArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantFindFirstOrThrowArgs} args - Arguments to find a TrainingParticipant
     * @example
     * // Get one TrainingParticipant
     * const trainingParticipant = await prisma.trainingParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingParticipants
     * const trainingParticipants = await prisma.trainingParticipant.findMany()
     * 
     * // Get first 10 TrainingParticipants
     * const trainingParticipants = await prisma.trainingParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingParticipantWithIdOnly = await prisma.trainingParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingParticipantFindManyArgs>(args?: SelectSubset<T, TrainingParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingParticipant.
     * @param {TrainingParticipantCreateArgs} args - Arguments to create a TrainingParticipant.
     * @example
     * // Create one TrainingParticipant
     * const TrainingParticipant = await prisma.trainingParticipant.create({
     *   data: {
     *     // ... data to create a TrainingParticipant
     *   }
     * })
     * 
     */
    create<T extends TrainingParticipantCreateArgs>(args: SelectSubset<T, TrainingParticipantCreateArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingParticipants.
     * @param {TrainingParticipantCreateManyArgs} args - Arguments to create many TrainingParticipants.
     * @example
     * // Create many TrainingParticipants
     * const trainingParticipant = await prisma.trainingParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingParticipantCreateManyArgs>(args?: SelectSubset<T, TrainingParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingParticipants and returns the data saved in the database.
     * @param {TrainingParticipantCreateManyAndReturnArgs} args - Arguments to create many TrainingParticipants.
     * @example
     * // Create many TrainingParticipants
     * const trainingParticipant = await prisma.trainingParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingParticipants and only return the `id`
     * const trainingParticipantWithIdOnly = await prisma.trainingParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingParticipant.
     * @param {TrainingParticipantDeleteArgs} args - Arguments to delete one TrainingParticipant.
     * @example
     * // Delete one TrainingParticipant
     * const TrainingParticipant = await prisma.trainingParticipant.delete({
     *   where: {
     *     // ... filter to delete one TrainingParticipant
     *   }
     * })
     * 
     */
    delete<T extends TrainingParticipantDeleteArgs>(args: SelectSubset<T, TrainingParticipantDeleteArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingParticipant.
     * @param {TrainingParticipantUpdateArgs} args - Arguments to update one TrainingParticipant.
     * @example
     * // Update one TrainingParticipant
     * const trainingParticipant = await prisma.trainingParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingParticipantUpdateArgs>(args: SelectSubset<T, TrainingParticipantUpdateArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingParticipants.
     * @param {TrainingParticipantDeleteManyArgs} args - Arguments to filter TrainingParticipants to delete.
     * @example
     * // Delete a few TrainingParticipants
     * const { count } = await prisma.trainingParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingParticipantDeleteManyArgs>(args?: SelectSubset<T, TrainingParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingParticipants
     * const trainingParticipant = await prisma.trainingParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingParticipantUpdateManyArgs>(args: SelectSubset<T, TrainingParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingParticipants and returns the data updated in the database.
     * @param {TrainingParticipantUpdateManyAndReturnArgs} args - Arguments to update many TrainingParticipants.
     * @example
     * // Update many TrainingParticipants
     * const trainingParticipant = await prisma.trainingParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingParticipants and only return the `id`
     * const trainingParticipantWithIdOnly = await prisma.trainingParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingParticipant.
     * @param {TrainingParticipantUpsertArgs} args - Arguments to update or create a TrainingParticipant.
     * @example
     * // Update or create a TrainingParticipant
     * const trainingParticipant = await prisma.trainingParticipant.upsert({
     *   create: {
     *     // ... data to create a TrainingParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingParticipant we want to update
     *   }
     * })
     */
    upsert<T extends TrainingParticipantUpsertArgs>(args: SelectSubset<T, TrainingParticipantUpsertArgs<ExtArgs>>): Prisma__TrainingParticipantClient<$Result.GetResult<Prisma.$TrainingParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantCountArgs} args - Arguments to filter TrainingParticipants to count.
     * @example
     * // Count the number of TrainingParticipants
     * const count = await prisma.trainingParticipant.count({
     *   where: {
     *     // ... the filter for the TrainingParticipants we want to count
     *   }
     * })
    **/
    count<T extends TrainingParticipantCountArgs>(
      args?: Subset<T, TrainingParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingParticipantAggregateArgs>(args: Subset<T, TrainingParticipantAggregateArgs>): Prisma.PrismaPromise<GetTrainingParticipantAggregateType<T>>

    /**
     * Group by TrainingParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingParticipantGroupByArgs['orderBy'] }
        : { orderBy?: TrainingParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingParticipant model
   */
  readonly fields: TrainingParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingParticipant model
   */
  interface TrainingParticipantFieldRefs {
    readonly id: FieldRef<"TrainingParticipant", 'String'>
    readonly trainingId: FieldRef<"TrainingParticipant", 'String'>
    readonly userId: FieldRef<"TrainingParticipant", 'String'>
    readonly inviteSent: FieldRef<"TrainingParticipant", 'Boolean'>
    readonly inviteSentAt: FieldRef<"TrainingParticipant", 'DateTime'>
    readonly inviteAccepted: FieldRef<"TrainingParticipant", 'Boolean'>
    readonly createdAt: FieldRef<"TrainingParticipant", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingParticipant findUnique
   */
  export type TrainingParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TrainingParticipant to fetch.
     */
    where: TrainingParticipantWhereUniqueInput
  }

  /**
   * TrainingParticipant findUniqueOrThrow
   */
  export type TrainingParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TrainingParticipant to fetch.
     */
    where: TrainingParticipantWhereUniqueInput
  }

  /**
   * TrainingParticipant findFirst
   */
  export type TrainingParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TrainingParticipant to fetch.
     */
    where?: TrainingParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingParticipants to fetch.
     */
    orderBy?: TrainingParticipantOrderByWithRelationInput | TrainingParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingParticipants.
     */
    cursor?: TrainingParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingParticipants.
     */
    distinct?: TrainingParticipantScalarFieldEnum | TrainingParticipantScalarFieldEnum[]
  }

  /**
   * TrainingParticipant findFirstOrThrow
   */
  export type TrainingParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TrainingParticipant to fetch.
     */
    where?: TrainingParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingParticipants to fetch.
     */
    orderBy?: TrainingParticipantOrderByWithRelationInput | TrainingParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingParticipants.
     */
    cursor?: TrainingParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingParticipants.
     */
    distinct?: TrainingParticipantScalarFieldEnum | TrainingParticipantScalarFieldEnum[]
  }

  /**
   * TrainingParticipant findMany
   */
  export type TrainingParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TrainingParticipants to fetch.
     */
    where?: TrainingParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingParticipants to fetch.
     */
    orderBy?: TrainingParticipantOrderByWithRelationInput | TrainingParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingParticipants.
     */
    cursor?: TrainingParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingParticipants.
     */
    skip?: number
    distinct?: TrainingParticipantScalarFieldEnum | TrainingParticipantScalarFieldEnum[]
  }

  /**
   * TrainingParticipant create
   */
  export type TrainingParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingParticipant.
     */
    data: XOR<TrainingParticipantCreateInput, TrainingParticipantUncheckedCreateInput>
  }

  /**
   * TrainingParticipant createMany
   */
  export type TrainingParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingParticipants.
     */
    data: TrainingParticipantCreateManyInput | TrainingParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingParticipant createManyAndReturn
   */
  export type TrainingParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingParticipants.
     */
    data: TrainingParticipantCreateManyInput | TrainingParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingParticipant update
   */
  export type TrainingParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingParticipant.
     */
    data: XOR<TrainingParticipantUpdateInput, TrainingParticipantUncheckedUpdateInput>
    /**
     * Choose, which TrainingParticipant to update.
     */
    where: TrainingParticipantWhereUniqueInput
  }

  /**
   * TrainingParticipant updateMany
   */
  export type TrainingParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingParticipants.
     */
    data: XOR<TrainingParticipantUpdateManyMutationInput, TrainingParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TrainingParticipants to update
     */
    where?: TrainingParticipantWhereInput
    /**
     * Limit how many TrainingParticipants to update.
     */
    limit?: number
  }

  /**
   * TrainingParticipant updateManyAndReturn
   */
  export type TrainingParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * The data used to update TrainingParticipants.
     */
    data: XOR<TrainingParticipantUpdateManyMutationInput, TrainingParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TrainingParticipants to update
     */
    where?: TrainingParticipantWhereInput
    /**
     * Limit how many TrainingParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingParticipant upsert
   */
  export type TrainingParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingParticipant to update in case it exists.
     */
    where: TrainingParticipantWhereUniqueInput
    /**
     * In case the TrainingParticipant found by the `where` argument doesn't exist, create a new TrainingParticipant with this data.
     */
    create: XOR<TrainingParticipantCreateInput, TrainingParticipantUncheckedCreateInput>
    /**
     * In case the TrainingParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingParticipantUpdateInput, TrainingParticipantUncheckedUpdateInput>
  }

  /**
   * TrainingParticipant delete
   */
  export type TrainingParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
    /**
     * Filter which TrainingParticipant to delete.
     */
    where: TrainingParticipantWhereUniqueInput
  }

  /**
   * TrainingParticipant deleteMany
   */
  export type TrainingParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingParticipants to delete
     */
    where?: TrainingParticipantWhereInput
    /**
     * Limit how many TrainingParticipants to delete.
     */
    limit?: number
  }

  /**
   * TrainingParticipant without action
   */
  export type TrainingParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingParticipant
     */
    select?: TrainingParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingParticipant
     */
    omit?: TrainingParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    sessionId: string | null
    userId: string | null
    status: $Enums.AttendanceStatus | null
    remarks: string | null
    signatureUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    sessionId: string | null
    userId: string | null
    status: $Enums.AttendanceStatus | null
    remarks: string | null
    signatureUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    trainingId: number
    sessionId: number
    userId: number
    status: number
    remarks: number
    signatureUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    trainingId?: true
    sessionId?: true
    userId?: true
    status?: true
    remarks?: true
    signatureUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    trainingId?: true
    sessionId?: true
    userId?: true
    status?: true
    remarks?: true
    signatureUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    trainingId?: true
    sessionId?: true
    userId?: true
    status?: true
    remarks?: true
    signatureUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    trainingId: string
    sessionId: string
    userId: string
    status: $Enums.AttendanceStatus
    remarks: string | null
    signatureUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
    remarks?: boolean
    signatureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
    remarks?: boolean
    signatureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
    remarks?: boolean
    signatureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    trainingId?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
    remarks?: boolean
    signatureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "sessionId" | "userId" | "status" | "remarks" | "signatureUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      session: Prisma.$TrainingSessionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      sessionId: string
      userId: string
      status: $Enums.AttendanceStatus
      remarks: string | null
      signatureUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session<T extends TrainingSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingSessionDefaultArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly trainingId: FieldRef<"Attendance", 'String'>
    readonly sessionId: FieldRef<"Attendance", 'String'>
    readonly userId: FieldRef<"Attendance", 'String'>
    readonly status: FieldRef<"Attendance", 'AttendanceStatus'>
    readonly remarks: FieldRef<"Attendance", 'String'>
    readonly signatureUrl: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model TrainingPhoto
   */

  export type AggregateTrainingPhoto = {
    _count: TrainingPhotoCountAggregateOutputType | null
    _min: TrainingPhotoMinAggregateOutputType | null
    _max: TrainingPhotoMaxAggregateOutputType | null
  }

  export type TrainingPhotoMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    photoUrl: string | null
    caption: string | null
    uploadedById: string | null
    createdAt: Date | null
  }

  export type TrainingPhotoMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    photoUrl: string | null
    caption: string | null
    uploadedById: string | null
    createdAt: Date | null
  }

  export type TrainingPhotoCountAggregateOutputType = {
    id: number
    trainingId: number
    photoUrl: number
    caption: number
    uploadedById: number
    createdAt: number
    _all: number
  }


  export type TrainingPhotoMinAggregateInputType = {
    id?: true
    trainingId?: true
    photoUrl?: true
    caption?: true
    uploadedById?: true
    createdAt?: true
  }

  export type TrainingPhotoMaxAggregateInputType = {
    id?: true
    trainingId?: true
    photoUrl?: true
    caption?: true
    uploadedById?: true
    createdAt?: true
  }

  export type TrainingPhotoCountAggregateInputType = {
    id?: true
    trainingId?: true
    photoUrl?: true
    caption?: true
    uploadedById?: true
    createdAt?: true
    _all?: true
  }

  export type TrainingPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingPhoto to aggregate.
     */
    where?: TrainingPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPhotos to fetch.
     */
    orderBy?: TrainingPhotoOrderByWithRelationInput | TrainingPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingPhotos
    **/
    _count?: true | TrainingPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingPhotoMaxAggregateInputType
  }

  export type GetTrainingPhotoAggregateType<T extends TrainingPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingPhoto[P]>
      : GetScalarType<T[P], AggregateTrainingPhoto[P]>
  }




  export type TrainingPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingPhotoWhereInput
    orderBy?: TrainingPhotoOrderByWithAggregationInput | TrainingPhotoOrderByWithAggregationInput[]
    by: TrainingPhotoScalarFieldEnum[] | TrainingPhotoScalarFieldEnum
    having?: TrainingPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingPhotoCountAggregateInputType | true
    _min?: TrainingPhotoMinAggregateInputType
    _max?: TrainingPhotoMaxAggregateInputType
  }

  export type TrainingPhotoGroupByOutputType = {
    id: string
    trainingId: string
    photoUrl: string
    caption: string | null
    uploadedById: string
    createdAt: Date
    _count: TrainingPhotoCountAggregateOutputType | null
    _min: TrainingPhotoMinAggregateOutputType | null
    _max: TrainingPhotoMaxAggregateOutputType | null
  }

  type GetTrainingPhotoGroupByPayload<T extends TrainingPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingPhotoGroupByOutputType[P]>
        }
      >
    >


  export type TrainingPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    photoUrl?: boolean
    caption?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPhoto"]>

  export type TrainingPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    photoUrl?: boolean
    caption?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPhoto"]>

  export type TrainingPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    photoUrl?: boolean
    caption?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingPhoto"]>

  export type TrainingPhotoSelectScalar = {
    id?: boolean
    trainingId?: boolean
    photoUrl?: boolean
    caption?: boolean
    uploadedById?: boolean
    createdAt?: boolean
  }

  export type TrainingPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "photoUrl" | "caption" | "uploadedById" | "createdAt", ExtArgs["result"]["trainingPhoto"]>
  export type TrainingPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingPhoto"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      photoUrl: string
      caption: string | null
      uploadedById: string
      createdAt: Date
    }, ExtArgs["result"]["trainingPhoto"]>
    composites: {}
  }

  type TrainingPhotoGetPayload<S extends boolean | null | undefined | TrainingPhotoDefaultArgs> = $Result.GetResult<Prisma.$TrainingPhotoPayload, S>

  type TrainingPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingPhotoCountAggregateInputType | true
    }

  export interface TrainingPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingPhoto'], meta: { name: 'TrainingPhoto' } }
    /**
     * Find zero or one TrainingPhoto that matches the filter.
     * @param {TrainingPhotoFindUniqueArgs} args - Arguments to find a TrainingPhoto
     * @example
     * // Get one TrainingPhoto
     * const trainingPhoto = await prisma.trainingPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingPhotoFindUniqueArgs>(args: SelectSubset<T, TrainingPhotoFindUniqueArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingPhotoFindUniqueOrThrowArgs} args - Arguments to find a TrainingPhoto
     * @example
     * // Get one TrainingPhoto
     * const trainingPhoto = await prisma.trainingPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoFindFirstArgs} args - Arguments to find a TrainingPhoto
     * @example
     * // Get one TrainingPhoto
     * const trainingPhoto = await prisma.trainingPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingPhotoFindFirstArgs>(args?: SelectSubset<T, TrainingPhotoFindFirstArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoFindFirstOrThrowArgs} args - Arguments to find a TrainingPhoto
     * @example
     * // Get one TrainingPhoto
     * const trainingPhoto = await prisma.trainingPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingPhotos
     * const trainingPhotos = await prisma.trainingPhoto.findMany()
     * 
     * // Get first 10 TrainingPhotos
     * const trainingPhotos = await prisma.trainingPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingPhotoWithIdOnly = await prisma.trainingPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingPhotoFindManyArgs>(args?: SelectSubset<T, TrainingPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingPhoto.
     * @param {TrainingPhotoCreateArgs} args - Arguments to create a TrainingPhoto.
     * @example
     * // Create one TrainingPhoto
     * const TrainingPhoto = await prisma.trainingPhoto.create({
     *   data: {
     *     // ... data to create a TrainingPhoto
     *   }
     * })
     * 
     */
    create<T extends TrainingPhotoCreateArgs>(args: SelectSubset<T, TrainingPhotoCreateArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingPhotos.
     * @param {TrainingPhotoCreateManyArgs} args - Arguments to create many TrainingPhotos.
     * @example
     * // Create many TrainingPhotos
     * const trainingPhoto = await prisma.trainingPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingPhotoCreateManyArgs>(args?: SelectSubset<T, TrainingPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingPhotos and returns the data saved in the database.
     * @param {TrainingPhotoCreateManyAndReturnArgs} args - Arguments to create many TrainingPhotos.
     * @example
     * // Create many TrainingPhotos
     * const trainingPhoto = await prisma.trainingPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingPhotos and only return the `id`
     * const trainingPhotoWithIdOnly = await prisma.trainingPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingPhoto.
     * @param {TrainingPhotoDeleteArgs} args - Arguments to delete one TrainingPhoto.
     * @example
     * // Delete one TrainingPhoto
     * const TrainingPhoto = await prisma.trainingPhoto.delete({
     *   where: {
     *     // ... filter to delete one TrainingPhoto
     *   }
     * })
     * 
     */
    delete<T extends TrainingPhotoDeleteArgs>(args: SelectSubset<T, TrainingPhotoDeleteArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingPhoto.
     * @param {TrainingPhotoUpdateArgs} args - Arguments to update one TrainingPhoto.
     * @example
     * // Update one TrainingPhoto
     * const trainingPhoto = await prisma.trainingPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingPhotoUpdateArgs>(args: SelectSubset<T, TrainingPhotoUpdateArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingPhotos.
     * @param {TrainingPhotoDeleteManyArgs} args - Arguments to filter TrainingPhotos to delete.
     * @example
     * // Delete a few TrainingPhotos
     * const { count } = await prisma.trainingPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingPhotoDeleteManyArgs>(args?: SelectSubset<T, TrainingPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingPhotos
     * const trainingPhoto = await prisma.trainingPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingPhotoUpdateManyArgs>(args: SelectSubset<T, TrainingPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingPhotos and returns the data updated in the database.
     * @param {TrainingPhotoUpdateManyAndReturnArgs} args - Arguments to update many TrainingPhotos.
     * @example
     * // Update many TrainingPhotos
     * const trainingPhoto = await prisma.trainingPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingPhotos and only return the `id`
     * const trainingPhotoWithIdOnly = await prisma.trainingPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingPhoto.
     * @param {TrainingPhotoUpsertArgs} args - Arguments to update or create a TrainingPhoto.
     * @example
     * // Update or create a TrainingPhoto
     * const trainingPhoto = await prisma.trainingPhoto.upsert({
     *   create: {
     *     // ... data to create a TrainingPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingPhoto we want to update
     *   }
     * })
     */
    upsert<T extends TrainingPhotoUpsertArgs>(args: SelectSubset<T, TrainingPhotoUpsertArgs<ExtArgs>>): Prisma__TrainingPhotoClient<$Result.GetResult<Prisma.$TrainingPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoCountArgs} args - Arguments to filter TrainingPhotos to count.
     * @example
     * // Count the number of TrainingPhotos
     * const count = await prisma.trainingPhoto.count({
     *   where: {
     *     // ... the filter for the TrainingPhotos we want to count
     *   }
     * })
    **/
    count<T extends TrainingPhotoCountArgs>(
      args?: Subset<T, TrainingPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingPhotoAggregateArgs>(args: Subset<T, TrainingPhotoAggregateArgs>): Prisma.PrismaPromise<GetTrainingPhotoAggregateType<T>>

    /**
     * Group by TrainingPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingPhotoGroupByArgs['orderBy'] }
        : { orderBy?: TrainingPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingPhoto model
   */
  readonly fields: TrainingPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingPhoto model
   */
  interface TrainingPhotoFieldRefs {
    readonly id: FieldRef<"TrainingPhoto", 'String'>
    readonly trainingId: FieldRef<"TrainingPhoto", 'String'>
    readonly photoUrl: FieldRef<"TrainingPhoto", 'String'>
    readonly caption: FieldRef<"TrainingPhoto", 'String'>
    readonly uploadedById: FieldRef<"TrainingPhoto", 'String'>
    readonly createdAt: FieldRef<"TrainingPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingPhoto findUnique
   */
  export type TrainingPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPhoto to fetch.
     */
    where: TrainingPhotoWhereUniqueInput
  }

  /**
   * TrainingPhoto findUniqueOrThrow
   */
  export type TrainingPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPhoto to fetch.
     */
    where: TrainingPhotoWhereUniqueInput
  }

  /**
   * TrainingPhoto findFirst
   */
  export type TrainingPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPhoto to fetch.
     */
    where?: TrainingPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPhotos to fetch.
     */
    orderBy?: TrainingPhotoOrderByWithRelationInput | TrainingPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPhotos.
     */
    cursor?: TrainingPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPhotos.
     */
    distinct?: TrainingPhotoScalarFieldEnum | TrainingPhotoScalarFieldEnum[]
  }

  /**
   * TrainingPhoto findFirstOrThrow
   */
  export type TrainingPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPhoto to fetch.
     */
    where?: TrainingPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPhotos to fetch.
     */
    orderBy?: TrainingPhotoOrderByWithRelationInput | TrainingPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingPhotos.
     */
    cursor?: TrainingPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingPhotos.
     */
    distinct?: TrainingPhotoScalarFieldEnum | TrainingPhotoScalarFieldEnum[]
  }

  /**
   * TrainingPhoto findMany
   */
  export type TrainingPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * Filter, which TrainingPhotos to fetch.
     */
    where?: TrainingPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingPhotos to fetch.
     */
    orderBy?: TrainingPhotoOrderByWithRelationInput | TrainingPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingPhotos.
     */
    cursor?: TrainingPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingPhotos.
     */
    skip?: number
    distinct?: TrainingPhotoScalarFieldEnum | TrainingPhotoScalarFieldEnum[]
  }

  /**
   * TrainingPhoto create
   */
  export type TrainingPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingPhoto.
     */
    data: XOR<TrainingPhotoCreateInput, TrainingPhotoUncheckedCreateInput>
  }

  /**
   * TrainingPhoto createMany
   */
  export type TrainingPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingPhotos.
     */
    data: TrainingPhotoCreateManyInput | TrainingPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingPhoto createManyAndReturn
   */
  export type TrainingPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingPhotos.
     */
    data: TrainingPhotoCreateManyInput | TrainingPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingPhoto update
   */
  export type TrainingPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingPhoto.
     */
    data: XOR<TrainingPhotoUpdateInput, TrainingPhotoUncheckedUpdateInput>
    /**
     * Choose, which TrainingPhoto to update.
     */
    where: TrainingPhotoWhereUniqueInput
  }

  /**
   * TrainingPhoto updateMany
   */
  export type TrainingPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingPhotos.
     */
    data: XOR<TrainingPhotoUpdateManyMutationInput, TrainingPhotoUncheckedUpdateManyInput>
    /**
     * Filter which TrainingPhotos to update
     */
    where?: TrainingPhotoWhereInput
    /**
     * Limit how many TrainingPhotos to update.
     */
    limit?: number
  }

  /**
   * TrainingPhoto updateManyAndReturn
   */
  export type TrainingPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * The data used to update TrainingPhotos.
     */
    data: XOR<TrainingPhotoUpdateManyMutationInput, TrainingPhotoUncheckedUpdateManyInput>
    /**
     * Filter which TrainingPhotos to update
     */
    where?: TrainingPhotoWhereInput
    /**
     * Limit how many TrainingPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingPhoto upsert
   */
  export type TrainingPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingPhoto to update in case it exists.
     */
    where: TrainingPhotoWhereUniqueInput
    /**
     * In case the TrainingPhoto found by the `where` argument doesn't exist, create a new TrainingPhoto with this data.
     */
    create: XOR<TrainingPhotoCreateInput, TrainingPhotoUncheckedCreateInput>
    /**
     * In case the TrainingPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingPhotoUpdateInput, TrainingPhotoUncheckedUpdateInput>
  }

  /**
   * TrainingPhoto delete
   */
  export type TrainingPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
    /**
     * Filter which TrainingPhoto to delete.
     */
    where: TrainingPhotoWhereUniqueInput
  }

  /**
   * TrainingPhoto deleteMany
   */
  export type TrainingPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingPhotos to delete
     */
    where?: TrainingPhotoWhereInput
    /**
     * Limit how many TrainingPhotos to delete.
     */
    limit?: number
  }

  /**
   * TrainingPhoto without action
   */
  export type TrainingPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingPhoto
     */
    select?: TrainingPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingPhoto
     */
    omit?: TrainingPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingPhotoInclude<ExtArgs> | null
  }


  /**
   * Model TrainingFeedback
   */

  export type AggregateTrainingFeedback = {
    _count: TrainingFeedbackCountAggregateOutputType | null
    _avg: TrainingFeedbackAvgAggregateOutputType | null
    _sum: TrainingFeedbackSumAggregateOutputType | null
    _min: TrainingFeedbackMinAggregateOutputType | null
    _max: TrainingFeedbackMaxAggregateOutputType | null
  }

  export type TrainingFeedbackAvgAggregateOutputType = {
    contentRating: number | null
    trainerRating: number | null
    materialRating: number | null
    venueRating: number | null
    overallRating: number | null
  }

  export type TrainingFeedbackSumAggregateOutputType = {
    contentRating: number | null
    trainerRating: number | null
    materialRating: number | null
    venueRating: number | null
    overallRating: number | null
  }

  export type TrainingFeedbackMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    userId: string | null
    contentRating: number | null
    trainerRating: number | null
    materialRating: number | null
    venueRating: number | null
    overallRating: number | null
    comments: string | null
    suggestedImprovements: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingFeedbackMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    userId: string | null
    contentRating: number | null
    trainerRating: number | null
    materialRating: number | null
    venueRating: number | null
    overallRating: number | null
    comments: string | null
    suggestedImprovements: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingFeedbackCountAggregateOutputType = {
    id: number
    trainingId: number
    userId: number
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments: number
    suggestedImprovements: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingFeedbackAvgAggregateInputType = {
    contentRating?: true
    trainerRating?: true
    materialRating?: true
    venueRating?: true
    overallRating?: true
  }

  export type TrainingFeedbackSumAggregateInputType = {
    contentRating?: true
    trainerRating?: true
    materialRating?: true
    venueRating?: true
    overallRating?: true
  }

  export type TrainingFeedbackMinAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    contentRating?: true
    trainerRating?: true
    materialRating?: true
    venueRating?: true
    overallRating?: true
    comments?: true
    suggestedImprovements?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingFeedbackMaxAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    contentRating?: true
    trainerRating?: true
    materialRating?: true
    venueRating?: true
    overallRating?: true
    comments?: true
    suggestedImprovements?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingFeedbackCountAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    contentRating?: true
    trainerRating?: true
    materialRating?: true
    venueRating?: true
    overallRating?: true
    comments?: true
    suggestedImprovements?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingFeedback to aggregate.
     */
    where?: TrainingFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFeedbacks to fetch.
     */
    orderBy?: TrainingFeedbackOrderByWithRelationInput | TrainingFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingFeedbacks
    **/
    _count?: true | TrainingFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingFeedbackMaxAggregateInputType
  }

  export type GetTrainingFeedbackAggregateType<T extends TrainingFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingFeedback[P]>
      : GetScalarType<T[P], AggregateTrainingFeedback[P]>
  }




  export type TrainingFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFeedbackWhereInput
    orderBy?: TrainingFeedbackOrderByWithAggregationInput | TrainingFeedbackOrderByWithAggregationInput[]
    by: TrainingFeedbackScalarFieldEnum[] | TrainingFeedbackScalarFieldEnum
    having?: TrainingFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingFeedbackCountAggregateInputType | true
    _avg?: TrainingFeedbackAvgAggregateInputType
    _sum?: TrainingFeedbackSumAggregateInputType
    _min?: TrainingFeedbackMinAggregateInputType
    _max?: TrainingFeedbackMaxAggregateInputType
  }

  export type TrainingFeedbackGroupByOutputType = {
    id: string
    trainingId: string
    userId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments: string | null
    suggestedImprovements: string | null
    createdAt: Date
    updatedAt: Date
    _count: TrainingFeedbackCountAggregateOutputType | null
    _avg: TrainingFeedbackAvgAggregateOutputType | null
    _sum: TrainingFeedbackSumAggregateOutputType | null
    _min: TrainingFeedbackMinAggregateOutputType | null
    _max: TrainingFeedbackMaxAggregateOutputType | null
  }

  type GetTrainingFeedbackGroupByPayload<T extends TrainingFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type TrainingFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    contentRating?: boolean
    trainerRating?: boolean
    materialRating?: boolean
    venueRating?: boolean
    overallRating?: boolean
    comments?: boolean
    suggestedImprovements?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingFeedback"]>

  export type TrainingFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    contentRating?: boolean
    trainerRating?: boolean
    materialRating?: boolean
    venueRating?: boolean
    overallRating?: boolean
    comments?: boolean
    suggestedImprovements?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingFeedback"]>

  export type TrainingFeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    contentRating?: boolean
    trainerRating?: boolean
    materialRating?: boolean
    venueRating?: boolean
    overallRating?: boolean
    comments?: boolean
    suggestedImprovements?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingFeedback"]>

  export type TrainingFeedbackSelectScalar = {
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    contentRating?: boolean
    trainerRating?: boolean
    materialRating?: boolean
    venueRating?: boolean
    overallRating?: boolean
    comments?: boolean
    suggestedImprovements?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "userId" | "contentRating" | "trainerRating" | "materialRating" | "venueRating" | "overallRating" | "comments" | "suggestedImprovements" | "createdAt" | "updatedAt", ExtArgs["result"]["trainingFeedback"]>
  export type TrainingFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingFeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingFeedback"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      userId: string
      contentRating: number
      trainerRating: number
      materialRating: number
      venueRating: number
      overallRating: number
      comments: string | null
      suggestedImprovements: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingFeedback"]>
    composites: {}
  }

  type TrainingFeedbackGetPayload<S extends boolean | null | undefined | TrainingFeedbackDefaultArgs> = $Result.GetResult<Prisma.$TrainingFeedbackPayload, S>

  type TrainingFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingFeedbackCountAggregateInputType | true
    }

  export interface TrainingFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingFeedback'], meta: { name: 'TrainingFeedback' } }
    /**
     * Find zero or one TrainingFeedback that matches the filter.
     * @param {TrainingFeedbackFindUniqueArgs} args - Arguments to find a TrainingFeedback
     * @example
     * // Get one TrainingFeedback
     * const trainingFeedback = await prisma.trainingFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingFeedbackFindUniqueArgs>(args: SelectSubset<T, TrainingFeedbackFindUniqueArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingFeedbackFindUniqueOrThrowArgs} args - Arguments to find a TrainingFeedback
     * @example
     * // Get one TrainingFeedback
     * const trainingFeedback = await prisma.trainingFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackFindFirstArgs} args - Arguments to find a TrainingFeedback
     * @example
     * // Get one TrainingFeedback
     * const trainingFeedback = await prisma.trainingFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingFeedbackFindFirstArgs>(args?: SelectSubset<T, TrainingFeedbackFindFirstArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackFindFirstOrThrowArgs} args - Arguments to find a TrainingFeedback
     * @example
     * // Get one TrainingFeedback
     * const trainingFeedback = await prisma.trainingFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingFeedbacks
     * const trainingFeedbacks = await prisma.trainingFeedback.findMany()
     * 
     * // Get first 10 TrainingFeedbacks
     * const trainingFeedbacks = await prisma.trainingFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingFeedbackWithIdOnly = await prisma.trainingFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingFeedbackFindManyArgs>(args?: SelectSubset<T, TrainingFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingFeedback.
     * @param {TrainingFeedbackCreateArgs} args - Arguments to create a TrainingFeedback.
     * @example
     * // Create one TrainingFeedback
     * const TrainingFeedback = await prisma.trainingFeedback.create({
     *   data: {
     *     // ... data to create a TrainingFeedback
     *   }
     * })
     * 
     */
    create<T extends TrainingFeedbackCreateArgs>(args: SelectSubset<T, TrainingFeedbackCreateArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingFeedbacks.
     * @param {TrainingFeedbackCreateManyArgs} args - Arguments to create many TrainingFeedbacks.
     * @example
     * // Create many TrainingFeedbacks
     * const trainingFeedback = await prisma.trainingFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingFeedbackCreateManyArgs>(args?: SelectSubset<T, TrainingFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingFeedbacks and returns the data saved in the database.
     * @param {TrainingFeedbackCreateManyAndReturnArgs} args - Arguments to create many TrainingFeedbacks.
     * @example
     * // Create many TrainingFeedbacks
     * const trainingFeedback = await prisma.trainingFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingFeedbacks and only return the `id`
     * const trainingFeedbackWithIdOnly = await prisma.trainingFeedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingFeedback.
     * @param {TrainingFeedbackDeleteArgs} args - Arguments to delete one TrainingFeedback.
     * @example
     * // Delete one TrainingFeedback
     * const TrainingFeedback = await prisma.trainingFeedback.delete({
     *   where: {
     *     // ... filter to delete one TrainingFeedback
     *   }
     * })
     * 
     */
    delete<T extends TrainingFeedbackDeleteArgs>(args: SelectSubset<T, TrainingFeedbackDeleteArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingFeedback.
     * @param {TrainingFeedbackUpdateArgs} args - Arguments to update one TrainingFeedback.
     * @example
     * // Update one TrainingFeedback
     * const trainingFeedback = await prisma.trainingFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingFeedbackUpdateArgs>(args: SelectSubset<T, TrainingFeedbackUpdateArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingFeedbacks.
     * @param {TrainingFeedbackDeleteManyArgs} args - Arguments to filter TrainingFeedbacks to delete.
     * @example
     * // Delete a few TrainingFeedbacks
     * const { count } = await prisma.trainingFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingFeedbackDeleteManyArgs>(args?: SelectSubset<T, TrainingFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingFeedbacks
     * const trainingFeedback = await prisma.trainingFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingFeedbackUpdateManyArgs>(args: SelectSubset<T, TrainingFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingFeedbacks and returns the data updated in the database.
     * @param {TrainingFeedbackUpdateManyAndReturnArgs} args - Arguments to update many TrainingFeedbacks.
     * @example
     * // Update many TrainingFeedbacks
     * const trainingFeedback = await prisma.trainingFeedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingFeedbacks and only return the `id`
     * const trainingFeedbackWithIdOnly = await prisma.trainingFeedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingFeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingFeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingFeedback.
     * @param {TrainingFeedbackUpsertArgs} args - Arguments to update or create a TrainingFeedback.
     * @example
     * // Update or create a TrainingFeedback
     * const trainingFeedback = await prisma.trainingFeedback.upsert({
     *   create: {
     *     // ... data to create a TrainingFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingFeedback we want to update
     *   }
     * })
     */
    upsert<T extends TrainingFeedbackUpsertArgs>(args: SelectSubset<T, TrainingFeedbackUpsertArgs<ExtArgs>>): Prisma__TrainingFeedbackClient<$Result.GetResult<Prisma.$TrainingFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackCountArgs} args - Arguments to filter TrainingFeedbacks to count.
     * @example
     * // Count the number of TrainingFeedbacks
     * const count = await prisma.trainingFeedback.count({
     *   where: {
     *     // ... the filter for the TrainingFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends TrainingFeedbackCountArgs>(
      args?: Subset<T, TrainingFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingFeedbackAggregateArgs>(args: Subset<T, TrainingFeedbackAggregateArgs>): Prisma.PrismaPromise<GetTrainingFeedbackAggregateType<T>>

    /**
     * Group by TrainingFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: TrainingFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingFeedback model
   */
  readonly fields: TrainingFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingFeedback model
   */
  interface TrainingFeedbackFieldRefs {
    readonly id: FieldRef<"TrainingFeedback", 'String'>
    readonly trainingId: FieldRef<"TrainingFeedback", 'String'>
    readonly userId: FieldRef<"TrainingFeedback", 'String'>
    readonly contentRating: FieldRef<"TrainingFeedback", 'Int'>
    readonly trainerRating: FieldRef<"TrainingFeedback", 'Int'>
    readonly materialRating: FieldRef<"TrainingFeedback", 'Int'>
    readonly venueRating: FieldRef<"TrainingFeedback", 'Int'>
    readonly overallRating: FieldRef<"TrainingFeedback", 'Int'>
    readonly comments: FieldRef<"TrainingFeedback", 'String'>
    readonly suggestedImprovements: FieldRef<"TrainingFeedback", 'String'>
    readonly createdAt: FieldRef<"TrainingFeedback", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingFeedback findUnique
   */
  export type TrainingFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFeedback to fetch.
     */
    where: TrainingFeedbackWhereUniqueInput
  }

  /**
   * TrainingFeedback findUniqueOrThrow
   */
  export type TrainingFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFeedback to fetch.
     */
    where: TrainingFeedbackWhereUniqueInput
  }

  /**
   * TrainingFeedback findFirst
   */
  export type TrainingFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFeedback to fetch.
     */
    where?: TrainingFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFeedbacks to fetch.
     */
    orderBy?: TrainingFeedbackOrderByWithRelationInput | TrainingFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingFeedbacks.
     */
    cursor?: TrainingFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingFeedbacks.
     */
    distinct?: TrainingFeedbackScalarFieldEnum | TrainingFeedbackScalarFieldEnum[]
  }

  /**
   * TrainingFeedback findFirstOrThrow
   */
  export type TrainingFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFeedback to fetch.
     */
    where?: TrainingFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFeedbacks to fetch.
     */
    orderBy?: TrainingFeedbackOrderByWithRelationInput | TrainingFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingFeedbacks.
     */
    cursor?: TrainingFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingFeedbacks.
     */
    distinct?: TrainingFeedbackScalarFieldEnum | TrainingFeedbackScalarFieldEnum[]
  }

  /**
   * TrainingFeedback findMany
   */
  export type TrainingFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFeedbacks to fetch.
     */
    where?: TrainingFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFeedbacks to fetch.
     */
    orderBy?: TrainingFeedbackOrderByWithRelationInput | TrainingFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingFeedbacks.
     */
    cursor?: TrainingFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFeedbacks.
     */
    skip?: number
    distinct?: TrainingFeedbackScalarFieldEnum | TrainingFeedbackScalarFieldEnum[]
  }

  /**
   * TrainingFeedback create
   */
  export type TrainingFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingFeedback.
     */
    data: XOR<TrainingFeedbackCreateInput, TrainingFeedbackUncheckedCreateInput>
  }

  /**
   * TrainingFeedback createMany
   */
  export type TrainingFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingFeedbacks.
     */
    data: TrainingFeedbackCreateManyInput | TrainingFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingFeedback createManyAndReturn
   */
  export type TrainingFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingFeedbacks.
     */
    data: TrainingFeedbackCreateManyInput | TrainingFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingFeedback update
   */
  export type TrainingFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingFeedback.
     */
    data: XOR<TrainingFeedbackUpdateInput, TrainingFeedbackUncheckedUpdateInput>
    /**
     * Choose, which TrainingFeedback to update.
     */
    where: TrainingFeedbackWhereUniqueInput
  }

  /**
   * TrainingFeedback updateMany
   */
  export type TrainingFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingFeedbacks.
     */
    data: XOR<TrainingFeedbackUpdateManyMutationInput, TrainingFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which TrainingFeedbacks to update
     */
    where?: TrainingFeedbackWhereInput
    /**
     * Limit how many TrainingFeedbacks to update.
     */
    limit?: number
  }

  /**
   * TrainingFeedback updateManyAndReturn
   */
  export type TrainingFeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * The data used to update TrainingFeedbacks.
     */
    data: XOR<TrainingFeedbackUpdateManyMutationInput, TrainingFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which TrainingFeedbacks to update
     */
    where?: TrainingFeedbackWhereInput
    /**
     * Limit how many TrainingFeedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingFeedback upsert
   */
  export type TrainingFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingFeedback to update in case it exists.
     */
    where: TrainingFeedbackWhereUniqueInput
    /**
     * In case the TrainingFeedback found by the `where` argument doesn't exist, create a new TrainingFeedback with this data.
     */
    create: XOR<TrainingFeedbackCreateInput, TrainingFeedbackUncheckedCreateInput>
    /**
     * In case the TrainingFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingFeedbackUpdateInput, TrainingFeedbackUncheckedUpdateInput>
  }

  /**
   * TrainingFeedback delete
   */
  export type TrainingFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
    /**
     * Filter which TrainingFeedback to delete.
     */
    where: TrainingFeedbackWhereUniqueInput
  }

  /**
   * TrainingFeedback deleteMany
   */
  export type TrainingFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingFeedbacks to delete
     */
    where?: TrainingFeedbackWhereInput
    /**
     * Limit how many TrainingFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * TrainingFeedback without action
   */
  export type TrainingFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFeedback
     */
    select?: TrainingFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFeedback
     */
    omit?: TrainingFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model TrainingFollowup
   */

  export type AggregateTrainingFollowup = {
    _count: TrainingFollowupCountAggregateOutputType | null
    _min: TrainingFollowupMinAggregateOutputType | null
    _max: TrainingFollowupMaxAggregateOutputType | null
  }

  export type TrainingFollowupMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    title: string | null
    description: string | null
    dueDate: Date | null
    isCompleted: boolean | null
    assignedToId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type TrainingFollowupMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    title: string | null
    description: string | null
    dueDate: Date | null
    isCompleted: boolean | null
    assignedToId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type TrainingFollowupCountAggregateOutputType = {
    id: number
    trainingId: number
    title: number
    description: number
    dueDate: number
    isCompleted: number
    assignedToId: number
    createdById: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type TrainingFollowupMinAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    dueDate?: true
    isCompleted?: true
    assignedToId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type TrainingFollowupMaxAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    dueDate?: true
    isCompleted?: true
    assignedToId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type TrainingFollowupCountAggregateInputType = {
    id?: true
    trainingId?: true
    title?: true
    description?: true
    dueDate?: true
    isCompleted?: true
    assignedToId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type TrainingFollowupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingFollowup to aggregate.
     */
    where?: TrainingFollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFollowups to fetch.
     */
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingFollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFollowups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFollowups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingFollowups
    **/
    _count?: true | TrainingFollowupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingFollowupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingFollowupMaxAggregateInputType
  }

  export type GetTrainingFollowupAggregateType<T extends TrainingFollowupAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingFollowup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingFollowup[P]>
      : GetScalarType<T[P], AggregateTrainingFollowup[P]>
  }




  export type TrainingFollowupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingFollowupWhereInput
    orderBy?: TrainingFollowupOrderByWithAggregationInput | TrainingFollowupOrderByWithAggregationInput[]
    by: TrainingFollowupScalarFieldEnum[] | TrainingFollowupScalarFieldEnum
    having?: TrainingFollowupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingFollowupCountAggregateInputType | true
    _min?: TrainingFollowupMinAggregateInputType
    _max?: TrainingFollowupMaxAggregateInputType
  }

  export type TrainingFollowupGroupByOutputType = {
    id: string
    trainingId: string
    title: string
    description: string
    dueDate: Date | null
    isCompleted: boolean
    assignedToId: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: TrainingFollowupCountAggregateOutputType | null
    _min: TrainingFollowupMinAggregateOutputType | null
    _max: TrainingFollowupMaxAggregateOutputType | null
  }

  type GetTrainingFollowupGroupByPayload<T extends TrainingFollowupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingFollowupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingFollowupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingFollowupGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingFollowupGroupByOutputType[P]>
        }
      >
    >


  export type TrainingFollowupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    isCompleted?: boolean
    assignedToId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingFollowup"]>

  export type TrainingFollowupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    isCompleted?: boolean
    assignedToId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingFollowup"]>

  export type TrainingFollowupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    isCompleted?: boolean
    assignedToId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingFollowup"]>

  export type TrainingFollowupSelectScalar = {
    id?: boolean
    trainingId?: boolean
    title?: boolean
    description?: boolean
    dueDate?: boolean
    isCompleted?: boolean
    assignedToId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type TrainingFollowupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "title" | "description" | "dueDate" | "isCompleted" | "assignedToId" | "createdById" | "createdAt" | "updatedAt" | "completedAt", ExtArgs["result"]["trainingFollowup"]>
  export type TrainingFollowupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingFollowupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingFollowupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingFollowupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingFollowup"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      title: string
      description: string
      dueDate: Date | null
      isCompleted: boolean
      assignedToId: string
      createdById: string
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["trainingFollowup"]>
    composites: {}
  }

  type TrainingFollowupGetPayload<S extends boolean | null | undefined | TrainingFollowupDefaultArgs> = $Result.GetResult<Prisma.$TrainingFollowupPayload, S>

  type TrainingFollowupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingFollowupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingFollowupCountAggregateInputType | true
    }

  export interface TrainingFollowupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingFollowup'], meta: { name: 'TrainingFollowup' } }
    /**
     * Find zero or one TrainingFollowup that matches the filter.
     * @param {TrainingFollowupFindUniqueArgs} args - Arguments to find a TrainingFollowup
     * @example
     * // Get one TrainingFollowup
     * const trainingFollowup = await prisma.trainingFollowup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingFollowupFindUniqueArgs>(args: SelectSubset<T, TrainingFollowupFindUniqueArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingFollowup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingFollowupFindUniqueOrThrowArgs} args - Arguments to find a TrainingFollowup
     * @example
     * // Get one TrainingFollowup
     * const trainingFollowup = await prisma.trainingFollowup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingFollowupFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingFollowupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingFollowup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupFindFirstArgs} args - Arguments to find a TrainingFollowup
     * @example
     * // Get one TrainingFollowup
     * const trainingFollowup = await prisma.trainingFollowup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingFollowupFindFirstArgs>(args?: SelectSubset<T, TrainingFollowupFindFirstArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingFollowup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupFindFirstOrThrowArgs} args - Arguments to find a TrainingFollowup
     * @example
     * // Get one TrainingFollowup
     * const trainingFollowup = await prisma.trainingFollowup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingFollowupFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingFollowupFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingFollowups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingFollowups
     * const trainingFollowups = await prisma.trainingFollowup.findMany()
     * 
     * // Get first 10 TrainingFollowups
     * const trainingFollowups = await prisma.trainingFollowup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingFollowupWithIdOnly = await prisma.trainingFollowup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingFollowupFindManyArgs>(args?: SelectSubset<T, TrainingFollowupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingFollowup.
     * @param {TrainingFollowupCreateArgs} args - Arguments to create a TrainingFollowup.
     * @example
     * // Create one TrainingFollowup
     * const TrainingFollowup = await prisma.trainingFollowup.create({
     *   data: {
     *     // ... data to create a TrainingFollowup
     *   }
     * })
     * 
     */
    create<T extends TrainingFollowupCreateArgs>(args: SelectSubset<T, TrainingFollowupCreateArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingFollowups.
     * @param {TrainingFollowupCreateManyArgs} args - Arguments to create many TrainingFollowups.
     * @example
     * // Create many TrainingFollowups
     * const trainingFollowup = await prisma.trainingFollowup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingFollowupCreateManyArgs>(args?: SelectSubset<T, TrainingFollowupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingFollowups and returns the data saved in the database.
     * @param {TrainingFollowupCreateManyAndReturnArgs} args - Arguments to create many TrainingFollowups.
     * @example
     * // Create many TrainingFollowups
     * const trainingFollowup = await prisma.trainingFollowup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingFollowups and only return the `id`
     * const trainingFollowupWithIdOnly = await prisma.trainingFollowup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingFollowupCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingFollowupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingFollowup.
     * @param {TrainingFollowupDeleteArgs} args - Arguments to delete one TrainingFollowup.
     * @example
     * // Delete one TrainingFollowup
     * const TrainingFollowup = await prisma.trainingFollowup.delete({
     *   where: {
     *     // ... filter to delete one TrainingFollowup
     *   }
     * })
     * 
     */
    delete<T extends TrainingFollowupDeleteArgs>(args: SelectSubset<T, TrainingFollowupDeleteArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingFollowup.
     * @param {TrainingFollowupUpdateArgs} args - Arguments to update one TrainingFollowup.
     * @example
     * // Update one TrainingFollowup
     * const trainingFollowup = await prisma.trainingFollowup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingFollowupUpdateArgs>(args: SelectSubset<T, TrainingFollowupUpdateArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingFollowups.
     * @param {TrainingFollowupDeleteManyArgs} args - Arguments to filter TrainingFollowups to delete.
     * @example
     * // Delete a few TrainingFollowups
     * const { count } = await prisma.trainingFollowup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingFollowupDeleteManyArgs>(args?: SelectSubset<T, TrainingFollowupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingFollowups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingFollowups
     * const trainingFollowup = await prisma.trainingFollowup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingFollowupUpdateManyArgs>(args: SelectSubset<T, TrainingFollowupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingFollowups and returns the data updated in the database.
     * @param {TrainingFollowupUpdateManyAndReturnArgs} args - Arguments to update many TrainingFollowups.
     * @example
     * // Update many TrainingFollowups
     * const trainingFollowup = await prisma.trainingFollowup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingFollowups and only return the `id`
     * const trainingFollowupWithIdOnly = await prisma.trainingFollowup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingFollowupUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingFollowupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingFollowup.
     * @param {TrainingFollowupUpsertArgs} args - Arguments to update or create a TrainingFollowup.
     * @example
     * // Update or create a TrainingFollowup
     * const trainingFollowup = await prisma.trainingFollowup.upsert({
     *   create: {
     *     // ... data to create a TrainingFollowup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingFollowup we want to update
     *   }
     * })
     */
    upsert<T extends TrainingFollowupUpsertArgs>(args: SelectSubset<T, TrainingFollowupUpsertArgs<ExtArgs>>): Prisma__TrainingFollowupClient<$Result.GetResult<Prisma.$TrainingFollowupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingFollowups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupCountArgs} args - Arguments to filter TrainingFollowups to count.
     * @example
     * // Count the number of TrainingFollowups
     * const count = await prisma.trainingFollowup.count({
     *   where: {
     *     // ... the filter for the TrainingFollowups we want to count
     *   }
     * })
    **/
    count<T extends TrainingFollowupCountArgs>(
      args?: Subset<T, TrainingFollowupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingFollowupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingFollowup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingFollowupAggregateArgs>(args: Subset<T, TrainingFollowupAggregateArgs>): Prisma.PrismaPromise<GetTrainingFollowupAggregateType<T>>

    /**
     * Group by TrainingFollowup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFollowupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingFollowupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingFollowupGroupByArgs['orderBy'] }
        : { orderBy?: TrainingFollowupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingFollowupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingFollowupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingFollowup model
   */
  readonly fields: TrainingFollowupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingFollowup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingFollowupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingFollowup model
   */
  interface TrainingFollowupFieldRefs {
    readonly id: FieldRef<"TrainingFollowup", 'String'>
    readonly trainingId: FieldRef<"TrainingFollowup", 'String'>
    readonly title: FieldRef<"TrainingFollowup", 'String'>
    readonly description: FieldRef<"TrainingFollowup", 'String'>
    readonly dueDate: FieldRef<"TrainingFollowup", 'DateTime'>
    readonly isCompleted: FieldRef<"TrainingFollowup", 'Boolean'>
    readonly assignedToId: FieldRef<"TrainingFollowup", 'String'>
    readonly createdById: FieldRef<"TrainingFollowup", 'String'>
    readonly createdAt: FieldRef<"TrainingFollowup", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingFollowup", 'DateTime'>
    readonly completedAt: FieldRef<"TrainingFollowup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingFollowup findUnique
   */
  export type TrainingFollowupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFollowup to fetch.
     */
    where: TrainingFollowupWhereUniqueInput
  }

  /**
   * TrainingFollowup findUniqueOrThrow
   */
  export type TrainingFollowupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFollowup to fetch.
     */
    where: TrainingFollowupWhereUniqueInput
  }

  /**
   * TrainingFollowup findFirst
   */
  export type TrainingFollowupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFollowup to fetch.
     */
    where?: TrainingFollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFollowups to fetch.
     */
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingFollowups.
     */
    cursor?: TrainingFollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFollowups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFollowups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingFollowups.
     */
    distinct?: TrainingFollowupScalarFieldEnum | TrainingFollowupScalarFieldEnum[]
  }

  /**
   * TrainingFollowup findFirstOrThrow
   */
  export type TrainingFollowupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFollowup to fetch.
     */
    where?: TrainingFollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFollowups to fetch.
     */
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingFollowups.
     */
    cursor?: TrainingFollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFollowups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFollowups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingFollowups.
     */
    distinct?: TrainingFollowupScalarFieldEnum | TrainingFollowupScalarFieldEnum[]
  }

  /**
   * TrainingFollowup findMany
   */
  export type TrainingFollowupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * Filter, which TrainingFollowups to fetch.
     */
    where?: TrainingFollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingFollowups to fetch.
     */
    orderBy?: TrainingFollowupOrderByWithRelationInput | TrainingFollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingFollowups.
     */
    cursor?: TrainingFollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingFollowups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingFollowups.
     */
    skip?: number
    distinct?: TrainingFollowupScalarFieldEnum | TrainingFollowupScalarFieldEnum[]
  }

  /**
   * TrainingFollowup create
   */
  export type TrainingFollowupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingFollowup.
     */
    data: XOR<TrainingFollowupCreateInput, TrainingFollowupUncheckedCreateInput>
  }

  /**
   * TrainingFollowup createMany
   */
  export type TrainingFollowupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingFollowups.
     */
    data: TrainingFollowupCreateManyInput | TrainingFollowupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingFollowup createManyAndReturn
   */
  export type TrainingFollowupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingFollowups.
     */
    data: TrainingFollowupCreateManyInput | TrainingFollowupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingFollowup update
   */
  export type TrainingFollowupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingFollowup.
     */
    data: XOR<TrainingFollowupUpdateInput, TrainingFollowupUncheckedUpdateInput>
    /**
     * Choose, which TrainingFollowup to update.
     */
    where: TrainingFollowupWhereUniqueInput
  }

  /**
   * TrainingFollowup updateMany
   */
  export type TrainingFollowupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingFollowups.
     */
    data: XOR<TrainingFollowupUpdateManyMutationInput, TrainingFollowupUncheckedUpdateManyInput>
    /**
     * Filter which TrainingFollowups to update
     */
    where?: TrainingFollowupWhereInput
    /**
     * Limit how many TrainingFollowups to update.
     */
    limit?: number
  }

  /**
   * TrainingFollowup updateManyAndReturn
   */
  export type TrainingFollowupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * The data used to update TrainingFollowups.
     */
    data: XOR<TrainingFollowupUpdateManyMutationInput, TrainingFollowupUncheckedUpdateManyInput>
    /**
     * Filter which TrainingFollowups to update
     */
    where?: TrainingFollowupWhereInput
    /**
     * Limit how many TrainingFollowups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingFollowup upsert
   */
  export type TrainingFollowupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingFollowup to update in case it exists.
     */
    where: TrainingFollowupWhereUniqueInput
    /**
     * In case the TrainingFollowup found by the `where` argument doesn't exist, create a new TrainingFollowup with this data.
     */
    create: XOR<TrainingFollowupCreateInput, TrainingFollowupUncheckedCreateInput>
    /**
     * In case the TrainingFollowup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingFollowupUpdateInput, TrainingFollowupUncheckedUpdateInput>
  }

  /**
   * TrainingFollowup delete
   */
  export type TrainingFollowupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
    /**
     * Filter which TrainingFollowup to delete.
     */
    where: TrainingFollowupWhereUniqueInput
  }

  /**
   * TrainingFollowup deleteMany
   */
  export type TrainingFollowupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingFollowups to delete
     */
    where?: TrainingFollowupWhereInput
    /**
     * Limit how many TrainingFollowups to delete.
     */
    limit?: number
  }

  /**
   * TrainingFollowup without action
   */
  export type TrainingFollowupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingFollowup
     */
    select?: TrainingFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingFollowup
     */
    omit?: TrainingFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingFollowupInclude<ExtArgs> | null
  }


  /**
   * Model TrainingNotification
   */

  export type AggregateTrainingNotification = {
    _count: TrainingNotificationCountAggregateOutputType | null
    _min: TrainingNotificationMinAggregateOutputType | null
    _max: TrainingNotificationMaxAggregateOutputType | null
  }

  export type TrainingNotificationMinAggregateOutputType = {
    id: string | null
    trainingId: string | null
    userId: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    sentAt: Date | null
    readAt: Date | null
  }

  export type TrainingNotificationMaxAggregateOutputType = {
    id: string | null
    trainingId: string | null
    userId: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    sentAt: Date | null
    readAt: Date | null
  }

  export type TrainingNotificationCountAggregateOutputType = {
    id: number
    trainingId: number
    userId: number
    title: number
    message: number
    isRead: number
    sentAt: number
    readAt: number
    _all: number
  }


  export type TrainingNotificationMinAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    sentAt?: true
    readAt?: true
  }

  export type TrainingNotificationMaxAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    sentAt?: true
    readAt?: true
  }

  export type TrainingNotificationCountAggregateInputType = {
    id?: true
    trainingId?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    sentAt?: true
    readAt?: true
    _all?: true
  }

  export type TrainingNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingNotification to aggregate.
     */
    where?: TrainingNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingNotifications to fetch.
     */
    orderBy?: TrainingNotificationOrderByWithRelationInput | TrainingNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingNotifications
    **/
    _count?: true | TrainingNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingNotificationMaxAggregateInputType
  }

  export type GetTrainingNotificationAggregateType<T extends TrainingNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingNotification[P]>
      : GetScalarType<T[P], AggregateTrainingNotification[P]>
  }




  export type TrainingNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingNotificationWhereInput
    orderBy?: TrainingNotificationOrderByWithAggregationInput | TrainingNotificationOrderByWithAggregationInput[]
    by: TrainingNotificationScalarFieldEnum[] | TrainingNotificationScalarFieldEnum
    having?: TrainingNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingNotificationCountAggregateInputType | true
    _min?: TrainingNotificationMinAggregateInputType
    _max?: TrainingNotificationMaxAggregateInputType
  }

  export type TrainingNotificationGroupByOutputType = {
    id: string
    trainingId: string
    userId: string
    title: string
    message: string
    isRead: boolean
    sentAt: Date
    readAt: Date | null
    _count: TrainingNotificationCountAggregateOutputType | null
    _min: TrainingNotificationMinAggregateOutputType | null
    _max: TrainingNotificationMaxAggregateOutputType | null
  }

  type GetTrainingNotificationGroupByPayload<T extends TrainingNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingNotificationGroupByOutputType[P]>
        }
      >
    >


  export type TrainingNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    sentAt?: boolean
    readAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingNotification"]>

  export type TrainingNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    sentAt?: boolean
    readAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingNotification"]>

  export type TrainingNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    sentAt?: boolean
    readAt?: boolean
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingNotification"]>

  export type TrainingNotificationSelectScalar = {
    id?: boolean
    trainingId?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    sentAt?: boolean
    readAt?: boolean
  }

  export type TrainingNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trainingId" | "userId" | "title" | "message" | "isRead" | "sentAt" | "readAt", ExtArgs["result"]["trainingNotification"]>
  export type TrainingNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrainingNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training?: boolean | TrainingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrainingNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingNotification"
    objects: {
      training: Prisma.$TrainingPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trainingId: string
      userId: string
      title: string
      message: string
      isRead: boolean
      sentAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["trainingNotification"]>
    composites: {}
  }

  type TrainingNotificationGetPayload<S extends boolean | null | undefined | TrainingNotificationDefaultArgs> = $Result.GetResult<Prisma.$TrainingNotificationPayload, S>

  type TrainingNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrainingNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingNotificationCountAggregateInputType | true
    }

  export interface TrainingNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingNotification'], meta: { name: 'TrainingNotification' } }
    /**
     * Find zero or one TrainingNotification that matches the filter.
     * @param {TrainingNotificationFindUniqueArgs} args - Arguments to find a TrainingNotification
     * @example
     * // Get one TrainingNotification
     * const trainingNotification = await prisma.trainingNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingNotificationFindUniqueArgs>(args: SelectSubset<T, TrainingNotificationFindUniqueArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrainingNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrainingNotificationFindUniqueOrThrowArgs} args - Arguments to find a TrainingNotification
     * @example
     * // Get one TrainingNotification
     * const trainingNotification = await prisma.trainingNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationFindFirstArgs} args - Arguments to find a TrainingNotification
     * @example
     * // Get one TrainingNotification
     * const trainingNotification = await prisma.trainingNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingNotificationFindFirstArgs>(args?: SelectSubset<T, TrainingNotificationFindFirstArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrainingNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationFindFirstOrThrowArgs} args - Arguments to find a TrainingNotification
     * @example
     * // Get one TrainingNotification
     * const trainingNotification = await prisma.trainingNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrainingNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingNotifications
     * const trainingNotifications = await prisma.trainingNotification.findMany()
     * 
     * // Get first 10 TrainingNotifications
     * const trainingNotifications = await prisma.trainingNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingNotificationWithIdOnly = await prisma.trainingNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingNotificationFindManyArgs>(args?: SelectSubset<T, TrainingNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrainingNotification.
     * @param {TrainingNotificationCreateArgs} args - Arguments to create a TrainingNotification.
     * @example
     * // Create one TrainingNotification
     * const TrainingNotification = await prisma.trainingNotification.create({
     *   data: {
     *     // ... data to create a TrainingNotification
     *   }
     * })
     * 
     */
    create<T extends TrainingNotificationCreateArgs>(args: SelectSubset<T, TrainingNotificationCreateArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrainingNotifications.
     * @param {TrainingNotificationCreateManyArgs} args - Arguments to create many TrainingNotifications.
     * @example
     * // Create many TrainingNotifications
     * const trainingNotification = await prisma.trainingNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingNotificationCreateManyArgs>(args?: SelectSubset<T, TrainingNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingNotifications and returns the data saved in the database.
     * @param {TrainingNotificationCreateManyAndReturnArgs} args - Arguments to create many TrainingNotifications.
     * @example
     * // Create many TrainingNotifications
     * const trainingNotification = await prisma.trainingNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingNotifications and only return the `id`
     * const trainingNotificationWithIdOnly = await prisma.trainingNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrainingNotification.
     * @param {TrainingNotificationDeleteArgs} args - Arguments to delete one TrainingNotification.
     * @example
     * // Delete one TrainingNotification
     * const TrainingNotification = await prisma.trainingNotification.delete({
     *   where: {
     *     // ... filter to delete one TrainingNotification
     *   }
     * })
     * 
     */
    delete<T extends TrainingNotificationDeleteArgs>(args: SelectSubset<T, TrainingNotificationDeleteArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrainingNotification.
     * @param {TrainingNotificationUpdateArgs} args - Arguments to update one TrainingNotification.
     * @example
     * // Update one TrainingNotification
     * const trainingNotification = await prisma.trainingNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingNotificationUpdateArgs>(args: SelectSubset<T, TrainingNotificationUpdateArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrainingNotifications.
     * @param {TrainingNotificationDeleteManyArgs} args - Arguments to filter TrainingNotifications to delete.
     * @example
     * // Delete a few TrainingNotifications
     * const { count } = await prisma.trainingNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingNotificationDeleteManyArgs>(args?: SelectSubset<T, TrainingNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingNotifications
     * const trainingNotification = await prisma.trainingNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingNotificationUpdateManyArgs>(args: SelectSubset<T, TrainingNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingNotifications and returns the data updated in the database.
     * @param {TrainingNotificationUpdateManyAndReturnArgs} args - Arguments to update many TrainingNotifications.
     * @example
     * // Update many TrainingNotifications
     * const trainingNotification = await prisma.trainingNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrainingNotifications and only return the `id`
     * const trainingNotificationWithIdOnly = await prisma.trainingNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrainingNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, TrainingNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrainingNotification.
     * @param {TrainingNotificationUpsertArgs} args - Arguments to update or create a TrainingNotification.
     * @example
     * // Update or create a TrainingNotification
     * const trainingNotification = await prisma.trainingNotification.upsert({
     *   create: {
     *     // ... data to create a TrainingNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingNotification we want to update
     *   }
     * })
     */
    upsert<T extends TrainingNotificationUpsertArgs>(args: SelectSubset<T, TrainingNotificationUpsertArgs<ExtArgs>>): Prisma__TrainingNotificationClient<$Result.GetResult<Prisma.$TrainingNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrainingNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationCountArgs} args - Arguments to filter TrainingNotifications to count.
     * @example
     * // Count the number of TrainingNotifications
     * const count = await prisma.trainingNotification.count({
     *   where: {
     *     // ... the filter for the TrainingNotifications we want to count
     *   }
     * })
    **/
    count<T extends TrainingNotificationCountArgs>(
      args?: Subset<T, TrainingNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingNotificationAggregateArgs>(args: Subset<T, TrainingNotificationAggregateArgs>): Prisma.PrismaPromise<GetTrainingNotificationAggregateType<T>>

    /**
     * Group by TrainingNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingNotificationGroupByArgs['orderBy'] }
        : { orderBy?: TrainingNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingNotification model
   */
  readonly fields: TrainingNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    training<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingNotification model
   */
  interface TrainingNotificationFieldRefs {
    readonly id: FieldRef<"TrainingNotification", 'String'>
    readonly trainingId: FieldRef<"TrainingNotification", 'String'>
    readonly userId: FieldRef<"TrainingNotification", 'String'>
    readonly title: FieldRef<"TrainingNotification", 'String'>
    readonly message: FieldRef<"TrainingNotification", 'String'>
    readonly isRead: FieldRef<"TrainingNotification", 'Boolean'>
    readonly sentAt: FieldRef<"TrainingNotification", 'DateTime'>
    readonly readAt: FieldRef<"TrainingNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingNotification findUnique
   */
  export type TrainingNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TrainingNotification to fetch.
     */
    where: TrainingNotificationWhereUniqueInput
  }

  /**
   * TrainingNotification findUniqueOrThrow
   */
  export type TrainingNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TrainingNotification to fetch.
     */
    where: TrainingNotificationWhereUniqueInput
  }

  /**
   * TrainingNotification findFirst
   */
  export type TrainingNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TrainingNotification to fetch.
     */
    where?: TrainingNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingNotifications to fetch.
     */
    orderBy?: TrainingNotificationOrderByWithRelationInput | TrainingNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingNotifications.
     */
    cursor?: TrainingNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingNotifications.
     */
    distinct?: TrainingNotificationScalarFieldEnum | TrainingNotificationScalarFieldEnum[]
  }

  /**
   * TrainingNotification findFirstOrThrow
   */
  export type TrainingNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TrainingNotification to fetch.
     */
    where?: TrainingNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingNotifications to fetch.
     */
    orderBy?: TrainingNotificationOrderByWithRelationInput | TrainingNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingNotifications.
     */
    cursor?: TrainingNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingNotifications.
     */
    distinct?: TrainingNotificationScalarFieldEnum | TrainingNotificationScalarFieldEnum[]
  }

  /**
   * TrainingNotification findMany
   */
  export type TrainingNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * Filter, which TrainingNotifications to fetch.
     */
    where?: TrainingNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingNotifications to fetch.
     */
    orderBy?: TrainingNotificationOrderByWithRelationInput | TrainingNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingNotifications.
     */
    cursor?: TrainingNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingNotifications.
     */
    skip?: number
    distinct?: TrainingNotificationScalarFieldEnum | TrainingNotificationScalarFieldEnum[]
  }

  /**
   * TrainingNotification create
   */
  export type TrainingNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingNotification.
     */
    data: XOR<TrainingNotificationCreateInput, TrainingNotificationUncheckedCreateInput>
  }

  /**
   * TrainingNotification createMany
   */
  export type TrainingNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingNotifications.
     */
    data: TrainingNotificationCreateManyInput | TrainingNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingNotification createManyAndReturn
   */
  export type TrainingNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many TrainingNotifications.
     */
    data: TrainingNotificationCreateManyInput | TrainingNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingNotification update
   */
  export type TrainingNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingNotification.
     */
    data: XOR<TrainingNotificationUpdateInput, TrainingNotificationUncheckedUpdateInput>
    /**
     * Choose, which TrainingNotification to update.
     */
    where: TrainingNotificationWhereUniqueInput
  }

  /**
   * TrainingNotification updateMany
   */
  export type TrainingNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingNotifications.
     */
    data: XOR<TrainingNotificationUpdateManyMutationInput, TrainingNotificationUncheckedUpdateManyInput>
    /**
     * Filter which TrainingNotifications to update
     */
    where?: TrainingNotificationWhereInput
    /**
     * Limit how many TrainingNotifications to update.
     */
    limit?: number
  }

  /**
   * TrainingNotification updateManyAndReturn
   */
  export type TrainingNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * The data used to update TrainingNotifications.
     */
    data: XOR<TrainingNotificationUpdateManyMutationInput, TrainingNotificationUncheckedUpdateManyInput>
    /**
     * Filter which TrainingNotifications to update
     */
    where?: TrainingNotificationWhereInput
    /**
     * Limit how many TrainingNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingNotification upsert
   */
  export type TrainingNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingNotification to update in case it exists.
     */
    where: TrainingNotificationWhereUniqueInput
    /**
     * In case the TrainingNotification found by the `where` argument doesn't exist, create a new TrainingNotification with this data.
     */
    create: XOR<TrainingNotificationCreateInput, TrainingNotificationUncheckedCreateInput>
    /**
     * In case the TrainingNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingNotificationUpdateInput, TrainingNotificationUncheckedUpdateInput>
  }

  /**
   * TrainingNotification delete
   */
  export type TrainingNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
    /**
     * Filter which TrainingNotification to delete.
     */
    where: TrainingNotificationWhereUniqueInput
  }

  /**
   * TrainingNotification deleteMany
   */
  export type TrainingNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingNotifications to delete
     */
    where?: TrainingNotificationWhereInput
    /**
     * Limit how many TrainingNotifications to delete.
     */
    limit?: number
  }

  /**
   * TrainingNotification without action
   */
  export type TrainingNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingNotification
     */
    select?: TrainingNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrainingNotification
     */
    omit?: TrainingNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingNotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    batchId: 'batchId',
    action: 'action',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const BatchScalarFieldEnum: {
    id: 'id',
    batchNumber: 'batchNumber',
    productId: 'productId',
    dateOfProduction: 'dateOfProduction',
    bestBeforeDate: 'bestBeforeDate',
    sampleAnalysisStarted: 'sampleAnalysisStarted',
    sampleAnalysisCompleted: 'sampleAnalysisCompleted',
    sampleAnalysisStatus: 'sampleAnalysisStatus',
    makerId: 'makerId',
    checkerId: 'checkerId',
    status: 'status',
    rejectionRemarks: 'rejectionRemarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BatchScalarFieldEnum = (typeof BatchScalarFieldEnum)[keyof typeof BatchScalarFieldEnum]


  export const ExportLogScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    exportType: 'exportType',
    exportedBy: 'exportedBy',
    exportedAt: 'exportedAt'
  };

  export type ExportLogScalarFieldEnum = (typeof ExportLogScalarFieldEnum)[keyof typeof ExportLogScalarFieldEnum]


  export const MethodologyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    procedure: 'procedure',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MethodologyScalarFieldEnum = (typeof MethodologyScalarFieldEnum)[keyof typeof MethodologyScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    batchId: 'batchId',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    action: 'action',
    resource: 'resource',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UnitOfMeasurementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    symbol: 'symbol',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitOfMeasurementScalarFieldEnum = (typeof UnitOfMeasurementScalarFieldEnum)[keyof typeof UnitOfMeasurementScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    roleId: 'roleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StandardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    categoryId: 'categoryId',
    createdById: 'createdById',
    modifiedById: 'modifiedById',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StandardScalarFieldEnum = (typeof StandardScalarFieldEnum)[keyof typeof StandardScalarFieldEnum]


  export const StandardCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StandardCategoryScalarFieldEnum = (typeof StandardCategoryScalarFieldEnum)[keyof typeof StandardCategoryScalarFieldEnum]


  export const StandardParameterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    categoryId: 'categoryId',
    description: 'description',
    dataType: 'dataType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StandardParameterScalarFieldEnum = (typeof StandardParameterScalarFieldEnum)[keyof typeof StandardParameterScalarFieldEnum]


  export const StandardDefinitionScalarFieldEnum: {
    id: 'id',
    parameterId: 'parameterId',
    standardValue: 'standardValue',
    unitId: 'unitId',
    methodologyId: 'methodologyId',
    createdById: 'createdById',
    modifiedById: 'modifiedById',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StandardDefinitionScalarFieldEnum = (typeof StandardDefinitionScalarFieldEnum)[keyof typeof StandardDefinitionScalarFieldEnum]


  export const BatchParameterValueScalarFieldEnum: {
    id: 'id',
    batchId: 'batchId',
    parameterId: 'parameterId',
    value: 'value',
    unitId: 'unitId',
    methodologyId: 'methodologyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BatchParameterValueScalarFieldEnum = (typeof BatchParameterValueScalarFieldEnum)[keyof typeof BatchParameterValueScalarFieldEnum]


  export const TrainingCalendarScalarFieldEnum: {
    id: 'id',
    month: 'month',
    year: 'year',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingCalendarScalarFieldEnum = (typeof TrainingCalendarScalarFieldEnum)[keyof typeof TrainingCalendarScalarFieldEnum]


  export const TrainingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    trainingType: 'trainingType',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    location: 'location',
    maxParticipants: 'maxParticipants',
    trainerId: 'trainerId',
    calendarId: 'calendarId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingScalarFieldEnum = (typeof TrainingScalarFieldEnum)[keyof typeof TrainingScalarFieldEnum]


  export const TrainingSessionScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    title: 'title',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    venue: 'venue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingSessionScalarFieldEnum = (typeof TrainingSessionScalarFieldEnum)[keyof typeof TrainingSessionScalarFieldEnum]


  export const TrainingDocumentScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    title: 'title',
    description: 'description',
    fileUrl: 'fileUrl',
    documentType: 'documentType',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingDocumentScalarFieldEnum = (typeof TrainingDocumentScalarFieldEnum)[keyof typeof TrainingDocumentScalarFieldEnum]


  export const TrainingParticipantScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    userId: 'userId',
    inviteSent: 'inviteSent',
    inviteSentAt: 'inviteSentAt',
    inviteAccepted: 'inviteAccepted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingParticipantScalarFieldEnum = (typeof TrainingParticipantScalarFieldEnum)[keyof typeof TrainingParticipantScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    sessionId: 'sessionId',
    userId: 'userId',
    status: 'status',
    remarks: 'remarks',
    signatureUrl: 'signatureUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const TrainingPhotoScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    photoUrl: 'photoUrl',
    caption: 'caption',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt'
  };

  export type TrainingPhotoScalarFieldEnum = (typeof TrainingPhotoScalarFieldEnum)[keyof typeof TrainingPhotoScalarFieldEnum]


  export const TrainingFeedbackScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    userId: 'userId',
    contentRating: 'contentRating',
    trainerRating: 'trainerRating',
    materialRating: 'materialRating',
    venueRating: 'venueRating',
    overallRating: 'overallRating',
    comments: 'comments',
    suggestedImprovements: 'suggestedImprovements',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingFeedbackScalarFieldEnum = (typeof TrainingFeedbackScalarFieldEnum)[keyof typeof TrainingFeedbackScalarFieldEnum]


  export const TrainingFollowupScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    title: 'title',
    description: 'description',
    dueDate: 'dueDate',
    isCompleted: 'isCompleted',
    assignedToId: 'assignedToId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type TrainingFollowupScalarFieldEnum = (typeof TrainingFollowupScalarFieldEnum)[keyof typeof TrainingFollowupScalarFieldEnum]


  export const TrainingNotificationScalarFieldEnum: {
    id: 'id',
    trainingId: 'trainingId',
    userId: 'userId',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    sentAt: 'sentAt',
    readAt: 'readAt'
  };

  export type TrainingNotificationScalarFieldEnum = (typeof TrainingNotificationScalarFieldEnum)[keyof typeof TrainingNotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SampleAnalysisStatus'
   */
  export type EnumSampleAnalysisStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SampleAnalysisStatus'>
    


  /**
   * Reference to a field of type 'SampleAnalysisStatus[]'
   */
  export type ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SampleAnalysisStatus[]'>
    


  /**
   * Reference to a field of type 'BatchStatus'
   */
  export type EnumBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchStatus'>
    


  /**
   * Reference to a field of type 'BatchStatus[]'
   */
  export type ListEnumBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'StandardStatus'
   */
  export type EnumStandardStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StandardStatus'>
    


  /**
   * Reference to a field of type 'StandardStatus[]'
   */
  export type ListEnumStandardStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StandardStatus[]'>
    


  /**
   * Reference to a field of type 'ParameterDataType'
   */
  export type EnumParameterDataTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParameterDataType'>
    


  /**
   * Reference to a field of type 'ParameterDataType[]'
   */
  export type ListEnumParameterDataTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParameterDataType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TrainingType'
   */
  export type EnumTrainingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingType'>
    


  /**
   * Reference to a field of type 'TrainingType[]'
   */
  export type ListEnumTrainingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingType[]'>
    


  /**
   * Reference to a field of type 'TrainingStatus'
   */
  export type EnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus'>
    


  /**
   * Reference to a field of type 'TrainingStatus[]'
   */
  export type ListEnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringFilter<"ActivityLog"> | string
    batchId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: StringFilter<"ActivityLog"> | string
    details?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    Batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Batch?: BatchOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    userId?: StringFilter<"ActivityLog"> | string
    batchId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: StringFilter<"ActivityLog"> | string
    details?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    Batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    userId?: StringWithAggregatesFilter<"ActivityLog"> | string
    batchId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    details?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type BatchWhereInput = {
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    id?: StringFilter<"Batch"> | string
    batchNumber?: StringFilter<"Batch"> | string
    productId?: StringFilter<"Batch"> | string
    dateOfProduction?: DateTimeFilter<"Batch"> | Date | string
    bestBeforeDate?: DateTimeFilter<"Batch"> | Date | string
    sampleAnalysisStarted?: DateTimeNullableFilter<"Batch"> | Date | string | null
    sampleAnalysisCompleted?: DateTimeNullableFilter<"Batch"> | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFilter<"Batch"> | $Enums.SampleAnalysisStatus
    makerId?: StringFilter<"Batch"> | string
    checkerId?: StringNullableFilter<"Batch"> | string | null
    status?: EnumBatchStatusFilter<"Batch"> | $Enums.BatchStatus
    rejectionRemarks?: StringNullableFilter<"Batch"> | string | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
    ActivityLog?: ActivityLogListRelationFilter
    User_Batch_checkerIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    User_Batch_makerIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    Notification?: NotificationListRelationFilter
    standards?: StandardListRelationFilter
    methodologies?: MethodologyListRelationFilter
    unitOfMeasurements?: UnitOfMeasurementListRelationFilter
    parameterValues?: BatchParameterValueListRelationFilter
  }

  export type BatchOrderByWithRelationInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    productId?: SortOrder
    dateOfProduction?: SortOrder
    bestBeforeDate?: SortOrder
    sampleAnalysisStarted?: SortOrderInput | SortOrder
    sampleAnalysisCompleted?: SortOrderInput | SortOrder
    sampleAnalysisStatus?: SortOrder
    makerId?: SortOrder
    checkerId?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionRemarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ActivityLog?: ActivityLogOrderByRelationAggregateInput
    User_Batch_checkerIdToUser?: UserOrderByWithRelationInput
    User_Batch_makerIdToUser?: UserOrderByWithRelationInput
    Product?: ProductOrderByWithRelationInput
    Notification?: NotificationOrderByRelationAggregateInput
    standards?: StandardOrderByRelationAggregateInput
    methodologies?: MethodologyOrderByRelationAggregateInput
    unitOfMeasurements?: UnitOfMeasurementOrderByRelationAggregateInput
    parameterValues?: BatchParameterValueOrderByRelationAggregateInput
  }

  export type BatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    batchNumber?: string
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    productId?: StringFilter<"Batch"> | string
    dateOfProduction?: DateTimeFilter<"Batch"> | Date | string
    bestBeforeDate?: DateTimeFilter<"Batch"> | Date | string
    sampleAnalysisStarted?: DateTimeNullableFilter<"Batch"> | Date | string | null
    sampleAnalysisCompleted?: DateTimeNullableFilter<"Batch"> | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFilter<"Batch"> | $Enums.SampleAnalysisStatus
    makerId?: StringFilter<"Batch"> | string
    checkerId?: StringNullableFilter<"Batch"> | string | null
    status?: EnumBatchStatusFilter<"Batch"> | $Enums.BatchStatus
    rejectionRemarks?: StringNullableFilter<"Batch"> | string | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
    ActivityLog?: ActivityLogListRelationFilter
    User_Batch_checkerIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    User_Batch_makerIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    Notification?: NotificationListRelationFilter
    standards?: StandardListRelationFilter
    methodologies?: MethodologyListRelationFilter
    unitOfMeasurements?: UnitOfMeasurementListRelationFilter
    parameterValues?: BatchParameterValueListRelationFilter
  }, "id" | "batchNumber">

  export type BatchOrderByWithAggregationInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    productId?: SortOrder
    dateOfProduction?: SortOrder
    bestBeforeDate?: SortOrder
    sampleAnalysisStarted?: SortOrderInput | SortOrder
    sampleAnalysisCompleted?: SortOrderInput | SortOrder
    sampleAnalysisStatus?: SortOrder
    makerId?: SortOrder
    checkerId?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionRemarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BatchCountOrderByAggregateInput
    _max?: BatchMaxOrderByAggregateInput
    _min?: BatchMinOrderByAggregateInput
  }

  export type BatchScalarWhereWithAggregatesInput = {
    AND?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    OR?: BatchScalarWhereWithAggregatesInput[]
    NOT?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Batch"> | string
    batchNumber?: StringWithAggregatesFilter<"Batch"> | string
    productId?: StringWithAggregatesFilter<"Batch"> | string
    dateOfProduction?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    bestBeforeDate?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    sampleAnalysisStarted?: DateTimeNullableWithAggregatesFilter<"Batch"> | Date | string | null
    sampleAnalysisCompleted?: DateTimeNullableWithAggregatesFilter<"Batch"> | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusWithAggregatesFilter<"Batch"> | $Enums.SampleAnalysisStatus
    makerId?: StringWithAggregatesFilter<"Batch"> | string
    checkerId?: StringNullableWithAggregatesFilter<"Batch"> | string | null
    status?: EnumBatchStatusWithAggregatesFilter<"Batch"> | $Enums.BatchStatus
    rejectionRemarks?: StringNullableWithAggregatesFilter<"Batch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
  }

  export type ExportLogWhereInput = {
    AND?: ExportLogWhereInput | ExportLogWhereInput[]
    OR?: ExportLogWhereInput[]
    NOT?: ExportLogWhereInput | ExportLogWhereInput[]
    id?: StringFilter<"ExportLog"> | string
    fileName?: StringFilter<"ExportLog"> | string
    exportType?: StringFilter<"ExportLog"> | string
    exportedBy?: StringFilter<"ExportLog"> | string
    exportedAt?: DateTimeFilter<"ExportLog"> | Date | string
  }

  export type ExportLogOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    exportType?: SortOrder
    exportedBy?: SortOrder
    exportedAt?: SortOrder
  }

  export type ExportLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExportLogWhereInput | ExportLogWhereInput[]
    OR?: ExportLogWhereInput[]
    NOT?: ExportLogWhereInput | ExportLogWhereInput[]
    fileName?: StringFilter<"ExportLog"> | string
    exportType?: StringFilter<"ExportLog"> | string
    exportedBy?: StringFilter<"ExportLog"> | string
    exportedAt?: DateTimeFilter<"ExportLog"> | Date | string
  }, "id">

  export type ExportLogOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    exportType?: SortOrder
    exportedBy?: SortOrder
    exportedAt?: SortOrder
    _count?: ExportLogCountOrderByAggregateInput
    _max?: ExportLogMaxOrderByAggregateInput
    _min?: ExportLogMinOrderByAggregateInput
  }

  export type ExportLogScalarWhereWithAggregatesInput = {
    AND?: ExportLogScalarWhereWithAggregatesInput | ExportLogScalarWhereWithAggregatesInput[]
    OR?: ExportLogScalarWhereWithAggregatesInput[]
    NOT?: ExportLogScalarWhereWithAggregatesInput | ExportLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExportLog"> | string
    fileName?: StringWithAggregatesFilter<"ExportLog"> | string
    exportType?: StringWithAggregatesFilter<"ExportLog"> | string
    exportedBy?: StringWithAggregatesFilter<"ExportLog"> | string
    exportedAt?: DateTimeWithAggregatesFilter<"ExportLog"> | Date | string
  }

  export type MethodologyWhereInput = {
    AND?: MethodologyWhereInput | MethodologyWhereInput[]
    OR?: MethodologyWhereInput[]
    NOT?: MethodologyWhereInput | MethodologyWhereInput[]
    id?: StringFilter<"Methodology"> | string
    name?: StringFilter<"Methodology"> | string
    description?: StringFilter<"Methodology"> | string
    procedure?: StringFilter<"Methodology"> | string
    createdAt?: DateTimeFilter<"Methodology"> | Date | string
    updatedAt?: DateTimeFilter<"Methodology"> | Date | string
    Standards?: StandardListRelationFilter
    batches?: BatchListRelationFilter
    batchParameterValues?: BatchParameterValueListRelationFilter
    standardDefinitions?: StandardDefinitionListRelationFilter
  }

  export type MethodologyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    procedure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Standards?: StandardOrderByRelationAggregateInput
    batches?: BatchOrderByRelationAggregateInput
    batchParameterValues?: BatchParameterValueOrderByRelationAggregateInput
    standardDefinitions?: StandardDefinitionOrderByRelationAggregateInput
  }

  export type MethodologyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MethodologyWhereInput | MethodologyWhereInput[]
    OR?: MethodologyWhereInput[]
    NOT?: MethodologyWhereInput | MethodologyWhereInput[]
    description?: StringFilter<"Methodology"> | string
    procedure?: StringFilter<"Methodology"> | string
    createdAt?: DateTimeFilter<"Methodology"> | Date | string
    updatedAt?: DateTimeFilter<"Methodology"> | Date | string
    Standards?: StandardListRelationFilter
    batches?: BatchListRelationFilter
    batchParameterValues?: BatchParameterValueListRelationFilter
    standardDefinitions?: StandardDefinitionListRelationFilter
  }, "id" | "name">

  export type MethodologyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    procedure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MethodologyCountOrderByAggregateInput
    _max?: MethodologyMaxOrderByAggregateInput
    _min?: MethodologyMinOrderByAggregateInput
  }

  export type MethodologyScalarWhereWithAggregatesInput = {
    AND?: MethodologyScalarWhereWithAggregatesInput | MethodologyScalarWhereWithAggregatesInput[]
    OR?: MethodologyScalarWhereWithAggregatesInput[]
    NOT?: MethodologyScalarWhereWithAggregatesInput | MethodologyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Methodology"> | string
    name?: StringWithAggregatesFilter<"Methodology"> | string
    description?: StringWithAggregatesFilter<"Methodology"> | string
    procedure?: StringWithAggregatesFilter<"Methodology"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Methodology"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Methodology"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    batchId?: StringNullableFilter<"Notification"> | string | null
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    Batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    Batch?: BatchOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    batchId?: StringNullableFilter<"Notification"> | string | null
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    Batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    batchId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    Role?: RoleListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Role?: RoleOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    action_resource?: PermissionActionResourceCompoundUniqueInput
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    action?: StringFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    Role?: RoleListRelationFilter
  }, "id" | "action_resource">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    resource?: StringWithAggregatesFilter<"Permission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    code?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    Batch?: BatchListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Batch?: BatchOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    Batch?: BatchListRelationFilter
  }, "id" | "name" | "code">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    code?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    User?: UserListRelationFilter
    Permission?: PermissionListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByRelationAggregateInput
    Permission?: PermissionOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    User?: UserListRelationFilter
    Permission?: PermissionListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type UnitOfMeasurementWhereInput = {
    AND?: UnitOfMeasurementWhereInput | UnitOfMeasurementWhereInput[]
    OR?: UnitOfMeasurementWhereInput[]
    NOT?: UnitOfMeasurementWhereInput | UnitOfMeasurementWhereInput[]
    id?: StringFilter<"UnitOfMeasurement"> | string
    name?: StringFilter<"UnitOfMeasurement"> | string
    symbol?: StringFilter<"UnitOfMeasurement"> | string
    description?: StringNullableFilter<"UnitOfMeasurement"> | string | null
    createdAt?: DateTimeFilter<"UnitOfMeasurement"> | Date | string
    updatedAt?: DateTimeFilter<"UnitOfMeasurement"> | Date | string
    Standards?: StandardListRelationFilter
    batchParameterValues?: BatchParameterValueListRelationFilter
    standardDefinitions?: StandardDefinitionListRelationFilter
    batches?: BatchListRelationFilter
  }

  export type UnitOfMeasurementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Standards?: StandardOrderByRelationAggregateInput
    batchParameterValues?: BatchParameterValueOrderByRelationAggregateInput
    standardDefinitions?: StandardDefinitionOrderByRelationAggregateInput
    batches?: BatchOrderByRelationAggregateInput
  }

  export type UnitOfMeasurementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: UnitOfMeasurementWhereInput | UnitOfMeasurementWhereInput[]
    OR?: UnitOfMeasurementWhereInput[]
    NOT?: UnitOfMeasurementWhereInput | UnitOfMeasurementWhereInput[]
    symbol?: StringFilter<"UnitOfMeasurement"> | string
    description?: StringNullableFilter<"UnitOfMeasurement"> | string | null
    createdAt?: DateTimeFilter<"UnitOfMeasurement"> | Date | string
    updatedAt?: DateTimeFilter<"UnitOfMeasurement"> | Date | string
    Standards?: StandardListRelationFilter
    batchParameterValues?: BatchParameterValueListRelationFilter
    standardDefinitions?: StandardDefinitionListRelationFilter
    batches?: BatchListRelationFilter
  }, "id" | "name">

  export type UnitOfMeasurementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitOfMeasurementCountOrderByAggregateInput
    _max?: UnitOfMeasurementMaxOrderByAggregateInput
    _min?: UnitOfMeasurementMinOrderByAggregateInput
  }

  export type UnitOfMeasurementScalarWhereWithAggregatesInput = {
    AND?: UnitOfMeasurementScalarWhereWithAggregatesInput | UnitOfMeasurementScalarWhereWithAggregatesInput[]
    OR?: UnitOfMeasurementScalarWhereWithAggregatesInput[]
    NOT?: UnitOfMeasurementScalarWhereWithAggregatesInput | UnitOfMeasurementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitOfMeasurement"> | string
    name?: StringWithAggregatesFilter<"UnitOfMeasurement"> | string
    symbol?: StringWithAggregatesFilter<"UnitOfMeasurement"> | string
    description?: StringNullableWithAggregatesFilter<"UnitOfMeasurement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UnitOfMeasurement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitOfMeasurement"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    ActivityLog?: ActivityLogListRelationFilter
    Batch_Batch_checkerIdToUser?: BatchListRelationFilter
    Batch_Batch_makerIdToUser?: BatchListRelationFilter
    Notification?: NotificationListRelationFilter
    Role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    StandardsCreated?: StandardListRelationFilter
    StandardsModified?: StandardListRelationFilter
    standardDefinitionsCreated?: StandardDefinitionListRelationFilter
    standardDefinitionsModified?: StandardDefinitionListRelationFilter
    trainerTrainings?: TrainingListRelationFilter
    createdTrainings?: TrainingListRelationFilter
    trainingParticipations?: TrainingParticipantListRelationFilter
    attendances?: AttendanceListRelationFilter
    uploadedDocuments?: TrainingDocumentListRelationFilter
    uploadedPhotos?: TrainingPhotoListRelationFilter
    feedbacks?: TrainingFeedbackListRelationFilter
    assignedFollowups?: TrainingFollowupListRelationFilter
    createdFollowups?: TrainingFollowupListRelationFilter
    trainingNotifications?: TrainingNotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ActivityLog?: ActivityLogOrderByRelationAggregateInput
    Batch_Batch_checkerIdToUser?: BatchOrderByRelationAggregateInput
    Batch_Batch_makerIdToUser?: BatchOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    Role?: RoleOrderByWithRelationInput
    StandardsCreated?: StandardOrderByRelationAggregateInput
    StandardsModified?: StandardOrderByRelationAggregateInput
    standardDefinitionsCreated?: StandardDefinitionOrderByRelationAggregateInput
    standardDefinitionsModified?: StandardDefinitionOrderByRelationAggregateInput
    trainerTrainings?: TrainingOrderByRelationAggregateInput
    createdTrainings?: TrainingOrderByRelationAggregateInput
    trainingParticipations?: TrainingParticipantOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    uploadedDocuments?: TrainingDocumentOrderByRelationAggregateInput
    uploadedPhotos?: TrainingPhotoOrderByRelationAggregateInput
    feedbacks?: TrainingFeedbackOrderByRelationAggregateInput
    assignedFollowups?: TrainingFollowupOrderByRelationAggregateInput
    createdFollowups?: TrainingFollowupOrderByRelationAggregateInput
    trainingNotifications?: TrainingNotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    ActivityLog?: ActivityLogListRelationFilter
    Batch_Batch_checkerIdToUser?: BatchListRelationFilter
    Batch_Batch_makerIdToUser?: BatchListRelationFilter
    Notification?: NotificationListRelationFilter
    Role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    StandardsCreated?: StandardListRelationFilter
    StandardsModified?: StandardListRelationFilter
    standardDefinitionsCreated?: StandardDefinitionListRelationFilter
    standardDefinitionsModified?: StandardDefinitionListRelationFilter
    trainerTrainings?: TrainingListRelationFilter
    createdTrainings?: TrainingListRelationFilter
    trainingParticipations?: TrainingParticipantListRelationFilter
    attendances?: AttendanceListRelationFilter
    uploadedDocuments?: TrainingDocumentListRelationFilter
    uploadedPhotos?: TrainingPhotoListRelationFilter
    feedbacks?: TrainingFeedbackListRelationFilter
    assignedFollowups?: TrainingFollowupListRelationFilter
    createdFollowups?: TrainingFollowupListRelationFilter
    trainingNotifications?: TrainingNotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    roleId?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type StandardWhereInput = {
    AND?: StandardWhereInput | StandardWhereInput[]
    OR?: StandardWhereInput[]
    NOT?: StandardWhereInput | StandardWhereInput[]
    id?: StringFilter<"Standard"> | string
    name?: StringFilter<"Standard"> | string
    code?: StringFilter<"Standard"> | string
    description?: StringFilter<"Standard"> | string
    categoryId?: StringFilter<"Standard"> | string
    createdById?: StringFilter<"Standard"> | string
    modifiedById?: StringNullableFilter<"Standard"> | string | null
    status?: EnumStandardStatusFilter<"Standard"> | $Enums.StandardStatus
    createdAt?: DateTimeFilter<"Standard"> | Date | string
    updatedAt?: DateTimeFilter<"Standard"> | Date | string
    Category?: XOR<StandardCategoryScalarRelationFilter, StandardCategoryWhereInput>
    CreatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ModifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    batches?: BatchListRelationFilter
    methodologies?: MethodologyListRelationFilter
    units?: UnitOfMeasurementListRelationFilter
  }

  export type StandardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Category?: StandardCategoryOrderByWithRelationInput
    CreatedBy?: UserOrderByWithRelationInput
    ModifiedBy?: UserOrderByWithRelationInput
    batches?: BatchOrderByRelationAggregateInput
    methodologies?: MethodologyOrderByRelationAggregateInput
    units?: UnitOfMeasurementOrderByRelationAggregateInput
  }

  export type StandardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: StandardWhereInput | StandardWhereInput[]
    OR?: StandardWhereInput[]
    NOT?: StandardWhereInput | StandardWhereInput[]
    description?: StringFilter<"Standard"> | string
    categoryId?: StringFilter<"Standard"> | string
    createdById?: StringFilter<"Standard"> | string
    modifiedById?: StringNullableFilter<"Standard"> | string | null
    status?: EnumStandardStatusFilter<"Standard"> | $Enums.StandardStatus
    createdAt?: DateTimeFilter<"Standard"> | Date | string
    updatedAt?: DateTimeFilter<"Standard"> | Date | string
    Category?: XOR<StandardCategoryScalarRelationFilter, StandardCategoryWhereInput>
    CreatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ModifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    batches?: BatchListRelationFilter
    methodologies?: MethodologyListRelationFilter
    units?: UnitOfMeasurementListRelationFilter
  }, "id" | "name" | "code">

  export type StandardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StandardCountOrderByAggregateInput
    _max?: StandardMaxOrderByAggregateInput
    _min?: StandardMinOrderByAggregateInput
  }

  export type StandardScalarWhereWithAggregatesInput = {
    AND?: StandardScalarWhereWithAggregatesInput | StandardScalarWhereWithAggregatesInput[]
    OR?: StandardScalarWhereWithAggregatesInput[]
    NOT?: StandardScalarWhereWithAggregatesInput | StandardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Standard"> | string
    name?: StringWithAggregatesFilter<"Standard"> | string
    code?: StringWithAggregatesFilter<"Standard"> | string
    description?: StringWithAggregatesFilter<"Standard"> | string
    categoryId?: StringWithAggregatesFilter<"Standard"> | string
    createdById?: StringWithAggregatesFilter<"Standard"> | string
    modifiedById?: StringNullableWithAggregatesFilter<"Standard"> | string | null
    status?: EnumStandardStatusWithAggregatesFilter<"Standard"> | $Enums.StandardStatus
    createdAt?: DateTimeWithAggregatesFilter<"Standard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Standard"> | Date | string
  }

  export type StandardCategoryWhereInput = {
    AND?: StandardCategoryWhereInput | StandardCategoryWhereInput[]
    OR?: StandardCategoryWhereInput[]
    NOT?: StandardCategoryWhereInput | StandardCategoryWhereInput[]
    id?: StringFilter<"StandardCategory"> | string
    name?: StringFilter<"StandardCategory"> | string
    description?: StringNullableFilter<"StandardCategory"> | string | null
    createdAt?: DateTimeFilter<"StandardCategory"> | Date | string
    updatedAt?: DateTimeFilter<"StandardCategory"> | Date | string
    parameters?: StandardParameterListRelationFilter
    Standards?: StandardListRelationFilter
  }

  export type StandardCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parameters?: StandardParameterOrderByRelationAggregateInput
    Standards?: StandardOrderByRelationAggregateInput
  }

  export type StandardCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: StandardCategoryWhereInput | StandardCategoryWhereInput[]
    OR?: StandardCategoryWhereInput[]
    NOT?: StandardCategoryWhereInput | StandardCategoryWhereInput[]
    description?: StringNullableFilter<"StandardCategory"> | string | null
    createdAt?: DateTimeFilter<"StandardCategory"> | Date | string
    updatedAt?: DateTimeFilter<"StandardCategory"> | Date | string
    parameters?: StandardParameterListRelationFilter
    Standards?: StandardListRelationFilter
  }, "id" | "name">

  export type StandardCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StandardCategoryCountOrderByAggregateInput
    _max?: StandardCategoryMaxOrderByAggregateInput
    _min?: StandardCategoryMinOrderByAggregateInput
  }

  export type StandardCategoryScalarWhereWithAggregatesInput = {
    AND?: StandardCategoryScalarWhereWithAggregatesInput | StandardCategoryScalarWhereWithAggregatesInput[]
    OR?: StandardCategoryScalarWhereWithAggregatesInput[]
    NOT?: StandardCategoryScalarWhereWithAggregatesInput | StandardCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StandardCategory"> | string
    name?: StringWithAggregatesFilter<"StandardCategory"> | string
    description?: StringNullableWithAggregatesFilter<"StandardCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StandardCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StandardCategory"> | Date | string
  }

  export type StandardParameterWhereInput = {
    AND?: StandardParameterWhereInput | StandardParameterWhereInput[]
    OR?: StandardParameterWhereInput[]
    NOT?: StandardParameterWhereInput | StandardParameterWhereInput[]
    id?: StringFilter<"StandardParameter"> | string
    name?: StringFilter<"StandardParameter"> | string
    categoryId?: StringFilter<"StandardParameter"> | string
    description?: StringNullableFilter<"StandardParameter"> | string | null
    dataType?: EnumParameterDataTypeFilter<"StandardParameter"> | $Enums.ParameterDataType
    createdAt?: DateTimeFilter<"StandardParameter"> | Date | string
    updatedAt?: DateTimeFilter<"StandardParameter"> | Date | string
    category?: XOR<StandardCategoryScalarRelationFilter, StandardCategoryWhereInput>
    batchValues?: BatchParameterValueListRelationFilter
    standards?: StandardDefinitionListRelationFilter
  }

  export type StandardParameterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    description?: SortOrderInput | SortOrder
    dataType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: StandardCategoryOrderByWithRelationInput
    batchValues?: BatchParameterValueOrderByRelationAggregateInput
    standards?: StandardDefinitionOrderByRelationAggregateInput
  }

  export type StandardParameterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StandardParameterWhereInput | StandardParameterWhereInput[]
    OR?: StandardParameterWhereInput[]
    NOT?: StandardParameterWhereInput | StandardParameterWhereInput[]
    name?: StringFilter<"StandardParameter"> | string
    categoryId?: StringFilter<"StandardParameter"> | string
    description?: StringNullableFilter<"StandardParameter"> | string | null
    dataType?: EnumParameterDataTypeFilter<"StandardParameter"> | $Enums.ParameterDataType
    createdAt?: DateTimeFilter<"StandardParameter"> | Date | string
    updatedAt?: DateTimeFilter<"StandardParameter"> | Date | string
    category?: XOR<StandardCategoryScalarRelationFilter, StandardCategoryWhereInput>
    batchValues?: BatchParameterValueListRelationFilter
    standards?: StandardDefinitionListRelationFilter
  }, "id">

  export type StandardParameterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    description?: SortOrderInput | SortOrder
    dataType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StandardParameterCountOrderByAggregateInput
    _max?: StandardParameterMaxOrderByAggregateInput
    _min?: StandardParameterMinOrderByAggregateInput
  }

  export type StandardParameterScalarWhereWithAggregatesInput = {
    AND?: StandardParameterScalarWhereWithAggregatesInput | StandardParameterScalarWhereWithAggregatesInput[]
    OR?: StandardParameterScalarWhereWithAggregatesInput[]
    NOT?: StandardParameterScalarWhereWithAggregatesInput | StandardParameterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StandardParameter"> | string
    name?: StringWithAggregatesFilter<"StandardParameter"> | string
    categoryId?: StringWithAggregatesFilter<"StandardParameter"> | string
    description?: StringNullableWithAggregatesFilter<"StandardParameter"> | string | null
    dataType?: EnumParameterDataTypeWithAggregatesFilter<"StandardParameter"> | $Enums.ParameterDataType
    createdAt?: DateTimeWithAggregatesFilter<"StandardParameter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StandardParameter"> | Date | string
  }

  export type StandardDefinitionWhereInput = {
    AND?: StandardDefinitionWhereInput | StandardDefinitionWhereInput[]
    OR?: StandardDefinitionWhereInput[]
    NOT?: StandardDefinitionWhereInput | StandardDefinitionWhereInput[]
    id?: StringFilter<"StandardDefinition"> | string
    parameterId?: StringFilter<"StandardDefinition"> | string
    standardValue?: StringFilter<"StandardDefinition"> | string
    unitId?: StringNullableFilter<"StandardDefinition"> | string | null
    methodologyId?: StringNullableFilter<"StandardDefinition"> | string | null
    createdById?: StringFilter<"StandardDefinition"> | string
    modifiedById?: StringNullableFilter<"StandardDefinition"> | string | null
    status?: EnumStandardStatusFilter<"StandardDefinition"> | $Enums.StandardStatus
    createdAt?: DateTimeFilter<"StandardDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"StandardDefinition"> | Date | string
    parameter?: XOR<StandardParameterScalarRelationFilter, StandardParameterWhereInput>
    unit?: XOR<UnitOfMeasurementNullableScalarRelationFilter, UnitOfMeasurementWhereInput> | null
    methodology?: XOR<MethodologyNullableScalarRelationFilter, MethodologyWhereInput> | null
    CreatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ModifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type StandardDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    parameterId?: SortOrder
    standardValue?: SortOrder
    unitId?: SortOrderInput | SortOrder
    methodologyId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parameter?: StandardParameterOrderByWithRelationInput
    unit?: UnitOfMeasurementOrderByWithRelationInput
    methodology?: MethodologyOrderByWithRelationInput
    CreatedBy?: UserOrderByWithRelationInput
    ModifiedBy?: UserOrderByWithRelationInput
  }

  export type StandardDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StandardDefinitionWhereInput | StandardDefinitionWhereInput[]
    OR?: StandardDefinitionWhereInput[]
    NOT?: StandardDefinitionWhereInput | StandardDefinitionWhereInput[]
    parameterId?: StringFilter<"StandardDefinition"> | string
    standardValue?: StringFilter<"StandardDefinition"> | string
    unitId?: StringNullableFilter<"StandardDefinition"> | string | null
    methodologyId?: StringNullableFilter<"StandardDefinition"> | string | null
    createdById?: StringFilter<"StandardDefinition"> | string
    modifiedById?: StringNullableFilter<"StandardDefinition"> | string | null
    status?: EnumStandardStatusFilter<"StandardDefinition"> | $Enums.StandardStatus
    createdAt?: DateTimeFilter<"StandardDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"StandardDefinition"> | Date | string
    parameter?: XOR<StandardParameterScalarRelationFilter, StandardParameterWhereInput>
    unit?: XOR<UnitOfMeasurementNullableScalarRelationFilter, UnitOfMeasurementWhereInput> | null
    methodology?: XOR<MethodologyNullableScalarRelationFilter, MethodologyWhereInput> | null
    CreatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ModifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type StandardDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    parameterId?: SortOrder
    standardValue?: SortOrder
    unitId?: SortOrderInput | SortOrder
    methodologyId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StandardDefinitionCountOrderByAggregateInput
    _max?: StandardDefinitionMaxOrderByAggregateInput
    _min?: StandardDefinitionMinOrderByAggregateInput
  }

  export type StandardDefinitionScalarWhereWithAggregatesInput = {
    AND?: StandardDefinitionScalarWhereWithAggregatesInput | StandardDefinitionScalarWhereWithAggregatesInput[]
    OR?: StandardDefinitionScalarWhereWithAggregatesInput[]
    NOT?: StandardDefinitionScalarWhereWithAggregatesInput | StandardDefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StandardDefinition"> | string
    parameterId?: StringWithAggregatesFilter<"StandardDefinition"> | string
    standardValue?: StringWithAggregatesFilter<"StandardDefinition"> | string
    unitId?: StringNullableWithAggregatesFilter<"StandardDefinition"> | string | null
    methodologyId?: StringNullableWithAggregatesFilter<"StandardDefinition"> | string | null
    createdById?: StringWithAggregatesFilter<"StandardDefinition"> | string
    modifiedById?: StringNullableWithAggregatesFilter<"StandardDefinition"> | string | null
    status?: EnumStandardStatusWithAggregatesFilter<"StandardDefinition"> | $Enums.StandardStatus
    createdAt?: DateTimeWithAggregatesFilter<"StandardDefinition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StandardDefinition"> | Date | string
  }

  export type BatchParameterValueWhereInput = {
    AND?: BatchParameterValueWhereInput | BatchParameterValueWhereInput[]
    OR?: BatchParameterValueWhereInput[]
    NOT?: BatchParameterValueWhereInput | BatchParameterValueWhereInput[]
    id?: StringFilter<"BatchParameterValue"> | string
    batchId?: StringFilter<"BatchParameterValue"> | string
    parameterId?: StringFilter<"BatchParameterValue"> | string
    value?: StringFilter<"BatchParameterValue"> | string
    unitId?: StringNullableFilter<"BatchParameterValue"> | string | null
    methodologyId?: StringNullableFilter<"BatchParameterValue"> | string | null
    createdAt?: DateTimeFilter<"BatchParameterValue"> | Date | string
    updatedAt?: DateTimeFilter<"BatchParameterValue"> | Date | string
    batch?: XOR<BatchScalarRelationFilter, BatchWhereInput>
    parameter?: XOR<StandardParameterScalarRelationFilter, StandardParameterWhereInput>
    unit?: XOR<UnitOfMeasurementNullableScalarRelationFilter, UnitOfMeasurementWhereInput> | null
    methodology?: XOR<MethodologyNullableScalarRelationFilter, MethodologyWhereInput> | null
  }

  export type BatchParameterValueOrderByWithRelationInput = {
    id?: SortOrder
    batchId?: SortOrder
    parameterId?: SortOrder
    value?: SortOrder
    unitId?: SortOrderInput | SortOrder
    methodologyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    batch?: BatchOrderByWithRelationInput
    parameter?: StandardParameterOrderByWithRelationInput
    unit?: UnitOfMeasurementOrderByWithRelationInput
    methodology?: MethodologyOrderByWithRelationInput
  }

  export type BatchParameterValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    batchId_parameterId?: BatchParameterValueBatchIdParameterIdCompoundUniqueInput
    AND?: BatchParameterValueWhereInput | BatchParameterValueWhereInput[]
    OR?: BatchParameterValueWhereInput[]
    NOT?: BatchParameterValueWhereInput | BatchParameterValueWhereInput[]
    batchId?: StringFilter<"BatchParameterValue"> | string
    parameterId?: StringFilter<"BatchParameterValue"> | string
    value?: StringFilter<"BatchParameterValue"> | string
    unitId?: StringNullableFilter<"BatchParameterValue"> | string | null
    methodologyId?: StringNullableFilter<"BatchParameterValue"> | string | null
    createdAt?: DateTimeFilter<"BatchParameterValue"> | Date | string
    updatedAt?: DateTimeFilter<"BatchParameterValue"> | Date | string
    batch?: XOR<BatchScalarRelationFilter, BatchWhereInput>
    parameter?: XOR<StandardParameterScalarRelationFilter, StandardParameterWhereInput>
    unit?: XOR<UnitOfMeasurementNullableScalarRelationFilter, UnitOfMeasurementWhereInput> | null
    methodology?: XOR<MethodologyNullableScalarRelationFilter, MethodologyWhereInput> | null
  }, "id" | "batchId_parameterId">

  export type BatchParameterValueOrderByWithAggregationInput = {
    id?: SortOrder
    batchId?: SortOrder
    parameterId?: SortOrder
    value?: SortOrder
    unitId?: SortOrderInput | SortOrder
    methodologyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BatchParameterValueCountOrderByAggregateInput
    _max?: BatchParameterValueMaxOrderByAggregateInput
    _min?: BatchParameterValueMinOrderByAggregateInput
  }

  export type BatchParameterValueScalarWhereWithAggregatesInput = {
    AND?: BatchParameterValueScalarWhereWithAggregatesInput | BatchParameterValueScalarWhereWithAggregatesInput[]
    OR?: BatchParameterValueScalarWhereWithAggregatesInput[]
    NOT?: BatchParameterValueScalarWhereWithAggregatesInput | BatchParameterValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BatchParameterValue"> | string
    batchId?: StringWithAggregatesFilter<"BatchParameterValue"> | string
    parameterId?: StringWithAggregatesFilter<"BatchParameterValue"> | string
    value?: StringWithAggregatesFilter<"BatchParameterValue"> | string
    unitId?: StringNullableWithAggregatesFilter<"BatchParameterValue"> | string | null
    methodologyId?: StringNullableWithAggregatesFilter<"BatchParameterValue"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BatchParameterValue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BatchParameterValue"> | Date | string
  }

  export type TrainingCalendarWhereInput = {
    AND?: TrainingCalendarWhereInput | TrainingCalendarWhereInput[]
    OR?: TrainingCalendarWhereInput[]
    NOT?: TrainingCalendarWhereInput | TrainingCalendarWhereInput[]
    id?: StringFilter<"TrainingCalendar"> | string
    month?: IntFilter<"TrainingCalendar"> | number
    year?: IntFilter<"TrainingCalendar"> | number
    description?: StringNullableFilter<"TrainingCalendar"> | string | null
    createdAt?: DateTimeFilter<"TrainingCalendar"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingCalendar"> | Date | string
    trainings?: TrainingListRelationFilter
  }

  export type TrainingCalendarOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainings?: TrainingOrderByRelationAggregateInput
  }

  export type TrainingCalendarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    month_year?: TrainingCalendarMonthYearCompoundUniqueInput
    AND?: TrainingCalendarWhereInput | TrainingCalendarWhereInput[]
    OR?: TrainingCalendarWhereInput[]
    NOT?: TrainingCalendarWhereInput | TrainingCalendarWhereInput[]
    month?: IntFilter<"TrainingCalendar"> | number
    year?: IntFilter<"TrainingCalendar"> | number
    description?: StringNullableFilter<"TrainingCalendar"> | string | null
    createdAt?: DateTimeFilter<"TrainingCalendar"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingCalendar"> | Date | string
    trainings?: TrainingListRelationFilter
  }, "id" | "month_year">

  export type TrainingCalendarOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingCalendarCountOrderByAggregateInput
    _avg?: TrainingCalendarAvgOrderByAggregateInput
    _max?: TrainingCalendarMaxOrderByAggregateInput
    _min?: TrainingCalendarMinOrderByAggregateInput
    _sum?: TrainingCalendarSumOrderByAggregateInput
  }

  export type TrainingCalendarScalarWhereWithAggregatesInput = {
    AND?: TrainingCalendarScalarWhereWithAggregatesInput | TrainingCalendarScalarWhereWithAggregatesInput[]
    OR?: TrainingCalendarScalarWhereWithAggregatesInput[]
    NOT?: TrainingCalendarScalarWhereWithAggregatesInput | TrainingCalendarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingCalendar"> | string
    month?: IntWithAggregatesFilter<"TrainingCalendar"> | number
    year?: IntWithAggregatesFilter<"TrainingCalendar"> | number
    description?: StringNullableWithAggregatesFilter<"TrainingCalendar"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TrainingCalendar"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingCalendar"> | Date | string
  }

  export type TrainingWhereInput = {
    AND?: TrainingWhereInput | TrainingWhereInput[]
    OR?: TrainingWhereInput[]
    NOT?: TrainingWhereInput | TrainingWhereInput[]
    id?: StringFilter<"Training"> | string
    title?: StringFilter<"Training"> | string
    description?: StringNullableFilter<"Training"> | string | null
    trainingType?: EnumTrainingTypeFilter<"Training"> | $Enums.TrainingType
    status?: EnumTrainingStatusFilter<"Training"> | $Enums.TrainingStatus
    startDate?: DateTimeFilter<"Training"> | Date | string
    endDate?: DateTimeFilter<"Training"> | Date | string
    location?: StringFilter<"Training"> | string
    maxParticipants?: IntNullableFilter<"Training"> | number | null
    trainerId?: StringFilter<"Training"> | string
    calendarId?: StringFilter<"Training"> | string
    createdById?: StringFilter<"Training"> | string
    createdAt?: DateTimeFilter<"Training"> | Date | string
    updatedAt?: DateTimeFilter<"Training"> | Date | string
    trainer?: XOR<UserScalarRelationFilter, UserWhereInput>
    calendar?: XOR<TrainingCalendarScalarRelationFilter, TrainingCalendarWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    sessions?: TrainingSessionListRelationFilter
    documents?: TrainingDocumentListRelationFilter
    attendance?: AttendanceListRelationFilter
    participants?: TrainingParticipantListRelationFilter
    photos?: TrainingPhotoListRelationFilter
    feedback?: TrainingFeedbackListRelationFilter
    followups?: TrainingFollowupListRelationFilter
    notifications?: TrainingNotificationListRelationFilter
  }

  export type TrainingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    trainingType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    trainerId?: SortOrder
    calendarId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainer?: UserOrderByWithRelationInput
    calendar?: TrainingCalendarOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    sessions?: TrainingSessionOrderByRelationAggregateInput
    documents?: TrainingDocumentOrderByRelationAggregateInput
    attendance?: AttendanceOrderByRelationAggregateInput
    participants?: TrainingParticipantOrderByRelationAggregateInput
    photos?: TrainingPhotoOrderByRelationAggregateInput
    feedback?: TrainingFeedbackOrderByRelationAggregateInput
    followups?: TrainingFollowupOrderByRelationAggregateInput
    notifications?: TrainingNotificationOrderByRelationAggregateInput
  }

  export type TrainingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingWhereInput | TrainingWhereInput[]
    OR?: TrainingWhereInput[]
    NOT?: TrainingWhereInput | TrainingWhereInput[]
    title?: StringFilter<"Training"> | string
    description?: StringNullableFilter<"Training"> | string | null
    trainingType?: EnumTrainingTypeFilter<"Training"> | $Enums.TrainingType
    status?: EnumTrainingStatusFilter<"Training"> | $Enums.TrainingStatus
    startDate?: DateTimeFilter<"Training"> | Date | string
    endDate?: DateTimeFilter<"Training"> | Date | string
    location?: StringFilter<"Training"> | string
    maxParticipants?: IntNullableFilter<"Training"> | number | null
    trainerId?: StringFilter<"Training"> | string
    calendarId?: StringFilter<"Training"> | string
    createdById?: StringFilter<"Training"> | string
    createdAt?: DateTimeFilter<"Training"> | Date | string
    updatedAt?: DateTimeFilter<"Training"> | Date | string
    trainer?: XOR<UserScalarRelationFilter, UserWhereInput>
    calendar?: XOR<TrainingCalendarScalarRelationFilter, TrainingCalendarWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    sessions?: TrainingSessionListRelationFilter
    documents?: TrainingDocumentListRelationFilter
    attendance?: AttendanceListRelationFilter
    participants?: TrainingParticipantListRelationFilter
    photos?: TrainingPhotoListRelationFilter
    feedback?: TrainingFeedbackListRelationFilter
    followups?: TrainingFollowupListRelationFilter
    notifications?: TrainingNotificationListRelationFilter
  }, "id">

  export type TrainingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    trainingType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    trainerId?: SortOrder
    calendarId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingCountOrderByAggregateInput
    _avg?: TrainingAvgOrderByAggregateInput
    _max?: TrainingMaxOrderByAggregateInput
    _min?: TrainingMinOrderByAggregateInput
    _sum?: TrainingSumOrderByAggregateInput
  }

  export type TrainingScalarWhereWithAggregatesInput = {
    AND?: TrainingScalarWhereWithAggregatesInput | TrainingScalarWhereWithAggregatesInput[]
    OR?: TrainingScalarWhereWithAggregatesInput[]
    NOT?: TrainingScalarWhereWithAggregatesInput | TrainingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Training"> | string
    title?: StringWithAggregatesFilter<"Training"> | string
    description?: StringNullableWithAggregatesFilter<"Training"> | string | null
    trainingType?: EnumTrainingTypeWithAggregatesFilter<"Training"> | $Enums.TrainingType
    status?: EnumTrainingStatusWithAggregatesFilter<"Training"> | $Enums.TrainingStatus
    startDate?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    location?: StringWithAggregatesFilter<"Training"> | string
    maxParticipants?: IntNullableWithAggregatesFilter<"Training"> | number | null
    trainerId?: StringWithAggregatesFilter<"Training"> | string
    calendarId?: StringWithAggregatesFilter<"Training"> | string
    createdById?: StringWithAggregatesFilter<"Training"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Training"> | Date | string
  }

  export type TrainingSessionWhereInput = {
    AND?: TrainingSessionWhereInput | TrainingSessionWhereInput[]
    OR?: TrainingSessionWhereInput[]
    NOT?: TrainingSessionWhereInput | TrainingSessionWhereInput[]
    id?: StringFilter<"TrainingSession"> | string
    trainingId?: StringFilter<"TrainingSession"> | string
    title?: StringFilter<"TrainingSession"> | string
    description?: StringNullableFilter<"TrainingSession"> | string | null
    startTime?: DateTimeFilter<"TrainingSession"> | Date | string
    endTime?: DateTimeFilter<"TrainingSession"> | Date | string
    venue?: StringFilter<"TrainingSession"> | string
    createdAt?: DateTimeFilter<"TrainingSession"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingSession"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    attendance?: AttendanceListRelationFilter
  }

  export type TrainingSessionOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    attendance?: AttendanceOrderByRelationAggregateInput
  }

  export type TrainingSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingSessionWhereInput | TrainingSessionWhereInput[]
    OR?: TrainingSessionWhereInput[]
    NOT?: TrainingSessionWhereInput | TrainingSessionWhereInput[]
    trainingId?: StringFilter<"TrainingSession"> | string
    title?: StringFilter<"TrainingSession"> | string
    description?: StringNullableFilter<"TrainingSession"> | string | null
    startTime?: DateTimeFilter<"TrainingSession"> | Date | string
    endTime?: DateTimeFilter<"TrainingSession"> | Date | string
    venue?: StringFilter<"TrainingSession"> | string
    createdAt?: DateTimeFilter<"TrainingSession"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingSession"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    attendance?: AttendanceListRelationFilter
  }, "id">

  export type TrainingSessionOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingSessionCountOrderByAggregateInput
    _max?: TrainingSessionMaxOrderByAggregateInput
    _min?: TrainingSessionMinOrderByAggregateInput
  }

  export type TrainingSessionScalarWhereWithAggregatesInput = {
    AND?: TrainingSessionScalarWhereWithAggregatesInput | TrainingSessionScalarWhereWithAggregatesInput[]
    OR?: TrainingSessionScalarWhereWithAggregatesInput[]
    NOT?: TrainingSessionScalarWhereWithAggregatesInput | TrainingSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingSession"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingSession"> | string
    title?: StringWithAggregatesFilter<"TrainingSession"> | string
    description?: StringNullableWithAggregatesFilter<"TrainingSession"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"TrainingSession"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"TrainingSession"> | Date | string
    venue?: StringWithAggregatesFilter<"TrainingSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrainingSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingSession"> | Date | string
  }

  export type TrainingDocumentWhereInput = {
    AND?: TrainingDocumentWhereInput | TrainingDocumentWhereInput[]
    OR?: TrainingDocumentWhereInput[]
    NOT?: TrainingDocumentWhereInput | TrainingDocumentWhereInput[]
    id?: StringFilter<"TrainingDocument"> | string
    trainingId?: StringFilter<"TrainingDocument"> | string
    title?: StringFilter<"TrainingDocument"> | string
    description?: StringNullableFilter<"TrainingDocument"> | string | null
    fileUrl?: StringFilter<"TrainingDocument"> | string
    documentType?: EnumDocumentTypeFilter<"TrainingDocument"> | $Enums.DocumentType
    uploadedById?: StringFilter<"TrainingDocument"> | string
    createdAt?: DateTimeFilter<"TrainingDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDocument"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrainingDocumentOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    documentType?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type TrainingDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingDocumentWhereInput | TrainingDocumentWhereInput[]
    OR?: TrainingDocumentWhereInput[]
    NOT?: TrainingDocumentWhereInput | TrainingDocumentWhereInput[]
    trainingId?: StringFilter<"TrainingDocument"> | string
    title?: StringFilter<"TrainingDocument"> | string
    description?: StringNullableFilter<"TrainingDocument"> | string | null
    fileUrl?: StringFilter<"TrainingDocument"> | string
    documentType?: EnumDocumentTypeFilter<"TrainingDocument"> | $Enums.DocumentType
    uploadedById?: StringFilter<"TrainingDocument"> | string
    createdAt?: DateTimeFilter<"TrainingDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDocument"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TrainingDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    documentType?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingDocumentCountOrderByAggregateInput
    _max?: TrainingDocumentMaxOrderByAggregateInput
    _min?: TrainingDocumentMinOrderByAggregateInput
  }

  export type TrainingDocumentScalarWhereWithAggregatesInput = {
    AND?: TrainingDocumentScalarWhereWithAggregatesInput | TrainingDocumentScalarWhereWithAggregatesInput[]
    OR?: TrainingDocumentScalarWhereWithAggregatesInput[]
    NOT?: TrainingDocumentScalarWhereWithAggregatesInput | TrainingDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingDocument"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingDocument"> | string
    title?: StringWithAggregatesFilter<"TrainingDocument"> | string
    description?: StringNullableWithAggregatesFilter<"TrainingDocument"> | string | null
    fileUrl?: StringWithAggregatesFilter<"TrainingDocument"> | string
    documentType?: EnumDocumentTypeWithAggregatesFilter<"TrainingDocument"> | $Enums.DocumentType
    uploadedById?: StringWithAggregatesFilter<"TrainingDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrainingDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingDocument"> | Date | string
  }

  export type TrainingParticipantWhereInput = {
    AND?: TrainingParticipantWhereInput | TrainingParticipantWhereInput[]
    OR?: TrainingParticipantWhereInput[]
    NOT?: TrainingParticipantWhereInput | TrainingParticipantWhereInput[]
    id?: StringFilter<"TrainingParticipant"> | string
    trainingId?: StringFilter<"TrainingParticipant"> | string
    userId?: StringFilter<"TrainingParticipant"> | string
    inviteSent?: BoolFilter<"TrainingParticipant"> | boolean
    inviteSentAt?: DateTimeNullableFilter<"TrainingParticipant"> | Date | string | null
    inviteAccepted?: BoolFilter<"TrainingParticipant"> | boolean
    createdAt?: DateTimeFilter<"TrainingParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingParticipant"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrainingParticipantOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    inviteSent?: SortOrder
    inviteSentAt?: SortOrderInput | SortOrder
    inviteAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TrainingParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trainingId_userId?: TrainingParticipantTrainingIdUserIdCompoundUniqueInput
    AND?: TrainingParticipantWhereInput | TrainingParticipantWhereInput[]
    OR?: TrainingParticipantWhereInput[]
    NOT?: TrainingParticipantWhereInput | TrainingParticipantWhereInput[]
    trainingId?: StringFilter<"TrainingParticipant"> | string
    userId?: StringFilter<"TrainingParticipant"> | string
    inviteSent?: BoolFilter<"TrainingParticipant"> | boolean
    inviteSentAt?: DateTimeNullableFilter<"TrainingParticipant"> | Date | string | null
    inviteAccepted?: BoolFilter<"TrainingParticipant"> | boolean
    createdAt?: DateTimeFilter<"TrainingParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingParticipant"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "trainingId_userId">

  export type TrainingParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    inviteSent?: SortOrder
    inviteSentAt?: SortOrderInput | SortOrder
    inviteAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingParticipantCountOrderByAggregateInput
    _max?: TrainingParticipantMaxOrderByAggregateInput
    _min?: TrainingParticipantMinOrderByAggregateInput
  }

  export type TrainingParticipantScalarWhereWithAggregatesInput = {
    AND?: TrainingParticipantScalarWhereWithAggregatesInput | TrainingParticipantScalarWhereWithAggregatesInput[]
    OR?: TrainingParticipantScalarWhereWithAggregatesInput[]
    NOT?: TrainingParticipantScalarWhereWithAggregatesInput | TrainingParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingParticipant"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingParticipant"> | string
    userId?: StringWithAggregatesFilter<"TrainingParticipant"> | string
    inviteSent?: BoolWithAggregatesFilter<"TrainingParticipant"> | boolean
    inviteSentAt?: DateTimeNullableWithAggregatesFilter<"TrainingParticipant"> | Date | string | null
    inviteAccepted?: BoolWithAggregatesFilter<"TrainingParticipant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TrainingParticipant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingParticipant"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    trainingId?: StringFilter<"Attendance"> | string
    sessionId?: StringFilter<"Attendance"> | string
    userId?: StringFilter<"Attendance"> | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    remarks?: StringNullableFilter<"Attendance"> | string | null
    signatureUrl?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    session?: XOR<TrainingSessionScalarRelationFilter, TrainingSessionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    session?: TrainingSessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_userId?: AttendanceSessionIdUserIdCompoundUniqueInput
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    trainingId?: StringFilter<"Attendance"> | string
    sessionId?: StringFilter<"Attendance"> | string
    userId?: StringFilter<"Attendance"> | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    remarks?: StringNullableFilter<"Attendance"> | string | null
    signatureUrl?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    session?: XOR<TrainingSessionScalarRelationFilter, TrainingSessionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionId_userId">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    trainingId?: StringWithAggregatesFilter<"Attendance"> | string
    sessionId?: StringWithAggregatesFilter<"Attendance"> | string
    userId?: StringWithAggregatesFilter<"Attendance"> | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"Attendance"> | $Enums.AttendanceStatus
    remarks?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    signatureUrl?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type TrainingPhotoWhereInput = {
    AND?: TrainingPhotoWhereInput | TrainingPhotoWhereInput[]
    OR?: TrainingPhotoWhereInput[]
    NOT?: TrainingPhotoWhereInput | TrainingPhotoWhereInput[]
    id?: StringFilter<"TrainingPhoto"> | string
    trainingId?: StringFilter<"TrainingPhoto"> | string
    photoUrl?: StringFilter<"TrainingPhoto"> | string
    caption?: StringNullableFilter<"TrainingPhoto"> | string | null
    uploadedById?: StringFilter<"TrainingPhoto"> | string
    createdAt?: DateTimeFilter<"TrainingPhoto"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrainingPhotoOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type TrainingPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingPhotoWhereInput | TrainingPhotoWhereInput[]
    OR?: TrainingPhotoWhereInput[]
    NOT?: TrainingPhotoWhereInput | TrainingPhotoWhereInput[]
    trainingId?: StringFilter<"TrainingPhoto"> | string
    photoUrl?: StringFilter<"TrainingPhoto"> | string
    caption?: StringNullableFilter<"TrainingPhoto"> | string | null
    uploadedById?: StringFilter<"TrainingPhoto"> | string
    createdAt?: DateTimeFilter<"TrainingPhoto"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TrainingPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    _count?: TrainingPhotoCountOrderByAggregateInput
    _max?: TrainingPhotoMaxOrderByAggregateInput
    _min?: TrainingPhotoMinOrderByAggregateInput
  }

  export type TrainingPhotoScalarWhereWithAggregatesInput = {
    AND?: TrainingPhotoScalarWhereWithAggregatesInput | TrainingPhotoScalarWhereWithAggregatesInput[]
    OR?: TrainingPhotoScalarWhereWithAggregatesInput[]
    NOT?: TrainingPhotoScalarWhereWithAggregatesInput | TrainingPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingPhoto"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingPhoto"> | string
    photoUrl?: StringWithAggregatesFilter<"TrainingPhoto"> | string
    caption?: StringNullableWithAggregatesFilter<"TrainingPhoto"> | string | null
    uploadedById?: StringWithAggregatesFilter<"TrainingPhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrainingPhoto"> | Date | string
  }

  export type TrainingFeedbackWhereInput = {
    AND?: TrainingFeedbackWhereInput | TrainingFeedbackWhereInput[]
    OR?: TrainingFeedbackWhereInput[]
    NOT?: TrainingFeedbackWhereInput | TrainingFeedbackWhereInput[]
    id?: StringFilter<"TrainingFeedback"> | string
    trainingId?: StringFilter<"TrainingFeedback"> | string
    userId?: StringFilter<"TrainingFeedback"> | string
    contentRating?: IntFilter<"TrainingFeedback"> | number
    trainerRating?: IntFilter<"TrainingFeedback"> | number
    materialRating?: IntFilter<"TrainingFeedback"> | number
    venueRating?: IntFilter<"TrainingFeedback"> | number
    overallRating?: IntFilter<"TrainingFeedback"> | number
    comments?: StringNullableFilter<"TrainingFeedback"> | string | null
    suggestedImprovements?: StringNullableFilter<"TrainingFeedback"> | string | null
    createdAt?: DateTimeFilter<"TrainingFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingFeedback"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrainingFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
    comments?: SortOrderInput | SortOrder
    suggestedImprovements?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    training?: TrainingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TrainingFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trainingId_userId?: TrainingFeedbackTrainingIdUserIdCompoundUniqueInput
    AND?: TrainingFeedbackWhereInput | TrainingFeedbackWhereInput[]
    OR?: TrainingFeedbackWhereInput[]
    NOT?: TrainingFeedbackWhereInput | TrainingFeedbackWhereInput[]
    trainingId?: StringFilter<"TrainingFeedback"> | string
    userId?: StringFilter<"TrainingFeedback"> | string
    contentRating?: IntFilter<"TrainingFeedback"> | number
    trainerRating?: IntFilter<"TrainingFeedback"> | number
    materialRating?: IntFilter<"TrainingFeedback"> | number
    venueRating?: IntFilter<"TrainingFeedback"> | number
    overallRating?: IntFilter<"TrainingFeedback"> | number
    comments?: StringNullableFilter<"TrainingFeedback"> | string | null
    suggestedImprovements?: StringNullableFilter<"TrainingFeedback"> | string | null
    createdAt?: DateTimeFilter<"TrainingFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingFeedback"> | Date | string
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "trainingId_userId">

  export type TrainingFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
    comments?: SortOrderInput | SortOrder
    suggestedImprovements?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingFeedbackCountOrderByAggregateInput
    _avg?: TrainingFeedbackAvgOrderByAggregateInput
    _max?: TrainingFeedbackMaxOrderByAggregateInput
    _min?: TrainingFeedbackMinOrderByAggregateInput
    _sum?: TrainingFeedbackSumOrderByAggregateInput
  }

  export type TrainingFeedbackScalarWhereWithAggregatesInput = {
    AND?: TrainingFeedbackScalarWhereWithAggregatesInput | TrainingFeedbackScalarWhereWithAggregatesInput[]
    OR?: TrainingFeedbackScalarWhereWithAggregatesInput[]
    NOT?: TrainingFeedbackScalarWhereWithAggregatesInput | TrainingFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingFeedback"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingFeedback"> | string
    userId?: StringWithAggregatesFilter<"TrainingFeedback"> | string
    contentRating?: IntWithAggregatesFilter<"TrainingFeedback"> | number
    trainerRating?: IntWithAggregatesFilter<"TrainingFeedback"> | number
    materialRating?: IntWithAggregatesFilter<"TrainingFeedback"> | number
    venueRating?: IntWithAggregatesFilter<"TrainingFeedback"> | number
    overallRating?: IntWithAggregatesFilter<"TrainingFeedback"> | number
    comments?: StringNullableWithAggregatesFilter<"TrainingFeedback"> | string | null
    suggestedImprovements?: StringNullableWithAggregatesFilter<"TrainingFeedback"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TrainingFeedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingFeedback"> | Date | string
  }

  export type TrainingFollowupWhereInput = {
    AND?: TrainingFollowupWhereInput | TrainingFollowupWhereInput[]
    OR?: TrainingFollowupWhereInput[]
    NOT?: TrainingFollowupWhereInput | TrainingFollowupWhereInput[]
    id?: StringFilter<"TrainingFollowup"> | string
    trainingId?: StringFilter<"TrainingFollowup"> | string
    title?: StringFilter<"TrainingFollowup"> | string
    description?: StringFilter<"TrainingFollowup"> | string
    dueDate?: DateTimeNullableFilter<"TrainingFollowup"> | Date | string | null
    isCompleted?: BoolFilter<"TrainingFollowup"> | boolean
    assignedToId?: StringFilter<"TrainingFollowup"> | string
    createdById?: StringFilter<"TrainingFollowup"> | string
    createdAt?: DateTimeFilter<"TrainingFollowup"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingFollowup"> | Date | string
    completedAt?: DateTimeNullableFilter<"TrainingFollowup"> | Date | string | null
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    assignedTo?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrainingFollowupOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    training?: TrainingOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type TrainingFollowupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingFollowupWhereInput | TrainingFollowupWhereInput[]
    OR?: TrainingFollowupWhereInput[]
    NOT?: TrainingFollowupWhereInput | TrainingFollowupWhereInput[]
    trainingId?: StringFilter<"TrainingFollowup"> | string
    title?: StringFilter<"TrainingFollowup"> | string
    description?: StringFilter<"TrainingFollowup"> | string
    dueDate?: DateTimeNullableFilter<"TrainingFollowup"> | Date | string | null
    isCompleted?: BoolFilter<"TrainingFollowup"> | boolean
    assignedToId?: StringFilter<"TrainingFollowup"> | string
    createdById?: StringFilter<"TrainingFollowup"> | string
    createdAt?: DateTimeFilter<"TrainingFollowup"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingFollowup"> | Date | string
    completedAt?: DateTimeNullableFilter<"TrainingFollowup"> | Date | string | null
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    assignedTo?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TrainingFollowupOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: TrainingFollowupCountOrderByAggregateInput
    _max?: TrainingFollowupMaxOrderByAggregateInput
    _min?: TrainingFollowupMinOrderByAggregateInput
  }

  export type TrainingFollowupScalarWhereWithAggregatesInput = {
    AND?: TrainingFollowupScalarWhereWithAggregatesInput | TrainingFollowupScalarWhereWithAggregatesInput[]
    OR?: TrainingFollowupScalarWhereWithAggregatesInput[]
    NOT?: TrainingFollowupScalarWhereWithAggregatesInput | TrainingFollowupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingFollowup"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingFollowup"> | string
    title?: StringWithAggregatesFilter<"TrainingFollowup"> | string
    description?: StringWithAggregatesFilter<"TrainingFollowup"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"TrainingFollowup"> | Date | string | null
    isCompleted?: BoolWithAggregatesFilter<"TrainingFollowup"> | boolean
    assignedToId?: StringWithAggregatesFilter<"TrainingFollowup"> | string
    createdById?: StringWithAggregatesFilter<"TrainingFollowup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrainingFollowup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingFollowup"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"TrainingFollowup"> | Date | string | null
  }

  export type TrainingNotificationWhereInput = {
    AND?: TrainingNotificationWhereInput | TrainingNotificationWhereInput[]
    OR?: TrainingNotificationWhereInput[]
    NOT?: TrainingNotificationWhereInput | TrainingNotificationWhereInput[]
    id?: StringFilter<"TrainingNotification"> | string
    trainingId?: StringFilter<"TrainingNotification"> | string
    userId?: StringFilter<"TrainingNotification"> | string
    title?: StringFilter<"TrainingNotification"> | string
    message?: StringFilter<"TrainingNotification"> | string
    isRead?: BoolFilter<"TrainingNotification"> | boolean
    sentAt?: DateTimeFilter<"TrainingNotification"> | Date | string
    readAt?: DateTimeNullableFilter<"TrainingNotification"> | Date | string | null
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrainingNotificationOrderByWithRelationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    training?: TrainingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TrainingNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingNotificationWhereInput | TrainingNotificationWhereInput[]
    OR?: TrainingNotificationWhereInput[]
    NOT?: TrainingNotificationWhereInput | TrainingNotificationWhereInput[]
    trainingId?: StringFilter<"TrainingNotification"> | string
    userId?: StringFilter<"TrainingNotification"> | string
    title?: StringFilter<"TrainingNotification"> | string
    message?: StringFilter<"TrainingNotification"> | string
    isRead?: BoolFilter<"TrainingNotification"> | boolean
    sentAt?: DateTimeFilter<"TrainingNotification"> | Date | string
    readAt?: DateTimeNullableFilter<"TrainingNotification"> | Date | string | null
    training?: XOR<TrainingScalarRelationFilter, TrainingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TrainingNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: TrainingNotificationCountOrderByAggregateInput
    _max?: TrainingNotificationMaxOrderByAggregateInput
    _min?: TrainingNotificationMinOrderByAggregateInput
  }

  export type TrainingNotificationScalarWhereWithAggregatesInput = {
    AND?: TrainingNotificationScalarWhereWithAggregatesInput | TrainingNotificationScalarWhereWithAggregatesInput[]
    OR?: TrainingNotificationScalarWhereWithAggregatesInput[]
    NOT?: TrainingNotificationScalarWhereWithAggregatesInput | TrainingNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingNotification"> | string
    trainingId?: StringWithAggregatesFilter<"TrainingNotification"> | string
    userId?: StringWithAggregatesFilter<"TrainingNotification"> | string
    title?: StringWithAggregatesFilter<"TrainingNotification"> | string
    message?: StringWithAggregatesFilter<"TrainingNotification"> | string
    isRead?: BoolWithAggregatesFilter<"TrainingNotification"> | boolean
    sentAt?: DateTimeWithAggregatesFilter<"TrainingNotification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"TrainingNotification"> | Date | string | null
  }

  export type ActivityLogCreateInput = {
    id: string
    action: string
    details?: string | null
    createdAt?: Date | string
    Batch?: BatchCreateNestedOneWithoutActivityLogInput
    User: UserCreateNestedOneWithoutActivityLogInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id: string
    userId: string
    batchId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneWithoutActivityLogNestedInput
    User?: UserUpdateOneRequiredWithoutActivityLogNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id: string
    userId: string
    batchId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchCreateManyInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportLogCreateInput = {
    id: string
    fileName: string
    exportType: string
    exportedBy: string
    exportedAt?: Date | string
  }

  export type ExportLogUncheckedCreateInput = {
    id: string
    fileName: string
    exportType: string
    exportedBy: string
    exportedAt?: Date | string
  }

  export type ExportLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    exportedBy?: StringFieldUpdateOperationsInput | string
    exportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    exportedBy?: StringFieldUpdateOperationsInput | string
    exportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportLogCreateManyInput = {
    id: string
    fileName: string
    exportType: string
    exportedBy: string
    exportedAt?: Date | string
  }

  export type ExportLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    exportedBy?: StringFieldUpdateOperationsInput | string
    exportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    exportType?: StringFieldUpdateOperationsInput | string
    exportedBy?: StringFieldUpdateOperationsInput | string
    exportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodologyCreateInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutMethodologiesInput
    batches?: BatchCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutMethodologyInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyUncheckedCreateInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutMethodologiesInput
    batches?: BatchUncheckedCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutMethodologyInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutMethodologiesNestedInput
    batches?: BatchUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutMethodologyNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutMethodologiesNestedInput
    batches?: BatchUncheckedUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutMethodologyNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyCreateManyInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MethodologyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodologyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    Batch?: BatchCreateNestedOneWithoutNotificationInput
    User: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id: string
    userId: string
    batchId?: string | null
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneWithoutNotificationNestedInput
    User?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id: string
    userId: string
    batchId?: string | null
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id: string
    action: string
    resource: string
    createdAt?: Date | string
    updatedAt: Date | string
    Role?: RoleCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id: string
    action: string
    resource: string
    createdAt?: Date | string
    updatedAt: Date | string
    Role?: RoleUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id: string
    action: string
    resource: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Batch?: BatchCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Batch?: BatchUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedManyWithoutRoleInput
    Permission?: PermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserUncheckedCreateNestedManyWithoutRoleInput
    Permission?: PermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateManyWithoutRoleNestedInput
    Permission?: PermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUncheckedUpdateManyWithoutRoleNestedInput
    Permission?: PermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfMeasurementCreateInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutUnitInput
    batches?: BatchCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementUncheckedCreateInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutUnitInput
    batches?: BatchUncheckedCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutUnitNestedInput
    batches?: BatchUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutUnitNestedInput
    batches?: BatchUncheckedUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type UnitOfMeasurementCreateManyInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type UnitOfMeasurementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfMeasurementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardCreateInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    Category: StandardCategoryCreateNestedOneWithoutStandardsInput
    CreatedBy: UserCreateNestedOneWithoutStandardsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardsModifiedInput
    batches?: BatchCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardsModifiedNestedInput
    batches?: BatchUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardCreateManyInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardCategoryCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parameters?: StandardParameterCreateNestedManyWithoutCategoryInput
    Standards?: StandardCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parameters?: StandardParameterUncheckedCreateNestedManyWithoutCategoryInput
    Standards?: StandardUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: StandardParameterUpdateManyWithoutCategoryNestedInput
    Standards?: StandardUpdateManyWithoutCategoryNestedInput
  }

  export type StandardCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: StandardParameterUncheckedUpdateManyWithoutCategoryNestedInput
    Standards?: StandardUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type StandardCategoryCreateManyInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardParameterCreateInput = {
    id: string
    name: string
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    category: StandardCategoryCreateNestedOneWithoutParametersInput
    batchValues?: BatchParameterValueCreateNestedManyWithoutParameterInput
    standards?: StandardDefinitionCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterUncheckedCreateInput = {
    id: string
    name: string
    categoryId: string
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    batchValues?: BatchParameterValueUncheckedCreateNestedManyWithoutParameterInput
    standards?: StandardDefinitionUncheckedCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StandardCategoryUpdateOneRequiredWithoutParametersNestedInput
    batchValues?: BatchParameterValueUpdateManyWithoutParameterNestedInput
    standards?: StandardDefinitionUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchValues?: BatchParameterValueUncheckedUpdateManyWithoutParameterNestedInput
    standards?: StandardDefinitionUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterCreateManyInput = {
    id: string
    name: string
    categoryId: string
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardParameterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardParameterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionCreateInput = {
    id: string
    standardValue: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    parameter: StandardParameterCreateNestedOneWithoutStandardsInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardDefinitionsInput
    methodology?: MethodologyCreateNestedOneWithoutStandardDefinitionsInput
    CreatedBy: UserCreateNestedOneWithoutStandardDefinitionsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardDefinitionsModifiedInput
  }

  export type StandardDefinitionUncheckedCreateInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StandardParameterUpdateOneRequiredWithoutStandardsNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutStandardDefinitionsNestedInput
    methodology?: MethodologyUpdateOneWithoutStandardDefinitionsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardDefinitionsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardDefinitionsModifiedNestedInput
  }

  export type StandardDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionCreateManyInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueCreateInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt: Date | string
    batch: BatchCreateNestedOneWithoutParameterValuesInput
    parameter: StandardParameterCreateNestedOneWithoutBatchValuesInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutBatchParameterValuesInput
    methodology?: MethodologyCreateNestedOneWithoutBatchParameterValuesInput
  }

  export type BatchParameterValueUncheckedCreateInput = {
    id: string
    batchId: string
    parameterId: string
    value: string
    unitId?: string | null
    methodologyId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchParameterValueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneRequiredWithoutParameterValuesNestedInput
    parameter?: StandardParameterUpdateOneRequiredWithoutBatchValuesNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutBatchParameterValuesNestedInput
    methodology?: MethodologyUpdateOneWithoutBatchParameterValuesNestedInput
  }

  export type BatchParameterValueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueCreateManyInput = {
    id: string
    batchId: string
    parameterId: string
    value: string
    unitId?: string | null
    methodologyId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchParameterValueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingCalendarCreateInput = {
    id?: string
    month: number
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingCreateNestedManyWithoutCalendarInput
  }

  export type TrainingCalendarUncheckedCreateInput = {
    id?: string
    month: number
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TrainingUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type TrainingCalendarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingUpdateManyWithoutCalendarNestedInput
  }

  export type TrainingCalendarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TrainingUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type TrainingCalendarCreateManyInput = {
    id?: string
    month: number
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingCalendarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingCalendarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingCreateInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutSessionsInput
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionUncheckedCreateInput = {
    id?: string
    trainingId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutSessionsNestedInput
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionCreateManyInput = {
    id?: string
    trainingId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentCreateInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    documentType: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutDocumentsInput
    uploadedBy: UserCreateNestedOneWithoutUploadedDocumentsInput
  }

  export type TrainingDocumentUncheckedCreateInput = {
    id?: string
    trainingId: string
    title: string
    description?: string | null
    fileUrl: string
    documentType: $Enums.DocumentType
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutDocumentsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
  }

  export type TrainingDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentCreateManyInput = {
    id?: string
    trainingId: string
    title: string
    description?: string | null
    fileUrl: string
    documentType: $Enums.DocumentType
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantCreateInput = {
    id?: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutTrainingParticipationsInput
  }

  export type TrainingParticipantUncheckedCreateInput = {
    id?: string
    trainingId: string
    userId: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutTrainingParticipationsNestedInput
  }

  export type TrainingParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantCreateManyInput = {
    id?: string
    trainingId: string
    userId: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutAttendanceInput
    session: TrainingSessionCreateNestedOneWithoutAttendanceInput
    user: UserCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    trainingId: string
    sessionId: string
    userId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutAttendanceNestedInput
    session?: TrainingSessionUpdateOneRequiredWithoutAttendanceNestedInput
    user?: UserUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    trainingId: string
    sessionId: string
    userId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoCreateInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
    training: TrainingCreateNestedOneWithoutPhotosInput
    uploadedBy: UserCreateNestedOneWithoutUploadedPhotosInput
  }

  export type TrainingPhotoUncheckedCreateInput = {
    id?: string
    trainingId: string
    photoUrl: string
    caption?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type TrainingPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutPhotosNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedPhotosNestedInput
  }

  export type TrainingPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoCreateManyInput = {
    id?: string
    trainingId: string
    photoUrl: string
    caption?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type TrainingPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackCreateInput = {
    id?: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutFeedbackInput
    user: UserCreateNestedOneWithoutFeedbacksInput
  }

  export type TrainingFeedbackUncheckedCreateInput = {
    id?: string
    trainingId: string
    userId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutFeedbackNestedInput
    user?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type TrainingFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackCreateManyInput = {
    id?: string
    trainingId: string
    userId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFollowupCreateInput = {
    id?: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    training: TrainingCreateNestedOneWithoutFollowupsInput
    assignedTo: UserCreateNestedOneWithoutAssignedFollowupsInput
    createdBy: UserCreateNestedOneWithoutCreatedFollowupsInput
  }

  export type TrainingFollowupUncheckedCreateInput = {
    id?: string
    trainingId: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    assignedToId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingFollowupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training?: TrainingUpdateOneRequiredWithoutFollowupsNestedInput
    assignedTo?: UserUpdateOneRequiredWithoutAssignedFollowupsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedFollowupsNestedInput
  }

  export type TrainingFollowupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingFollowupCreateManyInput = {
    id?: string
    trainingId: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    assignedToId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingFollowupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingFollowupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationCreateInput = {
    id?: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    training: TrainingCreateNestedOneWithoutNotificationsInput
    user: UserCreateNestedOneWithoutTrainingNotificationsInput
  }

  export type TrainingNotificationUncheckedCreateInput = {
    id?: string
    trainingId: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type TrainingNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training?: TrainingUpdateOneRequiredWithoutNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutTrainingNotificationsNestedInput
  }

  export type TrainingNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationCreateManyInput = {
    id?: string
    trainingId: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type TrainingNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BatchNullableScalarRelationFilter = {
    is?: BatchWhereInput | null
    isNot?: BatchWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumSampleAnalysisStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleAnalysisStatus | EnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleAnalysisStatusFilter<$PrismaModel> | $Enums.SampleAnalysisStatus
  }

  export type EnumBatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusFilter<$PrismaModel> | $Enums.BatchStatus
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type StandardListRelationFilter = {
    every?: StandardWhereInput
    some?: StandardWhereInput
    none?: StandardWhereInput
  }

  export type MethodologyListRelationFilter = {
    every?: MethodologyWhereInput
    some?: MethodologyWhereInput
    none?: MethodologyWhereInput
  }

  export type UnitOfMeasurementListRelationFilter = {
    every?: UnitOfMeasurementWhereInput
    some?: UnitOfMeasurementWhereInput
    none?: UnitOfMeasurementWhereInput
  }

  export type BatchParameterValueListRelationFilter = {
    every?: BatchParameterValueWhereInput
    some?: BatchParameterValueWhereInput
    none?: BatchParameterValueWhereInput
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StandardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MethodologyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOfMeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BatchParameterValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BatchCountOrderByAggregateInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    productId?: SortOrder
    dateOfProduction?: SortOrder
    bestBeforeDate?: SortOrder
    sampleAnalysisStarted?: SortOrder
    sampleAnalysisCompleted?: SortOrder
    sampleAnalysisStatus?: SortOrder
    makerId?: SortOrder
    checkerId?: SortOrder
    status?: SortOrder
    rejectionRemarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchMaxOrderByAggregateInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    productId?: SortOrder
    dateOfProduction?: SortOrder
    bestBeforeDate?: SortOrder
    sampleAnalysisStarted?: SortOrder
    sampleAnalysisCompleted?: SortOrder
    sampleAnalysisStatus?: SortOrder
    makerId?: SortOrder
    checkerId?: SortOrder
    status?: SortOrder
    rejectionRemarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchMinOrderByAggregateInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    productId?: SortOrder
    dateOfProduction?: SortOrder
    bestBeforeDate?: SortOrder
    sampleAnalysisStarted?: SortOrder
    sampleAnalysisCompleted?: SortOrder
    sampleAnalysisStatus?: SortOrder
    makerId?: SortOrder
    checkerId?: SortOrder
    status?: SortOrder
    rejectionRemarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumSampleAnalysisStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleAnalysisStatus | EnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleAnalysisStatusWithAggregatesFilter<$PrismaModel> | $Enums.SampleAnalysisStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSampleAnalysisStatusFilter<$PrismaModel>
    _max?: NestedEnumSampleAnalysisStatusFilter<$PrismaModel>
  }

  export type EnumBatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchStatusFilter<$PrismaModel>
  }

  export type ExportLogCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    exportType?: SortOrder
    exportedBy?: SortOrder
    exportedAt?: SortOrder
  }

  export type ExportLogMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    exportType?: SortOrder
    exportedBy?: SortOrder
    exportedAt?: SortOrder
  }

  export type ExportLogMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    exportType?: SortOrder
    exportedBy?: SortOrder
    exportedAt?: SortOrder
  }

  export type BatchListRelationFilter = {
    every?: BatchWhereInput
    some?: BatchWhereInput
    none?: BatchWhereInput
  }

  export type StandardDefinitionListRelationFilter = {
    every?: StandardDefinitionWhereInput
    some?: StandardDefinitionWhereInput
    none?: StandardDefinitionWhereInput
  }

  export type BatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StandardDefinitionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MethodologyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    procedure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MethodologyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    procedure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MethodologyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    procedure?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    batchId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionActionResourceCompoundUniqueInput = {
    action: string
    resource: string
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitOfMeasurementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitOfMeasurementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitOfMeasurementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type TrainingListRelationFilter = {
    every?: TrainingWhereInput
    some?: TrainingWhereInput
    none?: TrainingWhereInput
  }

  export type TrainingParticipantListRelationFilter = {
    every?: TrainingParticipantWhereInput
    some?: TrainingParticipantWhereInput
    none?: TrainingParticipantWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type TrainingDocumentListRelationFilter = {
    every?: TrainingDocumentWhereInput
    some?: TrainingDocumentWhereInput
    none?: TrainingDocumentWhereInput
  }

  export type TrainingPhotoListRelationFilter = {
    every?: TrainingPhotoWhereInput
    some?: TrainingPhotoWhereInput
    none?: TrainingPhotoWhereInput
  }

  export type TrainingFeedbackListRelationFilter = {
    every?: TrainingFeedbackWhereInput
    some?: TrainingFeedbackWhereInput
    none?: TrainingFeedbackWhereInput
  }

  export type TrainingFollowupListRelationFilter = {
    every?: TrainingFollowupWhereInput
    some?: TrainingFollowupWhereInput
    none?: TrainingFollowupWhereInput
  }

  export type TrainingNotificationListRelationFilter = {
    every?: TrainingNotificationWhereInput
    some?: TrainingNotificationWhereInput
    none?: TrainingNotificationWhereInput
  }

  export type TrainingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingFollowupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStandardStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StandardStatus | EnumStandardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStandardStatusFilter<$PrismaModel> | $Enums.StandardStatus
  }

  export type StandardCategoryScalarRelationFilter = {
    is?: StandardCategoryWhereInput
    isNot?: StandardCategoryWhereInput
  }

  export type StandardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStandardStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StandardStatus | EnumStandardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStandardStatusWithAggregatesFilter<$PrismaModel> | $Enums.StandardStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStandardStatusFilter<$PrismaModel>
    _max?: NestedEnumStandardStatusFilter<$PrismaModel>
  }

  export type StandardParameterListRelationFilter = {
    every?: StandardParameterWhereInput
    some?: StandardParameterWhereInput
    none?: StandardParameterWhereInput
  }

  export type StandardParameterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StandardCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumParameterDataTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ParameterDataType | EnumParameterDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParameterDataTypeFilter<$PrismaModel> | $Enums.ParameterDataType
  }

  export type StandardParameterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardParameterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardParameterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    dataType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumParameterDataTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParameterDataType | EnumParameterDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParameterDataTypeWithAggregatesFilter<$PrismaModel> | $Enums.ParameterDataType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParameterDataTypeFilter<$PrismaModel>
    _max?: NestedEnumParameterDataTypeFilter<$PrismaModel>
  }

  export type StandardParameterScalarRelationFilter = {
    is?: StandardParameterWhereInput
    isNot?: StandardParameterWhereInput
  }

  export type UnitOfMeasurementNullableScalarRelationFilter = {
    is?: UnitOfMeasurementWhereInput | null
    isNot?: UnitOfMeasurementWhereInput | null
  }

  export type MethodologyNullableScalarRelationFilter = {
    is?: MethodologyWhereInput | null
    isNot?: MethodologyWhereInput | null
  }

  export type StandardDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    parameterId?: SortOrder
    standardValue?: SortOrder
    unitId?: SortOrder
    methodologyId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    parameterId?: SortOrder
    standardValue?: SortOrder
    unitId?: SortOrder
    methodologyId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    parameterId?: SortOrder
    standardValue?: SortOrder
    unitId?: SortOrder
    methodologyId?: SortOrder
    createdById?: SortOrder
    modifiedById?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchScalarRelationFilter = {
    is?: BatchWhereInput
    isNot?: BatchWhereInput
  }

  export type BatchParameterValueBatchIdParameterIdCompoundUniqueInput = {
    batchId: string
    parameterId: string
  }

  export type BatchParameterValueCountOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    parameterId?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
    methodologyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchParameterValueMaxOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    parameterId?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
    methodologyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchParameterValueMinOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    parameterId?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
    methodologyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TrainingCalendarMonthYearCompoundUniqueInput = {
    month: number
    year: number
  }

  export type TrainingCalendarCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingCalendarAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
  }

  export type TrainingCalendarMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingCalendarMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    year?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingCalendarSumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumTrainingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingTypeFilter<$PrismaModel> | $Enums.TrainingType
  }

  export type EnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TrainingCalendarScalarRelationFilter = {
    is?: TrainingCalendarWhereInput
    isNot?: TrainingCalendarWhereInput
  }

  export type TrainingSessionListRelationFilter = {
    every?: TrainingSessionWhereInput
    some?: TrainingSessionWhereInput
    none?: TrainingSessionWhereInput
  }

  export type TrainingSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    trainingType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    maxParticipants?: SortOrder
    trainerId?: SortOrder
    calendarId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingAvgOrderByAggregateInput = {
    maxParticipants?: SortOrder
  }

  export type TrainingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    trainingType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    maxParticipants?: SortOrder
    trainerId?: SortOrder
    calendarId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    trainingType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    maxParticipants?: SortOrder
    trainerId?: SortOrder
    calendarId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingSumOrderByAggregateInput = {
    maxParticipants?: SortOrder
  }

  export type EnumTrainingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrainingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingTypeFilter<$PrismaModel>
    _max?: NestedEnumTrainingTypeFilter<$PrismaModel>
  }

  export type EnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type TrainingScalarRelationFilter = {
    is?: TrainingWhereInput
    isNot?: TrainingWhereInput
  }

  export type TrainingSessionCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingSessionMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type TrainingDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    documentType?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    documentType?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    documentType?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type TrainingParticipantTrainingIdUserIdCompoundUniqueInput = {
    trainingId: string
    userId: string
  }

  export type TrainingParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    inviteSent?: SortOrder
    inviteSentAt?: SortOrder
    inviteAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    inviteSent?: SortOrder
    inviteSentAt?: SortOrder
    inviteAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    inviteSent?: SortOrder
    inviteSentAt?: SortOrder
    inviteAccepted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type TrainingSessionScalarRelationFilter = {
    is?: TrainingSessionWhereInput
    isNot?: TrainingSessionWhereInput
  }

  export type AttendanceSessionIdUserIdCompoundUniqueInput = {
    sessionId: string
    userId: string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    signatureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    signatureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    signatureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type TrainingPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    photoUrl?: SortOrder
    caption?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingFeedbackTrainingIdUserIdCompoundUniqueInput = {
    trainingId: string
    userId: string
  }

  export type TrainingFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
    comments?: SortOrder
    suggestedImprovements?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingFeedbackAvgOrderByAggregateInput = {
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
  }

  export type TrainingFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
    comments?: SortOrder
    suggestedImprovements?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
    comments?: SortOrder
    suggestedImprovements?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingFeedbackSumOrderByAggregateInput = {
    contentRating?: SortOrder
    trainerRating?: SortOrder
    materialRating?: SortOrder
    venueRating?: SortOrder
    overallRating?: SortOrder
  }

  export type TrainingFollowupCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    isCompleted?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TrainingFollowupMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    isCompleted?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TrainingFollowupMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    isCompleted?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TrainingNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
  }

  export type TrainingNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
  }

  export type TrainingNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    trainingId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
  }

  export type BatchCreateNestedOneWithoutActivityLogInput = {
    create?: XOR<BatchCreateWithoutActivityLogInput, BatchUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: BatchCreateOrConnectWithoutActivityLogInput
    connect?: BatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivityLogInput = {
    create?: XOR<UserCreateWithoutActivityLogInput, UserUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BatchUpdateOneWithoutActivityLogNestedInput = {
    create?: XOR<BatchCreateWithoutActivityLogInput, BatchUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: BatchCreateOrConnectWithoutActivityLogInput
    upsert?: BatchUpsertWithoutActivityLogInput
    disconnect?: BatchWhereInput | boolean
    delete?: BatchWhereInput | boolean
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutActivityLogInput, BatchUpdateWithoutActivityLogInput>, BatchUncheckedUpdateWithoutActivityLogInput>
  }

  export type UserUpdateOneRequiredWithoutActivityLogNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogInput, UserUncheckedCreateWithoutActivityLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogInput
    upsert?: UserUpsertWithoutActivityLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogInput, UserUpdateWithoutActivityLogInput>, UserUncheckedUpdateWithoutActivityLogInput>
  }

  export type ActivityLogCreateNestedManyWithoutBatchInput = {
    create?: XOR<ActivityLogCreateWithoutBatchInput, ActivityLogUncheckedCreateWithoutBatchInput> | ActivityLogCreateWithoutBatchInput[] | ActivityLogUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutBatchInput | ActivityLogCreateOrConnectWithoutBatchInput[]
    createMany?: ActivityLogCreateManyBatchInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput = {
    create?: XOR<UserCreateWithoutBatch_Batch_checkerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_checkerIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBatch_Batch_checkerIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput = {
    create?: XOR<UserCreateWithoutBatch_Batch_makerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_makerIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBatch_Batch_makerIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutBatchInput = {
    create?: XOR<ProductCreateWithoutBatchInput, ProductUncheckedCreateWithoutBatchInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBatchInput
    connect?: ProductWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutBatchInput = {
    create?: XOR<NotificationCreateWithoutBatchInput, NotificationUncheckedCreateWithoutBatchInput> | NotificationCreateWithoutBatchInput[] | NotificationUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBatchInput | NotificationCreateOrConnectWithoutBatchInput[]
    createMany?: NotificationCreateManyBatchInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StandardCreateNestedManyWithoutBatchesInput = {
    create?: XOR<StandardCreateWithoutBatchesInput, StandardUncheckedCreateWithoutBatchesInput> | StandardCreateWithoutBatchesInput[] | StandardUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutBatchesInput | StandardCreateOrConnectWithoutBatchesInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type MethodologyCreateNestedManyWithoutBatchesInput = {
    create?: XOR<MethodologyCreateWithoutBatchesInput, MethodologyUncheckedCreateWithoutBatchesInput> | MethodologyCreateWithoutBatchesInput[] | MethodologyUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutBatchesInput | MethodologyCreateOrConnectWithoutBatchesInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
  }

  export type UnitOfMeasurementCreateNestedManyWithoutBatchesInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutBatchesInput, UnitOfMeasurementUncheckedCreateWithoutBatchesInput> | UnitOfMeasurementCreateWithoutBatchesInput[] | UnitOfMeasurementUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutBatchesInput | UnitOfMeasurementCreateOrConnectWithoutBatchesInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
  }

  export type BatchParameterValueCreateNestedManyWithoutBatchInput = {
    create?: XOR<BatchParameterValueCreateWithoutBatchInput, BatchParameterValueUncheckedCreateWithoutBatchInput> | BatchParameterValueCreateWithoutBatchInput[] | BatchParameterValueUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutBatchInput | BatchParameterValueCreateOrConnectWithoutBatchInput[]
    createMany?: BatchParameterValueCreateManyBatchInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<ActivityLogCreateWithoutBatchInput, ActivityLogUncheckedCreateWithoutBatchInput> | ActivityLogCreateWithoutBatchInput[] | ActivityLogUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutBatchInput | ActivityLogCreateOrConnectWithoutBatchInput[]
    createMany?: ActivityLogCreateManyBatchInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<NotificationCreateWithoutBatchInput, NotificationUncheckedCreateWithoutBatchInput> | NotificationCreateWithoutBatchInput[] | NotificationUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBatchInput | NotificationCreateOrConnectWithoutBatchInput[]
    createMany?: NotificationCreateManyBatchInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StandardUncheckedCreateNestedManyWithoutBatchesInput = {
    create?: XOR<StandardCreateWithoutBatchesInput, StandardUncheckedCreateWithoutBatchesInput> | StandardCreateWithoutBatchesInput[] | StandardUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutBatchesInput | StandardCreateOrConnectWithoutBatchesInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type MethodologyUncheckedCreateNestedManyWithoutBatchesInput = {
    create?: XOR<MethodologyCreateWithoutBatchesInput, MethodologyUncheckedCreateWithoutBatchesInput> | MethodologyCreateWithoutBatchesInput[] | MethodologyUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutBatchesInput | MethodologyCreateOrConnectWithoutBatchesInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
  }

  export type UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutBatchesInput, UnitOfMeasurementUncheckedCreateWithoutBatchesInput> | UnitOfMeasurementCreateWithoutBatchesInput[] | UnitOfMeasurementUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutBatchesInput | UnitOfMeasurementCreateOrConnectWithoutBatchesInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
  }

  export type BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<BatchParameterValueCreateWithoutBatchInput, BatchParameterValueUncheckedCreateWithoutBatchInput> | BatchParameterValueCreateWithoutBatchInput[] | BatchParameterValueUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutBatchInput | BatchParameterValueCreateOrConnectWithoutBatchInput[]
    createMany?: BatchParameterValueCreateManyBatchInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumSampleAnalysisStatusFieldUpdateOperationsInput = {
    set?: $Enums.SampleAnalysisStatus
  }

  export type EnumBatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.BatchStatus
  }

  export type ActivityLogUpdateManyWithoutBatchNestedInput = {
    create?: XOR<ActivityLogCreateWithoutBatchInput, ActivityLogUncheckedCreateWithoutBatchInput> | ActivityLogCreateWithoutBatchInput[] | ActivityLogUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutBatchInput | ActivityLogCreateOrConnectWithoutBatchInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutBatchInput | ActivityLogUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: ActivityLogCreateManyBatchInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutBatchInput | ActivityLogUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutBatchInput | ActivityLogUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutBatch_Batch_checkerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_checkerIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBatch_Batch_checkerIdToUserInput
    upsert?: UserUpsertWithoutBatch_Batch_checkerIdToUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBatch_Batch_checkerIdToUserInput, UserUpdateWithoutBatch_Batch_checkerIdToUserInput>, UserUncheckedUpdateWithoutBatch_Batch_checkerIdToUserInput>
  }

  export type UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutBatch_Batch_makerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_makerIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutBatch_Batch_makerIdToUserInput
    upsert?: UserUpsertWithoutBatch_Batch_makerIdToUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBatch_Batch_makerIdToUserInput, UserUpdateWithoutBatch_Batch_makerIdToUserInput>, UserUncheckedUpdateWithoutBatch_Batch_makerIdToUserInput>
  }

  export type ProductUpdateOneRequiredWithoutBatchNestedInput = {
    create?: XOR<ProductCreateWithoutBatchInput, ProductUncheckedCreateWithoutBatchInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBatchInput
    upsert?: ProductUpsertWithoutBatchInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutBatchInput, ProductUpdateWithoutBatchInput>, ProductUncheckedUpdateWithoutBatchInput>
  }

  export type NotificationUpdateManyWithoutBatchNestedInput = {
    create?: XOR<NotificationCreateWithoutBatchInput, NotificationUncheckedCreateWithoutBatchInput> | NotificationCreateWithoutBatchInput[] | NotificationUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBatchInput | NotificationCreateOrConnectWithoutBatchInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBatchInput | NotificationUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: NotificationCreateManyBatchInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBatchInput | NotificationUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBatchInput | NotificationUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StandardUpdateManyWithoutBatchesNestedInput = {
    create?: XOR<StandardCreateWithoutBatchesInput, StandardUncheckedCreateWithoutBatchesInput> | StandardCreateWithoutBatchesInput[] | StandardUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutBatchesInput | StandardCreateOrConnectWithoutBatchesInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutBatchesInput | StandardUpsertWithWhereUniqueWithoutBatchesInput[]
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutBatchesInput | StandardUpdateWithWhereUniqueWithoutBatchesInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutBatchesInput | StandardUpdateManyWithWhereWithoutBatchesInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type MethodologyUpdateManyWithoutBatchesNestedInput = {
    create?: XOR<MethodologyCreateWithoutBatchesInput, MethodologyUncheckedCreateWithoutBatchesInput> | MethodologyCreateWithoutBatchesInput[] | MethodologyUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutBatchesInput | MethodologyCreateOrConnectWithoutBatchesInput[]
    upsert?: MethodologyUpsertWithWhereUniqueWithoutBatchesInput | MethodologyUpsertWithWhereUniqueWithoutBatchesInput[]
    set?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    disconnect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    delete?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    update?: MethodologyUpdateWithWhereUniqueWithoutBatchesInput | MethodologyUpdateWithWhereUniqueWithoutBatchesInput[]
    updateMany?: MethodologyUpdateManyWithWhereWithoutBatchesInput | MethodologyUpdateManyWithWhereWithoutBatchesInput[]
    deleteMany?: MethodologyScalarWhereInput | MethodologyScalarWhereInput[]
  }

  export type UnitOfMeasurementUpdateManyWithoutBatchesNestedInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutBatchesInput, UnitOfMeasurementUncheckedCreateWithoutBatchesInput> | UnitOfMeasurementCreateWithoutBatchesInput[] | UnitOfMeasurementUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutBatchesInput | UnitOfMeasurementCreateOrConnectWithoutBatchesInput[]
    upsert?: UnitOfMeasurementUpsertWithWhereUniqueWithoutBatchesInput | UnitOfMeasurementUpsertWithWhereUniqueWithoutBatchesInput[]
    set?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    disconnect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    delete?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    update?: UnitOfMeasurementUpdateWithWhereUniqueWithoutBatchesInput | UnitOfMeasurementUpdateWithWhereUniqueWithoutBatchesInput[]
    updateMany?: UnitOfMeasurementUpdateManyWithWhereWithoutBatchesInput | UnitOfMeasurementUpdateManyWithWhereWithoutBatchesInput[]
    deleteMany?: UnitOfMeasurementScalarWhereInput | UnitOfMeasurementScalarWhereInput[]
  }

  export type BatchParameterValueUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutBatchInput, BatchParameterValueUncheckedCreateWithoutBatchInput> | BatchParameterValueCreateWithoutBatchInput[] | BatchParameterValueUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutBatchInput | BatchParameterValueCreateOrConnectWithoutBatchInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutBatchInput | BatchParameterValueUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BatchParameterValueCreateManyBatchInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutBatchInput | BatchParameterValueUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutBatchInput | BatchParameterValueUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<ActivityLogCreateWithoutBatchInput, ActivityLogUncheckedCreateWithoutBatchInput> | ActivityLogCreateWithoutBatchInput[] | ActivityLogUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutBatchInput | ActivityLogCreateOrConnectWithoutBatchInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutBatchInput | ActivityLogUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: ActivityLogCreateManyBatchInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutBatchInput | ActivityLogUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutBatchInput | ActivityLogUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<NotificationCreateWithoutBatchInput, NotificationUncheckedCreateWithoutBatchInput> | NotificationCreateWithoutBatchInput[] | NotificationUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBatchInput | NotificationCreateOrConnectWithoutBatchInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBatchInput | NotificationUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: NotificationCreateManyBatchInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBatchInput | NotificationUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBatchInput | NotificationUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StandardUncheckedUpdateManyWithoutBatchesNestedInput = {
    create?: XOR<StandardCreateWithoutBatchesInput, StandardUncheckedCreateWithoutBatchesInput> | StandardCreateWithoutBatchesInput[] | StandardUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutBatchesInput | StandardCreateOrConnectWithoutBatchesInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutBatchesInput | StandardUpsertWithWhereUniqueWithoutBatchesInput[]
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutBatchesInput | StandardUpdateWithWhereUniqueWithoutBatchesInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutBatchesInput | StandardUpdateManyWithWhereWithoutBatchesInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type MethodologyUncheckedUpdateManyWithoutBatchesNestedInput = {
    create?: XOR<MethodologyCreateWithoutBatchesInput, MethodologyUncheckedCreateWithoutBatchesInput> | MethodologyCreateWithoutBatchesInput[] | MethodologyUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutBatchesInput | MethodologyCreateOrConnectWithoutBatchesInput[]
    upsert?: MethodologyUpsertWithWhereUniqueWithoutBatchesInput | MethodologyUpsertWithWhereUniqueWithoutBatchesInput[]
    set?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    disconnect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    delete?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    update?: MethodologyUpdateWithWhereUniqueWithoutBatchesInput | MethodologyUpdateWithWhereUniqueWithoutBatchesInput[]
    updateMany?: MethodologyUpdateManyWithWhereWithoutBatchesInput | MethodologyUpdateManyWithWhereWithoutBatchesInput[]
    deleteMany?: MethodologyScalarWhereInput | MethodologyScalarWhereInput[]
  }

  export type UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutBatchesInput, UnitOfMeasurementUncheckedCreateWithoutBatchesInput> | UnitOfMeasurementCreateWithoutBatchesInput[] | UnitOfMeasurementUncheckedCreateWithoutBatchesInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutBatchesInput | UnitOfMeasurementCreateOrConnectWithoutBatchesInput[]
    upsert?: UnitOfMeasurementUpsertWithWhereUniqueWithoutBatchesInput | UnitOfMeasurementUpsertWithWhereUniqueWithoutBatchesInput[]
    set?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    disconnect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    delete?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    update?: UnitOfMeasurementUpdateWithWhereUniqueWithoutBatchesInput | UnitOfMeasurementUpdateWithWhereUniqueWithoutBatchesInput[]
    updateMany?: UnitOfMeasurementUpdateManyWithWhereWithoutBatchesInput | UnitOfMeasurementUpdateManyWithWhereWithoutBatchesInput[]
    deleteMany?: UnitOfMeasurementScalarWhereInput | UnitOfMeasurementScalarWhereInput[]
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutBatchInput, BatchParameterValueUncheckedCreateWithoutBatchInput> | BatchParameterValueCreateWithoutBatchInput[] | BatchParameterValueUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutBatchInput | BatchParameterValueCreateOrConnectWithoutBatchInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutBatchInput | BatchParameterValueUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BatchParameterValueCreateManyBatchInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutBatchInput | BatchParameterValueUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutBatchInput | BatchParameterValueUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type StandardCreateNestedManyWithoutMethodologiesInput = {
    create?: XOR<StandardCreateWithoutMethodologiesInput, StandardUncheckedCreateWithoutMethodologiesInput> | StandardCreateWithoutMethodologiesInput[] | StandardUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutMethodologiesInput | StandardCreateOrConnectWithoutMethodologiesInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type BatchCreateNestedManyWithoutMethodologiesInput = {
    create?: XOR<BatchCreateWithoutMethodologiesInput, BatchUncheckedCreateWithoutMethodologiesInput> | BatchCreateWithoutMethodologiesInput[] | BatchUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutMethodologiesInput | BatchCreateOrConnectWithoutMethodologiesInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchParameterValueCreateNestedManyWithoutMethodologyInput = {
    create?: XOR<BatchParameterValueCreateWithoutMethodologyInput, BatchParameterValueUncheckedCreateWithoutMethodologyInput> | BatchParameterValueCreateWithoutMethodologyInput[] | BatchParameterValueUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutMethodologyInput | BatchParameterValueCreateOrConnectWithoutMethodologyInput[]
    createMany?: BatchParameterValueCreateManyMethodologyInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type StandardDefinitionCreateNestedManyWithoutMethodologyInput = {
    create?: XOR<StandardDefinitionCreateWithoutMethodologyInput, StandardDefinitionUncheckedCreateWithoutMethodologyInput> | StandardDefinitionCreateWithoutMethodologyInput[] | StandardDefinitionUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutMethodologyInput | StandardDefinitionCreateOrConnectWithoutMethodologyInput[]
    createMany?: StandardDefinitionCreateManyMethodologyInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type StandardUncheckedCreateNestedManyWithoutMethodologiesInput = {
    create?: XOR<StandardCreateWithoutMethodologiesInput, StandardUncheckedCreateWithoutMethodologiesInput> | StandardCreateWithoutMethodologiesInput[] | StandardUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutMethodologiesInput | StandardCreateOrConnectWithoutMethodologiesInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutMethodologiesInput = {
    create?: XOR<BatchCreateWithoutMethodologiesInput, BatchUncheckedCreateWithoutMethodologiesInput> | BatchCreateWithoutMethodologiesInput[] | BatchUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutMethodologiesInput | BatchCreateOrConnectWithoutMethodologiesInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchParameterValueUncheckedCreateNestedManyWithoutMethodologyInput = {
    create?: XOR<BatchParameterValueCreateWithoutMethodologyInput, BatchParameterValueUncheckedCreateWithoutMethodologyInput> | BatchParameterValueCreateWithoutMethodologyInput[] | BatchParameterValueUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutMethodologyInput | BatchParameterValueCreateOrConnectWithoutMethodologyInput[]
    createMany?: BatchParameterValueCreateManyMethodologyInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type StandardDefinitionUncheckedCreateNestedManyWithoutMethodologyInput = {
    create?: XOR<StandardDefinitionCreateWithoutMethodologyInput, StandardDefinitionUncheckedCreateWithoutMethodologyInput> | StandardDefinitionCreateWithoutMethodologyInput[] | StandardDefinitionUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutMethodologyInput | StandardDefinitionCreateOrConnectWithoutMethodologyInput[]
    createMany?: StandardDefinitionCreateManyMethodologyInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type StandardUpdateManyWithoutMethodologiesNestedInput = {
    create?: XOR<StandardCreateWithoutMethodologiesInput, StandardUncheckedCreateWithoutMethodologiesInput> | StandardCreateWithoutMethodologiesInput[] | StandardUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutMethodologiesInput | StandardCreateOrConnectWithoutMethodologiesInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutMethodologiesInput | StandardUpsertWithWhereUniqueWithoutMethodologiesInput[]
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutMethodologiesInput | StandardUpdateWithWhereUniqueWithoutMethodologiesInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutMethodologiesInput | StandardUpdateManyWithWhereWithoutMethodologiesInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type BatchUpdateManyWithoutMethodologiesNestedInput = {
    create?: XOR<BatchCreateWithoutMethodologiesInput, BatchUncheckedCreateWithoutMethodologiesInput> | BatchCreateWithoutMethodologiesInput[] | BatchUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutMethodologiesInput | BatchCreateOrConnectWithoutMethodologiesInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutMethodologiesInput | BatchUpsertWithWhereUniqueWithoutMethodologiesInput[]
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutMethodologiesInput | BatchUpdateWithWhereUniqueWithoutMethodologiesInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutMethodologiesInput | BatchUpdateManyWithWhereWithoutMethodologiesInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchParameterValueUpdateManyWithoutMethodologyNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutMethodologyInput, BatchParameterValueUncheckedCreateWithoutMethodologyInput> | BatchParameterValueCreateWithoutMethodologyInput[] | BatchParameterValueUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutMethodologyInput | BatchParameterValueCreateOrConnectWithoutMethodologyInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutMethodologyInput | BatchParameterValueUpsertWithWhereUniqueWithoutMethodologyInput[]
    createMany?: BatchParameterValueCreateManyMethodologyInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutMethodologyInput | BatchParameterValueUpdateWithWhereUniqueWithoutMethodologyInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutMethodologyInput | BatchParameterValueUpdateManyWithWhereWithoutMethodologyInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type StandardDefinitionUpdateManyWithoutMethodologyNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutMethodologyInput, StandardDefinitionUncheckedCreateWithoutMethodologyInput> | StandardDefinitionCreateWithoutMethodologyInput[] | StandardDefinitionUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutMethodologyInput | StandardDefinitionCreateOrConnectWithoutMethodologyInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutMethodologyInput | StandardDefinitionUpsertWithWhereUniqueWithoutMethodologyInput[]
    createMany?: StandardDefinitionCreateManyMethodologyInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutMethodologyInput | StandardDefinitionUpdateWithWhereUniqueWithoutMethodologyInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutMethodologyInput | StandardDefinitionUpdateManyWithWhereWithoutMethodologyInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type StandardUncheckedUpdateManyWithoutMethodologiesNestedInput = {
    create?: XOR<StandardCreateWithoutMethodologiesInput, StandardUncheckedCreateWithoutMethodologiesInput> | StandardCreateWithoutMethodologiesInput[] | StandardUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutMethodologiesInput | StandardCreateOrConnectWithoutMethodologiesInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutMethodologiesInput | StandardUpsertWithWhereUniqueWithoutMethodologiesInput[]
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutMethodologiesInput | StandardUpdateWithWhereUniqueWithoutMethodologiesInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutMethodologiesInput | StandardUpdateManyWithWhereWithoutMethodologiesInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutMethodologiesNestedInput = {
    create?: XOR<BatchCreateWithoutMethodologiesInput, BatchUncheckedCreateWithoutMethodologiesInput> | BatchCreateWithoutMethodologiesInput[] | BatchUncheckedCreateWithoutMethodologiesInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutMethodologiesInput | BatchCreateOrConnectWithoutMethodologiesInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutMethodologiesInput | BatchUpsertWithWhereUniqueWithoutMethodologiesInput[]
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutMethodologiesInput | BatchUpdateWithWhereUniqueWithoutMethodologiesInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutMethodologiesInput | BatchUpdateManyWithWhereWithoutMethodologiesInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutMethodologyNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutMethodologyInput, BatchParameterValueUncheckedCreateWithoutMethodologyInput> | BatchParameterValueCreateWithoutMethodologyInput[] | BatchParameterValueUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutMethodologyInput | BatchParameterValueCreateOrConnectWithoutMethodologyInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutMethodologyInput | BatchParameterValueUpsertWithWhereUniqueWithoutMethodologyInput[]
    createMany?: BatchParameterValueCreateManyMethodologyInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutMethodologyInput | BatchParameterValueUpdateWithWhereUniqueWithoutMethodologyInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutMethodologyInput | BatchParameterValueUpdateManyWithWhereWithoutMethodologyInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutMethodologyNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutMethodologyInput, StandardDefinitionUncheckedCreateWithoutMethodologyInput> | StandardDefinitionCreateWithoutMethodologyInput[] | StandardDefinitionUncheckedCreateWithoutMethodologyInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutMethodologyInput | StandardDefinitionCreateOrConnectWithoutMethodologyInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutMethodologyInput | StandardDefinitionUpsertWithWhereUniqueWithoutMethodologyInput[]
    createMany?: StandardDefinitionCreateManyMethodologyInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutMethodologyInput | StandardDefinitionUpdateWithWhereUniqueWithoutMethodologyInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutMethodologyInput | StandardDefinitionUpdateManyWithWhereWithoutMethodologyInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type BatchCreateNestedOneWithoutNotificationInput = {
    create?: XOR<BatchCreateWithoutNotificationInput, BatchUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: BatchCreateOrConnectWithoutNotificationInput
    connect?: BatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BatchUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<BatchCreateWithoutNotificationInput, BatchUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: BatchCreateOrConnectWithoutNotificationInput
    upsert?: BatchUpsertWithoutNotificationInput
    disconnect?: BatchWhereInput | boolean
    delete?: BatchWhereInput | boolean
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutNotificationInput, BatchUpdateWithoutNotificationInput>, BatchUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type RoleCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RoleCreateWithoutPermissionInput, RoleUncheckedCreateWithoutPermissionInput> | RoleCreateWithoutPermissionInput[] | RoleUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionInput | RoleCreateOrConnectWithoutPermissionInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RoleCreateWithoutPermissionInput, RoleUncheckedCreateWithoutPermissionInput> | RoleCreateWithoutPermissionInput[] | RoleUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionInput | RoleCreateOrConnectWithoutPermissionInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type RoleUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionInput, RoleUncheckedCreateWithoutPermissionInput> | RoleCreateWithoutPermissionInput[] | RoleUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionInput | RoleCreateOrConnectWithoutPermissionInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutPermissionInput | RoleUpsertWithWhereUniqueWithoutPermissionInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutPermissionInput | RoleUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutPermissionInput | RoleUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionInput, RoleUncheckedCreateWithoutPermissionInput> | RoleCreateWithoutPermissionInput[] | RoleUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionInput | RoleCreateOrConnectWithoutPermissionInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutPermissionInput | RoleUpsertWithWhereUniqueWithoutPermissionInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutPermissionInput | RoleUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutPermissionInput | RoleUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type BatchCreateNestedManyWithoutProductInput = {
    create?: XOR<BatchCreateWithoutProductInput, BatchUncheckedCreateWithoutProductInput> | BatchCreateWithoutProductInput[] | BatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutProductInput | BatchCreateOrConnectWithoutProductInput[]
    createMany?: BatchCreateManyProductInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<BatchCreateWithoutProductInput, BatchUncheckedCreateWithoutProductInput> | BatchCreateWithoutProductInput[] | BatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutProductInput | BatchCreateOrConnectWithoutProductInput[]
    createMany?: BatchCreateManyProductInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchUpdateManyWithoutProductNestedInput = {
    create?: XOR<BatchCreateWithoutProductInput, BatchUncheckedCreateWithoutProductInput> | BatchCreateWithoutProductInput[] | BatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutProductInput | BatchCreateOrConnectWithoutProductInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutProductInput | BatchUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: BatchCreateManyProductInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutProductInput | BatchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutProductInput | BatchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<BatchCreateWithoutProductInput, BatchUncheckedCreateWithoutProductInput> | BatchCreateWithoutProductInput[] | BatchUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutProductInput | BatchCreateOrConnectWithoutProductInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutProductInput | BatchUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: BatchCreateManyProductInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutProductInput | BatchUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutProductInput | BatchUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutRoleInput | PermissionUpsertWithWhereUniqueWithoutRoleInput[]
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutRoleInput | PermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutRoleInput | PermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutRoleInput | PermissionUpsertWithWhereUniqueWithoutRoleInput[]
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutRoleInput | PermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutRoleInput | PermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type StandardCreateNestedManyWithoutUnitsInput = {
    create?: XOR<StandardCreateWithoutUnitsInput, StandardUncheckedCreateWithoutUnitsInput> | StandardCreateWithoutUnitsInput[] | StandardUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutUnitsInput | StandardCreateOrConnectWithoutUnitsInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type BatchParameterValueCreateNestedManyWithoutUnitInput = {
    create?: XOR<BatchParameterValueCreateWithoutUnitInput, BatchParameterValueUncheckedCreateWithoutUnitInput> | BatchParameterValueCreateWithoutUnitInput[] | BatchParameterValueUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutUnitInput | BatchParameterValueCreateOrConnectWithoutUnitInput[]
    createMany?: BatchParameterValueCreateManyUnitInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type StandardDefinitionCreateNestedManyWithoutUnitInput = {
    create?: XOR<StandardDefinitionCreateWithoutUnitInput, StandardDefinitionUncheckedCreateWithoutUnitInput> | StandardDefinitionCreateWithoutUnitInput[] | StandardDefinitionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutUnitInput | StandardDefinitionCreateOrConnectWithoutUnitInput[]
    createMany?: StandardDefinitionCreateManyUnitInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type BatchCreateNestedManyWithoutUnitOfMeasurementsInput = {
    create?: XOR<BatchCreateWithoutUnitOfMeasurementsInput, BatchUncheckedCreateWithoutUnitOfMeasurementsInput> | BatchCreateWithoutUnitOfMeasurementsInput[] | BatchUncheckedCreateWithoutUnitOfMeasurementsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUnitOfMeasurementsInput | BatchCreateOrConnectWithoutUnitOfMeasurementsInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type StandardUncheckedCreateNestedManyWithoutUnitsInput = {
    create?: XOR<StandardCreateWithoutUnitsInput, StandardUncheckedCreateWithoutUnitsInput> | StandardCreateWithoutUnitsInput[] | StandardUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutUnitsInput | StandardCreateOrConnectWithoutUnitsInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type BatchParameterValueUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<BatchParameterValueCreateWithoutUnitInput, BatchParameterValueUncheckedCreateWithoutUnitInput> | BatchParameterValueCreateWithoutUnitInput[] | BatchParameterValueUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutUnitInput | BatchParameterValueCreateOrConnectWithoutUnitInput[]
    createMany?: BatchParameterValueCreateManyUnitInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type StandardDefinitionUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<StandardDefinitionCreateWithoutUnitInput, StandardDefinitionUncheckedCreateWithoutUnitInput> | StandardDefinitionCreateWithoutUnitInput[] | StandardDefinitionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutUnitInput | StandardDefinitionCreateOrConnectWithoutUnitInput[]
    createMany?: StandardDefinitionCreateManyUnitInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutUnitOfMeasurementsInput = {
    create?: XOR<BatchCreateWithoutUnitOfMeasurementsInput, BatchUncheckedCreateWithoutUnitOfMeasurementsInput> | BatchCreateWithoutUnitOfMeasurementsInput[] | BatchUncheckedCreateWithoutUnitOfMeasurementsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUnitOfMeasurementsInput | BatchCreateOrConnectWithoutUnitOfMeasurementsInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type StandardUpdateManyWithoutUnitsNestedInput = {
    create?: XOR<StandardCreateWithoutUnitsInput, StandardUncheckedCreateWithoutUnitsInput> | StandardCreateWithoutUnitsInput[] | StandardUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutUnitsInput | StandardCreateOrConnectWithoutUnitsInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutUnitsInput | StandardUpsertWithWhereUniqueWithoutUnitsInput[]
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutUnitsInput | StandardUpdateWithWhereUniqueWithoutUnitsInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutUnitsInput | StandardUpdateManyWithWhereWithoutUnitsInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type BatchParameterValueUpdateManyWithoutUnitNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutUnitInput, BatchParameterValueUncheckedCreateWithoutUnitInput> | BatchParameterValueCreateWithoutUnitInput[] | BatchParameterValueUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutUnitInput | BatchParameterValueCreateOrConnectWithoutUnitInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutUnitInput | BatchParameterValueUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: BatchParameterValueCreateManyUnitInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutUnitInput | BatchParameterValueUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutUnitInput | BatchParameterValueUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type StandardDefinitionUpdateManyWithoutUnitNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutUnitInput, StandardDefinitionUncheckedCreateWithoutUnitInput> | StandardDefinitionCreateWithoutUnitInput[] | StandardDefinitionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutUnitInput | StandardDefinitionCreateOrConnectWithoutUnitInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutUnitInput | StandardDefinitionUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: StandardDefinitionCreateManyUnitInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutUnitInput | StandardDefinitionUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutUnitInput | StandardDefinitionUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type BatchUpdateManyWithoutUnitOfMeasurementsNestedInput = {
    create?: XOR<BatchCreateWithoutUnitOfMeasurementsInput, BatchUncheckedCreateWithoutUnitOfMeasurementsInput> | BatchCreateWithoutUnitOfMeasurementsInput[] | BatchUncheckedCreateWithoutUnitOfMeasurementsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUnitOfMeasurementsInput | BatchCreateOrConnectWithoutUnitOfMeasurementsInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUnitOfMeasurementsInput | BatchUpsertWithWhereUniqueWithoutUnitOfMeasurementsInput[]
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUnitOfMeasurementsInput | BatchUpdateWithWhereUniqueWithoutUnitOfMeasurementsInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUnitOfMeasurementsInput | BatchUpdateManyWithWhereWithoutUnitOfMeasurementsInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type StandardUncheckedUpdateManyWithoutUnitsNestedInput = {
    create?: XOR<StandardCreateWithoutUnitsInput, StandardUncheckedCreateWithoutUnitsInput> | StandardCreateWithoutUnitsInput[] | StandardUncheckedCreateWithoutUnitsInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutUnitsInput | StandardCreateOrConnectWithoutUnitsInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutUnitsInput | StandardUpsertWithWhereUniqueWithoutUnitsInput[]
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutUnitsInput | StandardUpdateWithWhereUniqueWithoutUnitsInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutUnitsInput | StandardUpdateManyWithWhereWithoutUnitsInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutUnitInput, BatchParameterValueUncheckedCreateWithoutUnitInput> | BatchParameterValueCreateWithoutUnitInput[] | BatchParameterValueUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutUnitInput | BatchParameterValueCreateOrConnectWithoutUnitInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutUnitInput | BatchParameterValueUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: BatchParameterValueCreateManyUnitInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutUnitInput | BatchParameterValueUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutUnitInput | BatchParameterValueUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutUnitInput, StandardDefinitionUncheckedCreateWithoutUnitInput> | StandardDefinitionCreateWithoutUnitInput[] | StandardDefinitionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutUnitInput | StandardDefinitionCreateOrConnectWithoutUnitInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutUnitInput | StandardDefinitionUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: StandardDefinitionCreateManyUnitInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutUnitInput | StandardDefinitionUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutUnitInput | StandardDefinitionUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutUnitOfMeasurementsNestedInput = {
    create?: XOR<BatchCreateWithoutUnitOfMeasurementsInput, BatchUncheckedCreateWithoutUnitOfMeasurementsInput> | BatchCreateWithoutUnitOfMeasurementsInput[] | BatchUncheckedCreateWithoutUnitOfMeasurementsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUnitOfMeasurementsInput | BatchCreateOrConnectWithoutUnitOfMeasurementsInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUnitOfMeasurementsInput | BatchUpsertWithWhereUniqueWithoutUnitOfMeasurementsInput[]
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUnitOfMeasurementsInput | BatchUpdateWithWhereUniqueWithoutUnitOfMeasurementsInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUnitOfMeasurementsInput | BatchUpdateManyWithWhereWithoutUnitOfMeasurementsInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput> | BatchCreateWithoutUser_Batch_checkerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_checkerIdToUserInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput> | BatchCreateWithoutUser_Batch_makerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_makerIdToUserInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type RoleCreateNestedOneWithoutUserInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput
    connect?: RoleWhereUniqueInput
  }

  export type StandardCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StandardCreateWithoutCreatedByInput, StandardUncheckedCreateWithoutCreatedByInput> | StandardCreateWithoutCreatedByInput[] | StandardUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCreatedByInput | StandardCreateOrConnectWithoutCreatedByInput[]
    createMany?: StandardCreateManyCreatedByInputEnvelope
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type StandardCreateNestedManyWithoutModifiedByInput = {
    create?: XOR<StandardCreateWithoutModifiedByInput, StandardUncheckedCreateWithoutModifiedByInput> | StandardCreateWithoutModifiedByInput[] | StandardUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutModifiedByInput | StandardCreateOrConnectWithoutModifiedByInput[]
    createMany?: StandardCreateManyModifiedByInputEnvelope
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type StandardDefinitionCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StandardDefinitionCreateWithoutCreatedByInput, StandardDefinitionUncheckedCreateWithoutCreatedByInput> | StandardDefinitionCreateWithoutCreatedByInput[] | StandardDefinitionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutCreatedByInput | StandardDefinitionCreateOrConnectWithoutCreatedByInput[]
    createMany?: StandardDefinitionCreateManyCreatedByInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type StandardDefinitionCreateNestedManyWithoutModifiedByInput = {
    create?: XOR<StandardDefinitionCreateWithoutModifiedByInput, StandardDefinitionUncheckedCreateWithoutModifiedByInput> | StandardDefinitionCreateWithoutModifiedByInput[] | StandardDefinitionUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutModifiedByInput | StandardDefinitionCreateOrConnectWithoutModifiedByInput[]
    createMany?: StandardDefinitionCreateManyModifiedByInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type TrainingCreateNestedManyWithoutTrainerInput = {
    create?: XOR<TrainingCreateWithoutTrainerInput, TrainingUncheckedCreateWithoutTrainerInput> | TrainingCreateWithoutTrainerInput[] | TrainingUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutTrainerInput | TrainingCreateOrConnectWithoutTrainerInput[]
    createMany?: TrainingCreateManyTrainerInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type TrainingCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TrainingCreateWithoutCreatedByInput, TrainingUncheckedCreateWithoutCreatedByInput> | TrainingCreateWithoutCreatedByInput[] | TrainingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCreatedByInput | TrainingCreateOrConnectWithoutCreatedByInput[]
    createMany?: TrainingCreateManyCreatedByInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type TrainingParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<TrainingParticipantCreateWithoutUserInput, TrainingParticipantUncheckedCreateWithoutUserInput> | TrainingParticipantCreateWithoutUserInput[] | TrainingParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutUserInput | TrainingParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TrainingParticipantCreateManyUserInputEnvelope
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type TrainingDocumentCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TrainingDocumentCreateWithoutUploadedByInput, TrainingDocumentUncheckedCreateWithoutUploadedByInput> | TrainingDocumentCreateWithoutUploadedByInput[] | TrainingDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutUploadedByInput | TrainingDocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: TrainingDocumentCreateManyUploadedByInputEnvelope
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
  }

  export type TrainingPhotoCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TrainingPhotoCreateWithoutUploadedByInput, TrainingPhotoUncheckedCreateWithoutUploadedByInput> | TrainingPhotoCreateWithoutUploadedByInput[] | TrainingPhotoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutUploadedByInput | TrainingPhotoCreateOrConnectWithoutUploadedByInput[]
    createMany?: TrainingPhotoCreateManyUploadedByInputEnvelope
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
  }

  export type TrainingFeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<TrainingFeedbackCreateWithoutUserInput, TrainingFeedbackUncheckedCreateWithoutUserInput> | TrainingFeedbackCreateWithoutUserInput[] | TrainingFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutUserInput | TrainingFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: TrainingFeedbackCreateManyUserInputEnvelope
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
  }

  export type TrainingFollowupCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TrainingFollowupCreateWithoutAssignedToInput, TrainingFollowupUncheckedCreateWithoutAssignedToInput> | TrainingFollowupCreateWithoutAssignedToInput[] | TrainingFollowupUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutAssignedToInput | TrainingFollowupCreateOrConnectWithoutAssignedToInput[]
    createMany?: TrainingFollowupCreateManyAssignedToInputEnvelope
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
  }

  export type TrainingFollowupCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TrainingFollowupCreateWithoutCreatedByInput, TrainingFollowupUncheckedCreateWithoutCreatedByInput> | TrainingFollowupCreateWithoutCreatedByInput[] | TrainingFollowupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutCreatedByInput | TrainingFollowupCreateOrConnectWithoutCreatedByInput[]
    createMany?: TrainingFollowupCreateManyCreatedByInputEnvelope
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
  }

  export type TrainingNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<TrainingNotificationCreateWithoutUserInput, TrainingNotificationUncheckedCreateWithoutUserInput> | TrainingNotificationCreateWithoutUserInput[] | TrainingNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutUserInput | TrainingNotificationCreateOrConnectWithoutUserInput[]
    createMany?: TrainingNotificationCreateManyUserInputEnvelope
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput> | BatchCreateWithoutUser_Batch_checkerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_checkerIdToUserInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput> | BatchCreateWithoutUser_Batch_makerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_makerIdToUserInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StandardUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StandardCreateWithoutCreatedByInput, StandardUncheckedCreateWithoutCreatedByInput> | StandardCreateWithoutCreatedByInput[] | StandardUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCreatedByInput | StandardCreateOrConnectWithoutCreatedByInput[]
    createMany?: StandardCreateManyCreatedByInputEnvelope
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type StandardUncheckedCreateNestedManyWithoutModifiedByInput = {
    create?: XOR<StandardCreateWithoutModifiedByInput, StandardUncheckedCreateWithoutModifiedByInput> | StandardCreateWithoutModifiedByInput[] | StandardUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutModifiedByInput | StandardCreateOrConnectWithoutModifiedByInput[]
    createMany?: StandardCreateManyModifiedByInputEnvelope
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<StandardDefinitionCreateWithoutCreatedByInput, StandardDefinitionUncheckedCreateWithoutCreatedByInput> | StandardDefinitionCreateWithoutCreatedByInput[] | StandardDefinitionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutCreatedByInput | StandardDefinitionCreateOrConnectWithoutCreatedByInput[]
    createMany?: StandardDefinitionCreateManyCreatedByInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput = {
    create?: XOR<StandardDefinitionCreateWithoutModifiedByInput, StandardDefinitionUncheckedCreateWithoutModifiedByInput> | StandardDefinitionCreateWithoutModifiedByInput[] | StandardDefinitionUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutModifiedByInput | StandardDefinitionCreateOrConnectWithoutModifiedByInput[]
    createMany?: StandardDefinitionCreateManyModifiedByInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type TrainingUncheckedCreateNestedManyWithoutTrainerInput = {
    create?: XOR<TrainingCreateWithoutTrainerInput, TrainingUncheckedCreateWithoutTrainerInput> | TrainingCreateWithoutTrainerInput[] | TrainingUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutTrainerInput | TrainingCreateOrConnectWithoutTrainerInput[]
    createMany?: TrainingCreateManyTrainerInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type TrainingUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TrainingCreateWithoutCreatedByInput, TrainingUncheckedCreateWithoutCreatedByInput> | TrainingCreateWithoutCreatedByInput[] | TrainingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCreatedByInput | TrainingCreateOrConnectWithoutCreatedByInput[]
    createMany?: TrainingCreateManyCreatedByInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type TrainingParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TrainingParticipantCreateWithoutUserInput, TrainingParticipantUncheckedCreateWithoutUserInput> | TrainingParticipantCreateWithoutUserInput[] | TrainingParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutUserInput | TrainingParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TrainingParticipantCreateManyUserInputEnvelope
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TrainingDocumentCreateWithoutUploadedByInput, TrainingDocumentUncheckedCreateWithoutUploadedByInput> | TrainingDocumentCreateWithoutUploadedByInput[] | TrainingDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutUploadedByInput | TrainingDocumentCreateOrConnectWithoutUploadedByInput[]
    createMany?: TrainingDocumentCreateManyUploadedByInputEnvelope
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
  }

  export type TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TrainingPhotoCreateWithoutUploadedByInput, TrainingPhotoUncheckedCreateWithoutUploadedByInput> | TrainingPhotoCreateWithoutUploadedByInput[] | TrainingPhotoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutUploadedByInput | TrainingPhotoCreateOrConnectWithoutUploadedByInput[]
    createMany?: TrainingPhotoCreateManyUploadedByInputEnvelope
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
  }

  export type TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TrainingFeedbackCreateWithoutUserInput, TrainingFeedbackUncheckedCreateWithoutUserInput> | TrainingFeedbackCreateWithoutUserInput[] | TrainingFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutUserInput | TrainingFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: TrainingFeedbackCreateManyUserInputEnvelope
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
  }

  export type TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TrainingFollowupCreateWithoutAssignedToInput, TrainingFollowupUncheckedCreateWithoutAssignedToInput> | TrainingFollowupCreateWithoutAssignedToInput[] | TrainingFollowupUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutAssignedToInput | TrainingFollowupCreateOrConnectWithoutAssignedToInput[]
    createMany?: TrainingFollowupCreateManyAssignedToInputEnvelope
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
  }

  export type TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TrainingFollowupCreateWithoutCreatedByInput, TrainingFollowupUncheckedCreateWithoutCreatedByInput> | TrainingFollowupCreateWithoutCreatedByInput[] | TrainingFollowupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutCreatedByInput | TrainingFollowupCreateOrConnectWithoutCreatedByInput[]
    createMany?: TrainingFollowupCreateManyCreatedByInputEnvelope
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
  }

  export type TrainingNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TrainingNotificationCreateWithoutUserInput, TrainingNotificationUncheckedCreateWithoutUserInput> | TrainingNotificationCreateWithoutUserInput[] | TrainingNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutUserInput | TrainingNotificationCreateOrConnectWithoutUserInput[]
    createMany?: TrainingNotificationCreateManyUserInputEnvelope
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput> | BatchCreateWithoutUser_Batch_checkerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput | BatchUpsertWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_checkerIdToUserInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput | BatchUpdateWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUser_Batch_checkerIdToUserInput | BatchUpdateManyWithWhereWithoutUser_Batch_checkerIdToUserInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput> | BatchCreateWithoutUser_Batch_makerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUser_Batch_makerIdToUserInput | BatchUpsertWithWhereUniqueWithoutUser_Batch_makerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_makerIdToUserInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUser_Batch_makerIdToUserInput | BatchUpdateWithWhereUniqueWithoutUser_Batch_makerIdToUserInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUser_Batch_makerIdToUserInput | BatchUpdateManyWithWhereWithoutUser_Batch_makerIdToUserInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RoleUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput
    upsert?: RoleUpsertWithoutUserInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserInput, RoleUpdateWithoutUserInput>, RoleUncheckedUpdateWithoutUserInput>
  }

  export type StandardUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StandardCreateWithoutCreatedByInput, StandardUncheckedCreateWithoutCreatedByInput> | StandardCreateWithoutCreatedByInput[] | StandardUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCreatedByInput | StandardCreateOrConnectWithoutCreatedByInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutCreatedByInput | StandardUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StandardCreateManyCreatedByInputEnvelope
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutCreatedByInput | StandardUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutCreatedByInput | StandardUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type StandardUpdateManyWithoutModifiedByNestedInput = {
    create?: XOR<StandardCreateWithoutModifiedByInput, StandardUncheckedCreateWithoutModifiedByInput> | StandardCreateWithoutModifiedByInput[] | StandardUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutModifiedByInput | StandardCreateOrConnectWithoutModifiedByInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutModifiedByInput | StandardUpsertWithWhereUniqueWithoutModifiedByInput[]
    createMany?: StandardCreateManyModifiedByInputEnvelope
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutModifiedByInput | StandardUpdateWithWhereUniqueWithoutModifiedByInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutModifiedByInput | StandardUpdateManyWithWhereWithoutModifiedByInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type StandardDefinitionUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutCreatedByInput, StandardDefinitionUncheckedCreateWithoutCreatedByInput> | StandardDefinitionCreateWithoutCreatedByInput[] | StandardDefinitionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutCreatedByInput | StandardDefinitionCreateOrConnectWithoutCreatedByInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutCreatedByInput | StandardDefinitionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StandardDefinitionCreateManyCreatedByInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutCreatedByInput | StandardDefinitionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutCreatedByInput | StandardDefinitionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type StandardDefinitionUpdateManyWithoutModifiedByNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutModifiedByInput, StandardDefinitionUncheckedCreateWithoutModifiedByInput> | StandardDefinitionCreateWithoutModifiedByInput[] | StandardDefinitionUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutModifiedByInput | StandardDefinitionCreateOrConnectWithoutModifiedByInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutModifiedByInput | StandardDefinitionUpsertWithWhereUniqueWithoutModifiedByInput[]
    createMany?: StandardDefinitionCreateManyModifiedByInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutModifiedByInput | StandardDefinitionUpdateWithWhereUniqueWithoutModifiedByInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutModifiedByInput | StandardDefinitionUpdateManyWithWhereWithoutModifiedByInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type TrainingUpdateManyWithoutTrainerNestedInput = {
    create?: XOR<TrainingCreateWithoutTrainerInput, TrainingUncheckedCreateWithoutTrainerInput> | TrainingCreateWithoutTrainerInput[] | TrainingUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutTrainerInput | TrainingCreateOrConnectWithoutTrainerInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutTrainerInput | TrainingUpsertWithWhereUniqueWithoutTrainerInput[]
    createMany?: TrainingCreateManyTrainerInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutTrainerInput | TrainingUpdateWithWhereUniqueWithoutTrainerInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutTrainerInput | TrainingUpdateManyWithWhereWithoutTrainerInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type TrainingUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TrainingCreateWithoutCreatedByInput, TrainingUncheckedCreateWithoutCreatedByInput> | TrainingCreateWithoutCreatedByInput[] | TrainingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCreatedByInput | TrainingCreateOrConnectWithoutCreatedByInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutCreatedByInput | TrainingUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TrainingCreateManyCreatedByInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutCreatedByInput | TrainingUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutCreatedByInput | TrainingUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type TrainingParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrainingParticipantCreateWithoutUserInput, TrainingParticipantUncheckedCreateWithoutUserInput> | TrainingParticipantCreateWithoutUserInput[] | TrainingParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutUserInput | TrainingParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TrainingParticipantUpsertWithWhereUniqueWithoutUserInput | TrainingParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrainingParticipantCreateManyUserInputEnvelope
    set?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    disconnect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    delete?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    update?: TrainingParticipantUpdateWithWhereUniqueWithoutUserInput | TrainingParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrainingParticipantUpdateManyWithWhereWithoutUserInput | TrainingParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrainingParticipantScalarWhereInput | TrainingParticipantScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TrainingDocumentUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TrainingDocumentCreateWithoutUploadedByInput, TrainingDocumentUncheckedCreateWithoutUploadedByInput> | TrainingDocumentCreateWithoutUploadedByInput[] | TrainingDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutUploadedByInput | TrainingDocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: TrainingDocumentUpsertWithWhereUniqueWithoutUploadedByInput | TrainingDocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TrainingDocumentCreateManyUploadedByInputEnvelope
    set?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    disconnect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    delete?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    update?: TrainingDocumentUpdateWithWhereUniqueWithoutUploadedByInput | TrainingDocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TrainingDocumentUpdateManyWithWhereWithoutUploadedByInput | TrainingDocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
  }

  export type TrainingPhotoUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TrainingPhotoCreateWithoutUploadedByInput, TrainingPhotoUncheckedCreateWithoutUploadedByInput> | TrainingPhotoCreateWithoutUploadedByInput[] | TrainingPhotoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutUploadedByInput | TrainingPhotoCreateOrConnectWithoutUploadedByInput[]
    upsert?: TrainingPhotoUpsertWithWhereUniqueWithoutUploadedByInput | TrainingPhotoUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TrainingPhotoCreateManyUploadedByInputEnvelope
    set?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    disconnect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    delete?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    update?: TrainingPhotoUpdateWithWhereUniqueWithoutUploadedByInput | TrainingPhotoUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TrainingPhotoUpdateManyWithWhereWithoutUploadedByInput | TrainingPhotoUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TrainingPhotoScalarWhereInput | TrainingPhotoScalarWhereInput[]
  }

  export type TrainingFeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrainingFeedbackCreateWithoutUserInput, TrainingFeedbackUncheckedCreateWithoutUserInput> | TrainingFeedbackCreateWithoutUserInput[] | TrainingFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutUserInput | TrainingFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: TrainingFeedbackUpsertWithWhereUniqueWithoutUserInput | TrainingFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrainingFeedbackCreateManyUserInputEnvelope
    set?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    disconnect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    delete?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    update?: TrainingFeedbackUpdateWithWhereUniqueWithoutUserInput | TrainingFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrainingFeedbackUpdateManyWithWhereWithoutUserInput | TrainingFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrainingFeedbackScalarWhereInput | TrainingFeedbackScalarWhereInput[]
  }

  export type TrainingFollowupUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TrainingFollowupCreateWithoutAssignedToInput, TrainingFollowupUncheckedCreateWithoutAssignedToInput> | TrainingFollowupCreateWithoutAssignedToInput[] | TrainingFollowupUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutAssignedToInput | TrainingFollowupCreateOrConnectWithoutAssignedToInput[]
    upsert?: TrainingFollowupUpsertWithWhereUniqueWithoutAssignedToInput | TrainingFollowupUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TrainingFollowupCreateManyAssignedToInputEnvelope
    set?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    disconnect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    delete?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    update?: TrainingFollowupUpdateWithWhereUniqueWithoutAssignedToInput | TrainingFollowupUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TrainingFollowupUpdateManyWithWhereWithoutAssignedToInput | TrainingFollowupUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
  }

  export type TrainingFollowupUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TrainingFollowupCreateWithoutCreatedByInput, TrainingFollowupUncheckedCreateWithoutCreatedByInput> | TrainingFollowupCreateWithoutCreatedByInput[] | TrainingFollowupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutCreatedByInput | TrainingFollowupCreateOrConnectWithoutCreatedByInput[]
    upsert?: TrainingFollowupUpsertWithWhereUniqueWithoutCreatedByInput | TrainingFollowupUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TrainingFollowupCreateManyCreatedByInputEnvelope
    set?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    disconnect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    delete?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    update?: TrainingFollowupUpdateWithWhereUniqueWithoutCreatedByInput | TrainingFollowupUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TrainingFollowupUpdateManyWithWhereWithoutCreatedByInput | TrainingFollowupUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
  }

  export type TrainingNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrainingNotificationCreateWithoutUserInput, TrainingNotificationUncheckedCreateWithoutUserInput> | TrainingNotificationCreateWithoutUserInput[] | TrainingNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutUserInput | TrainingNotificationCreateOrConnectWithoutUserInput[]
    upsert?: TrainingNotificationUpsertWithWhereUniqueWithoutUserInput | TrainingNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrainingNotificationCreateManyUserInputEnvelope
    set?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    disconnect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    delete?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    update?: TrainingNotificationUpdateWithWhereUniqueWithoutUserInput | TrainingNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrainingNotificationUpdateManyWithWhereWithoutUserInput | TrainingNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrainingNotificationScalarWhereInput | TrainingNotificationScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput> | BatchCreateWithoutUser_Batch_checkerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput | BatchUpsertWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_checkerIdToUserInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput | BatchUpdateWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUser_Batch_checkerIdToUserInput | BatchUpdateManyWithWhereWithoutUser_Batch_checkerIdToUserInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput = {
    create?: XOR<BatchCreateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput> | BatchCreateWithoutUser_Batch_makerIdToUserInput[] | BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput | BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUser_Batch_makerIdToUserInput | BatchUpsertWithWhereUniqueWithoutUser_Batch_makerIdToUserInput[]
    createMany?: BatchCreateManyUser_Batch_makerIdToUserInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUser_Batch_makerIdToUserInput | BatchUpdateWithWhereUniqueWithoutUser_Batch_makerIdToUserInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUser_Batch_makerIdToUserInput | BatchUpdateManyWithWhereWithoutUser_Batch_makerIdToUserInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StandardUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StandardCreateWithoutCreatedByInput, StandardUncheckedCreateWithoutCreatedByInput> | StandardCreateWithoutCreatedByInput[] | StandardUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCreatedByInput | StandardCreateOrConnectWithoutCreatedByInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutCreatedByInput | StandardUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StandardCreateManyCreatedByInputEnvelope
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutCreatedByInput | StandardUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutCreatedByInput | StandardUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type StandardUncheckedUpdateManyWithoutModifiedByNestedInput = {
    create?: XOR<StandardCreateWithoutModifiedByInput, StandardUncheckedCreateWithoutModifiedByInput> | StandardCreateWithoutModifiedByInput[] | StandardUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutModifiedByInput | StandardCreateOrConnectWithoutModifiedByInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutModifiedByInput | StandardUpsertWithWhereUniqueWithoutModifiedByInput[]
    createMany?: StandardCreateManyModifiedByInputEnvelope
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutModifiedByInput | StandardUpdateWithWhereUniqueWithoutModifiedByInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutModifiedByInput | StandardUpdateManyWithWhereWithoutModifiedByInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutCreatedByInput, StandardDefinitionUncheckedCreateWithoutCreatedByInput> | StandardDefinitionCreateWithoutCreatedByInput[] | StandardDefinitionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutCreatedByInput | StandardDefinitionCreateOrConnectWithoutCreatedByInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutCreatedByInput | StandardDefinitionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: StandardDefinitionCreateManyCreatedByInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutCreatedByInput | StandardDefinitionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutCreatedByInput | StandardDefinitionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutModifiedByInput, StandardDefinitionUncheckedCreateWithoutModifiedByInput> | StandardDefinitionCreateWithoutModifiedByInput[] | StandardDefinitionUncheckedCreateWithoutModifiedByInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutModifiedByInput | StandardDefinitionCreateOrConnectWithoutModifiedByInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutModifiedByInput | StandardDefinitionUpsertWithWhereUniqueWithoutModifiedByInput[]
    createMany?: StandardDefinitionCreateManyModifiedByInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutModifiedByInput | StandardDefinitionUpdateWithWhereUniqueWithoutModifiedByInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutModifiedByInput | StandardDefinitionUpdateManyWithWhereWithoutModifiedByInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type TrainingUncheckedUpdateManyWithoutTrainerNestedInput = {
    create?: XOR<TrainingCreateWithoutTrainerInput, TrainingUncheckedCreateWithoutTrainerInput> | TrainingCreateWithoutTrainerInput[] | TrainingUncheckedCreateWithoutTrainerInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutTrainerInput | TrainingCreateOrConnectWithoutTrainerInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutTrainerInput | TrainingUpsertWithWhereUniqueWithoutTrainerInput[]
    createMany?: TrainingCreateManyTrainerInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutTrainerInput | TrainingUpdateWithWhereUniqueWithoutTrainerInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutTrainerInput | TrainingUpdateManyWithWhereWithoutTrainerInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type TrainingUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TrainingCreateWithoutCreatedByInput, TrainingUncheckedCreateWithoutCreatedByInput> | TrainingCreateWithoutCreatedByInput[] | TrainingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCreatedByInput | TrainingCreateOrConnectWithoutCreatedByInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutCreatedByInput | TrainingUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TrainingCreateManyCreatedByInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutCreatedByInput | TrainingUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutCreatedByInput | TrainingUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrainingParticipantCreateWithoutUserInput, TrainingParticipantUncheckedCreateWithoutUserInput> | TrainingParticipantCreateWithoutUserInput[] | TrainingParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutUserInput | TrainingParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TrainingParticipantUpsertWithWhereUniqueWithoutUserInput | TrainingParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrainingParticipantCreateManyUserInputEnvelope
    set?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    disconnect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    delete?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    update?: TrainingParticipantUpdateWithWhereUniqueWithoutUserInput | TrainingParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrainingParticipantUpdateManyWithWhereWithoutUserInput | TrainingParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrainingParticipantScalarWhereInput | TrainingParticipantScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TrainingDocumentCreateWithoutUploadedByInput, TrainingDocumentUncheckedCreateWithoutUploadedByInput> | TrainingDocumentCreateWithoutUploadedByInput[] | TrainingDocumentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutUploadedByInput | TrainingDocumentCreateOrConnectWithoutUploadedByInput[]
    upsert?: TrainingDocumentUpsertWithWhereUniqueWithoutUploadedByInput | TrainingDocumentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TrainingDocumentCreateManyUploadedByInputEnvelope
    set?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    disconnect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    delete?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    update?: TrainingDocumentUpdateWithWhereUniqueWithoutUploadedByInput | TrainingDocumentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TrainingDocumentUpdateManyWithWhereWithoutUploadedByInput | TrainingDocumentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
  }

  export type TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TrainingPhotoCreateWithoutUploadedByInput, TrainingPhotoUncheckedCreateWithoutUploadedByInput> | TrainingPhotoCreateWithoutUploadedByInput[] | TrainingPhotoUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutUploadedByInput | TrainingPhotoCreateOrConnectWithoutUploadedByInput[]
    upsert?: TrainingPhotoUpsertWithWhereUniqueWithoutUploadedByInput | TrainingPhotoUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TrainingPhotoCreateManyUploadedByInputEnvelope
    set?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    disconnect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    delete?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    update?: TrainingPhotoUpdateWithWhereUniqueWithoutUploadedByInput | TrainingPhotoUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TrainingPhotoUpdateManyWithWhereWithoutUploadedByInput | TrainingPhotoUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TrainingPhotoScalarWhereInput | TrainingPhotoScalarWhereInput[]
  }

  export type TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrainingFeedbackCreateWithoutUserInput, TrainingFeedbackUncheckedCreateWithoutUserInput> | TrainingFeedbackCreateWithoutUserInput[] | TrainingFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutUserInput | TrainingFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: TrainingFeedbackUpsertWithWhereUniqueWithoutUserInput | TrainingFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrainingFeedbackCreateManyUserInputEnvelope
    set?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    disconnect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    delete?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    update?: TrainingFeedbackUpdateWithWhereUniqueWithoutUserInput | TrainingFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrainingFeedbackUpdateManyWithWhereWithoutUserInput | TrainingFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrainingFeedbackScalarWhereInput | TrainingFeedbackScalarWhereInput[]
  }

  export type TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TrainingFollowupCreateWithoutAssignedToInput, TrainingFollowupUncheckedCreateWithoutAssignedToInput> | TrainingFollowupCreateWithoutAssignedToInput[] | TrainingFollowupUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutAssignedToInput | TrainingFollowupCreateOrConnectWithoutAssignedToInput[]
    upsert?: TrainingFollowupUpsertWithWhereUniqueWithoutAssignedToInput | TrainingFollowupUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TrainingFollowupCreateManyAssignedToInputEnvelope
    set?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    disconnect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    delete?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    update?: TrainingFollowupUpdateWithWhereUniqueWithoutAssignedToInput | TrainingFollowupUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TrainingFollowupUpdateManyWithWhereWithoutAssignedToInput | TrainingFollowupUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
  }

  export type TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TrainingFollowupCreateWithoutCreatedByInput, TrainingFollowupUncheckedCreateWithoutCreatedByInput> | TrainingFollowupCreateWithoutCreatedByInput[] | TrainingFollowupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutCreatedByInput | TrainingFollowupCreateOrConnectWithoutCreatedByInput[]
    upsert?: TrainingFollowupUpsertWithWhereUniqueWithoutCreatedByInput | TrainingFollowupUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TrainingFollowupCreateManyCreatedByInputEnvelope
    set?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    disconnect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    delete?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    update?: TrainingFollowupUpdateWithWhereUniqueWithoutCreatedByInput | TrainingFollowupUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TrainingFollowupUpdateManyWithWhereWithoutCreatedByInput | TrainingFollowupUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
  }

  export type TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrainingNotificationCreateWithoutUserInput, TrainingNotificationUncheckedCreateWithoutUserInput> | TrainingNotificationCreateWithoutUserInput[] | TrainingNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutUserInput | TrainingNotificationCreateOrConnectWithoutUserInput[]
    upsert?: TrainingNotificationUpsertWithWhereUniqueWithoutUserInput | TrainingNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrainingNotificationCreateManyUserInputEnvelope
    set?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    disconnect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    delete?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    update?: TrainingNotificationUpdateWithWhereUniqueWithoutUserInput | TrainingNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrainingNotificationUpdateManyWithWhereWithoutUserInput | TrainingNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrainingNotificationScalarWhereInput | TrainingNotificationScalarWhereInput[]
  }

  export type StandardCategoryCreateNestedOneWithoutStandardsInput = {
    create?: XOR<StandardCategoryCreateWithoutStandardsInput, StandardCategoryUncheckedCreateWithoutStandardsInput>
    connectOrCreate?: StandardCategoryCreateOrConnectWithoutStandardsInput
    connect?: StandardCategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStandardsCreatedInput = {
    create?: XOR<UserCreateWithoutStandardsCreatedInput, UserUncheckedCreateWithoutStandardsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStandardsModifiedInput = {
    create?: XOR<UserCreateWithoutStandardsModifiedInput, UserUncheckedCreateWithoutStandardsModifiedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardsModifiedInput
    connect?: UserWhereUniqueInput
  }

  export type BatchCreateNestedManyWithoutStandardsInput = {
    create?: XOR<BatchCreateWithoutStandardsInput, BatchUncheckedCreateWithoutStandardsInput> | BatchCreateWithoutStandardsInput[] | BatchUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutStandardsInput | BatchCreateOrConnectWithoutStandardsInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type MethodologyCreateNestedManyWithoutStandardsInput = {
    create?: XOR<MethodologyCreateWithoutStandardsInput, MethodologyUncheckedCreateWithoutStandardsInput> | MethodologyCreateWithoutStandardsInput[] | MethodologyUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutStandardsInput | MethodologyCreateOrConnectWithoutStandardsInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
  }

  export type UnitOfMeasurementCreateNestedManyWithoutStandardsInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardsInput, UnitOfMeasurementUncheckedCreateWithoutStandardsInput> | UnitOfMeasurementCreateWithoutStandardsInput[] | UnitOfMeasurementUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardsInput | UnitOfMeasurementCreateOrConnectWithoutStandardsInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutStandardsInput = {
    create?: XOR<BatchCreateWithoutStandardsInput, BatchUncheckedCreateWithoutStandardsInput> | BatchCreateWithoutStandardsInput[] | BatchUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutStandardsInput | BatchCreateOrConnectWithoutStandardsInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type MethodologyUncheckedCreateNestedManyWithoutStandardsInput = {
    create?: XOR<MethodologyCreateWithoutStandardsInput, MethodologyUncheckedCreateWithoutStandardsInput> | MethodologyCreateWithoutStandardsInput[] | MethodologyUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutStandardsInput | MethodologyCreateOrConnectWithoutStandardsInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
  }

  export type UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardsInput, UnitOfMeasurementUncheckedCreateWithoutStandardsInput> | UnitOfMeasurementCreateWithoutStandardsInput[] | UnitOfMeasurementUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardsInput | UnitOfMeasurementCreateOrConnectWithoutStandardsInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
  }

  export type EnumStandardStatusFieldUpdateOperationsInput = {
    set?: $Enums.StandardStatus
  }

  export type StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput = {
    create?: XOR<StandardCategoryCreateWithoutStandardsInput, StandardCategoryUncheckedCreateWithoutStandardsInput>
    connectOrCreate?: StandardCategoryCreateOrConnectWithoutStandardsInput
    upsert?: StandardCategoryUpsertWithoutStandardsInput
    connect?: StandardCategoryWhereUniqueInput
    update?: XOR<XOR<StandardCategoryUpdateToOneWithWhereWithoutStandardsInput, StandardCategoryUpdateWithoutStandardsInput>, StandardCategoryUncheckedUpdateWithoutStandardsInput>
  }

  export type UserUpdateOneRequiredWithoutStandardsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutStandardsCreatedInput, UserUncheckedCreateWithoutStandardsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardsCreatedInput
    upsert?: UserUpsertWithoutStandardsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStandardsCreatedInput, UserUpdateWithoutStandardsCreatedInput>, UserUncheckedUpdateWithoutStandardsCreatedInput>
  }

  export type UserUpdateOneWithoutStandardsModifiedNestedInput = {
    create?: XOR<UserCreateWithoutStandardsModifiedInput, UserUncheckedCreateWithoutStandardsModifiedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardsModifiedInput
    upsert?: UserUpsertWithoutStandardsModifiedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStandardsModifiedInput, UserUpdateWithoutStandardsModifiedInput>, UserUncheckedUpdateWithoutStandardsModifiedInput>
  }

  export type BatchUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<BatchCreateWithoutStandardsInput, BatchUncheckedCreateWithoutStandardsInput> | BatchCreateWithoutStandardsInput[] | BatchUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutStandardsInput | BatchCreateOrConnectWithoutStandardsInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutStandardsInput | BatchUpsertWithWhereUniqueWithoutStandardsInput[]
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutStandardsInput | BatchUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutStandardsInput | BatchUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type MethodologyUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<MethodologyCreateWithoutStandardsInput, MethodologyUncheckedCreateWithoutStandardsInput> | MethodologyCreateWithoutStandardsInput[] | MethodologyUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutStandardsInput | MethodologyCreateOrConnectWithoutStandardsInput[]
    upsert?: MethodologyUpsertWithWhereUniqueWithoutStandardsInput | MethodologyUpsertWithWhereUniqueWithoutStandardsInput[]
    set?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    disconnect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    delete?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    update?: MethodologyUpdateWithWhereUniqueWithoutStandardsInput | MethodologyUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: MethodologyUpdateManyWithWhereWithoutStandardsInput | MethodologyUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: MethodologyScalarWhereInput | MethodologyScalarWhereInput[]
  }

  export type UnitOfMeasurementUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardsInput, UnitOfMeasurementUncheckedCreateWithoutStandardsInput> | UnitOfMeasurementCreateWithoutStandardsInput[] | UnitOfMeasurementUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardsInput | UnitOfMeasurementCreateOrConnectWithoutStandardsInput[]
    upsert?: UnitOfMeasurementUpsertWithWhereUniqueWithoutStandardsInput | UnitOfMeasurementUpsertWithWhereUniqueWithoutStandardsInput[]
    set?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    disconnect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    delete?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    update?: UnitOfMeasurementUpdateWithWhereUniqueWithoutStandardsInput | UnitOfMeasurementUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: UnitOfMeasurementUpdateManyWithWhereWithoutStandardsInput | UnitOfMeasurementUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: UnitOfMeasurementScalarWhereInput | UnitOfMeasurementScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<BatchCreateWithoutStandardsInput, BatchUncheckedCreateWithoutStandardsInput> | BatchCreateWithoutStandardsInput[] | BatchUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutStandardsInput | BatchCreateOrConnectWithoutStandardsInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutStandardsInput | BatchUpsertWithWhereUniqueWithoutStandardsInput[]
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutStandardsInput | BatchUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutStandardsInput | BatchUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type MethodologyUncheckedUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<MethodologyCreateWithoutStandardsInput, MethodologyUncheckedCreateWithoutStandardsInput> | MethodologyCreateWithoutStandardsInput[] | MethodologyUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: MethodologyCreateOrConnectWithoutStandardsInput | MethodologyCreateOrConnectWithoutStandardsInput[]
    upsert?: MethodologyUpsertWithWhereUniqueWithoutStandardsInput | MethodologyUpsertWithWhereUniqueWithoutStandardsInput[]
    set?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    disconnect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    delete?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    connect?: MethodologyWhereUniqueInput | MethodologyWhereUniqueInput[]
    update?: MethodologyUpdateWithWhereUniqueWithoutStandardsInput | MethodologyUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: MethodologyUpdateManyWithWhereWithoutStandardsInput | MethodologyUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: MethodologyScalarWhereInput | MethodologyScalarWhereInput[]
  }

  export type UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardsInput, UnitOfMeasurementUncheckedCreateWithoutStandardsInput> | UnitOfMeasurementCreateWithoutStandardsInput[] | UnitOfMeasurementUncheckedCreateWithoutStandardsInput[]
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardsInput | UnitOfMeasurementCreateOrConnectWithoutStandardsInput[]
    upsert?: UnitOfMeasurementUpsertWithWhereUniqueWithoutStandardsInput | UnitOfMeasurementUpsertWithWhereUniqueWithoutStandardsInput[]
    set?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    disconnect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    delete?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    connect?: UnitOfMeasurementWhereUniqueInput | UnitOfMeasurementWhereUniqueInput[]
    update?: UnitOfMeasurementUpdateWithWhereUniqueWithoutStandardsInput | UnitOfMeasurementUpdateWithWhereUniqueWithoutStandardsInput[]
    updateMany?: UnitOfMeasurementUpdateManyWithWhereWithoutStandardsInput | UnitOfMeasurementUpdateManyWithWhereWithoutStandardsInput[]
    deleteMany?: UnitOfMeasurementScalarWhereInput | UnitOfMeasurementScalarWhereInput[]
  }

  export type StandardParameterCreateNestedManyWithoutCategoryInput = {
    create?: XOR<StandardParameterCreateWithoutCategoryInput, StandardParameterUncheckedCreateWithoutCategoryInput> | StandardParameterCreateWithoutCategoryInput[] | StandardParameterUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardParameterCreateOrConnectWithoutCategoryInput | StandardParameterCreateOrConnectWithoutCategoryInput[]
    createMany?: StandardParameterCreateManyCategoryInputEnvelope
    connect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
  }

  export type StandardCreateNestedManyWithoutCategoryInput = {
    create?: XOR<StandardCreateWithoutCategoryInput, StandardUncheckedCreateWithoutCategoryInput> | StandardCreateWithoutCategoryInput[] | StandardUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCategoryInput | StandardCreateOrConnectWithoutCategoryInput[]
    createMany?: StandardCreateManyCategoryInputEnvelope
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type StandardParameterUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<StandardParameterCreateWithoutCategoryInput, StandardParameterUncheckedCreateWithoutCategoryInput> | StandardParameterCreateWithoutCategoryInput[] | StandardParameterUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardParameterCreateOrConnectWithoutCategoryInput | StandardParameterCreateOrConnectWithoutCategoryInput[]
    createMany?: StandardParameterCreateManyCategoryInputEnvelope
    connect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
  }

  export type StandardUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<StandardCreateWithoutCategoryInput, StandardUncheckedCreateWithoutCategoryInput> | StandardCreateWithoutCategoryInput[] | StandardUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCategoryInput | StandardCreateOrConnectWithoutCategoryInput[]
    createMany?: StandardCreateManyCategoryInputEnvelope
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
  }

  export type StandardParameterUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<StandardParameterCreateWithoutCategoryInput, StandardParameterUncheckedCreateWithoutCategoryInput> | StandardParameterCreateWithoutCategoryInput[] | StandardParameterUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardParameterCreateOrConnectWithoutCategoryInput | StandardParameterCreateOrConnectWithoutCategoryInput[]
    upsert?: StandardParameterUpsertWithWhereUniqueWithoutCategoryInput | StandardParameterUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: StandardParameterCreateManyCategoryInputEnvelope
    set?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    disconnect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    delete?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    connect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    update?: StandardParameterUpdateWithWhereUniqueWithoutCategoryInput | StandardParameterUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: StandardParameterUpdateManyWithWhereWithoutCategoryInput | StandardParameterUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: StandardParameterScalarWhereInput | StandardParameterScalarWhereInput[]
  }

  export type StandardUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<StandardCreateWithoutCategoryInput, StandardUncheckedCreateWithoutCategoryInput> | StandardCreateWithoutCategoryInput[] | StandardUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCategoryInput | StandardCreateOrConnectWithoutCategoryInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutCategoryInput | StandardUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: StandardCreateManyCategoryInputEnvelope
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutCategoryInput | StandardUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutCategoryInput | StandardUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type StandardParameterUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<StandardParameterCreateWithoutCategoryInput, StandardParameterUncheckedCreateWithoutCategoryInput> | StandardParameterCreateWithoutCategoryInput[] | StandardParameterUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardParameterCreateOrConnectWithoutCategoryInput | StandardParameterCreateOrConnectWithoutCategoryInput[]
    upsert?: StandardParameterUpsertWithWhereUniqueWithoutCategoryInput | StandardParameterUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: StandardParameterCreateManyCategoryInputEnvelope
    set?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    disconnect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    delete?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    connect?: StandardParameterWhereUniqueInput | StandardParameterWhereUniqueInput[]
    update?: StandardParameterUpdateWithWhereUniqueWithoutCategoryInput | StandardParameterUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: StandardParameterUpdateManyWithWhereWithoutCategoryInput | StandardParameterUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: StandardParameterScalarWhereInput | StandardParameterScalarWhereInput[]
  }

  export type StandardUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<StandardCreateWithoutCategoryInput, StandardUncheckedCreateWithoutCategoryInput> | StandardCreateWithoutCategoryInput[] | StandardUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StandardCreateOrConnectWithoutCategoryInput | StandardCreateOrConnectWithoutCategoryInput[]
    upsert?: StandardUpsertWithWhereUniqueWithoutCategoryInput | StandardUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: StandardCreateManyCategoryInputEnvelope
    set?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    disconnect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    delete?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    connect?: StandardWhereUniqueInput | StandardWhereUniqueInput[]
    update?: StandardUpdateWithWhereUniqueWithoutCategoryInput | StandardUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: StandardUpdateManyWithWhereWithoutCategoryInput | StandardUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: StandardScalarWhereInput | StandardScalarWhereInput[]
  }

  export type StandardCategoryCreateNestedOneWithoutParametersInput = {
    create?: XOR<StandardCategoryCreateWithoutParametersInput, StandardCategoryUncheckedCreateWithoutParametersInput>
    connectOrCreate?: StandardCategoryCreateOrConnectWithoutParametersInput
    connect?: StandardCategoryWhereUniqueInput
  }

  export type BatchParameterValueCreateNestedManyWithoutParameterInput = {
    create?: XOR<BatchParameterValueCreateWithoutParameterInput, BatchParameterValueUncheckedCreateWithoutParameterInput> | BatchParameterValueCreateWithoutParameterInput[] | BatchParameterValueUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutParameterInput | BatchParameterValueCreateOrConnectWithoutParameterInput[]
    createMany?: BatchParameterValueCreateManyParameterInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type StandardDefinitionCreateNestedManyWithoutParameterInput = {
    create?: XOR<StandardDefinitionCreateWithoutParameterInput, StandardDefinitionUncheckedCreateWithoutParameterInput> | StandardDefinitionCreateWithoutParameterInput[] | StandardDefinitionUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutParameterInput | StandardDefinitionCreateOrConnectWithoutParameterInput[]
    createMany?: StandardDefinitionCreateManyParameterInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type BatchParameterValueUncheckedCreateNestedManyWithoutParameterInput = {
    create?: XOR<BatchParameterValueCreateWithoutParameterInput, BatchParameterValueUncheckedCreateWithoutParameterInput> | BatchParameterValueCreateWithoutParameterInput[] | BatchParameterValueUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutParameterInput | BatchParameterValueCreateOrConnectWithoutParameterInput[]
    createMany?: BatchParameterValueCreateManyParameterInputEnvelope
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
  }

  export type StandardDefinitionUncheckedCreateNestedManyWithoutParameterInput = {
    create?: XOR<StandardDefinitionCreateWithoutParameterInput, StandardDefinitionUncheckedCreateWithoutParameterInput> | StandardDefinitionCreateWithoutParameterInput[] | StandardDefinitionUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutParameterInput | StandardDefinitionCreateOrConnectWithoutParameterInput[]
    createMany?: StandardDefinitionCreateManyParameterInputEnvelope
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
  }

  export type EnumParameterDataTypeFieldUpdateOperationsInput = {
    set?: $Enums.ParameterDataType
  }

  export type StandardCategoryUpdateOneRequiredWithoutParametersNestedInput = {
    create?: XOR<StandardCategoryCreateWithoutParametersInput, StandardCategoryUncheckedCreateWithoutParametersInput>
    connectOrCreate?: StandardCategoryCreateOrConnectWithoutParametersInput
    upsert?: StandardCategoryUpsertWithoutParametersInput
    connect?: StandardCategoryWhereUniqueInput
    update?: XOR<XOR<StandardCategoryUpdateToOneWithWhereWithoutParametersInput, StandardCategoryUpdateWithoutParametersInput>, StandardCategoryUncheckedUpdateWithoutParametersInput>
  }

  export type BatchParameterValueUpdateManyWithoutParameterNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutParameterInput, BatchParameterValueUncheckedCreateWithoutParameterInput> | BatchParameterValueCreateWithoutParameterInput[] | BatchParameterValueUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutParameterInput | BatchParameterValueCreateOrConnectWithoutParameterInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutParameterInput | BatchParameterValueUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: BatchParameterValueCreateManyParameterInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutParameterInput | BatchParameterValueUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutParameterInput | BatchParameterValueUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type StandardDefinitionUpdateManyWithoutParameterNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutParameterInput, StandardDefinitionUncheckedCreateWithoutParameterInput> | StandardDefinitionCreateWithoutParameterInput[] | StandardDefinitionUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutParameterInput | StandardDefinitionCreateOrConnectWithoutParameterInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutParameterInput | StandardDefinitionUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: StandardDefinitionCreateManyParameterInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutParameterInput | StandardDefinitionUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutParameterInput | StandardDefinitionUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutParameterNestedInput = {
    create?: XOR<BatchParameterValueCreateWithoutParameterInput, BatchParameterValueUncheckedCreateWithoutParameterInput> | BatchParameterValueCreateWithoutParameterInput[] | BatchParameterValueUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: BatchParameterValueCreateOrConnectWithoutParameterInput | BatchParameterValueCreateOrConnectWithoutParameterInput[]
    upsert?: BatchParameterValueUpsertWithWhereUniqueWithoutParameterInput | BatchParameterValueUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: BatchParameterValueCreateManyParameterInputEnvelope
    set?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    disconnect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    delete?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    connect?: BatchParameterValueWhereUniqueInput | BatchParameterValueWhereUniqueInput[]
    update?: BatchParameterValueUpdateWithWhereUniqueWithoutParameterInput | BatchParameterValueUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: BatchParameterValueUpdateManyWithWhereWithoutParameterInput | BatchParameterValueUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutParameterNestedInput = {
    create?: XOR<StandardDefinitionCreateWithoutParameterInput, StandardDefinitionUncheckedCreateWithoutParameterInput> | StandardDefinitionCreateWithoutParameterInput[] | StandardDefinitionUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: StandardDefinitionCreateOrConnectWithoutParameterInput | StandardDefinitionCreateOrConnectWithoutParameterInput[]
    upsert?: StandardDefinitionUpsertWithWhereUniqueWithoutParameterInput | StandardDefinitionUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: StandardDefinitionCreateManyParameterInputEnvelope
    set?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    disconnect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    delete?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    connect?: StandardDefinitionWhereUniqueInput | StandardDefinitionWhereUniqueInput[]
    update?: StandardDefinitionUpdateWithWhereUniqueWithoutParameterInput | StandardDefinitionUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: StandardDefinitionUpdateManyWithWhereWithoutParameterInput | StandardDefinitionUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
  }

  export type StandardParameterCreateNestedOneWithoutStandardsInput = {
    create?: XOR<StandardParameterCreateWithoutStandardsInput, StandardParameterUncheckedCreateWithoutStandardsInput>
    connectOrCreate?: StandardParameterCreateOrConnectWithoutStandardsInput
    connect?: StandardParameterWhereUniqueInput
  }

  export type UnitOfMeasurementCreateNestedOneWithoutStandardDefinitionsInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardDefinitionsInput, UnitOfMeasurementUncheckedCreateWithoutStandardDefinitionsInput>
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardDefinitionsInput
    connect?: UnitOfMeasurementWhereUniqueInput
  }

  export type MethodologyCreateNestedOneWithoutStandardDefinitionsInput = {
    create?: XOR<MethodologyCreateWithoutStandardDefinitionsInput, MethodologyUncheckedCreateWithoutStandardDefinitionsInput>
    connectOrCreate?: MethodologyCreateOrConnectWithoutStandardDefinitionsInput
    connect?: MethodologyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStandardDefinitionsCreatedInput = {
    create?: XOR<UserCreateWithoutStandardDefinitionsCreatedInput, UserUncheckedCreateWithoutStandardDefinitionsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardDefinitionsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStandardDefinitionsModifiedInput = {
    create?: XOR<UserCreateWithoutStandardDefinitionsModifiedInput, UserUncheckedCreateWithoutStandardDefinitionsModifiedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardDefinitionsModifiedInput
    connect?: UserWhereUniqueInput
  }

  export type StandardParameterUpdateOneRequiredWithoutStandardsNestedInput = {
    create?: XOR<StandardParameterCreateWithoutStandardsInput, StandardParameterUncheckedCreateWithoutStandardsInput>
    connectOrCreate?: StandardParameterCreateOrConnectWithoutStandardsInput
    upsert?: StandardParameterUpsertWithoutStandardsInput
    connect?: StandardParameterWhereUniqueInput
    update?: XOR<XOR<StandardParameterUpdateToOneWithWhereWithoutStandardsInput, StandardParameterUpdateWithoutStandardsInput>, StandardParameterUncheckedUpdateWithoutStandardsInput>
  }

  export type UnitOfMeasurementUpdateOneWithoutStandardDefinitionsNestedInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutStandardDefinitionsInput, UnitOfMeasurementUncheckedCreateWithoutStandardDefinitionsInput>
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutStandardDefinitionsInput
    upsert?: UnitOfMeasurementUpsertWithoutStandardDefinitionsInput
    disconnect?: UnitOfMeasurementWhereInput | boolean
    delete?: UnitOfMeasurementWhereInput | boolean
    connect?: UnitOfMeasurementWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasurementUpdateToOneWithWhereWithoutStandardDefinitionsInput, UnitOfMeasurementUpdateWithoutStandardDefinitionsInput>, UnitOfMeasurementUncheckedUpdateWithoutStandardDefinitionsInput>
  }

  export type MethodologyUpdateOneWithoutStandardDefinitionsNestedInput = {
    create?: XOR<MethodologyCreateWithoutStandardDefinitionsInput, MethodologyUncheckedCreateWithoutStandardDefinitionsInput>
    connectOrCreate?: MethodologyCreateOrConnectWithoutStandardDefinitionsInput
    upsert?: MethodologyUpsertWithoutStandardDefinitionsInput
    disconnect?: MethodologyWhereInput | boolean
    delete?: MethodologyWhereInput | boolean
    connect?: MethodologyWhereUniqueInput
    update?: XOR<XOR<MethodologyUpdateToOneWithWhereWithoutStandardDefinitionsInput, MethodologyUpdateWithoutStandardDefinitionsInput>, MethodologyUncheckedUpdateWithoutStandardDefinitionsInput>
  }

  export type UserUpdateOneRequiredWithoutStandardDefinitionsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutStandardDefinitionsCreatedInput, UserUncheckedCreateWithoutStandardDefinitionsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardDefinitionsCreatedInput
    upsert?: UserUpsertWithoutStandardDefinitionsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStandardDefinitionsCreatedInput, UserUpdateWithoutStandardDefinitionsCreatedInput>, UserUncheckedUpdateWithoutStandardDefinitionsCreatedInput>
  }

  export type UserUpdateOneWithoutStandardDefinitionsModifiedNestedInput = {
    create?: XOR<UserCreateWithoutStandardDefinitionsModifiedInput, UserUncheckedCreateWithoutStandardDefinitionsModifiedInput>
    connectOrCreate?: UserCreateOrConnectWithoutStandardDefinitionsModifiedInput
    upsert?: UserUpsertWithoutStandardDefinitionsModifiedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStandardDefinitionsModifiedInput, UserUpdateWithoutStandardDefinitionsModifiedInput>, UserUncheckedUpdateWithoutStandardDefinitionsModifiedInput>
  }

  export type BatchCreateNestedOneWithoutParameterValuesInput = {
    create?: XOR<BatchCreateWithoutParameterValuesInput, BatchUncheckedCreateWithoutParameterValuesInput>
    connectOrCreate?: BatchCreateOrConnectWithoutParameterValuesInput
    connect?: BatchWhereUniqueInput
  }

  export type StandardParameterCreateNestedOneWithoutBatchValuesInput = {
    create?: XOR<StandardParameterCreateWithoutBatchValuesInput, StandardParameterUncheckedCreateWithoutBatchValuesInput>
    connectOrCreate?: StandardParameterCreateOrConnectWithoutBatchValuesInput
    connect?: StandardParameterWhereUniqueInput
  }

  export type UnitOfMeasurementCreateNestedOneWithoutBatchParameterValuesInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutBatchParameterValuesInput, UnitOfMeasurementUncheckedCreateWithoutBatchParameterValuesInput>
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutBatchParameterValuesInput
    connect?: UnitOfMeasurementWhereUniqueInput
  }

  export type MethodologyCreateNestedOneWithoutBatchParameterValuesInput = {
    create?: XOR<MethodologyCreateWithoutBatchParameterValuesInput, MethodologyUncheckedCreateWithoutBatchParameterValuesInput>
    connectOrCreate?: MethodologyCreateOrConnectWithoutBatchParameterValuesInput
    connect?: MethodologyWhereUniqueInput
  }

  export type BatchUpdateOneRequiredWithoutParameterValuesNestedInput = {
    create?: XOR<BatchCreateWithoutParameterValuesInput, BatchUncheckedCreateWithoutParameterValuesInput>
    connectOrCreate?: BatchCreateOrConnectWithoutParameterValuesInput
    upsert?: BatchUpsertWithoutParameterValuesInput
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutParameterValuesInput, BatchUpdateWithoutParameterValuesInput>, BatchUncheckedUpdateWithoutParameterValuesInput>
  }

  export type StandardParameterUpdateOneRequiredWithoutBatchValuesNestedInput = {
    create?: XOR<StandardParameterCreateWithoutBatchValuesInput, StandardParameterUncheckedCreateWithoutBatchValuesInput>
    connectOrCreate?: StandardParameterCreateOrConnectWithoutBatchValuesInput
    upsert?: StandardParameterUpsertWithoutBatchValuesInput
    connect?: StandardParameterWhereUniqueInput
    update?: XOR<XOR<StandardParameterUpdateToOneWithWhereWithoutBatchValuesInput, StandardParameterUpdateWithoutBatchValuesInput>, StandardParameterUncheckedUpdateWithoutBatchValuesInput>
  }

  export type UnitOfMeasurementUpdateOneWithoutBatchParameterValuesNestedInput = {
    create?: XOR<UnitOfMeasurementCreateWithoutBatchParameterValuesInput, UnitOfMeasurementUncheckedCreateWithoutBatchParameterValuesInput>
    connectOrCreate?: UnitOfMeasurementCreateOrConnectWithoutBatchParameterValuesInput
    upsert?: UnitOfMeasurementUpsertWithoutBatchParameterValuesInput
    disconnect?: UnitOfMeasurementWhereInput | boolean
    delete?: UnitOfMeasurementWhereInput | boolean
    connect?: UnitOfMeasurementWhereUniqueInput
    update?: XOR<XOR<UnitOfMeasurementUpdateToOneWithWhereWithoutBatchParameterValuesInput, UnitOfMeasurementUpdateWithoutBatchParameterValuesInput>, UnitOfMeasurementUncheckedUpdateWithoutBatchParameterValuesInput>
  }

  export type MethodologyUpdateOneWithoutBatchParameterValuesNestedInput = {
    create?: XOR<MethodologyCreateWithoutBatchParameterValuesInput, MethodologyUncheckedCreateWithoutBatchParameterValuesInput>
    connectOrCreate?: MethodologyCreateOrConnectWithoutBatchParameterValuesInput
    upsert?: MethodologyUpsertWithoutBatchParameterValuesInput
    disconnect?: MethodologyWhereInput | boolean
    delete?: MethodologyWhereInput | boolean
    connect?: MethodologyWhereUniqueInput
    update?: XOR<XOR<MethodologyUpdateToOneWithWhereWithoutBatchParameterValuesInput, MethodologyUpdateWithoutBatchParameterValuesInput>, MethodologyUncheckedUpdateWithoutBatchParameterValuesInput>
  }

  export type TrainingCreateNestedManyWithoutCalendarInput = {
    create?: XOR<TrainingCreateWithoutCalendarInput, TrainingUncheckedCreateWithoutCalendarInput> | TrainingCreateWithoutCalendarInput[] | TrainingUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCalendarInput | TrainingCreateOrConnectWithoutCalendarInput[]
    createMany?: TrainingCreateManyCalendarInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type TrainingUncheckedCreateNestedManyWithoutCalendarInput = {
    create?: XOR<TrainingCreateWithoutCalendarInput, TrainingUncheckedCreateWithoutCalendarInput> | TrainingCreateWithoutCalendarInput[] | TrainingUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCalendarInput | TrainingCreateOrConnectWithoutCalendarInput[]
    createMany?: TrainingCreateManyCalendarInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TrainingUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<TrainingCreateWithoutCalendarInput, TrainingUncheckedCreateWithoutCalendarInput> | TrainingCreateWithoutCalendarInput[] | TrainingUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCalendarInput | TrainingCreateOrConnectWithoutCalendarInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutCalendarInput | TrainingUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: TrainingCreateManyCalendarInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutCalendarInput | TrainingUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutCalendarInput | TrainingUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type TrainingUncheckedUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<TrainingCreateWithoutCalendarInput, TrainingUncheckedCreateWithoutCalendarInput> | TrainingCreateWithoutCalendarInput[] | TrainingUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutCalendarInput | TrainingCreateOrConnectWithoutCalendarInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutCalendarInput | TrainingUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: TrainingCreateManyCalendarInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutCalendarInput | TrainingUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutCalendarInput | TrainingUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTrainerTrainingsInput = {
    create?: XOR<UserCreateWithoutTrainerTrainingsInput, UserUncheckedCreateWithoutTrainerTrainingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainerTrainingsInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingCalendarCreateNestedOneWithoutTrainingsInput = {
    create?: XOR<TrainingCalendarCreateWithoutTrainingsInput, TrainingCalendarUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: TrainingCalendarCreateOrConnectWithoutTrainingsInput
    connect?: TrainingCalendarWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTrainingsInput = {
    create?: XOR<UserCreateWithoutCreatedTrainingsInput, UserUncheckedCreateWithoutCreatedTrainingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTrainingsInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingSessionCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingSessionCreateWithoutTrainingInput, TrainingSessionUncheckedCreateWithoutTrainingInput> | TrainingSessionCreateWithoutTrainingInput[] | TrainingSessionUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutTrainingInput | TrainingSessionCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingSessionCreateManyTrainingInputEnvelope
    connect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
  }

  export type TrainingDocumentCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingDocumentCreateWithoutTrainingInput, TrainingDocumentUncheckedCreateWithoutTrainingInput> | TrainingDocumentCreateWithoutTrainingInput[] | TrainingDocumentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutTrainingInput | TrainingDocumentCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingDocumentCreateManyTrainingInputEnvelope
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutTrainingInput = {
    create?: XOR<AttendanceCreateWithoutTrainingInput, AttendanceUncheckedCreateWithoutTrainingInput> | AttendanceCreateWithoutTrainingInput[] | AttendanceUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTrainingInput | AttendanceCreateOrConnectWithoutTrainingInput[]
    createMany?: AttendanceCreateManyTrainingInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type TrainingParticipantCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingParticipantCreateWithoutTrainingInput, TrainingParticipantUncheckedCreateWithoutTrainingInput> | TrainingParticipantCreateWithoutTrainingInput[] | TrainingParticipantUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutTrainingInput | TrainingParticipantCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingParticipantCreateManyTrainingInputEnvelope
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
  }

  export type TrainingPhotoCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingPhotoCreateWithoutTrainingInput, TrainingPhotoUncheckedCreateWithoutTrainingInput> | TrainingPhotoCreateWithoutTrainingInput[] | TrainingPhotoUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutTrainingInput | TrainingPhotoCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingPhotoCreateManyTrainingInputEnvelope
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
  }

  export type TrainingFeedbackCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingFeedbackCreateWithoutTrainingInput, TrainingFeedbackUncheckedCreateWithoutTrainingInput> | TrainingFeedbackCreateWithoutTrainingInput[] | TrainingFeedbackUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutTrainingInput | TrainingFeedbackCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingFeedbackCreateManyTrainingInputEnvelope
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
  }

  export type TrainingFollowupCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingFollowupCreateWithoutTrainingInput, TrainingFollowupUncheckedCreateWithoutTrainingInput> | TrainingFollowupCreateWithoutTrainingInput[] | TrainingFollowupUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutTrainingInput | TrainingFollowupCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingFollowupCreateManyTrainingInputEnvelope
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
  }

  export type TrainingNotificationCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingNotificationCreateWithoutTrainingInput, TrainingNotificationUncheckedCreateWithoutTrainingInput> | TrainingNotificationCreateWithoutTrainingInput[] | TrainingNotificationUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutTrainingInput | TrainingNotificationCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingNotificationCreateManyTrainingInputEnvelope
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
  }

  export type TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingSessionCreateWithoutTrainingInput, TrainingSessionUncheckedCreateWithoutTrainingInput> | TrainingSessionCreateWithoutTrainingInput[] | TrainingSessionUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutTrainingInput | TrainingSessionCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingSessionCreateManyTrainingInputEnvelope
    connect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
  }

  export type TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingDocumentCreateWithoutTrainingInput, TrainingDocumentUncheckedCreateWithoutTrainingInput> | TrainingDocumentCreateWithoutTrainingInput[] | TrainingDocumentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutTrainingInput | TrainingDocumentCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingDocumentCreateManyTrainingInputEnvelope
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<AttendanceCreateWithoutTrainingInput, AttendanceUncheckedCreateWithoutTrainingInput> | AttendanceCreateWithoutTrainingInput[] | AttendanceUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTrainingInput | AttendanceCreateOrConnectWithoutTrainingInput[]
    createMany?: AttendanceCreateManyTrainingInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingParticipantCreateWithoutTrainingInput, TrainingParticipantUncheckedCreateWithoutTrainingInput> | TrainingParticipantCreateWithoutTrainingInput[] | TrainingParticipantUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutTrainingInput | TrainingParticipantCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingParticipantCreateManyTrainingInputEnvelope
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
  }

  export type TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingPhotoCreateWithoutTrainingInput, TrainingPhotoUncheckedCreateWithoutTrainingInput> | TrainingPhotoCreateWithoutTrainingInput[] | TrainingPhotoUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutTrainingInput | TrainingPhotoCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingPhotoCreateManyTrainingInputEnvelope
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
  }

  export type TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingFeedbackCreateWithoutTrainingInput, TrainingFeedbackUncheckedCreateWithoutTrainingInput> | TrainingFeedbackCreateWithoutTrainingInput[] | TrainingFeedbackUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutTrainingInput | TrainingFeedbackCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingFeedbackCreateManyTrainingInputEnvelope
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
  }

  export type TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingFollowupCreateWithoutTrainingInput, TrainingFollowupUncheckedCreateWithoutTrainingInput> | TrainingFollowupCreateWithoutTrainingInput[] | TrainingFollowupUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutTrainingInput | TrainingFollowupCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingFollowupCreateManyTrainingInputEnvelope
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
  }

  export type TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TrainingNotificationCreateWithoutTrainingInput, TrainingNotificationUncheckedCreateWithoutTrainingInput> | TrainingNotificationCreateWithoutTrainingInput[] | TrainingNotificationUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutTrainingInput | TrainingNotificationCreateOrConnectWithoutTrainingInput[]
    createMany?: TrainingNotificationCreateManyTrainingInputEnvelope
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
  }

  export type EnumTrainingTypeFieldUpdateOperationsInput = {
    set?: $Enums.TrainingType
  }

  export type EnumTrainingStatusFieldUpdateOperationsInput = {
    set?: $Enums.TrainingStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput = {
    create?: XOR<UserCreateWithoutTrainerTrainingsInput, UserUncheckedCreateWithoutTrainerTrainingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainerTrainingsInput
    upsert?: UserUpsertWithoutTrainerTrainingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrainerTrainingsInput, UserUpdateWithoutTrainerTrainingsInput>, UserUncheckedUpdateWithoutTrainerTrainingsInput>
  }

  export type TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput = {
    create?: XOR<TrainingCalendarCreateWithoutTrainingsInput, TrainingCalendarUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: TrainingCalendarCreateOrConnectWithoutTrainingsInput
    upsert?: TrainingCalendarUpsertWithoutTrainingsInput
    connect?: TrainingCalendarWhereUniqueInput
    update?: XOR<XOR<TrainingCalendarUpdateToOneWithWhereWithoutTrainingsInput, TrainingCalendarUpdateWithoutTrainingsInput>, TrainingCalendarUncheckedUpdateWithoutTrainingsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTrainingsInput, UserUncheckedCreateWithoutCreatedTrainingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTrainingsInput
    upsert?: UserUpsertWithoutCreatedTrainingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTrainingsInput, UserUpdateWithoutCreatedTrainingsInput>, UserUncheckedUpdateWithoutCreatedTrainingsInput>
  }

  export type TrainingSessionUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingSessionCreateWithoutTrainingInput, TrainingSessionUncheckedCreateWithoutTrainingInput> | TrainingSessionCreateWithoutTrainingInput[] | TrainingSessionUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutTrainingInput | TrainingSessionCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingSessionUpsertWithWhereUniqueWithoutTrainingInput | TrainingSessionUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingSessionCreateManyTrainingInputEnvelope
    set?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    disconnect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    delete?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    connect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    update?: TrainingSessionUpdateWithWhereUniqueWithoutTrainingInput | TrainingSessionUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingSessionUpdateManyWithWhereWithoutTrainingInput | TrainingSessionUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingSessionScalarWhereInput | TrainingSessionScalarWhereInput[]
  }

  export type TrainingDocumentUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingDocumentCreateWithoutTrainingInput, TrainingDocumentUncheckedCreateWithoutTrainingInput> | TrainingDocumentCreateWithoutTrainingInput[] | TrainingDocumentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutTrainingInput | TrainingDocumentCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingDocumentUpsertWithWhereUniqueWithoutTrainingInput | TrainingDocumentUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingDocumentCreateManyTrainingInputEnvelope
    set?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    disconnect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    delete?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    update?: TrainingDocumentUpdateWithWhereUniqueWithoutTrainingInput | TrainingDocumentUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingDocumentUpdateManyWithWhereWithoutTrainingInput | TrainingDocumentUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<AttendanceCreateWithoutTrainingInput, AttendanceUncheckedCreateWithoutTrainingInput> | AttendanceCreateWithoutTrainingInput[] | AttendanceUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTrainingInput | AttendanceCreateOrConnectWithoutTrainingInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutTrainingInput | AttendanceUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: AttendanceCreateManyTrainingInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutTrainingInput | AttendanceUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutTrainingInput | AttendanceUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TrainingParticipantUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingParticipantCreateWithoutTrainingInput, TrainingParticipantUncheckedCreateWithoutTrainingInput> | TrainingParticipantCreateWithoutTrainingInput[] | TrainingParticipantUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutTrainingInput | TrainingParticipantCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingParticipantUpsertWithWhereUniqueWithoutTrainingInput | TrainingParticipantUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingParticipantCreateManyTrainingInputEnvelope
    set?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    disconnect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    delete?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    update?: TrainingParticipantUpdateWithWhereUniqueWithoutTrainingInput | TrainingParticipantUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingParticipantUpdateManyWithWhereWithoutTrainingInput | TrainingParticipantUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingParticipantScalarWhereInput | TrainingParticipantScalarWhereInput[]
  }

  export type TrainingPhotoUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingPhotoCreateWithoutTrainingInput, TrainingPhotoUncheckedCreateWithoutTrainingInput> | TrainingPhotoCreateWithoutTrainingInput[] | TrainingPhotoUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutTrainingInput | TrainingPhotoCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingPhotoUpsertWithWhereUniqueWithoutTrainingInput | TrainingPhotoUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingPhotoCreateManyTrainingInputEnvelope
    set?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    disconnect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    delete?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    update?: TrainingPhotoUpdateWithWhereUniqueWithoutTrainingInput | TrainingPhotoUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingPhotoUpdateManyWithWhereWithoutTrainingInput | TrainingPhotoUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingPhotoScalarWhereInput | TrainingPhotoScalarWhereInput[]
  }

  export type TrainingFeedbackUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingFeedbackCreateWithoutTrainingInput, TrainingFeedbackUncheckedCreateWithoutTrainingInput> | TrainingFeedbackCreateWithoutTrainingInput[] | TrainingFeedbackUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutTrainingInput | TrainingFeedbackCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingFeedbackUpsertWithWhereUniqueWithoutTrainingInput | TrainingFeedbackUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingFeedbackCreateManyTrainingInputEnvelope
    set?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    disconnect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    delete?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    update?: TrainingFeedbackUpdateWithWhereUniqueWithoutTrainingInput | TrainingFeedbackUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingFeedbackUpdateManyWithWhereWithoutTrainingInput | TrainingFeedbackUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingFeedbackScalarWhereInput | TrainingFeedbackScalarWhereInput[]
  }

  export type TrainingFollowupUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingFollowupCreateWithoutTrainingInput, TrainingFollowupUncheckedCreateWithoutTrainingInput> | TrainingFollowupCreateWithoutTrainingInput[] | TrainingFollowupUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutTrainingInput | TrainingFollowupCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingFollowupUpsertWithWhereUniqueWithoutTrainingInput | TrainingFollowupUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingFollowupCreateManyTrainingInputEnvelope
    set?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    disconnect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    delete?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    update?: TrainingFollowupUpdateWithWhereUniqueWithoutTrainingInput | TrainingFollowupUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingFollowupUpdateManyWithWhereWithoutTrainingInput | TrainingFollowupUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
  }

  export type TrainingNotificationUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingNotificationCreateWithoutTrainingInput, TrainingNotificationUncheckedCreateWithoutTrainingInput> | TrainingNotificationCreateWithoutTrainingInput[] | TrainingNotificationUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutTrainingInput | TrainingNotificationCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingNotificationUpsertWithWhereUniqueWithoutTrainingInput | TrainingNotificationUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingNotificationCreateManyTrainingInputEnvelope
    set?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    disconnect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    delete?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    update?: TrainingNotificationUpdateWithWhereUniqueWithoutTrainingInput | TrainingNotificationUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingNotificationUpdateManyWithWhereWithoutTrainingInput | TrainingNotificationUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingNotificationScalarWhereInput | TrainingNotificationScalarWhereInput[]
  }

  export type TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingSessionCreateWithoutTrainingInput, TrainingSessionUncheckedCreateWithoutTrainingInput> | TrainingSessionCreateWithoutTrainingInput[] | TrainingSessionUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutTrainingInput | TrainingSessionCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingSessionUpsertWithWhereUniqueWithoutTrainingInput | TrainingSessionUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingSessionCreateManyTrainingInputEnvelope
    set?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    disconnect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    delete?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    connect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    update?: TrainingSessionUpdateWithWhereUniqueWithoutTrainingInput | TrainingSessionUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingSessionUpdateManyWithWhereWithoutTrainingInput | TrainingSessionUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingSessionScalarWhereInput | TrainingSessionScalarWhereInput[]
  }

  export type TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingDocumentCreateWithoutTrainingInput, TrainingDocumentUncheckedCreateWithoutTrainingInput> | TrainingDocumentCreateWithoutTrainingInput[] | TrainingDocumentUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutTrainingInput | TrainingDocumentCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingDocumentUpsertWithWhereUniqueWithoutTrainingInput | TrainingDocumentUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingDocumentCreateManyTrainingInputEnvelope
    set?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    disconnect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    delete?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    update?: TrainingDocumentUpdateWithWhereUniqueWithoutTrainingInput | TrainingDocumentUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingDocumentUpdateManyWithWhereWithoutTrainingInput | TrainingDocumentUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<AttendanceCreateWithoutTrainingInput, AttendanceUncheckedCreateWithoutTrainingInput> | AttendanceCreateWithoutTrainingInput[] | AttendanceUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTrainingInput | AttendanceCreateOrConnectWithoutTrainingInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutTrainingInput | AttendanceUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: AttendanceCreateManyTrainingInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutTrainingInput | AttendanceUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutTrainingInput | AttendanceUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingParticipantCreateWithoutTrainingInput, TrainingParticipantUncheckedCreateWithoutTrainingInput> | TrainingParticipantCreateWithoutTrainingInput[] | TrainingParticipantUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingParticipantCreateOrConnectWithoutTrainingInput | TrainingParticipantCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingParticipantUpsertWithWhereUniqueWithoutTrainingInput | TrainingParticipantUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingParticipantCreateManyTrainingInputEnvelope
    set?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    disconnect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    delete?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    connect?: TrainingParticipantWhereUniqueInput | TrainingParticipantWhereUniqueInput[]
    update?: TrainingParticipantUpdateWithWhereUniqueWithoutTrainingInput | TrainingParticipantUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingParticipantUpdateManyWithWhereWithoutTrainingInput | TrainingParticipantUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingParticipantScalarWhereInput | TrainingParticipantScalarWhereInput[]
  }

  export type TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingPhotoCreateWithoutTrainingInput, TrainingPhotoUncheckedCreateWithoutTrainingInput> | TrainingPhotoCreateWithoutTrainingInput[] | TrainingPhotoUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingPhotoCreateOrConnectWithoutTrainingInput | TrainingPhotoCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingPhotoUpsertWithWhereUniqueWithoutTrainingInput | TrainingPhotoUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingPhotoCreateManyTrainingInputEnvelope
    set?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    disconnect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    delete?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    connect?: TrainingPhotoWhereUniqueInput | TrainingPhotoWhereUniqueInput[]
    update?: TrainingPhotoUpdateWithWhereUniqueWithoutTrainingInput | TrainingPhotoUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingPhotoUpdateManyWithWhereWithoutTrainingInput | TrainingPhotoUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingPhotoScalarWhereInput | TrainingPhotoScalarWhereInput[]
  }

  export type TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingFeedbackCreateWithoutTrainingInput, TrainingFeedbackUncheckedCreateWithoutTrainingInput> | TrainingFeedbackCreateWithoutTrainingInput[] | TrainingFeedbackUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFeedbackCreateOrConnectWithoutTrainingInput | TrainingFeedbackCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingFeedbackUpsertWithWhereUniqueWithoutTrainingInput | TrainingFeedbackUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingFeedbackCreateManyTrainingInputEnvelope
    set?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    disconnect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    delete?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    connect?: TrainingFeedbackWhereUniqueInput | TrainingFeedbackWhereUniqueInput[]
    update?: TrainingFeedbackUpdateWithWhereUniqueWithoutTrainingInput | TrainingFeedbackUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingFeedbackUpdateManyWithWhereWithoutTrainingInput | TrainingFeedbackUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingFeedbackScalarWhereInput | TrainingFeedbackScalarWhereInput[]
  }

  export type TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingFollowupCreateWithoutTrainingInput, TrainingFollowupUncheckedCreateWithoutTrainingInput> | TrainingFollowupCreateWithoutTrainingInput[] | TrainingFollowupUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingFollowupCreateOrConnectWithoutTrainingInput | TrainingFollowupCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingFollowupUpsertWithWhereUniqueWithoutTrainingInput | TrainingFollowupUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingFollowupCreateManyTrainingInputEnvelope
    set?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    disconnect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    delete?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    connect?: TrainingFollowupWhereUniqueInput | TrainingFollowupWhereUniqueInput[]
    update?: TrainingFollowupUpdateWithWhereUniqueWithoutTrainingInput | TrainingFollowupUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingFollowupUpdateManyWithWhereWithoutTrainingInput | TrainingFollowupUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
  }

  export type TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TrainingNotificationCreateWithoutTrainingInput, TrainingNotificationUncheckedCreateWithoutTrainingInput> | TrainingNotificationCreateWithoutTrainingInput[] | TrainingNotificationUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TrainingNotificationCreateOrConnectWithoutTrainingInput | TrainingNotificationCreateOrConnectWithoutTrainingInput[]
    upsert?: TrainingNotificationUpsertWithWhereUniqueWithoutTrainingInput | TrainingNotificationUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TrainingNotificationCreateManyTrainingInputEnvelope
    set?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    disconnect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    delete?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    connect?: TrainingNotificationWhereUniqueInput | TrainingNotificationWhereUniqueInput[]
    update?: TrainingNotificationUpdateWithWhereUniqueWithoutTrainingInput | TrainingNotificationUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TrainingNotificationUpdateManyWithWhereWithoutTrainingInput | TrainingNotificationUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TrainingNotificationScalarWhereInput | TrainingNotificationScalarWhereInput[]
  }

  export type TrainingCreateNestedOneWithoutSessionsInput = {
    create?: XOR<TrainingCreateWithoutSessionsInput, TrainingUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutSessionsInput
    connect?: TrainingWhereUniqueInput
  }

  export type AttendanceCreateNestedManyWithoutSessionInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type TrainingUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<TrainingCreateWithoutSessionsInput, TrainingUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutSessionsInput
    upsert?: TrainingUpsertWithoutSessionsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutSessionsInput, TrainingUpdateWithoutSessionsInput>, TrainingUncheckedUpdateWithoutSessionsInput>
  }

  export type AttendanceUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutSessionInput | AttendanceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutSessionInput | AttendanceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutSessionInput | AttendanceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput> | AttendanceCreateWithoutSessionInput[] | AttendanceUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSessionInput | AttendanceCreateOrConnectWithoutSessionInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutSessionInput | AttendanceUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AttendanceCreateManySessionInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutSessionInput | AttendanceUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutSessionInput | AttendanceUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TrainingCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<TrainingCreateWithoutDocumentsInput, TrainingUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutDocumentsInput
    connect?: TrainingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedDocumentsInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type TrainingUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<TrainingCreateWithoutDocumentsInput, TrainingUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutDocumentsInput
    upsert?: TrainingUpsertWithoutDocumentsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutDocumentsInput, TrainingUpdateWithoutDocumentsInput>, TrainingUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    upsert?: UserUpsertWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedDocumentsInput, UserUpdateWithoutUploadedDocumentsInput>, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type TrainingCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<TrainingCreateWithoutParticipantsInput, TrainingUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutParticipantsInput
    connect?: TrainingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTrainingParticipationsInput = {
    create?: XOR<UserCreateWithoutTrainingParticipationsInput, UserUncheckedCreateWithoutTrainingParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingParticipationsInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<TrainingCreateWithoutParticipantsInput, TrainingUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutParticipantsInput
    upsert?: TrainingUpsertWithoutParticipantsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutParticipantsInput, TrainingUpdateWithoutParticipantsInput>, TrainingUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutTrainingParticipationsNestedInput = {
    create?: XOR<UserCreateWithoutTrainingParticipationsInput, UserUncheckedCreateWithoutTrainingParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingParticipationsInput
    upsert?: UserUpsertWithoutTrainingParticipationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrainingParticipationsInput, UserUpdateWithoutTrainingParticipationsInput>, UserUncheckedUpdateWithoutTrainingParticipationsInput>
  }

  export type TrainingCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<TrainingCreateWithoutAttendanceInput, TrainingUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutAttendanceInput
    connect?: TrainingWhereUniqueInput
  }

  export type TrainingSessionCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<TrainingSessionCreateWithoutAttendanceInput, TrainingSessionUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutAttendanceInput
    connect?: TrainingSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type TrainingUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<TrainingCreateWithoutAttendanceInput, TrainingUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutAttendanceInput
    upsert?: TrainingUpsertWithoutAttendanceInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutAttendanceInput, TrainingUpdateWithoutAttendanceInput>, TrainingUncheckedUpdateWithoutAttendanceInput>
  }

  export type TrainingSessionUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<TrainingSessionCreateWithoutAttendanceInput, TrainingSessionUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutAttendanceInput
    upsert?: TrainingSessionUpsertWithoutAttendanceInput
    connect?: TrainingSessionWhereUniqueInput
    update?: XOR<XOR<TrainingSessionUpdateToOneWithWhereWithoutAttendanceInput, TrainingSessionUpdateWithoutAttendanceInput>, TrainingSessionUncheckedUpdateWithoutAttendanceInput>
  }

  export type UserUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    upsert?: UserUpsertWithoutAttendancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendancesInput, UserUpdateWithoutAttendancesInput>, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type TrainingCreateNestedOneWithoutPhotosInput = {
    create?: XOR<TrainingCreateWithoutPhotosInput, TrainingUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutPhotosInput
    connect?: TrainingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedPhotosInput = {
    create?: XOR<UserCreateWithoutUploadedPhotosInput, UserUncheckedCreateWithoutUploadedPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedPhotosInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<TrainingCreateWithoutPhotosInput, TrainingUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutPhotosInput
    upsert?: TrainingUpsertWithoutPhotosInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutPhotosInput, TrainingUpdateWithoutPhotosInput>, TrainingUncheckedUpdateWithoutPhotosInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedPhotosNestedInput = {
    create?: XOR<UserCreateWithoutUploadedPhotosInput, UserUncheckedCreateWithoutUploadedPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedPhotosInput
    upsert?: UserUpsertWithoutUploadedPhotosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedPhotosInput, UserUpdateWithoutUploadedPhotosInput>, UserUncheckedUpdateWithoutUploadedPhotosInput>
  }

  export type TrainingCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<TrainingCreateWithoutFeedbackInput, TrainingUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutFeedbackInput
    connect?: TrainingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<TrainingCreateWithoutFeedbackInput, TrainingUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutFeedbackInput
    upsert?: TrainingUpsertWithoutFeedbackInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutFeedbackInput, TrainingUpdateWithoutFeedbackInput>, TrainingUncheckedUpdateWithoutFeedbackInput>
  }

  export type UserUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    upsert?: UserUpsertWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbacksInput, UserUpdateWithoutFeedbacksInput>, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type TrainingCreateNestedOneWithoutFollowupsInput = {
    create?: XOR<TrainingCreateWithoutFollowupsInput, TrainingUncheckedCreateWithoutFollowupsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutFollowupsInput
    connect?: TrainingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedFollowupsInput = {
    create?: XOR<UserCreateWithoutAssignedFollowupsInput, UserUncheckedCreateWithoutAssignedFollowupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedFollowupsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedFollowupsInput = {
    create?: XOR<UserCreateWithoutCreatedFollowupsInput, UserUncheckedCreateWithoutCreatedFollowupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFollowupsInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingUpdateOneRequiredWithoutFollowupsNestedInput = {
    create?: XOR<TrainingCreateWithoutFollowupsInput, TrainingUncheckedCreateWithoutFollowupsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutFollowupsInput
    upsert?: TrainingUpsertWithoutFollowupsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutFollowupsInput, TrainingUpdateWithoutFollowupsInput>, TrainingUncheckedUpdateWithoutFollowupsInput>
  }

  export type UserUpdateOneRequiredWithoutAssignedFollowupsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedFollowupsInput, UserUncheckedCreateWithoutAssignedFollowupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedFollowupsInput
    upsert?: UserUpsertWithoutAssignedFollowupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedFollowupsInput, UserUpdateWithoutAssignedFollowupsInput>, UserUncheckedUpdateWithoutAssignedFollowupsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedFollowupsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedFollowupsInput, UserUncheckedCreateWithoutCreatedFollowupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFollowupsInput
    upsert?: UserUpsertWithoutCreatedFollowupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedFollowupsInput, UserUpdateWithoutCreatedFollowupsInput>, UserUncheckedUpdateWithoutCreatedFollowupsInput>
  }

  export type TrainingCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<TrainingCreateWithoutNotificationsInput, TrainingUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutNotificationsInput
    connect?: TrainingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTrainingNotificationsInput = {
    create?: XOR<UserCreateWithoutTrainingNotificationsInput, UserUncheckedCreateWithoutTrainingNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<TrainingCreateWithoutNotificationsInput, TrainingUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutNotificationsInput
    upsert?: TrainingUpsertWithoutNotificationsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutNotificationsInput, TrainingUpdateWithoutNotificationsInput>, TrainingUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutTrainingNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutTrainingNotificationsInput, UserUncheckedCreateWithoutTrainingNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingNotificationsInput
    upsert?: UserUpsertWithoutTrainingNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrainingNotificationsInput, UserUpdateWithoutTrainingNotificationsInput>, UserUncheckedUpdateWithoutTrainingNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSampleAnalysisStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleAnalysisStatus | EnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleAnalysisStatusFilter<$PrismaModel> | $Enums.SampleAnalysisStatus
  }

  export type NestedEnumBatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusFilter<$PrismaModel> | $Enums.BatchStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSampleAnalysisStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleAnalysisStatus | EnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleAnalysisStatus[] | ListEnumSampleAnalysisStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleAnalysisStatusWithAggregatesFilter<$PrismaModel> | $Enums.SampleAnalysisStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSampleAnalysisStatusFilter<$PrismaModel>
    _max?: NestedEnumSampleAnalysisStatusFilter<$PrismaModel>
  }

  export type NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumStandardStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StandardStatus | EnumStandardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStandardStatusFilter<$PrismaModel> | $Enums.StandardStatus
  }

  export type NestedEnumStandardStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StandardStatus | EnumStandardStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StandardStatus[] | ListEnumStandardStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStandardStatusWithAggregatesFilter<$PrismaModel> | $Enums.StandardStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStandardStatusFilter<$PrismaModel>
    _max?: NestedEnumStandardStatusFilter<$PrismaModel>
  }

  export type NestedEnumParameterDataTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ParameterDataType | EnumParameterDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParameterDataTypeFilter<$PrismaModel> | $Enums.ParameterDataType
  }

  export type NestedEnumParameterDataTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParameterDataType | EnumParameterDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParameterDataType[] | ListEnumParameterDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParameterDataTypeWithAggregatesFilter<$PrismaModel> | $Enums.ParameterDataType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParameterDataTypeFilter<$PrismaModel>
    _max?: NestedEnumParameterDataTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTrainingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingTypeFilter<$PrismaModel> | $Enums.TrainingType
  }

  export type NestedEnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type NestedEnumTrainingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingType | EnumTrainingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingType[] | ListEnumTrainingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrainingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingTypeFilter<$PrismaModel>
    _max?: NestedEnumTrainingTypeFilter<$PrismaModel>
  }

  export type NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type BatchCreateWithoutActivityLogInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutActivityLogInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutActivityLogInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutActivityLogInput, BatchUncheckedCreateWithoutActivityLogInput>
  }

  export type UserCreateWithoutActivityLogInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityLogInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogInput, UserUncheckedCreateWithoutActivityLogInput>
  }

  export type BatchUpsertWithoutActivityLogInput = {
    update: XOR<BatchUpdateWithoutActivityLogInput, BatchUncheckedUpdateWithoutActivityLogInput>
    create: XOR<BatchCreateWithoutActivityLogInput, BatchUncheckedCreateWithoutActivityLogInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutActivityLogInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutActivityLogInput, BatchUncheckedUpdateWithoutActivityLogInput>
  }

  export type BatchUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type UserUpsertWithoutActivityLogInput = {
    update: XOR<UserUpdateWithoutActivityLogInput, UserUncheckedUpdateWithoutActivityLogInput>
    create: XOR<UserCreateWithoutActivityLogInput, UserUncheckedCreateWithoutActivityLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogInput, UserUncheckedUpdateWithoutActivityLogInput>
  }

  export type UserUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActivityLogCreateWithoutBatchInput = {
    id: string
    action: string
    details?: string | null
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutActivityLogInput
  }

  export type ActivityLogUncheckedCreateWithoutBatchInput = {
    id: string
    userId: string
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutBatchInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutBatchInput, ActivityLogUncheckedCreateWithoutBatchInput>
  }

  export type ActivityLogCreateManyBatchInputEnvelope = {
    data: ActivityLogCreateManyBatchInput | ActivityLogCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBatch_Batch_checkerIdToUserInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBatch_Batch_checkerIdToUserInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBatch_Batch_checkerIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBatch_Batch_checkerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_checkerIdToUserInput>
  }

  export type UserCreateWithoutBatch_Batch_makerIdToUserInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBatch_Batch_makerIdToUserInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBatch_Batch_makerIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBatch_Batch_makerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_makerIdToUserInput>
  }

  export type ProductCreateWithoutBatchInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ProductUncheckedCreateWithoutBatchInput = {
    id: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ProductCreateOrConnectWithoutBatchInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBatchInput, ProductUncheckedCreateWithoutBatchInput>
  }

  export type NotificationCreateWithoutBatchInput = {
    id: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutBatchInput = {
    id: string
    userId: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutBatchInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutBatchInput, NotificationUncheckedCreateWithoutBatchInput>
  }

  export type NotificationCreateManyBatchInputEnvelope = {
    data: NotificationCreateManyBatchInput | NotificationCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type StandardCreateWithoutBatchesInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    Category: StandardCategoryCreateNestedOneWithoutStandardsInput
    CreatedBy: UserCreateNestedOneWithoutStandardsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardsModifiedInput
    methodologies?: MethodologyCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateWithoutBatchesInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardCreateOrConnectWithoutBatchesInput = {
    where: StandardWhereUniqueInput
    create: XOR<StandardCreateWithoutBatchesInput, StandardUncheckedCreateWithoutBatchesInput>
  }

  export type MethodologyCreateWithoutBatchesInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutMethodologyInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyUncheckedCreateWithoutBatchesInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutMethodologyInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyCreateOrConnectWithoutBatchesInput = {
    where: MethodologyWhereUniqueInput
    create: XOR<MethodologyCreateWithoutBatchesInput, MethodologyUncheckedCreateWithoutBatchesInput>
  }

  export type UnitOfMeasurementCreateWithoutBatchesInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutUnitInput
  }

  export type UnitOfMeasurementUncheckedCreateWithoutBatchesInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitOfMeasurementCreateOrConnectWithoutBatchesInput = {
    where: UnitOfMeasurementWhereUniqueInput
    create: XOR<UnitOfMeasurementCreateWithoutBatchesInput, UnitOfMeasurementUncheckedCreateWithoutBatchesInput>
  }

  export type BatchParameterValueCreateWithoutBatchInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt: Date | string
    parameter: StandardParameterCreateNestedOneWithoutBatchValuesInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutBatchParameterValuesInput
    methodology?: MethodologyCreateNestedOneWithoutBatchParameterValuesInput
  }

  export type BatchParameterValueUncheckedCreateWithoutBatchInput = {
    id: string
    parameterId: string
    value: string
    unitId?: string | null
    methodologyId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchParameterValueCreateOrConnectWithoutBatchInput = {
    where: BatchParameterValueWhereUniqueInput
    create: XOR<BatchParameterValueCreateWithoutBatchInput, BatchParameterValueUncheckedCreateWithoutBatchInput>
  }

  export type BatchParameterValueCreateManyBatchInputEnvelope = {
    data: BatchParameterValueCreateManyBatchInput | BatchParameterValueCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutBatchInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutBatchInput, ActivityLogUncheckedUpdateWithoutBatchInput>
    create: XOR<ActivityLogCreateWithoutBatchInput, ActivityLogUncheckedCreateWithoutBatchInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutBatchInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutBatchInput, ActivityLogUncheckedUpdateWithoutBatchInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutBatchInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutBatchInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringFilter<"ActivityLog"> | string
    batchId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: StringFilter<"ActivityLog"> | string
    details?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type UserUpsertWithoutBatch_Batch_checkerIdToUserInput = {
    update: XOR<UserUpdateWithoutBatch_Batch_checkerIdToUserInput, UserUncheckedUpdateWithoutBatch_Batch_checkerIdToUserInput>
    create: XOR<UserCreateWithoutBatch_Batch_checkerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_checkerIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBatch_Batch_checkerIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBatch_Batch_checkerIdToUserInput, UserUncheckedUpdateWithoutBatch_Batch_checkerIdToUserInput>
  }

  export type UserUpdateWithoutBatch_Batch_checkerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBatch_Batch_checkerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutBatch_Batch_makerIdToUserInput = {
    update: XOR<UserUpdateWithoutBatch_Batch_makerIdToUserInput, UserUncheckedUpdateWithoutBatch_Batch_makerIdToUserInput>
    create: XOR<UserCreateWithoutBatch_Batch_makerIdToUserInput, UserUncheckedCreateWithoutBatch_Batch_makerIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBatch_Batch_makerIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBatch_Batch_makerIdToUserInput, UserUncheckedUpdateWithoutBatch_Batch_makerIdToUserInput>
  }

  export type UserUpdateWithoutBatch_Batch_makerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBatch_Batch_makerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutBatchInput = {
    update: XOR<ProductUpdateWithoutBatchInput, ProductUncheckedUpdateWithoutBatchInput>
    create: XOR<ProductCreateWithoutBatchInput, ProductUncheckedCreateWithoutBatchInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutBatchInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutBatchInput, ProductUncheckedUpdateWithoutBatchInput>
  }

  export type ProductUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutBatchInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutBatchInput, NotificationUncheckedUpdateWithoutBatchInput>
    create: XOR<NotificationCreateWithoutBatchInput, NotificationUncheckedCreateWithoutBatchInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutBatchInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutBatchInput, NotificationUncheckedUpdateWithoutBatchInput>
  }

  export type NotificationUpdateManyWithWhereWithoutBatchInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutBatchInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    batchId?: StringNullableFilter<"Notification"> | string | null
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type StandardUpsertWithWhereUniqueWithoutBatchesInput = {
    where: StandardWhereUniqueInput
    update: XOR<StandardUpdateWithoutBatchesInput, StandardUncheckedUpdateWithoutBatchesInput>
    create: XOR<StandardCreateWithoutBatchesInput, StandardUncheckedCreateWithoutBatchesInput>
  }

  export type StandardUpdateWithWhereUniqueWithoutBatchesInput = {
    where: StandardWhereUniqueInput
    data: XOR<StandardUpdateWithoutBatchesInput, StandardUncheckedUpdateWithoutBatchesInput>
  }

  export type StandardUpdateManyWithWhereWithoutBatchesInput = {
    where: StandardScalarWhereInput
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyWithoutBatchesInput>
  }

  export type StandardScalarWhereInput = {
    AND?: StandardScalarWhereInput | StandardScalarWhereInput[]
    OR?: StandardScalarWhereInput[]
    NOT?: StandardScalarWhereInput | StandardScalarWhereInput[]
    id?: StringFilter<"Standard"> | string
    name?: StringFilter<"Standard"> | string
    code?: StringFilter<"Standard"> | string
    description?: StringFilter<"Standard"> | string
    categoryId?: StringFilter<"Standard"> | string
    createdById?: StringFilter<"Standard"> | string
    modifiedById?: StringNullableFilter<"Standard"> | string | null
    status?: EnumStandardStatusFilter<"Standard"> | $Enums.StandardStatus
    createdAt?: DateTimeFilter<"Standard"> | Date | string
    updatedAt?: DateTimeFilter<"Standard"> | Date | string
  }

  export type MethodologyUpsertWithWhereUniqueWithoutBatchesInput = {
    where: MethodologyWhereUniqueInput
    update: XOR<MethodologyUpdateWithoutBatchesInput, MethodologyUncheckedUpdateWithoutBatchesInput>
    create: XOR<MethodologyCreateWithoutBatchesInput, MethodologyUncheckedCreateWithoutBatchesInput>
  }

  export type MethodologyUpdateWithWhereUniqueWithoutBatchesInput = {
    where: MethodologyWhereUniqueInput
    data: XOR<MethodologyUpdateWithoutBatchesInput, MethodologyUncheckedUpdateWithoutBatchesInput>
  }

  export type MethodologyUpdateManyWithWhereWithoutBatchesInput = {
    where: MethodologyScalarWhereInput
    data: XOR<MethodologyUpdateManyMutationInput, MethodologyUncheckedUpdateManyWithoutBatchesInput>
  }

  export type MethodologyScalarWhereInput = {
    AND?: MethodologyScalarWhereInput | MethodologyScalarWhereInput[]
    OR?: MethodologyScalarWhereInput[]
    NOT?: MethodologyScalarWhereInput | MethodologyScalarWhereInput[]
    id?: StringFilter<"Methodology"> | string
    name?: StringFilter<"Methodology"> | string
    description?: StringFilter<"Methodology"> | string
    procedure?: StringFilter<"Methodology"> | string
    createdAt?: DateTimeFilter<"Methodology"> | Date | string
    updatedAt?: DateTimeFilter<"Methodology"> | Date | string
  }

  export type UnitOfMeasurementUpsertWithWhereUniqueWithoutBatchesInput = {
    where: UnitOfMeasurementWhereUniqueInput
    update: XOR<UnitOfMeasurementUpdateWithoutBatchesInput, UnitOfMeasurementUncheckedUpdateWithoutBatchesInput>
    create: XOR<UnitOfMeasurementCreateWithoutBatchesInput, UnitOfMeasurementUncheckedCreateWithoutBatchesInput>
  }

  export type UnitOfMeasurementUpdateWithWhereUniqueWithoutBatchesInput = {
    where: UnitOfMeasurementWhereUniqueInput
    data: XOR<UnitOfMeasurementUpdateWithoutBatchesInput, UnitOfMeasurementUncheckedUpdateWithoutBatchesInput>
  }

  export type UnitOfMeasurementUpdateManyWithWhereWithoutBatchesInput = {
    where: UnitOfMeasurementScalarWhereInput
    data: XOR<UnitOfMeasurementUpdateManyMutationInput, UnitOfMeasurementUncheckedUpdateManyWithoutBatchesInput>
  }

  export type UnitOfMeasurementScalarWhereInput = {
    AND?: UnitOfMeasurementScalarWhereInput | UnitOfMeasurementScalarWhereInput[]
    OR?: UnitOfMeasurementScalarWhereInput[]
    NOT?: UnitOfMeasurementScalarWhereInput | UnitOfMeasurementScalarWhereInput[]
    id?: StringFilter<"UnitOfMeasurement"> | string
    name?: StringFilter<"UnitOfMeasurement"> | string
    symbol?: StringFilter<"UnitOfMeasurement"> | string
    description?: StringNullableFilter<"UnitOfMeasurement"> | string | null
    createdAt?: DateTimeFilter<"UnitOfMeasurement"> | Date | string
    updatedAt?: DateTimeFilter<"UnitOfMeasurement"> | Date | string
  }

  export type BatchParameterValueUpsertWithWhereUniqueWithoutBatchInput = {
    where: BatchParameterValueWhereUniqueInput
    update: XOR<BatchParameterValueUpdateWithoutBatchInput, BatchParameterValueUncheckedUpdateWithoutBatchInput>
    create: XOR<BatchParameterValueCreateWithoutBatchInput, BatchParameterValueUncheckedCreateWithoutBatchInput>
  }

  export type BatchParameterValueUpdateWithWhereUniqueWithoutBatchInput = {
    where: BatchParameterValueWhereUniqueInput
    data: XOR<BatchParameterValueUpdateWithoutBatchInput, BatchParameterValueUncheckedUpdateWithoutBatchInput>
  }

  export type BatchParameterValueUpdateManyWithWhereWithoutBatchInput = {
    where: BatchParameterValueScalarWhereInput
    data: XOR<BatchParameterValueUpdateManyMutationInput, BatchParameterValueUncheckedUpdateManyWithoutBatchInput>
  }

  export type BatchParameterValueScalarWhereInput = {
    AND?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
    OR?: BatchParameterValueScalarWhereInput[]
    NOT?: BatchParameterValueScalarWhereInput | BatchParameterValueScalarWhereInput[]
    id?: StringFilter<"BatchParameterValue"> | string
    batchId?: StringFilter<"BatchParameterValue"> | string
    parameterId?: StringFilter<"BatchParameterValue"> | string
    value?: StringFilter<"BatchParameterValue"> | string
    unitId?: StringNullableFilter<"BatchParameterValue"> | string | null
    methodologyId?: StringNullableFilter<"BatchParameterValue"> | string | null
    createdAt?: DateTimeFilter<"BatchParameterValue"> | Date | string
    updatedAt?: DateTimeFilter<"BatchParameterValue"> | Date | string
  }

  export type StandardCreateWithoutMethodologiesInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    Category: StandardCategoryCreateNestedOneWithoutStandardsInput
    CreatedBy: UserCreateNestedOneWithoutStandardsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardsModifiedInput
    batches?: BatchCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateWithoutMethodologiesInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardCreateOrConnectWithoutMethodologiesInput = {
    where: StandardWhereUniqueInput
    create: XOR<StandardCreateWithoutMethodologiesInput, StandardUncheckedCreateWithoutMethodologiesInput>
  }

  export type BatchCreateWithoutMethodologiesInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutMethodologiesInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutMethodologiesInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutMethodologiesInput, BatchUncheckedCreateWithoutMethodologiesInput>
  }

  export type BatchParameterValueCreateWithoutMethodologyInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt: Date | string
    batch: BatchCreateNestedOneWithoutParameterValuesInput
    parameter: StandardParameterCreateNestedOneWithoutBatchValuesInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutBatchParameterValuesInput
  }

  export type BatchParameterValueUncheckedCreateWithoutMethodologyInput = {
    id: string
    batchId: string
    parameterId: string
    value: string
    unitId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchParameterValueCreateOrConnectWithoutMethodologyInput = {
    where: BatchParameterValueWhereUniqueInput
    create: XOR<BatchParameterValueCreateWithoutMethodologyInput, BatchParameterValueUncheckedCreateWithoutMethodologyInput>
  }

  export type BatchParameterValueCreateManyMethodologyInputEnvelope = {
    data: BatchParameterValueCreateManyMethodologyInput | BatchParameterValueCreateManyMethodologyInput[]
    skipDuplicates?: boolean
  }

  export type StandardDefinitionCreateWithoutMethodologyInput = {
    id: string
    standardValue: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    parameter: StandardParameterCreateNestedOneWithoutStandardsInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardDefinitionsInput
    CreatedBy: UserCreateNestedOneWithoutStandardDefinitionsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardDefinitionsModifiedInput
  }

  export type StandardDefinitionUncheckedCreateWithoutMethodologyInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateOrConnectWithoutMethodologyInput = {
    where: StandardDefinitionWhereUniqueInput
    create: XOR<StandardDefinitionCreateWithoutMethodologyInput, StandardDefinitionUncheckedCreateWithoutMethodologyInput>
  }

  export type StandardDefinitionCreateManyMethodologyInputEnvelope = {
    data: StandardDefinitionCreateManyMethodologyInput | StandardDefinitionCreateManyMethodologyInput[]
    skipDuplicates?: boolean
  }

  export type StandardUpsertWithWhereUniqueWithoutMethodologiesInput = {
    where: StandardWhereUniqueInput
    update: XOR<StandardUpdateWithoutMethodologiesInput, StandardUncheckedUpdateWithoutMethodologiesInput>
    create: XOR<StandardCreateWithoutMethodologiesInput, StandardUncheckedCreateWithoutMethodologiesInput>
  }

  export type StandardUpdateWithWhereUniqueWithoutMethodologiesInput = {
    where: StandardWhereUniqueInput
    data: XOR<StandardUpdateWithoutMethodologiesInput, StandardUncheckedUpdateWithoutMethodologiesInput>
  }

  export type StandardUpdateManyWithWhereWithoutMethodologiesInput = {
    where: StandardScalarWhereInput
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyWithoutMethodologiesInput>
  }

  export type BatchUpsertWithWhereUniqueWithoutMethodologiesInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutMethodologiesInput, BatchUncheckedUpdateWithoutMethodologiesInput>
    create: XOR<BatchCreateWithoutMethodologiesInput, BatchUncheckedCreateWithoutMethodologiesInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutMethodologiesInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutMethodologiesInput, BatchUncheckedUpdateWithoutMethodologiesInput>
  }

  export type BatchUpdateManyWithWhereWithoutMethodologiesInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutMethodologiesInput>
  }

  export type BatchScalarWhereInput = {
    AND?: BatchScalarWhereInput | BatchScalarWhereInput[]
    OR?: BatchScalarWhereInput[]
    NOT?: BatchScalarWhereInput | BatchScalarWhereInput[]
    id?: StringFilter<"Batch"> | string
    batchNumber?: StringFilter<"Batch"> | string
    productId?: StringFilter<"Batch"> | string
    dateOfProduction?: DateTimeFilter<"Batch"> | Date | string
    bestBeforeDate?: DateTimeFilter<"Batch"> | Date | string
    sampleAnalysisStarted?: DateTimeNullableFilter<"Batch"> | Date | string | null
    sampleAnalysisCompleted?: DateTimeNullableFilter<"Batch"> | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFilter<"Batch"> | $Enums.SampleAnalysisStatus
    makerId?: StringFilter<"Batch"> | string
    checkerId?: StringNullableFilter<"Batch"> | string | null
    status?: EnumBatchStatusFilter<"Batch"> | $Enums.BatchStatus
    rejectionRemarks?: StringNullableFilter<"Batch"> | string | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
  }

  export type BatchParameterValueUpsertWithWhereUniqueWithoutMethodologyInput = {
    where: BatchParameterValueWhereUniqueInput
    update: XOR<BatchParameterValueUpdateWithoutMethodologyInput, BatchParameterValueUncheckedUpdateWithoutMethodologyInput>
    create: XOR<BatchParameterValueCreateWithoutMethodologyInput, BatchParameterValueUncheckedCreateWithoutMethodologyInput>
  }

  export type BatchParameterValueUpdateWithWhereUniqueWithoutMethodologyInput = {
    where: BatchParameterValueWhereUniqueInput
    data: XOR<BatchParameterValueUpdateWithoutMethodologyInput, BatchParameterValueUncheckedUpdateWithoutMethodologyInput>
  }

  export type BatchParameterValueUpdateManyWithWhereWithoutMethodologyInput = {
    where: BatchParameterValueScalarWhereInput
    data: XOR<BatchParameterValueUpdateManyMutationInput, BatchParameterValueUncheckedUpdateManyWithoutMethodologyInput>
  }

  export type StandardDefinitionUpsertWithWhereUniqueWithoutMethodologyInput = {
    where: StandardDefinitionWhereUniqueInput
    update: XOR<StandardDefinitionUpdateWithoutMethodologyInput, StandardDefinitionUncheckedUpdateWithoutMethodologyInput>
    create: XOR<StandardDefinitionCreateWithoutMethodologyInput, StandardDefinitionUncheckedCreateWithoutMethodologyInput>
  }

  export type StandardDefinitionUpdateWithWhereUniqueWithoutMethodologyInput = {
    where: StandardDefinitionWhereUniqueInput
    data: XOR<StandardDefinitionUpdateWithoutMethodologyInput, StandardDefinitionUncheckedUpdateWithoutMethodologyInput>
  }

  export type StandardDefinitionUpdateManyWithWhereWithoutMethodologyInput = {
    where: StandardDefinitionScalarWhereInput
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyWithoutMethodologyInput>
  }

  export type StandardDefinitionScalarWhereInput = {
    AND?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
    OR?: StandardDefinitionScalarWhereInput[]
    NOT?: StandardDefinitionScalarWhereInput | StandardDefinitionScalarWhereInput[]
    id?: StringFilter<"StandardDefinition"> | string
    parameterId?: StringFilter<"StandardDefinition"> | string
    standardValue?: StringFilter<"StandardDefinition"> | string
    unitId?: StringNullableFilter<"StandardDefinition"> | string | null
    methodologyId?: StringNullableFilter<"StandardDefinition"> | string | null
    createdById?: StringFilter<"StandardDefinition"> | string
    modifiedById?: StringNullableFilter<"StandardDefinition"> | string | null
    status?: EnumStandardStatusFilter<"StandardDefinition"> | $Enums.StandardStatus
    createdAt?: DateTimeFilter<"StandardDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"StandardDefinition"> | Date | string
  }

  export type BatchCreateWithoutNotificationInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutNotificationInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutNotificationInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutNotificationInput, BatchUncheckedCreateWithoutNotificationInput>
  }

  export type UserCreateWithoutNotificationInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type BatchUpsertWithoutNotificationInput = {
    update: XOR<BatchUpdateWithoutNotificationInput, BatchUncheckedUpdateWithoutNotificationInput>
    create: XOR<BatchCreateWithoutNotificationInput, BatchUncheckedCreateWithoutNotificationInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutNotificationInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutNotificationInput, BatchUncheckedUpdateWithoutNotificationInput>
  }

  export type BatchUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleCreateWithoutPermissionInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionInput, RoleUncheckedCreateWithoutPermissionInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutPermissionInput, RoleUncheckedUpdateWithoutPermissionInput>
    create: XOR<RoleCreateWithoutPermissionInput, RoleUncheckedCreateWithoutPermissionInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutPermissionInput, RoleUncheckedUpdateWithoutPermissionInput>
  }

  export type RoleUpdateManyWithWhereWithoutPermissionInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
  }

  export type BatchCreateWithoutProductInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutProductInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutProductInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutProductInput, BatchUncheckedCreateWithoutProductInput>
  }

  export type BatchCreateManyProductInputEnvelope = {
    data: BatchCreateManyProductInput | BatchCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type BatchUpsertWithWhereUniqueWithoutProductInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutProductInput, BatchUncheckedUpdateWithoutProductInput>
    create: XOR<BatchCreateWithoutProductInput, BatchUncheckedCreateWithoutProductInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutProductInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutProductInput, BatchUncheckedUpdateWithoutProductInput>
  }

  export type BatchUpdateManyWithWhereWithoutProductInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutProductInput>
  }

  export type UserCreateWithoutRoleInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type PermissionCreateWithoutRoleInput = {
    id: string
    action: string
    resource: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type PermissionUncheckedCreateWithoutRoleInput = {
    id: string
    action: string
    resource: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type PermissionCreateOrConnectWithoutRoleInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput>
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type PermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutRoleInput, PermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutRoleInput, PermissionUncheckedUpdateWithoutRoleInput>
  }

  export type PermissionUpdateManyWithWhereWithoutRoleInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    OR?: PermissionScalarWhereInput[]
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    id?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
  }

  export type StandardCreateWithoutUnitsInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    Category: StandardCategoryCreateNestedOneWithoutStandardsInput
    CreatedBy: UserCreateNestedOneWithoutStandardsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardsModifiedInput
    batches?: BatchCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateWithoutUnitsInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardCreateOrConnectWithoutUnitsInput = {
    where: StandardWhereUniqueInput
    create: XOR<StandardCreateWithoutUnitsInput, StandardUncheckedCreateWithoutUnitsInput>
  }

  export type BatchParameterValueCreateWithoutUnitInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt: Date | string
    batch: BatchCreateNestedOneWithoutParameterValuesInput
    parameter: StandardParameterCreateNestedOneWithoutBatchValuesInput
    methodology?: MethodologyCreateNestedOneWithoutBatchParameterValuesInput
  }

  export type BatchParameterValueUncheckedCreateWithoutUnitInput = {
    id: string
    batchId: string
    parameterId: string
    value: string
    methodologyId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchParameterValueCreateOrConnectWithoutUnitInput = {
    where: BatchParameterValueWhereUniqueInput
    create: XOR<BatchParameterValueCreateWithoutUnitInput, BatchParameterValueUncheckedCreateWithoutUnitInput>
  }

  export type BatchParameterValueCreateManyUnitInputEnvelope = {
    data: BatchParameterValueCreateManyUnitInput | BatchParameterValueCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type StandardDefinitionCreateWithoutUnitInput = {
    id: string
    standardValue: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    parameter: StandardParameterCreateNestedOneWithoutStandardsInput
    methodology?: MethodologyCreateNestedOneWithoutStandardDefinitionsInput
    CreatedBy: UserCreateNestedOneWithoutStandardDefinitionsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardDefinitionsModifiedInput
  }

  export type StandardDefinitionUncheckedCreateWithoutUnitInput = {
    id: string
    parameterId: string
    standardValue: string
    methodologyId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateOrConnectWithoutUnitInput = {
    where: StandardDefinitionWhereUniqueInput
    create: XOR<StandardDefinitionCreateWithoutUnitInput, StandardDefinitionUncheckedCreateWithoutUnitInput>
  }

  export type StandardDefinitionCreateManyUnitInputEnvelope = {
    data: StandardDefinitionCreateManyUnitInput | StandardDefinitionCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type BatchCreateWithoutUnitOfMeasurementsInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutUnitOfMeasurementsInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutUnitOfMeasurementsInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutUnitOfMeasurementsInput, BatchUncheckedCreateWithoutUnitOfMeasurementsInput>
  }

  export type StandardUpsertWithWhereUniqueWithoutUnitsInput = {
    where: StandardWhereUniqueInput
    update: XOR<StandardUpdateWithoutUnitsInput, StandardUncheckedUpdateWithoutUnitsInput>
    create: XOR<StandardCreateWithoutUnitsInput, StandardUncheckedCreateWithoutUnitsInput>
  }

  export type StandardUpdateWithWhereUniqueWithoutUnitsInput = {
    where: StandardWhereUniqueInput
    data: XOR<StandardUpdateWithoutUnitsInput, StandardUncheckedUpdateWithoutUnitsInput>
  }

  export type StandardUpdateManyWithWhereWithoutUnitsInput = {
    where: StandardScalarWhereInput
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyWithoutUnitsInput>
  }

  export type BatchParameterValueUpsertWithWhereUniqueWithoutUnitInput = {
    where: BatchParameterValueWhereUniqueInput
    update: XOR<BatchParameterValueUpdateWithoutUnitInput, BatchParameterValueUncheckedUpdateWithoutUnitInput>
    create: XOR<BatchParameterValueCreateWithoutUnitInput, BatchParameterValueUncheckedCreateWithoutUnitInput>
  }

  export type BatchParameterValueUpdateWithWhereUniqueWithoutUnitInput = {
    where: BatchParameterValueWhereUniqueInput
    data: XOR<BatchParameterValueUpdateWithoutUnitInput, BatchParameterValueUncheckedUpdateWithoutUnitInput>
  }

  export type BatchParameterValueUpdateManyWithWhereWithoutUnitInput = {
    where: BatchParameterValueScalarWhereInput
    data: XOR<BatchParameterValueUpdateManyMutationInput, BatchParameterValueUncheckedUpdateManyWithoutUnitInput>
  }

  export type StandardDefinitionUpsertWithWhereUniqueWithoutUnitInput = {
    where: StandardDefinitionWhereUniqueInput
    update: XOR<StandardDefinitionUpdateWithoutUnitInput, StandardDefinitionUncheckedUpdateWithoutUnitInput>
    create: XOR<StandardDefinitionCreateWithoutUnitInput, StandardDefinitionUncheckedCreateWithoutUnitInput>
  }

  export type StandardDefinitionUpdateWithWhereUniqueWithoutUnitInput = {
    where: StandardDefinitionWhereUniqueInput
    data: XOR<StandardDefinitionUpdateWithoutUnitInput, StandardDefinitionUncheckedUpdateWithoutUnitInput>
  }

  export type StandardDefinitionUpdateManyWithWhereWithoutUnitInput = {
    where: StandardDefinitionScalarWhereInput
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyWithoutUnitInput>
  }

  export type BatchUpsertWithWhereUniqueWithoutUnitOfMeasurementsInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutUnitOfMeasurementsInput, BatchUncheckedUpdateWithoutUnitOfMeasurementsInput>
    create: XOR<BatchCreateWithoutUnitOfMeasurementsInput, BatchUncheckedCreateWithoutUnitOfMeasurementsInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutUnitOfMeasurementsInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutUnitOfMeasurementsInput, BatchUncheckedUpdateWithoutUnitOfMeasurementsInput>
  }

  export type BatchUpdateManyWithWhereWithoutUnitOfMeasurementsInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutUnitOfMeasurementsInput>
  }

  export type ActivityLogCreateWithoutUserInput = {
    id: string
    action: string
    details?: string | null
    createdAt?: Date | string
    Batch?: BatchCreateNestedOneWithoutActivityLogInput
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id: string
    batchId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BatchCreateWithoutUser_Batch_checkerIdToUserInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutUser_Batch_checkerIdToUserInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput>
  }

  export type BatchCreateManyUser_Batch_checkerIdToUserInputEnvelope = {
    data: BatchCreateManyUser_Batch_checkerIdToUserInput | BatchCreateManyUser_Batch_checkerIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type BatchCreateWithoutUser_Batch_makerIdToUserInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutUser_Batch_makerIdToUserInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput>
  }

  export type BatchCreateManyUser_Batch_makerIdToUserInputEnvelope = {
    data: BatchCreateManyUser_Batch_makerIdToUserInput | BatchCreateManyUser_Batch_makerIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    Batch?: BatchCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id: string
    batchId?: string | null
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutUserInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Permission?: PermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUserInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Permission?: PermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUserInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
  }

  export type StandardCreateWithoutCreatedByInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    Category: StandardCategoryCreateNestedOneWithoutStandardsInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardsModifiedInput
    batches?: BatchCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateWithoutCreatedByInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardCreateOrConnectWithoutCreatedByInput = {
    where: StandardWhereUniqueInput
    create: XOR<StandardCreateWithoutCreatedByInput, StandardUncheckedCreateWithoutCreatedByInput>
  }

  export type StandardCreateManyCreatedByInputEnvelope = {
    data: StandardCreateManyCreatedByInput | StandardCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type StandardCreateWithoutModifiedByInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    Category: StandardCategoryCreateNestedOneWithoutStandardsInput
    CreatedBy: UserCreateNestedOneWithoutStandardsCreatedInput
    batches?: BatchCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateWithoutModifiedByInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardCreateOrConnectWithoutModifiedByInput = {
    where: StandardWhereUniqueInput
    create: XOR<StandardCreateWithoutModifiedByInput, StandardUncheckedCreateWithoutModifiedByInput>
  }

  export type StandardCreateManyModifiedByInputEnvelope = {
    data: StandardCreateManyModifiedByInput | StandardCreateManyModifiedByInput[]
    skipDuplicates?: boolean
  }

  export type StandardDefinitionCreateWithoutCreatedByInput = {
    id: string
    standardValue: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    parameter: StandardParameterCreateNestedOneWithoutStandardsInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardDefinitionsInput
    methodology?: MethodologyCreateNestedOneWithoutStandardDefinitionsInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardDefinitionsModifiedInput
  }

  export type StandardDefinitionUncheckedCreateWithoutCreatedByInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateOrConnectWithoutCreatedByInput = {
    where: StandardDefinitionWhereUniqueInput
    create: XOR<StandardDefinitionCreateWithoutCreatedByInput, StandardDefinitionUncheckedCreateWithoutCreatedByInput>
  }

  export type StandardDefinitionCreateManyCreatedByInputEnvelope = {
    data: StandardDefinitionCreateManyCreatedByInput | StandardDefinitionCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type StandardDefinitionCreateWithoutModifiedByInput = {
    id: string
    standardValue: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    parameter: StandardParameterCreateNestedOneWithoutStandardsInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardDefinitionsInput
    methodology?: MethodologyCreateNestedOneWithoutStandardDefinitionsInput
    CreatedBy: UserCreateNestedOneWithoutStandardDefinitionsCreatedInput
  }

  export type StandardDefinitionUncheckedCreateWithoutModifiedByInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    createdById: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateOrConnectWithoutModifiedByInput = {
    where: StandardDefinitionWhereUniqueInput
    create: XOR<StandardDefinitionCreateWithoutModifiedByInput, StandardDefinitionUncheckedCreateWithoutModifiedByInput>
  }

  export type StandardDefinitionCreateManyModifiedByInputEnvelope = {
    data: StandardDefinitionCreateManyModifiedByInput | StandardDefinitionCreateManyModifiedByInput[]
    skipDuplicates?: boolean
  }

  export type TrainingCreateWithoutTrainerInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutTrainerInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutTrainerInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutTrainerInput, TrainingUncheckedCreateWithoutTrainerInput>
  }

  export type TrainingCreateManyTrainerInputEnvelope = {
    data: TrainingCreateManyTrainerInput | TrainingCreateManyTrainerInput[]
    skipDuplicates?: boolean
  }

  export type TrainingCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutCreatedByInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutCreatedByInput, TrainingUncheckedCreateWithoutCreatedByInput>
  }

  export type TrainingCreateManyCreatedByInputEnvelope = {
    data: TrainingCreateManyCreatedByInput | TrainingCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TrainingParticipantCreateWithoutUserInput = {
    id?: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutParticipantsInput
  }

  export type TrainingParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    trainingId: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingParticipantCreateOrConnectWithoutUserInput = {
    where: TrainingParticipantWhereUniqueInput
    create: XOR<TrainingParticipantCreateWithoutUserInput, TrainingParticipantUncheckedCreateWithoutUserInput>
  }

  export type TrainingParticipantCreateManyUserInputEnvelope = {
    data: TrainingParticipantCreateManyUserInput | TrainingParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutUserInput = {
    id?: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutAttendanceInput
    session: TrainingSessionCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutUserInput = {
    id?: string
    trainingId: string
    sessionId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceCreateManyUserInputEnvelope = {
    data: AttendanceCreateManyUserInput | AttendanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TrainingDocumentCreateWithoutUploadedByInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    documentType: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutDocumentsInput
  }

  export type TrainingDocumentUncheckedCreateWithoutUploadedByInput = {
    id?: string
    trainingId: string
    title: string
    description?: string | null
    fileUrl: string
    documentType: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDocumentCreateOrConnectWithoutUploadedByInput = {
    where: TrainingDocumentWhereUniqueInput
    create: XOR<TrainingDocumentCreateWithoutUploadedByInput, TrainingDocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type TrainingDocumentCreateManyUploadedByInputEnvelope = {
    data: TrainingDocumentCreateManyUploadedByInput | TrainingDocumentCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type TrainingPhotoCreateWithoutUploadedByInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
    training: TrainingCreateNestedOneWithoutPhotosInput
  }

  export type TrainingPhotoUncheckedCreateWithoutUploadedByInput = {
    id?: string
    trainingId: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
  }

  export type TrainingPhotoCreateOrConnectWithoutUploadedByInput = {
    where: TrainingPhotoWhereUniqueInput
    create: XOR<TrainingPhotoCreateWithoutUploadedByInput, TrainingPhotoUncheckedCreateWithoutUploadedByInput>
  }

  export type TrainingPhotoCreateManyUploadedByInputEnvelope = {
    data: TrainingPhotoCreateManyUploadedByInput | TrainingPhotoCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type TrainingFeedbackCreateWithoutUserInput = {
    id?: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutFeedbackInput
  }

  export type TrainingFeedbackUncheckedCreateWithoutUserInput = {
    id?: string
    trainingId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingFeedbackCreateOrConnectWithoutUserInput = {
    where: TrainingFeedbackWhereUniqueInput
    create: XOR<TrainingFeedbackCreateWithoutUserInput, TrainingFeedbackUncheckedCreateWithoutUserInput>
  }

  export type TrainingFeedbackCreateManyUserInputEnvelope = {
    data: TrainingFeedbackCreateManyUserInput | TrainingFeedbackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TrainingFollowupCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    training: TrainingCreateNestedOneWithoutFollowupsInput
    createdBy: UserCreateNestedOneWithoutCreatedFollowupsInput
  }

  export type TrainingFollowupUncheckedCreateWithoutAssignedToInput = {
    id?: string
    trainingId: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingFollowupCreateOrConnectWithoutAssignedToInput = {
    where: TrainingFollowupWhereUniqueInput
    create: XOR<TrainingFollowupCreateWithoutAssignedToInput, TrainingFollowupUncheckedCreateWithoutAssignedToInput>
  }

  export type TrainingFollowupCreateManyAssignedToInputEnvelope = {
    data: TrainingFollowupCreateManyAssignedToInput | TrainingFollowupCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type TrainingFollowupCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    training: TrainingCreateNestedOneWithoutFollowupsInput
    assignedTo: UserCreateNestedOneWithoutAssignedFollowupsInput
  }

  export type TrainingFollowupUncheckedCreateWithoutCreatedByInput = {
    id?: string
    trainingId: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    assignedToId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingFollowupCreateOrConnectWithoutCreatedByInput = {
    where: TrainingFollowupWhereUniqueInput
    create: XOR<TrainingFollowupCreateWithoutCreatedByInput, TrainingFollowupUncheckedCreateWithoutCreatedByInput>
  }

  export type TrainingFollowupCreateManyCreatedByInputEnvelope = {
    data: TrainingFollowupCreateManyCreatedByInput | TrainingFollowupCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TrainingNotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    training: TrainingCreateNestedOneWithoutNotificationsInput
  }

  export type TrainingNotificationUncheckedCreateWithoutUserInput = {
    id?: string
    trainingId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type TrainingNotificationCreateOrConnectWithoutUserInput = {
    where: TrainingNotificationWhereUniqueInput
    create: XOR<TrainingNotificationCreateWithoutUserInput, TrainingNotificationUncheckedCreateWithoutUserInput>
  }

  export type TrainingNotificationCreateManyUserInputEnvelope = {
    data: TrainingNotificationCreateManyUserInput | TrainingNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type BatchUpsertWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedUpdateWithoutUser_Batch_checkerIdToUserInput>
    create: XOR<BatchCreateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_checkerIdToUserInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutUser_Batch_checkerIdToUserInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutUser_Batch_checkerIdToUserInput, BatchUncheckedUpdateWithoutUser_Batch_checkerIdToUserInput>
  }

  export type BatchUpdateManyWithWhereWithoutUser_Batch_checkerIdToUserInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserInput>
  }

  export type BatchUpsertWithWhereUniqueWithoutUser_Batch_makerIdToUserInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedUpdateWithoutUser_Batch_makerIdToUserInput>
    create: XOR<BatchCreateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedCreateWithoutUser_Batch_makerIdToUserInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutUser_Batch_makerIdToUserInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutUser_Batch_makerIdToUserInput, BatchUncheckedUpdateWithoutUser_Batch_makerIdToUserInput>
  }

  export type BatchUpdateManyWithWhereWithoutUser_Batch_makerIdToUserInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type RoleUpsertWithoutUserInput = {
    update: XOR<RoleUpdateWithoutUserInput, RoleUncheckedUpdateWithoutUserInput>
    create: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserInput, RoleUncheckedUpdateWithoutUserInput>
  }

  export type RoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Permission?: PermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Permission?: PermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type StandardUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: StandardWhereUniqueInput
    update: XOR<StandardUpdateWithoutCreatedByInput, StandardUncheckedUpdateWithoutCreatedByInput>
    create: XOR<StandardCreateWithoutCreatedByInput, StandardUncheckedCreateWithoutCreatedByInput>
  }

  export type StandardUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: StandardWhereUniqueInput
    data: XOR<StandardUpdateWithoutCreatedByInput, StandardUncheckedUpdateWithoutCreatedByInput>
  }

  export type StandardUpdateManyWithWhereWithoutCreatedByInput = {
    where: StandardScalarWhereInput
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type StandardUpsertWithWhereUniqueWithoutModifiedByInput = {
    where: StandardWhereUniqueInput
    update: XOR<StandardUpdateWithoutModifiedByInput, StandardUncheckedUpdateWithoutModifiedByInput>
    create: XOR<StandardCreateWithoutModifiedByInput, StandardUncheckedCreateWithoutModifiedByInput>
  }

  export type StandardUpdateWithWhereUniqueWithoutModifiedByInput = {
    where: StandardWhereUniqueInput
    data: XOR<StandardUpdateWithoutModifiedByInput, StandardUncheckedUpdateWithoutModifiedByInput>
  }

  export type StandardUpdateManyWithWhereWithoutModifiedByInput = {
    where: StandardScalarWhereInput
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyWithoutModifiedByInput>
  }

  export type StandardDefinitionUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: StandardDefinitionWhereUniqueInput
    update: XOR<StandardDefinitionUpdateWithoutCreatedByInput, StandardDefinitionUncheckedUpdateWithoutCreatedByInput>
    create: XOR<StandardDefinitionCreateWithoutCreatedByInput, StandardDefinitionUncheckedCreateWithoutCreatedByInput>
  }

  export type StandardDefinitionUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: StandardDefinitionWhereUniqueInput
    data: XOR<StandardDefinitionUpdateWithoutCreatedByInput, StandardDefinitionUncheckedUpdateWithoutCreatedByInput>
  }

  export type StandardDefinitionUpdateManyWithWhereWithoutCreatedByInput = {
    where: StandardDefinitionScalarWhereInput
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type StandardDefinitionUpsertWithWhereUniqueWithoutModifiedByInput = {
    where: StandardDefinitionWhereUniqueInput
    update: XOR<StandardDefinitionUpdateWithoutModifiedByInput, StandardDefinitionUncheckedUpdateWithoutModifiedByInput>
    create: XOR<StandardDefinitionCreateWithoutModifiedByInput, StandardDefinitionUncheckedCreateWithoutModifiedByInput>
  }

  export type StandardDefinitionUpdateWithWhereUniqueWithoutModifiedByInput = {
    where: StandardDefinitionWhereUniqueInput
    data: XOR<StandardDefinitionUpdateWithoutModifiedByInput, StandardDefinitionUncheckedUpdateWithoutModifiedByInput>
  }

  export type StandardDefinitionUpdateManyWithWhereWithoutModifiedByInput = {
    where: StandardDefinitionScalarWhereInput
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyWithoutModifiedByInput>
  }

  export type TrainingUpsertWithWhereUniqueWithoutTrainerInput = {
    where: TrainingWhereUniqueInput
    update: XOR<TrainingUpdateWithoutTrainerInput, TrainingUncheckedUpdateWithoutTrainerInput>
    create: XOR<TrainingCreateWithoutTrainerInput, TrainingUncheckedCreateWithoutTrainerInput>
  }

  export type TrainingUpdateWithWhereUniqueWithoutTrainerInput = {
    where: TrainingWhereUniqueInput
    data: XOR<TrainingUpdateWithoutTrainerInput, TrainingUncheckedUpdateWithoutTrainerInput>
  }

  export type TrainingUpdateManyWithWhereWithoutTrainerInput = {
    where: TrainingScalarWhereInput
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyWithoutTrainerInput>
  }

  export type TrainingScalarWhereInput = {
    AND?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
    OR?: TrainingScalarWhereInput[]
    NOT?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
    id?: StringFilter<"Training"> | string
    title?: StringFilter<"Training"> | string
    description?: StringNullableFilter<"Training"> | string | null
    trainingType?: EnumTrainingTypeFilter<"Training"> | $Enums.TrainingType
    status?: EnumTrainingStatusFilter<"Training"> | $Enums.TrainingStatus
    startDate?: DateTimeFilter<"Training"> | Date | string
    endDate?: DateTimeFilter<"Training"> | Date | string
    location?: StringFilter<"Training"> | string
    maxParticipants?: IntNullableFilter<"Training"> | number | null
    trainerId?: StringFilter<"Training"> | string
    calendarId?: StringFilter<"Training"> | string
    createdById?: StringFilter<"Training"> | string
    createdAt?: DateTimeFilter<"Training"> | Date | string
    updatedAt?: DateTimeFilter<"Training"> | Date | string
  }

  export type TrainingUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TrainingWhereUniqueInput
    update: XOR<TrainingUpdateWithoutCreatedByInput, TrainingUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TrainingCreateWithoutCreatedByInput, TrainingUncheckedCreateWithoutCreatedByInput>
  }

  export type TrainingUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TrainingWhereUniqueInput
    data: XOR<TrainingUpdateWithoutCreatedByInput, TrainingUncheckedUpdateWithoutCreatedByInput>
  }

  export type TrainingUpdateManyWithWhereWithoutCreatedByInput = {
    where: TrainingScalarWhereInput
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TrainingParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: TrainingParticipantWhereUniqueInput
    update: XOR<TrainingParticipantUpdateWithoutUserInput, TrainingParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<TrainingParticipantCreateWithoutUserInput, TrainingParticipantUncheckedCreateWithoutUserInput>
  }

  export type TrainingParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: TrainingParticipantWhereUniqueInput
    data: XOR<TrainingParticipantUpdateWithoutUserInput, TrainingParticipantUncheckedUpdateWithoutUserInput>
  }

  export type TrainingParticipantUpdateManyWithWhereWithoutUserInput = {
    where: TrainingParticipantScalarWhereInput
    data: XOR<TrainingParticipantUpdateManyMutationInput, TrainingParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type TrainingParticipantScalarWhereInput = {
    AND?: TrainingParticipantScalarWhereInput | TrainingParticipantScalarWhereInput[]
    OR?: TrainingParticipantScalarWhereInput[]
    NOT?: TrainingParticipantScalarWhereInput | TrainingParticipantScalarWhereInput[]
    id?: StringFilter<"TrainingParticipant"> | string
    trainingId?: StringFilter<"TrainingParticipant"> | string
    userId?: StringFilter<"TrainingParticipant"> | string
    inviteSent?: BoolFilter<"TrainingParticipant"> | boolean
    inviteSentAt?: DateTimeNullableFilter<"TrainingParticipant"> | Date | string | null
    inviteAccepted?: BoolFilter<"TrainingParticipant"> | boolean
    createdAt?: DateTimeFilter<"TrainingParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingParticipant"> | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    trainingId?: StringFilter<"Attendance"> | string
    sessionId?: StringFilter<"Attendance"> | string
    userId?: StringFilter<"Attendance"> | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    remarks?: StringNullableFilter<"Attendance"> | string | null
    signatureUrl?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type TrainingDocumentUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: TrainingDocumentWhereUniqueInput
    update: XOR<TrainingDocumentUpdateWithoutUploadedByInput, TrainingDocumentUncheckedUpdateWithoutUploadedByInput>
    create: XOR<TrainingDocumentCreateWithoutUploadedByInput, TrainingDocumentUncheckedCreateWithoutUploadedByInput>
  }

  export type TrainingDocumentUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: TrainingDocumentWhereUniqueInput
    data: XOR<TrainingDocumentUpdateWithoutUploadedByInput, TrainingDocumentUncheckedUpdateWithoutUploadedByInput>
  }

  export type TrainingDocumentUpdateManyWithWhereWithoutUploadedByInput = {
    where: TrainingDocumentScalarWhereInput
    data: XOR<TrainingDocumentUpdateManyMutationInput, TrainingDocumentUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type TrainingDocumentScalarWhereInput = {
    AND?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
    OR?: TrainingDocumentScalarWhereInput[]
    NOT?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
    id?: StringFilter<"TrainingDocument"> | string
    trainingId?: StringFilter<"TrainingDocument"> | string
    title?: StringFilter<"TrainingDocument"> | string
    description?: StringNullableFilter<"TrainingDocument"> | string | null
    fileUrl?: StringFilter<"TrainingDocument"> | string
    documentType?: EnumDocumentTypeFilter<"TrainingDocument"> | $Enums.DocumentType
    uploadedById?: StringFilter<"TrainingDocument"> | string
    createdAt?: DateTimeFilter<"TrainingDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingDocument"> | Date | string
  }

  export type TrainingPhotoUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: TrainingPhotoWhereUniqueInput
    update: XOR<TrainingPhotoUpdateWithoutUploadedByInput, TrainingPhotoUncheckedUpdateWithoutUploadedByInput>
    create: XOR<TrainingPhotoCreateWithoutUploadedByInput, TrainingPhotoUncheckedCreateWithoutUploadedByInput>
  }

  export type TrainingPhotoUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: TrainingPhotoWhereUniqueInput
    data: XOR<TrainingPhotoUpdateWithoutUploadedByInput, TrainingPhotoUncheckedUpdateWithoutUploadedByInput>
  }

  export type TrainingPhotoUpdateManyWithWhereWithoutUploadedByInput = {
    where: TrainingPhotoScalarWhereInput
    data: XOR<TrainingPhotoUpdateManyMutationInput, TrainingPhotoUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type TrainingPhotoScalarWhereInput = {
    AND?: TrainingPhotoScalarWhereInput | TrainingPhotoScalarWhereInput[]
    OR?: TrainingPhotoScalarWhereInput[]
    NOT?: TrainingPhotoScalarWhereInput | TrainingPhotoScalarWhereInput[]
    id?: StringFilter<"TrainingPhoto"> | string
    trainingId?: StringFilter<"TrainingPhoto"> | string
    photoUrl?: StringFilter<"TrainingPhoto"> | string
    caption?: StringNullableFilter<"TrainingPhoto"> | string | null
    uploadedById?: StringFilter<"TrainingPhoto"> | string
    createdAt?: DateTimeFilter<"TrainingPhoto"> | Date | string
  }

  export type TrainingFeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: TrainingFeedbackWhereUniqueInput
    update: XOR<TrainingFeedbackUpdateWithoutUserInput, TrainingFeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<TrainingFeedbackCreateWithoutUserInput, TrainingFeedbackUncheckedCreateWithoutUserInput>
  }

  export type TrainingFeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: TrainingFeedbackWhereUniqueInput
    data: XOR<TrainingFeedbackUpdateWithoutUserInput, TrainingFeedbackUncheckedUpdateWithoutUserInput>
  }

  export type TrainingFeedbackUpdateManyWithWhereWithoutUserInput = {
    where: TrainingFeedbackScalarWhereInput
    data: XOR<TrainingFeedbackUpdateManyMutationInput, TrainingFeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type TrainingFeedbackScalarWhereInput = {
    AND?: TrainingFeedbackScalarWhereInput | TrainingFeedbackScalarWhereInput[]
    OR?: TrainingFeedbackScalarWhereInput[]
    NOT?: TrainingFeedbackScalarWhereInput | TrainingFeedbackScalarWhereInput[]
    id?: StringFilter<"TrainingFeedback"> | string
    trainingId?: StringFilter<"TrainingFeedback"> | string
    userId?: StringFilter<"TrainingFeedback"> | string
    contentRating?: IntFilter<"TrainingFeedback"> | number
    trainerRating?: IntFilter<"TrainingFeedback"> | number
    materialRating?: IntFilter<"TrainingFeedback"> | number
    venueRating?: IntFilter<"TrainingFeedback"> | number
    overallRating?: IntFilter<"TrainingFeedback"> | number
    comments?: StringNullableFilter<"TrainingFeedback"> | string | null
    suggestedImprovements?: StringNullableFilter<"TrainingFeedback"> | string | null
    createdAt?: DateTimeFilter<"TrainingFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingFeedback"> | Date | string
  }

  export type TrainingFollowupUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: TrainingFollowupWhereUniqueInput
    update: XOR<TrainingFollowupUpdateWithoutAssignedToInput, TrainingFollowupUncheckedUpdateWithoutAssignedToInput>
    create: XOR<TrainingFollowupCreateWithoutAssignedToInput, TrainingFollowupUncheckedCreateWithoutAssignedToInput>
  }

  export type TrainingFollowupUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: TrainingFollowupWhereUniqueInput
    data: XOR<TrainingFollowupUpdateWithoutAssignedToInput, TrainingFollowupUncheckedUpdateWithoutAssignedToInput>
  }

  export type TrainingFollowupUpdateManyWithWhereWithoutAssignedToInput = {
    where: TrainingFollowupScalarWhereInput
    data: XOR<TrainingFollowupUpdateManyMutationInput, TrainingFollowupUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type TrainingFollowupScalarWhereInput = {
    AND?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
    OR?: TrainingFollowupScalarWhereInput[]
    NOT?: TrainingFollowupScalarWhereInput | TrainingFollowupScalarWhereInput[]
    id?: StringFilter<"TrainingFollowup"> | string
    trainingId?: StringFilter<"TrainingFollowup"> | string
    title?: StringFilter<"TrainingFollowup"> | string
    description?: StringFilter<"TrainingFollowup"> | string
    dueDate?: DateTimeNullableFilter<"TrainingFollowup"> | Date | string | null
    isCompleted?: BoolFilter<"TrainingFollowup"> | boolean
    assignedToId?: StringFilter<"TrainingFollowup"> | string
    createdById?: StringFilter<"TrainingFollowup"> | string
    createdAt?: DateTimeFilter<"TrainingFollowup"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingFollowup"> | Date | string
    completedAt?: DateTimeNullableFilter<"TrainingFollowup"> | Date | string | null
  }

  export type TrainingFollowupUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TrainingFollowupWhereUniqueInput
    update: XOR<TrainingFollowupUpdateWithoutCreatedByInput, TrainingFollowupUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TrainingFollowupCreateWithoutCreatedByInput, TrainingFollowupUncheckedCreateWithoutCreatedByInput>
  }

  export type TrainingFollowupUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TrainingFollowupWhereUniqueInput
    data: XOR<TrainingFollowupUpdateWithoutCreatedByInput, TrainingFollowupUncheckedUpdateWithoutCreatedByInput>
  }

  export type TrainingFollowupUpdateManyWithWhereWithoutCreatedByInput = {
    where: TrainingFollowupScalarWhereInput
    data: XOR<TrainingFollowupUpdateManyMutationInput, TrainingFollowupUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TrainingNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: TrainingNotificationWhereUniqueInput
    update: XOR<TrainingNotificationUpdateWithoutUserInput, TrainingNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<TrainingNotificationCreateWithoutUserInput, TrainingNotificationUncheckedCreateWithoutUserInput>
  }

  export type TrainingNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: TrainingNotificationWhereUniqueInput
    data: XOR<TrainingNotificationUpdateWithoutUserInput, TrainingNotificationUncheckedUpdateWithoutUserInput>
  }

  export type TrainingNotificationUpdateManyWithWhereWithoutUserInput = {
    where: TrainingNotificationScalarWhereInput
    data: XOR<TrainingNotificationUpdateManyMutationInput, TrainingNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type TrainingNotificationScalarWhereInput = {
    AND?: TrainingNotificationScalarWhereInput | TrainingNotificationScalarWhereInput[]
    OR?: TrainingNotificationScalarWhereInput[]
    NOT?: TrainingNotificationScalarWhereInput | TrainingNotificationScalarWhereInput[]
    id?: StringFilter<"TrainingNotification"> | string
    trainingId?: StringFilter<"TrainingNotification"> | string
    userId?: StringFilter<"TrainingNotification"> | string
    title?: StringFilter<"TrainingNotification"> | string
    message?: StringFilter<"TrainingNotification"> | string
    isRead?: BoolFilter<"TrainingNotification"> | boolean
    sentAt?: DateTimeFilter<"TrainingNotification"> | Date | string
    readAt?: DateTimeNullableFilter<"TrainingNotification"> | Date | string | null
  }

  export type StandardCategoryCreateWithoutStandardsInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parameters?: StandardParameterCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryUncheckedCreateWithoutStandardsInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parameters?: StandardParameterUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryCreateOrConnectWithoutStandardsInput = {
    where: StandardCategoryWhereUniqueInput
    create: XOR<StandardCategoryCreateWithoutStandardsInput, StandardCategoryUncheckedCreateWithoutStandardsInput>
  }

  export type UserCreateWithoutStandardsCreatedInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStandardsCreatedInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStandardsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStandardsCreatedInput, UserUncheckedCreateWithoutStandardsCreatedInput>
  }

  export type UserCreateWithoutStandardsModifiedInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStandardsModifiedInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStandardsModifiedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStandardsModifiedInput, UserUncheckedCreateWithoutStandardsModifiedInput>
  }

  export type BatchCreateWithoutStandardsInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutStandardsInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
    parameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutStandardsInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutStandardsInput, BatchUncheckedCreateWithoutStandardsInput>
  }

  export type MethodologyCreateWithoutStandardsInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutMethodologyInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyUncheckedCreateWithoutStandardsInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutMethodologyInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyCreateOrConnectWithoutStandardsInput = {
    where: MethodologyWhereUniqueInput
    create: XOR<MethodologyCreateWithoutStandardsInput, MethodologyUncheckedCreateWithoutStandardsInput>
  }

  export type UnitOfMeasurementCreateWithoutStandardsInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutUnitInput
    batches?: BatchCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementUncheckedCreateWithoutStandardsInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutUnitInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutUnitInput
    batches?: BatchUncheckedCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementCreateOrConnectWithoutStandardsInput = {
    where: UnitOfMeasurementWhereUniqueInput
    create: XOR<UnitOfMeasurementCreateWithoutStandardsInput, UnitOfMeasurementUncheckedCreateWithoutStandardsInput>
  }

  export type StandardCategoryUpsertWithoutStandardsInput = {
    update: XOR<StandardCategoryUpdateWithoutStandardsInput, StandardCategoryUncheckedUpdateWithoutStandardsInput>
    create: XOR<StandardCategoryCreateWithoutStandardsInput, StandardCategoryUncheckedCreateWithoutStandardsInput>
    where?: StandardCategoryWhereInput
  }

  export type StandardCategoryUpdateToOneWithWhereWithoutStandardsInput = {
    where?: StandardCategoryWhereInput
    data: XOR<StandardCategoryUpdateWithoutStandardsInput, StandardCategoryUncheckedUpdateWithoutStandardsInput>
  }

  export type StandardCategoryUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: StandardParameterUpdateManyWithoutCategoryNestedInput
  }

  export type StandardCategoryUncheckedUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: StandardParameterUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type UserUpsertWithoutStandardsCreatedInput = {
    update: XOR<UserUpdateWithoutStandardsCreatedInput, UserUncheckedUpdateWithoutStandardsCreatedInput>
    create: XOR<UserCreateWithoutStandardsCreatedInput, UserUncheckedCreateWithoutStandardsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStandardsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStandardsCreatedInput, UserUncheckedUpdateWithoutStandardsCreatedInput>
  }

  export type UserUpdateWithoutStandardsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStandardsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutStandardsModifiedInput = {
    update: XOR<UserUpdateWithoutStandardsModifiedInput, UserUncheckedUpdateWithoutStandardsModifiedInput>
    create: XOR<UserCreateWithoutStandardsModifiedInput, UserUncheckedCreateWithoutStandardsModifiedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStandardsModifiedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStandardsModifiedInput, UserUncheckedUpdateWithoutStandardsModifiedInput>
  }

  export type UserUpdateWithoutStandardsModifiedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStandardsModifiedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BatchUpsertWithWhereUniqueWithoutStandardsInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutStandardsInput, BatchUncheckedUpdateWithoutStandardsInput>
    create: XOR<BatchCreateWithoutStandardsInput, BatchUncheckedCreateWithoutStandardsInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutStandardsInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutStandardsInput, BatchUncheckedUpdateWithoutStandardsInput>
  }

  export type BatchUpdateManyWithWhereWithoutStandardsInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutStandardsInput>
  }

  export type MethodologyUpsertWithWhereUniqueWithoutStandardsInput = {
    where: MethodologyWhereUniqueInput
    update: XOR<MethodologyUpdateWithoutStandardsInput, MethodologyUncheckedUpdateWithoutStandardsInput>
    create: XOR<MethodologyCreateWithoutStandardsInput, MethodologyUncheckedCreateWithoutStandardsInput>
  }

  export type MethodologyUpdateWithWhereUniqueWithoutStandardsInput = {
    where: MethodologyWhereUniqueInput
    data: XOR<MethodologyUpdateWithoutStandardsInput, MethodologyUncheckedUpdateWithoutStandardsInput>
  }

  export type MethodologyUpdateManyWithWhereWithoutStandardsInput = {
    where: MethodologyScalarWhereInput
    data: XOR<MethodologyUpdateManyMutationInput, MethodologyUncheckedUpdateManyWithoutStandardsInput>
  }

  export type UnitOfMeasurementUpsertWithWhereUniqueWithoutStandardsInput = {
    where: UnitOfMeasurementWhereUniqueInput
    update: XOR<UnitOfMeasurementUpdateWithoutStandardsInput, UnitOfMeasurementUncheckedUpdateWithoutStandardsInput>
    create: XOR<UnitOfMeasurementCreateWithoutStandardsInput, UnitOfMeasurementUncheckedCreateWithoutStandardsInput>
  }

  export type UnitOfMeasurementUpdateWithWhereUniqueWithoutStandardsInput = {
    where: UnitOfMeasurementWhereUniqueInput
    data: XOR<UnitOfMeasurementUpdateWithoutStandardsInput, UnitOfMeasurementUncheckedUpdateWithoutStandardsInput>
  }

  export type UnitOfMeasurementUpdateManyWithWhereWithoutStandardsInput = {
    where: UnitOfMeasurementScalarWhereInput
    data: XOR<UnitOfMeasurementUpdateManyMutationInput, UnitOfMeasurementUncheckedUpdateManyWithoutStandardsInput>
  }

  export type StandardParameterCreateWithoutCategoryInput = {
    id: string
    name: string
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    batchValues?: BatchParameterValueCreateNestedManyWithoutParameterInput
    standards?: StandardDefinitionCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterUncheckedCreateWithoutCategoryInput = {
    id: string
    name: string
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    batchValues?: BatchParameterValueUncheckedCreateNestedManyWithoutParameterInput
    standards?: StandardDefinitionUncheckedCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterCreateOrConnectWithoutCategoryInput = {
    where: StandardParameterWhereUniqueInput
    create: XOR<StandardParameterCreateWithoutCategoryInput, StandardParameterUncheckedCreateWithoutCategoryInput>
  }

  export type StandardParameterCreateManyCategoryInputEnvelope = {
    data: StandardParameterCreateManyCategoryInput | StandardParameterCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type StandardCreateWithoutCategoryInput = {
    id: string
    name: string
    code: string
    description: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    CreatedBy: UserCreateNestedOneWithoutStandardsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardsModifiedInput
    batches?: BatchCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementCreateNestedManyWithoutStandardsInput
  }

  export type StandardUncheckedCreateWithoutCategoryInput = {
    id: string
    name: string
    code: string
    description: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    batches?: BatchUncheckedCreateNestedManyWithoutStandardsInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutStandardsInput
    units?: UnitOfMeasurementUncheckedCreateNestedManyWithoutStandardsInput
  }

  export type StandardCreateOrConnectWithoutCategoryInput = {
    where: StandardWhereUniqueInput
    create: XOR<StandardCreateWithoutCategoryInput, StandardUncheckedCreateWithoutCategoryInput>
  }

  export type StandardCreateManyCategoryInputEnvelope = {
    data: StandardCreateManyCategoryInput | StandardCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type StandardParameterUpsertWithWhereUniqueWithoutCategoryInput = {
    where: StandardParameterWhereUniqueInput
    update: XOR<StandardParameterUpdateWithoutCategoryInput, StandardParameterUncheckedUpdateWithoutCategoryInput>
    create: XOR<StandardParameterCreateWithoutCategoryInput, StandardParameterUncheckedCreateWithoutCategoryInput>
  }

  export type StandardParameterUpdateWithWhereUniqueWithoutCategoryInput = {
    where: StandardParameterWhereUniqueInput
    data: XOR<StandardParameterUpdateWithoutCategoryInput, StandardParameterUncheckedUpdateWithoutCategoryInput>
  }

  export type StandardParameterUpdateManyWithWhereWithoutCategoryInput = {
    where: StandardParameterScalarWhereInput
    data: XOR<StandardParameterUpdateManyMutationInput, StandardParameterUncheckedUpdateManyWithoutCategoryInput>
  }

  export type StandardParameterScalarWhereInput = {
    AND?: StandardParameterScalarWhereInput | StandardParameterScalarWhereInput[]
    OR?: StandardParameterScalarWhereInput[]
    NOT?: StandardParameterScalarWhereInput | StandardParameterScalarWhereInput[]
    id?: StringFilter<"StandardParameter"> | string
    name?: StringFilter<"StandardParameter"> | string
    categoryId?: StringFilter<"StandardParameter"> | string
    description?: StringNullableFilter<"StandardParameter"> | string | null
    dataType?: EnumParameterDataTypeFilter<"StandardParameter"> | $Enums.ParameterDataType
    createdAt?: DateTimeFilter<"StandardParameter"> | Date | string
    updatedAt?: DateTimeFilter<"StandardParameter"> | Date | string
  }

  export type StandardUpsertWithWhereUniqueWithoutCategoryInput = {
    where: StandardWhereUniqueInput
    update: XOR<StandardUpdateWithoutCategoryInput, StandardUncheckedUpdateWithoutCategoryInput>
    create: XOR<StandardCreateWithoutCategoryInput, StandardUncheckedCreateWithoutCategoryInput>
  }

  export type StandardUpdateWithWhereUniqueWithoutCategoryInput = {
    where: StandardWhereUniqueInput
    data: XOR<StandardUpdateWithoutCategoryInput, StandardUncheckedUpdateWithoutCategoryInput>
  }

  export type StandardUpdateManyWithWhereWithoutCategoryInput = {
    where: StandardScalarWhereInput
    data: XOR<StandardUpdateManyMutationInput, StandardUncheckedUpdateManyWithoutCategoryInput>
  }

  export type StandardCategoryCreateWithoutParametersInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryUncheckedCreateWithoutParametersInput = {
    id: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type StandardCategoryCreateOrConnectWithoutParametersInput = {
    where: StandardCategoryWhereUniqueInput
    create: XOR<StandardCategoryCreateWithoutParametersInput, StandardCategoryUncheckedCreateWithoutParametersInput>
  }

  export type BatchParameterValueCreateWithoutParameterInput = {
    id: string
    value: string
    createdAt?: Date | string
    updatedAt: Date | string
    batch: BatchCreateNestedOneWithoutParameterValuesInput
    unit?: UnitOfMeasurementCreateNestedOneWithoutBatchParameterValuesInput
    methodology?: MethodologyCreateNestedOneWithoutBatchParameterValuesInput
  }

  export type BatchParameterValueUncheckedCreateWithoutParameterInput = {
    id: string
    batchId: string
    value: string
    unitId?: string | null
    methodologyId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchParameterValueCreateOrConnectWithoutParameterInput = {
    where: BatchParameterValueWhereUniqueInput
    create: XOR<BatchParameterValueCreateWithoutParameterInput, BatchParameterValueUncheckedCreateWithoutParameterInput>
  }

  export type BatchParameterValueCreateManyParameterInputEnvelope = {
    data: BatchParameterValueCreateManyParameterInput | BatchParameterValueCreateManyParameterInput[]
    skipDuplicates?: boolean
  }

  export type StandardDefinitionCreateWithoutParameterInput = {
    id: string
    standardValue: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
    unit?: UnitOfMeasurementCreateNestedOneWithoutStandardDefinitionsInput
    methodology?: MethodologyCreateNestedOneWithoutStandardDefinitionsInput
    CreatedBy: UserCreateNestedOneWithoutStandardDefinitionsCreatedInput
    ModifiedBy?: UserCreateNestedOneWithoutStandardDefinitionsModifiedInput
  }

  export type StandardDefinitionUncheckedCreateWithoutParameterInput = {
    id: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateOrConnectWithoutParameterInput = {
    where: StandardDefinitionWhereUniqueInput
    create: XOR<StandardDefinitionCreateWithoutParameterInput, StandardDefinitionUncheckedCreateWithoutParameterInput>
  }

  export type StandardDefinitionCreateManyParameterInputEnvelope = {
    data: StandardDefinitionCreateManyParameterInput | StandardDefinitionCreateManyParameterInput[]
    skipDuplicates?: boolean
  }

  export type StandardCategoryUpsertWithoutParametersInput = {
    update: XOR<StandardCategoryUpdateWithoutParametersInput, StandardCategoryUncheckedUpdateWithoutParametersInput>
    create: XOR<StandardCategoryCreateWithoutParametersInput, StandardCategoryUncheckedCreateWithoutParametersInput>
    where?: StandardCategoryWhereInput
  }

  export type StandardCategoryUpdateToOneWithWhereWithoutParametersInput = {
    where?: StandardCategoryWhereInput
    data: XOR<StandardCategoryUpdateWithoutParametersInput, StandardCategoryUncheckedUpdateWithoutParametersInput>
  }

  export type StandardCategoryUpdateWithoutParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutCategoryNestedInput
  }

  export type StandardCategoryUncheckedUpdateWithoutParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type BatchParameterValueUpsertWithWhereUniqueWithoutParameterInput = {
    where: BatchParameterValueWhereUniqueInput
    update: XOR<BatchParameterValueUpdateWithoutParameterInput, BatchParameterValueUncheckedUpdateWithoutParameterInput>
    create: XOR<BatchParameterValueCreateWithoutParameterInput, BatchParameterValueUncheckedCreateWithoutParameterInput>
  }

  export type BatchParameterValueUpdateWithWhereUniqueWithoutParameterInput = {
    where: BatchParameterValueWhereUniqueInput
    data: XOR<BatchParameterValueUpdateWithoutParameterInput, BatchParameterValueUncheckedUpdateWithoutParameterInput>
  }

  export type BatchParameterValueUpdateManyWithWhereWithoutParameterInput = {
    where: BatchParameterValueScalarWhereInput
    data: XOR<BatchParameterValueUpdateManyMutationInput, BatchParameterValueUncheckedUpdateManyWithoutParameterInput>
  }

  export type StandardDefinitionUpsertWithWhereUniqueWithoutParameterInput = {
    where: StandardDefinitionWhereUniqueInput
    update: XOR<StandardDefinitionUpdateWithoutParameterInput, StandardDefinitionUncheckedUpdateWithoutParameterInput>
    create: XOR<StandardDefinitionCreateWithoutParameterInput, StandardDefinitionUncheckedCreateWithoutParameterInput>
  }

  export type StandardDefinitionUpdateWithWhereUniqueWithoutParameterInput = {
    where: StandardDefinitionWhereUniqueInput
    data: XOR<StandardDefinitionUpdateWithoutParameterInput, StandardDefinitionUncheckedUpdateWithoutParameterInput>
  }

  export type StandardDefinitionUpdateManyWithWhereWithoutParameterInput = {
    where: StandardDefinitionScalarWhereInput
    data: XOR<StandardDefinitionUpdateManyMutationInput, StandardDefinitionUncheckedUpdateManyWithoutParameterInput>
  }

  export type StandardParameterCreateWithoutStandardsInput = {
    id: string
    name: string
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    category: StandardCategoryCreateNestedOneWithoutParametersInput
    batchValues?: BatchParameterValueCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterUncheckedCreateWithoutStandardsInput = {
    id: string
    name: string
    categoryId: string
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    batchValues?: BatchParameterValueUncheckedCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterCreateOrConnectWithoutStandardsInput = {
    where: StandardParameterWhereUniqueInput
    create: XOR<StandardParameterCreateWithoutStandardsInput, StandardParameterUncheckedCreateWithoutStandardsInput>
  }

  export type UnitOfMeasurementCreateWithoutStandardDefinitionsInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutUnitInput
    batches?: BatchCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementUncheckedCreateWithoutStandardDefinitionsInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutUnitsInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutUnitInput
    batches?: BatchUncheckedCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementCreateOrConnectWithoutStandardDefinitionsInput = {
    where: UnitOfMeasurementWhereUniqueInput
    create: XOR<UnitOfMeasurementCreateWithoutStandardDefinitionsInput, UnitOfMeasurementUncheckedCreateWithoutStandardDefinitionsInput>
  }

  export type MethodologyCreateWithoutStandardDefinitionsInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutMethodologiesInput
    batches?: BatchCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyUncheckedCreateWithoutStandardDefinitionsInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutMethodologiesInput
    batches?: BatchUncheckedCreateNestedManyWithoutMethodologiesInput
    batchParameterValues?: BatchParameterValueUncheckedCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyCreateOrConnectWithoutStandardDefinitionsInput = {
    where: MethodologyWhereUniqueInput
    create: XOR<MethodologyCreateWithoutStandardDefinitionsInput, MethodologyUncheckedCreateWithoutStandardDefinitionsInput>
  }

  export type UserCreateWithoutStandardDefinitionsCreatedInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStandardDefinitionsCreatedInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStandardDefinitionsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStandardDefinitionsCreatedInput, UserUncheckedCreateWithoutStandardDefinitionsCreatedInput>
  }

  export type UserCreateWithoutStandardDefinitionsModifiedInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStandardDefinitionsModifiedInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStandardDefinitionsModifiedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStandardDefinitionsModifiedInput, UserUncheckedCreateWithoutStandardDefinitionsModifiedInput>
  }

  export type StandardParameterUpsertWithoutStandardsInput = {
    update: XOR<StandardParameterUpdateWithoutStandardsInput, StandardParameterUncheckedUpdateWithoutStandardsInput>
    create: XOR<StandardParameterCreateWithoutStandardsInput, StandardParameterUncheckedCreateWithoutStandardsInput>
    where?: StandardParameterWhereInput
  }

  export type StandardParameterUpdateToOneWithWhereWithoutStandardsInput = {
    where?: StandardParameterWhereInput
    data: XOR<StandardParameterUpdateWithoutStandardsInput, StandardParameterUncheckedUpdateWithoutStandardsInput>
  }

  export type StandardParameterUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StandardCategoryUpdateOneRequiredWithoutParametersNestedInput
    batchValues?: BatchParameterValueUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterUncheckedUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchValues?: BatchParameterValueUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type UnitOfMeasurementUpsertWithoutStandardDefinitionsInput = {
    update: XOR<UnitOfMeasurementUpdateWithoutStandardDefinitionsInput, UnitOfMeasurementUncheckedUpdateWithoutStandardDefinitionsInput>
    create: XOR<UnitOfMeasurementCreateWithoutStandardDefinitionsInput, UnitOfMeasurementUncheckedCreateWithoutStandardDefinitionsInput>
    where?: UnitOfMeasurementWhereInput
  }

  export type UnitOfMeasurementUpdateToOneWithWhereWithoutStandardDefinitionsInput = {
    where?: UnitOfMeasurementWhereInput
    data: XOR<UnitOfMeasurementUpdateWithoutStandardDefinitionsInput, UnitOfMeasurementUncheckedUpdateWithoutStandardDefinitionsInput>
  }

  export type UnitOfMeasurementUpdateWithoutStandardDefinitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutUnitNestedInput
    batches?: BatchUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateWithoutStandardDefinitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutUnitNestedInput
    batches?: BatchUncheckedUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type MethodologyUpsertWithoutStandardDefinitionsInput = {
    update: XOR<MethodologyUpdateWithoutStandardDefinitionsInput, MethodologyUncheckedUpdateWithoutStandardDefinitionsInput>
    create: XOR<MethodologyCreateWithoutStandardDefinitionsInput, MethodologyUncheckedCreateWithoutStandardDefinitionsInput>
    where?: MethodologyWhereInput
  }

  export type MethodologyUpdateToOneWithWhereWithoutStandardDefinitionsInput = {
    where?: MethodologyWhereInput
    data: XOR<MethodologyUpdateWithoutStandardDefinitionsInput, MethodologyUncheckedUpdateWithoutStandardDefinitionsInput>
  }

  export type MethodologyUpdateWithoutStandardDefinitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutMethodologiesNestedInput
    batches?: BatchUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateWithoutStandardDefinitionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutMethodologiesNestedInput
    batches?: BatchUncheckedUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutMethodologyNestedInput
  }

  export type UserUpsertWithoutStandardDefinitionsCreatedInput = {
    update: XOR<UserUpdateWithoutStandardDefinitionsCreatedInput, UserUncheckedUpdateWithoutStandardDefinitionsCreatedInput>
    create: XOR<UserCreateWithoutStandardDefinitionsCreatedInput, UserUncheckedCreateWithoutStandardDefinitionsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStandardDefinitionsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStandardDefinitionsCreatedInput, UserUncheckedUpdateWithoutStandardDefinitionsCreatedInput>
  }

  export type UserUpdateWithoutStandardDefinitionsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStandardDefinitionsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutStandardDefinitionsModifiedInput = {
    update: XOR<UserUpdateWithoutStandardDefinitionsModifiedInput, UserUncheckedUpdateWithoutStandardDefinitionsModifiedInput>
    create: XOR<UserCreateWithoutStandardDefinitionsModifiedInput, UserUncheckedCreateWithoutStandardDefinitionsModifiedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStandardDefinitionsModifiedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStandardDefinitionsModifiedInput, UserUncheckedUpdateWithoutStandardDefinitionsModifiedInput>
  }

  export type UserUpdateWithoutStandardDefinitionsModifiedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStandardDefinitionsModifiedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BatchCreateWithoutParameterValuesInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutBatchInput
    User_Batch_checkerIdToUser?: UserCreateNestedOneWithoutBatch_Batch_checkerIdToUserInput
    User_Batch_makerIdToUser: UserCreateNestedOneWithoutBatch_Batch_makerIdToUserInput
    Product: ProductCreateNestedOneWithoutBatchInput
    Notification?: NotificationCreateNestedManyWithoutBatchInput
    standards?: StandardCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementCreateNestedManyWithoutBatchesInput
  }

  export type BatchUncheckedCreateWithoutParameterValuesInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutBatchInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutBatchInput
    standards?: StandardUncheckedCreateNestedManyWithoutBatchesInput
    methodologies?: MethodologyUncheckedCreateNestedManyWithoutBatchesInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedCreateNestedManyWithoutBatchesInput
  }

  export type BatchCreateOrConnectWithoutParameterValuesInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutParameterValuesInput, BatchUncheckedCreateWithoutParameterValuesInput>
  }

  export type StandardParameterCreateWithoutBatchValuesInput = {
    id: string
    name: string
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    category: StandardCategoryCreateNestedOneWithoutParametersInput
    standards?: StandardDefinitionCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterUncheckedCreateWithoutBatchValuesInput = {
    id: string
    name: string
    categoryId: string
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
    standards?: StandardDefinitionUncheckedCreateNestedManyWithoutParameterInput
  }

  export type StandardParameterCreateOrConnectWithoutBatchValuesInput = {
    where: StandardParameterWhereUniqueInput
    create: XOR<StandardParameterCreateWithoutBatchValuesInput, StandardParameterUncheckedCreateWithoutBatchValuesInput>
  }

  export type UnitOfMeasurementCreateWithoutBatchParameterValuesInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutUnitsInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutUnitInput
    batches?: BatchCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementUncheckedCreateWithoutBatchParameterValuesInput = {
    id: string
    name: string
    symbol: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutUnitsInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutUnitInput
    batches?: BatchUncheckedCreateNestedManyWithoutUnitOfMeasurementsInput
  }

  export type UnitOfMeasurementCreateOrConnectWithoutBatchParameterValuesInput = {
    where: UnitOfMeasurementWhereUniqueInput
    create: XOR<UnitOfMeasurementCreateWithoutBatchParameterValuesInput, UnitOfMeasurementUncheckedCreateWithoutBatchParameterValuesInput>
  }

  export type MethodologyCreateWithoutBatchParameterValuesInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardCreateNestedManyWithoutMethodologiesInput
    batches?: BatchCreateNestedManyWithoutMethodologiesInput
    standardDefinitions?: StandardDefinitionCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyUncheckedCreateWithoutBatchParameterValuesInput = {
    id: string
    name: string
    description: string
    procedure: string
    createdAt?: Date | string
    updatedAt: Date | string
    Standards?: StandardUncheckedCreateNestedManyWithoutMethodologiesInput
    batches?: BatchUncheckedCreateNestedManyWithoutMethodologiesInput
    standardDefinitions?: StandardDefinitionUncheckedCreateNestedManyWithoutMethodologyInput
  }

  export type MethodologyCreateOrConnectWithoutBatchParameterValuesInput = {
    where: MethodologyWhereUniqueInput
    create: XOR<MethodologyCreateWithoutBatchParameterValuesInput, MethodologyUncheckedCreateWithoutBatchParameterValuesInput>
  }

  export type BatchUpsertWithoutParameterValuesInput = {
    update: XOR<BatchUpdateWithoutParameterValuesInput, BatchUncheckedUpdateWithoutParameterValuesInput>
    create: XOR<BatchCreateWithoutParameterValuesInput, BatchUncheckedCreateWithoutParameterValuesInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutParameterValuesInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutParameterValuesInput, BatchUncheckedUpdateWithoutParameterValuesInput>
  }

  export type BatchUpdateWithoutParameterValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
  }

  export type BatchUncheckedUpdateWithoutParameterValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
  }

  export type StandardParameterUpsertWithoutBatchValuesInput = {
    update: XOR<StandardParameterUpdateWithoutBatchValuesInput, StandardParameterUncheckedUpdateWithoutBatchValuesInput>
    create: XOR<StandardParameterCreateWithoutBatchValuesInput, StandardParameterUncheckedCreateWithoutBatchValuesInput>
    where?: StandardParameterWhereInput
  }

  export type StandardParameterUpdateToOneWithWhereWithoutBatchValuesInput = {
    where?: StandardParameterWhereInput
    data: XOR<StandardParameterUpdateWithoutBatchValuesInput, StandardParameterUncheckedUpdateWithoutBatchValuesInput>
  }

  export type StandardParameterUpdateWithoutBatchValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StandardCategoryUpdateOneRequiredWithoutParametersNestedInput
    standards?: StandardDefinitionUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterUncheckedUpdateWithoutBatchValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    standards?: StandardDefinitionUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type UnitOfMeasurementUpsertWithoutBatchParameterValuesInput = {
    update: XOR<UnitOfMeasurementUpdateWithoutBatchParameterValuesInput, UnitOfMeasurementUncheckedUpdateWithoutBatchParameterValuesInput>
    create: XOR<UnitOfMeasurementCreateWithoutBatchParameterValuesInput, UnitOfMeasurementUncheckedCreateWithoutBatchParameterValuesInput>
    where?: UnitOfMeasurementWhereInput
  }

  export type UnitOfMeasurementUpdateToOneWithWhereWithoutBatchParameterValuesInput = {
    where?: UnitOfMeasurementWhereInput
    data: XOR<UnitOfMeasurementUpdateWithoutBatchParameterValuesInput, UnitOfMeasurementUncheckedUpdateWithoutBatchParameterValuesInput>
  }

  export type UnitOfMeasurementUpdateWithoutBatchParameterValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutUnitsNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutUnitNestedInput
    batches?: BatchUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateWithoutBatchParameterValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutUnitsNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutUnitNestedInput
    batches?: BatchUncheckedUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type MethodologyUpsertWithoutBatchParameterValuesInput = {
    update: XOR<MethodologyUpdateWithoutBatchParameterValuesInput, MethodologyUncheckedUpdateWithoutBatchParameterValuesInput>
    create: XOR<MethodologyCreateWithoutBatchParameterValuesInput, MethodologyUncheckedCreateWithoutBatchParameterValuesInput>
    where?: MethodologyWhereInput
  }

  export type MethodologyUpdateToOneWithWhereWithoutBatchParameterValuesInput = {
    where?: MethodologyWhereInput
    data: XOR<MethodologyUpdateWithoutBatchParameterValuesInput, MethodologyUncheckedUpdateWithoutBatchParameterValuesInput>
  }

  export type MethodologyUpdateWithoutBatchParameterValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutMethodologiesNestedInput
    batches?: BatchUpdateManyWithoutMethodologiesNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateWithoutBatchParameterValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutMethodologiesNestedInput
    batches?: BatchUncheckedUpdateManyWithoutMethodologiesNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutMethodologyNestedInput
  }

  export type TrainingCreateWithoutCalendarInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutCalendarInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutCalendarInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutCalendarInput, TrainingUncheckedCreateWithoutCalendarInput>
  }

  export type TrainingCreateManyCalendarInputEnvelope = {
    data: TrainingCreateManyCalendarInput | TrainingCreateManyCalendarInput[]
    skipDuplicates?: boolean
  }

  export type TrainingUpsertWithWhereUniqueWithoutCalendarInput = {
    where: TrainingWhereUniqueInput
    update: XOR<TrainingUpdateWithoutCalendarInput, TrainingUncheckedUpdateWithoutCalendarInput>
    create: XOR<TrainingCreateWithoutCalendarInput, TrainingUncheckedCreateWithoutCalendarInput>
  }

  export type TrainingUpdateWithWhereUniqueWithoutCalendarInput = {
    where: TrainingWhereUniqueInput
    data: XOR<TrainingUpdateWithoutCalendarInput, TrainingUncheckedUpdateWithoutCalendarInput>
  }

  export type TrainingUpdateManyWithWhereWithoutCalendarInput = {
    where: TrainingScalarWhereInput
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyWithoutCalendarInput>
  }

  export type UserCreateWithoutTrainerTrainingsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTrainerTrainingsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTrainerTrainingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrainerTrainingsInput, UserUncheckedCreateWithoutTrainerTrainingsInput>
  }

  export type TrainingCalendarCreateWithoutTrainingsInput = {
    id?: string
    month: number
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingCalendarUncheckedCreateWithoutTrainingsInput = {
    id?: string
    month: number
    year: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingCalendarCreateOrConnectWithoutTrainingsInput = {
    where: TrainingCalendarWhereUniqueInput
    create: XOR<TrainingCalendarCreateWithoutTrainingsInput, TrainingCalendarUncheckedCreateWithoutTrainingsInput>
  }

  export type UserCreateWithoutCreatedTrainingsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedTrainingsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedTrainingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTrainingsInput, UserUncheckedCreateWithoutCreatedTrainingsInput>
  }

  export type TrainingSessionCreateWithoutTrainingInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionUncheckedCreateWithoutTrainingInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionCreateOrConnectWithoutTrainingInput = {
    where: TrainingSessionWhereUniqueInput
    create: XOR<TrainingSessionCreateWithoutTrainingInput, TrainingSessionUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingSessionCreateManyTrainingInputEnvelope = {
    data: TrainingSessionCreateManyTrainingInput | TrainingSessionCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingDocumentCreateWithoutTrainingInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    documentType: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutUploadedDocumentsInput
  }

  export type TrainingDocumentUncheckedCreateWithoutTrainingInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    documentType: $Enums.DocumentType
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDocumentCreateOrConnectWithoutTrainingInput = {
    where: TrainingDocumentWhereUniqueInput
    create: XOR<TrainingDocumentCreateWithoutTrainingInput, TrainingDocumentUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingDocumentCreateManyTrainingInputEnvelope = {
    data: TrainingDocumentCreateManyTrainingInput | TrainingDocumentCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutTrainingInput = {
    id?: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: TrainingSessionCreateNestedOneWithoutAttendanceInput
    user: UserCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutTrainingInput = {
    id?: string
    sessionId: string
    userId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutTrainingInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutTrainingInput, AttendanceUncheckedCreateWithoutTrainingInput>
  }

  export type AttendanceCreateManyTrainingInputEnvelope = {
    data: AttendanceCreateManyTrainingInput | AttendanceCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingParticipantCreateWithoutTrainingInput = {
    id?: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTrainingParticipationsInput
  }

  export type TrainingParticipantUncheckedCreateWithoutTrainingInput = {
    id?: string
    userId: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingParticipantCreateOrConnectWithoutTrainingInput = {
    where: TrainingParticipantWhereUniqueInput
    create: XOR<TrainingParticipantCreateWithoutTrainingInput, TrainingParticipantUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingParticipantCreateManyTrainingInputEnvelope = {
    data: TrainingParticipantCreateManyTrainingInput | TrainingParticipantCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingPhotoCreateWithoutTrainingInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutUploadedPhotosInput
  }

  export type TrainingPhotoUncheckedCreateWithoutTrainingInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type TrainingPhotoCreateOrConnectWithoutTrainingInput = {
    where: TrainingPhotoWhereUniqueInput
    create: XOR<TrainingPhotoCreateWithoutTrainingInput, TrainingPhotoUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingPhotoCreateManyTrainingInputEnvelope = {
    data: TrainingPhotoCreateManyTrainingInput | TrainingPhotoCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingFeedbackCreateWithoutTrainingInput = {
    id?: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFeedbacksInput
  }

  export type TrainingFeedbackUncheckedCreateWithoutTrainingInput = {
    id?: string
    userId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingFeedbackCreateOrConnectWithoutTrainingInput = {
    where: TrainingFeedbackWhereUniqueInput
    create: XOR<TrainingFeedbackCreateWithoutTrainingInput, TrainingFeedbackUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingFeedbackCreateManyTrainingInputEnvelope = {
    data: TrainingFeedbackCreateManyTrainingInput | TrainingFeedbackCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingFollowupCreateWithoutTrainingInput = {
    id?: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    assignedTo: UserCreateNestedOneWithoutAssignedFollowupsInput
    createdBy: UserCreateNestedOneWithoutCreatedFollowupsInput
  }

  export type TrainingFollowupUncheckedCreateWithoutTrainingInput = {
    id?: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    assignedToId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingFollowupCreateOrConnectWithoutTrainingInput = {
    where: TrainingFollowupWhereUniqueInput
    create: XOR<TrainingFollowupCreateWithoutTrainingInput, TrainingFollowupUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingFollowupCreateManyTrainingInputEnvelope = {
    data: TrainingFollowupCreateManyTrainingInput | TrainingFollowupCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingNotificationCreateWithoutTrainingInput = {
    id?: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutTrainingNotificationsInput
  }

  export type TrainingNotificationUncheckedCreateWithoutTrainingInput = {
    id?: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type TrainingNotificationCreateOrConnectWithoutTrainingInput = {
    where: TrainingNotificationWhereUniqueInput
    create: XOR<TrainingNotificationCreateWithoutTrainingInput, TrainingNotificationUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingNotificationCreateManyTrainingInputEnvelope = {
    data: TrainingNotificationCreateManyTrainingInput | TrainingNotificationCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTrainerTrainingsInput = {
    update: XOR<UserUpdateWithoutTrainerTrainingsInput, UserUncheckedUpdateWithoutTrainerTrainingsInput>
    create: XOR<UserCreateWithoutTrainerTrainingsInput, UserUncheckedCreateWithoutTrainerTrainingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrainerTrainingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrainerTrainingsInput, UserUncheckedUpdateWithoutTrainerTrainingsInput>
  }

  export type UserUpdateWithoutTrainerTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTrainerTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrainingCalendarUpsertWithoutTrainingsInput = {
    update: XOR<TrainingCalendarUpdateWithoutTrainingsInput, TrainingCalendarUncheckedUpdateWithoutTrainingsInput>
    create: XOR<TrainingCalendarCreateWithoutTrainingsInput, TrainingCalendarUncheckedCreateWithoutTrainingsInput>
    where?: TrainingCalendarWhereInput
  }

  export type TrainingCalendarUpdateToOneWithWhereWithoutTrainingsInput = {
    where?: TrainingCalendarWhereInput
    data: XOR<TrainingCalendarUpdateWithoutTrainingsInput, TrainingCalendarUncheckedUpdateWithoutTrainingsInput>
  }

  export type TrainingCalendarUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingCalendarUncheckedUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedTrainingsInput = {
    update: XOR<UserUpdateWithoutCreatedTrainingsInput, UserUncheckedUpdateWithoutCreatedTrainingsInput>
    create: XOR<UserCreateWithoutCreatedTrainingsInput, UserUncheckedCreateWithoutCreatedTrainingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTrainingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTrainingsInput, UserUncheckedUpdateWithoutCreatedTrainingsInput>
  }

  export type UserUpdateWithoutCreatedTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrainingSessionUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingSessionWhereUniqueInput
    update: XOR<TrainingSessionUpdateWithoutTrainingInput, TrainingSessionUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingSessionCreateWithoutTrainingInput, TrainingSessionUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingSessionUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingSessionWhereUniqueInput
    data: XOR<TrainingSessionUpdateWithoutTrainingInput, TrainingSessionUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingSessionUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingSessionScalarWhereInput
    data: XOR<TrainingSessionUpdateManyMutationInput, TrainingSessionUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingSessionScalarWhereInput = {
    AND?: TrainingSessionScalarWhereInput | TrainingSessionScalarWhereInput[]
    OR?: TrainingSessionScalarWhereInput[]
    NOT?: TrainingSessionScalarWhereInput | TrainingSessionScalarWhereInput[]
    id?: StringFilter<"TrainingSession"> | string
    trainingId?: StringFilter<"TrainingSession"> | string
    title?: StringFilter<"TrainingSession"> | string
    description?: StringNullableFilter<"TrainingSession"> | string | null
    startTime?: DateTimeFilter<"TrainingSession"> | Date | string
    endTime?: DateTimeFilter<"TrainingSession"> | Date | string
    venue?: StringFilter<"TrainingSession"> | string
    createdAt?: DateTimeFilter<"TrainingSession"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingSession"> | Date | string
  }

  export type TrainingDocumentUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingDocumentWhereUniqueInput
    update: XOR<TrainingDocumentUpdateWithoutTrainingInput, TrainingDocumentUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingDocumentCreateWithoutTrainingInput, TrainingDocumentUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingDocumentUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingDocumentWhereUniqueInput
    data: XOR<TrainingDocumentUpdateWithoutTrainingInput, TrainingDocumentUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingDocumentUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingDocumentScalarWhereInput
    data: XOR<TrainingDocumentUpdateManyMutationInput, TrainingDocumentUncheckedUpdateManyWithoutTrainingInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutTrainingInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutTrainingInput, AttendanceUncheckedUpdateWithoutTrainingInput>
    create: XOR<AttendanceCreateWithoutTrainingInput, AttendanceUncheckedCreateWithoutTrainingInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutTrainingInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutTrainingInput, AttendanceUncheckedUpdateWithoutTrainingInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutTrainingInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingParticipantUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingParticipantWhereUniqueInput
    update: XOR<TrainingParticipantUpdateWithoutTrainingInput, TrainingParticipantUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingParticipantCreateWithoutTrainingInput, TrainingParticipantUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingParticipantUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingParticipantWhereUniqueInput
    data: XOR<TrainingParticipantUpdateWithoutTrainingInput, TrainingParticipantUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingParticipantUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingParticipantScalarWhereInput
    data: XOR<TrainingParticipantUpdateManyMutationInput, TrainingParticipantUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingPhotoUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingPhotoWhereUniqueInput
    update: XOR<TrainingPhotoUpdateWithoutTrainingInput, TrainingPhotoUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingPhotoCreateWithoutTrainingInput, TrainingPhotoUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingPhotoUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingPhotoWhereUniqueInput
    data: XOR<TrainingPhotoUpdateWithoutTrainingInput, TrainingPhotoUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingPhotoUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingPhotoScalarWhereInput
    data: XOR<TrainingPhotoUpdateManyMutationInput, TrainingPhotoUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingFeedbackUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingFeedbackWhereUniqueInput
    update: XOR<TrainingFeedbackUpdateWithoutTrainingInput, TrainingFeedbackUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingFeedbackCreateWithoutTrainingInput, TrainingFeedbackUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingFeedbackUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingFeedbackWhereUniqueInput
    data: XOR<TrainingFeedbackUpdateWithoutTrainingInput, TrainingFeedbackUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingFeedbackUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingFeedbackScalarWhereInput
    data: XOR<TrainingFeedbackUpdateManyMutationInput, TrainingFeedbackUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingFollowupUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingFollowupWhereUniqueInput
    update: XOR<TrainingFollowupUpdateWithoutTrainingInput, TrainingFollowupUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingFollowupCreateWithoutTrainingInput, TrainingFollowupUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingFollowupUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingFollowupWhereUniqueInput
    data: XOR<TrainingFollowupUpdateWithoutTrainingInput, TrainingFollowupUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingFollowupUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingFollowupScalarWhereInput
    data: XOR<TrainingFollowupUpdateManyMutationInput, TrainingFollowupUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingNotificationUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TrainingNotificationWhereUniqueInput
    update: XOR<TrainingNotificationUpdateWithoutTrainingInput, TrainingNotificationUncheckedUpdateWithoutTrainingInput>
    create: XOR<TrainingNotificationCreateWithoutTrainingInput, TrainingNotificationUncheckedCreateWithoutTrainingInput>
  }

  export type TrainingNotificationUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TrainingNotificationWhereUniqueInput
    data: XOR<TrainingNotificationUpdateWithoutTrainingInput, TrainingNotificationUncheckedUpdateWithoutTrainingInput>
  }

  export type TrainingNotificationUpdateManyWithWhereWithoutTrainingInput = {
    where: TrainingNotificationScalarWhereInput
    data: XOR<TrainingNotificationUpdateManyMutationInput, TrainingNotificationUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingCreateWithoutSessionsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutSessionsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutSessionsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutSessionsInput, TrainingUncheckedCreateWithoutSessionsInput>
  }

  export type AttendanceCreateWithoutSessionInput = {
    id?: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutAttendanceInput
    user: UserCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutSessionInput = {
    id?: string
    trainingId: string
    userId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutSessionInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput>
  }

  export type AttendanceCreateManySessionInputEnvelope = {
    data: AttendanceCreateManySessionInput | AttendanceCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type TrainingUpsertWithoutSessionsInput = {
    update: XOR<TrainingUpdateWithoutSessionsInput, TrainingUncheckedUpdateWithoutSessionsInput>
    create: XOR<TrainingCreateWithoutSessionsInput, TrainingUncheckedCreateWithoutSessionsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutSessionsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutSessionsInput, TrainingUncheckedUpdateWithoutSessionsInput>
  }

  export type TrainingUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type AttendanceUpsertWithWhereUniqueWithoutSessionInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutSessionInput, AttendanceUncheckedUpdateWithoutSessionInput>
    create: XOR<AttendanceCreateWithoutSessionInput, AttendanceUncheckedCreateWithoutSessionInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutSessionInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutSessionInput, AttendanceUncheckedUpdateWithoutSessionInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutSessionInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutSessionInput>
  }

  export type TrainingCreateWithoutDocumentsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutDocumentsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutDocumentsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutDocumentsInput, TrainingUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutUploadedDocumentsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadedDocumentsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadedDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
  }

  export type TrainingUpsertWithoutDocumentsInput = {
    update: XOR<TrainingUpdateWithoutDocumentsInput, TrainingUncheckedUpdateWithoutDocumentsInput>
    create: XOR<TrainingCreateWithoutDocumentsInput, TrainingUncheckedCreateWithoutDocumentsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutDocumentsInput, TrainingUncheckedUpdateWithoutDocumentsInput>
  }

  export type TrainingUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type UserUpsertWithoutUploadedDocumentsInput = {
    update: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type UserUpdateWithoutUploadedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrainingCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutParticipantsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutParticipantsInput, TrainingUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutTrainingParticipationsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTrainingParticipationsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTrainingParticipationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrainingParticipationsInput, UserUncheckedCreateWithoutTrainingParticipationsInput>
  }

  export type TrainingUpsertWithoutParticipantsInput = {
    update: XOR<TrainingUpdateWithoutParticipantsInput, TrainingUncheckedUpdateWithoutParticipantsInput>
    create: XOR<TrainingCreateWithoutParticipantsInput, TrainingUncheckedCreateWithoutParticipantsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutParticipantsInput, TrainingUncheckedUpdateWithoutParticipantsInput>
  }

  export type TrainingUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type UserUpsertWithoutTrainingParticipationsInput = {
    update: XOR<UserUpdateWithoutTrainingParticipationsInput, UserUncheckedUpdateWithoutTrainingParticipationsInput>
    create: XOR<UserCreateWithoutTrainingParticipationsInput, UserUncheckedCreateWithoutTrainingParticipationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrainingParticipationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrainingParticipationsInput, UserUncheckedUpdateWithoutTrainingParticipationsInput>
  }

  export type UserUpdateWithoutTrainingParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTrainingParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrainingCreateWithoutAttendanceInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutAttendanceInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutAttendanceInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutAttendanceInput, TrainingUncheckedCreateWithoutAttendanceInput>
  }

  export type TrainingSessionCreateWithoutAttendanceInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    createdAt?: Date | string
    updatedAt?: Date | string
    training: TrainingCreateNestedOneWithoutSessionsInput
  }

  export type TrainingSessionUncheckedCreateWithoutAttendanceInput = {
    id?: string
    trainingId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingSessionCreateOrConnectWithoutAttendanceInput = {
    where: TrainingSessionWhereUniqueInput
    create: XOR<TrainingSessionCreateWithoutAttendanceInput, TrainingSessionUncheckedCreateWithoutAttendanceInput>
  }

  export type UserCreateWithoutAttendancesInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttendancesInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttendancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
  }

  export type TrainingUpsertWithoutAttendanceInput = {
    update: XOR<TrainingUpdateWithoutAttendanceInput, TrainingUncheckedUpdateWithoutAttendanceInput>
    create: XOR<TrainingCreateWithoutAttendanceInput, TrainingUncheckedCreateWithoutAttendanceInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutAttendanceInput, TrainingUncheckedUpdateWithoutAttendanceInput>
  }

  export type TrainingUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingSessionUpsertWithoutAttendanceInput = {
    update: XOR<TrainingSessionUpdateWithoutAttendanceInput, TrainingSessionUncheckedUpdateWithoutAttendanceInput>
    create: XOR<TrainingSessionCreateWithoutAttendanceInput, TrainingSessionUncheckedCreateWithoutAttendanceInput>
    where?: TrainingSessionWhereInput
  }

  export type TrainingSessionUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: TrainingSessionWhereInput
    data: XOR<TrainingSessionUpdateWithoutAttendanceInput, TrainingSessionUncheckedUpdateWithoutAttendanceInput>
  }

  export type TrainingSessionUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type TrainingSessionUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAttendancesInput = {
    update: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrainingCreateWithoutPhotosInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutPhotosInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutPhotosInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutPhotosInput, TrainingUncheckedCreateWithoutPhotosInput>
  }

  export type UserCreateWithoutUploadedPhotosInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadedPhotosInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadedPhotosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedPhotosInput, UserUncheckedCreateWithoutUploadedPhotosInput>
  }

  export type TrainingUpsertWithoutPhotosInput = {
    update: XOR<TrainingUpdateWithoutPhotosInput, TrainingUncheckedUpdateWithoutPhotosInput>
    create: XOR<TrainingCreateWithoutPhotosInput, TrainingUncheckedCreateWithoutPhotosInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutPhotosInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutPhotosInput, TrainingUncheckedUpdateWithoutPhotosInput>
  }

  export type TrainingUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type UserUpsertWithoutUploadedPhotosInput = {
    update: XOR<UserUpdateWithoutUploadedPhotosInput, UserUncheckedUpdateWithoutUploadedPhotosInput>
    create: XOR<UserCreateWithoutUploadedPhotosInput, UserUncheckedCreateWithoutUploadedPhotosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedPhotosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedPhotosInput, UserUncheckedUpdateWithoutUploadedPhotosInput>
  }

  export type UserUpdateWithoutUploadedPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrainingCreateWithoutFeedbackInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutFeedbackInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutFeedbackInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutFeedbackInput, TrainingUncheckedCreateWithoutFeedbackInput>
  }

  export type UserCreateWithoutFeedbacksInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbacksInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbacksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
  }

  export type TrainingUpsertWithoutFeedbackInput = {
    update: XOR<TrainingUpdateWithoutFeedbackInput, TrainingUncheckedUpdateWithoutFeedbackInput>
    create: XOR<TrainingCreateWithoutFeedbackInput, TrainingUncheckedCreateWithoutFeedbackInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutFeedbackInput, TrainingUncheckedUpdateWithoutFeedbackInput>
  }

  export type TrainingUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type UserUpsertWithoutFeedbacksInput = {
    update: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrainingCreateWithoutFollowupsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutFollowupsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    notifications?: TrainingNotificationUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutFollowupsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutFollowupsInput, TrainingUncheckedCreateWithoutFollowupsInput>
  }

  export type UserCreateWithoutAssignedFollowupsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedFollowupsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedFollowupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedFollowupsInput, UserUncheckedCreateWithoutAssignedFollowupsInput>
  }

  export type UserCreateWithoutCreatedFollowupsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    trainingNotifications?: TrainingNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedFollowupsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    trainingNotifications?: TrainingNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedFollowupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedFollowupsInput, UserUncheckedCreateWithoutCreatedFollowupsInput>
  }

  export type TrainingUpsertWithoutFollowupsInput = {
    update: XOR<TrainingUpdateWithoutFollowupsInput, TrainingUncheckedUpdateWithoutFollowupsInput>
    create: XOR<TrainingCreateWithoutFollowupsInput, TrainingUncheckedCreateWithoutFollowupsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutFollowupsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutFollowupsInput, TrainingUncheckedUpdateWithoutFollowupsInput>
  }

  export type TrainingUpdateWithoutFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type UserUpsertWithoutAssignedFollowupsInput = {
    update: XOR<UserUpdateWithoutAssignedFollowupsInput, UserUncheckedUpdateWithoutAssignedFollowupsInput>
    create: XOR<UserCreateWithoutAssignedFollowupsInput, UserUncheckedCreateWithoutAssignedFollowupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedFollowupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedFollowupsInput, UserUncheckedUpdateWithoutAssignedFollowupsInput>
  }

  export type UserUpdateWithoutAssignedFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCreatedFollowupsInput = {
    update: XOR<UserUpdateWithoutCreatedFollowupsInput, UserUncheckedUpdateWithoutCreatedFollowupsInput>
    create: XOR<UserCreateWithoutCreatedFollowupsInput, UserUncheckedCreateWithoutCreatedFollowupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedFollowupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedFollowupsInput, UserUncheckedUpdateWithoutCreatedFollowupsInput>
  }

  export type UserUpdateWithoutCreatedFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrainingCreateWithoutNotificationsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainer: UserCreateNestedOneWithoutTrainerTrainingsInput
    calendar: TrainingCalendarCreateNestedOneWithoutTrainingsInput
    createdBy: UserCreateNestedOneWithoutCreatedTrainingsInput
    sessions?: TrainingSessionCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutNotificationsInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutTrainingInput
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutTrainingInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutTrainingInput
    participants?: TrainingParticipantUncheckedCreateNestedManyWithoutTrainingInput
    photos?: TrainingPhotoUncheckedCreateNestedManyWithoutTrainingInput
    feedback?: TrainingFeedbackUncheckedCreateNestedManyWithoutTrainingInput
    followups?: TrainingFollowupUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutNotificationsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutNotificationsInput, TrainingUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutTrainingNotificationsInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Role: RoleCreateNestedOneWithoutUserInput
    StandardsCreated?: StandardCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantCreateNestedManyWithoutUserInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutTrainingNotificationsInput = {
    id: string
    email: string
    name: string
    password: string
    roleId: string
    createdAt?: Date | string
    updatedAt: Date | string
    ActivityLog?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_checkerIdToUserInput
    Batch_Batch_makerIdToUser?: BatchUncheckedCreateNestedManyWithoutUser_Batch_makerIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    StandardsCreated?: StandardUncheckedCreateNestedManyWithoutCreatedByInput
    StandardsModified?: StandardUncheckedCreateNestedManyWithoutModifiedByInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedCreateNestedManyWithoutCreatedByInput
    standardDefinitionsModified?: StandardDefinitionUncheckedCreateNestedManyWithoutModifiedByInput
    trainerTrainings?: TrainingUncheckedCreateNestedManyWithoutTrainerInput
    createdTrainings?: TrainingUncheckedCreateNestedManyWithoutCreatedByInput
    trainingParticipations?: TrainingParticipantUncheckedCreateNestedManyWithoutUserInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: TrainingDocumentUncheckedCreateNestedManyWithoutUploadedByInput
    uploadedPhotos?: TrainingPhotoUncheckedCreateNestedManyWithoutUploadedByInput
    feedbacks?: TrainingFeedbackUncheckedCreateNestedManyWithoutUserInput
    assignedFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutAssignedToInput
    createdFollowups?: TrainingFollowupUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutTrainingNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrainingNotificationsInput, UserUncheckedCreateWithoutTrainingNotificationsInput>
  }

  export type TrainingUpsertWithoutNotificationsInput = {
    update: XOR<TrainingUpdateWithoutNotificationsInput, TrainingUncheckedUpdateWithoutNotificationsInput>
    create: XOR<TrainingCreateWithoutNotificationsInput, TrainingUncheckedCreateWithoutNotificationsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutNotificationsInput, TrainingUncheckedUpdateWithoutNotificationsInput>
  }

  export type TrainingUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type UserUpsertWithoutTrainingNotificationsInput = {
    update: XOR<UserUpdateWithoutTrainingNotificationsInput, UserUncheckedUpdateWithoutTrainingNotificationsInput>
    create: XOR<UserCreateWithoutTrainingNotificationsInput, UserUncheckedCreateWithoutTrainingNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrainingNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrainingNotificationsInput, UserUncheckedUpdateWithoutTrainingNotificationsInput>
  }

  export type UserUpdateWithoutTrainingNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTrainingNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ActivityLogCreateManyBatchInput = {
    id: string
    userId: string
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyBatchInput = {
    id: string
    userId: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type BatchParameterValueCreateManyBatchInput = {
    id: string
    parameterId: string
    value: string
    unitId?: string | null
    methodologyId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ActivityLogUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutActivityLogNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardsModifiedNestedInput
    methodologies?: MethodologyUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    methodologies?: MethodologyUncheckedUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateManyWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodologyUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutMethodologyNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutMethodologyNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateManyWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfMeasurementUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutUnitNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Standards?: StandardUncheckedUpdateManyWithoutUnitsNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateManyWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StandardParameterUpdateOneRequiredWithoutBatchValuesNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutBatchParameterValuesNestedInput
    methodology?: MethodologyUpdateOneWithoutBatchParameterValuesNestedInput
  }

  export type BatchParameterValueUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueCreateManyMethodologyInput = {
    id: string
    batchId: string
    parameterId: string
    value: string
    unitId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateManyMethodologyInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardUpdateWithoutMethodologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardsModifiedNestedInput
    batches?: BatchUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateWithoutMethodologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateManyWithoutMethodologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateWithoutMethodologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutMethodologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutMethodologiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUpdateWithoutMethodologyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneRequiredWithoutParameterValuesNestedInput
    parameter?: StandardParameterUpdateOneRequiredWithoutBatchValuesNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutBatchParameterValuesNestedInput
  }

  export type BatchParameterValueUncheckedUpdateWithoutMethodologyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutMethodologyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUpdateWithoutMethodologyInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StandardParameterUpdateOneRequiredWithoutStandardsNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutStandardDefinitionsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardDefinitionsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardDefinitionsModifiedNestedInput
  }

  export type StandardDefinitionUncheckedUpdateWithoutMethodologyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutMethodologyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateManyProductInput = {
    id: string
    batchNumber: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyRoleInput = {
    id: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    Batch_Batch_checkerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserNestedInput
    Batch_Batch_makerIdToUser?: BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    StandardsCreated?: StandardUncheckedUpdateManyWithoutCreatedByNestedInput
    StandardsModified?: StandardUncheckedUpdateManyWithoutModifiedByNestedInput
    standardDefinitionsCreated?: StandardDefinitionUncheckedUpdateManyWithoutCreatedByNestedInput
    standardDefinitionsModified?: StandardDefinitionUncheckedUpdateManyWithoutModifiedByNestedInput
    trainerTrainings?: TrainingUncheckedUpdateManyWithoutTrainerNestedInput
    createdTrainings?: TrainingUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingParticipations?: TrainingParticipantUncheckedUpdateManyWithoutUserNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: TrainingDocumentUncheckedUpdateManyWithoutUploadedByNestedInput
    uploadedPhotos?: TrainingPhotoUncheckedUpdateManyWithoutUploadedByNestedInput
    feedbacks?: TrainingFeedbackUncheckedUpdateManyWithoutUserNestedInput
    assignedFollowups?: TrainingFollowupUncheckedUpdateManyWithoutAssignedToNestedInput
    createdFollowups?: TrainingFollowupUncheckedUpdateManyWithoutCreatedByNestedInput
    trainingNotifications?: TrainingNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueCreateManyUnitInput = {
    id: string
    batchId: string
    parameterId: string
    value: string
    methodologyId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateManyUnitInput = {
    id: string
    parameterId: string
    standardValue: string
    methodologyId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardsModifiedNestedInput
    batches?: BatchUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateManyWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneRequiredWithoutParameterValuesNestedInput
    parameter?: StandardParameterUpdateOneRequiredWithoutBatchValuesNestedInput
    methodology?: MethodologyUpdateOneWithoutBatchParameterValuesNestedInput
  }

  export type BatchParameterValueUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StandardParameterUpdateOneRequiredWithoutStandardsNestedInput
    methodology?: MethodologyUpdateOneWithoutStandardDefinitionsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardDefinitionsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardDefinitionsModifiedNestedInput
  }

  export type StandardDefinitionUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateWithoutUnitOfMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutUnitOfMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutUnitOfMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyUserInput = {
    id: string
    batchId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type BatchCreateManyUser_Batch_checkerIdToUserInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    makerId: string
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchCreateManyUser_Batch_makerIdToUserInput = {
    id: string
    batchNumber: string
    productId: string
    dateOfProduction: Date | string
    bestBeforeDate: Date | string
    sampleAnalysisStarted?: Date | string | null
    sampleAnalysisCompleted?: Date | string | null
    sampleAnalysisStatus?: $Enums.SampleAnalysisStatus
    checkerId?: string | null
    status?: $Enums.BatchStatus
    rejectionRemarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id: string
    batchId?: string | null
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type StandardCreateManyCreatedByInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardCreateManyModifiedByInput = {
    id: string
    name: string
    code: string
    description: string
    categoryId: string
    createdById: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateManyCreatedByInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateManyModifiedByInput = {
    id: string
    parameterId: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    createdById: string
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TrainingCreateManyTrainerInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    calendarId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingCreateManyCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    calendarId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingParticipantCreateManyUserInput = {
    id?: string
    trainingId: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyUserInput = {
    id?: string
    trainingId: string
    sessionId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDocumentCreateManyUploadedByInput = {
    id?: string
    trainingId: string
    title: string
    description?: string | null
    fileUrl: string
    documentType: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPhotoCreateManyUploadedByInput = {
    id?: string
    trainingId: string
    photoUrl: string
    caption?: string | null
    createdAt?: Date | string
  }

  export type TrainingFeedbackCreateManyUserInput = {
    id?: string
    trainingId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingFollowupCreateManyAssignedToInput = {
    id?: string
    trainingId: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingFollowupCreateManyCreatedByInput = {
    id?: string
    trainingId: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    assignedToId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingNotificationCreateManyUserInput = {
    id?: string
    trainingId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type ActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneWithoutActivityLogNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateWithoutUser_Batch_checkerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutUser_Batch_checkerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutUser_Batch_checkerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateWithoutUser_Batch_makerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    standards?: StandardUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutUser_Batch_makerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    standards?: StandardUncheckedUpdateManyWithoutBatchesNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutUser_Batch_makerIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardsModifiedNestedInput
    batches?: BatchUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardUpdateWithoutModifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Category?: StandardCategoryUpdateOneRequiredWithoutStandardsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardsCreatedNestedInput
    batches?: BatchUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateWithoutModifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateManyWithoutModifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StandardParameterUpdateOneRequiredWithoutStandardsNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutStandardDefinitionsNestedInput
    methodology?: MethodologyUpdateOneWithoutStandardDefinitionsNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardDefinitionsModifiedNestedInput
  }

  export type StandardDefinitionUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUpdateWithoutModifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: StandardParameterUpdateOneRequiredWithoutStandardsNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutStandardDefinitionsNestedInput
    methodology?: MethodologyUpdateOneWithoutStandardDefinitionsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardDefinitionsCreatedNestedInput
  }

  export type StandardDefinitionUncheckedUpdateWithoutModifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutModifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingUpdateWithoutTrainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutTrainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateManyWithoutTrainerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    calendarId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    calendar?: TrainingCalendarUpdateOneRequiredWithoutTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    calendarId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type TrainingParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutAttendanceNestedInput
    session?: TrainingSessionUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type TrainingDocumentUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type TrainingPhotoUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type TrainingFeedbackUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFollowupUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training?: TrainingUpdateOneRequiredWithoutFollowupsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedFollowupsNestedInput
  }

  export type TrainingFollowupUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingFollowupUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingFollowupUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training?: TrainingUpdateOneRequiredWithoutFollowupsNestedInput
    assignedTo?: UserUpdateOneRequiredWithoutAssignedFollowupsNestedInput
  }

  export type TrainingFollowupUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingFollowupUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    training?: TrainingUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type TrainingNotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BatchUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUpdateManyWithoutBatchNestedInput
    User_Batch_checkerIdToUser?: UserUpdateOneWithoutBatch_Batch_checkerIdToUserNestedInput
    User_Batch_makerIdToUser?: UserUpdateOneRequiredWithoutBatch_Batch_makerIdToUserNestedInput
    Product?: ProductUpdateOneRequiredWithoutBatchNestedInput
    Notification?: NotificationUpdateManyWithoutBatchNestedInput
    methodologies?: MethodologyUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ActivityLog?: ActivityLogUncheckedUpdateManyWithoutBatchNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutBatchNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutBatchesNestedInput
    unitOfMeasurements?: UnitOfMeasurementUncheckedUpdateManyWithoutBatchesNestedInput
    parameterValues?: BatchParameterValueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    dateOfProduction?: DateTimeFieldUpdateOperationsInput | Date | string
    bestBeforeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleAnalysisStarted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisCompleted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleAnalysisStatus?: EnumSampleAnalysisStatusFieldUpdateOperationsInput | $Enums.SampleAnalysisStatus
    makerId?: StringFieldUpdateOperationsInput | string
    checkerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    rejectionRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodologyUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUpdateManyWithoutMethodologyNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutMethodologiesNestedInput
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutMethodologyNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutMethodologyNestedInput
  }

  export type MethodologyUncheckedUpdateManyWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    procedure?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitOfMeasurementUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchParameterValues?: BatchParameterValueUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUpdateManyWithoutUnitNestedInput
    batches?: BatchUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchParameterValues?: BatchParameterValueUncheckedUpdateManyWithoutUnitNestedInput
    standardDefinitions?: StandardDefinitionUncheckedUpdateManyWithoutUnitNestedInput
    batches?: BatchUncheckedUpdateManyWithoutUnitOfMeasurementsNestedInput
  }

  export type UnitOfMeasurementUncheckedUpdateManyWithoutStandardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardParameterCreateManyCategoryInput = {
    id: string
    name: string
    description?: string | null
    dataType: $Enums.ParameterDataType
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardCreateManyCategoryInput = {
    id: string
    name: string
    code: string
    description: string
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardParameterUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchValues?: BatchParameterValueUpdateManyWithoutParameterNestedInput
    standards?: StandardDefinitionUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchValues?: BatchParameterValueUncheckedUpdateManyWithoutParameterNestedInput
    standards?: StandardDefinitionUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type StandardParameterUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: EnumParameterDataTypeFieldUpdateOperationsInput | $Enums.ParameterDataType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: UserUpdateOneRequiredWithoutStandardsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardsModifiedNestedInput
    batches?: BatchUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: BatchUncheckedUpdateManyWithoutStandardsNestedInput
    methodologies?: MethodologyUncheckedUpdateManyWithoutStandardsNestedInput
    units?: UnitOfMeasurementUncheckedUpdateManyWithoutStandardsNestedInput
  }

  export type StandardUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueCreateManyParameterInput = {
    id: string
    batchId: string
    value: string
    unitId?: string | null
    methodologyId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type StandardDefinitionCreateManyParameterInput = {
    id: string
    standardValue: string
    unitId?: string | null
    methodologyId?: string | null
    createdById: string
    modifiedById?: string | null
    status?: $Enums.StandardStatus
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchParameterValueUpdateWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneRequiredWithoutParameterValuesNestedInput
    unit?: UnitOfMeasurementUpdateOneWithoutBatchParameterValuesNestedInput
    methodology?: MethodologyUpdateOneWithoutBatchParameterValuesNestedInput
  }

  export type BatchParameterValueUncheckedUpdateWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchParameterValueUncheckedUpdateManyWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUpdateWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitOfMeasurementUpdateOneWithoutStandardDefinitionsNestedInput
    methodology?: MethodologyUpdateOneWithoutStandardDefinitionsNestedInput
    CreatedBy?: UserUpdateOneRequiredWithoutStandardDefinitionsCreatedNestedInput
    ModifiedBy?: UserUpdateOneWithoutStandardDefinitionsModifiedNestedInput
  }

  export type StandardDefinitionUncheckedUpdateWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardDefinitionUncheckedUpdateManyWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardValue?: StringFieldUpdateOperationsInput | string
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    methodologyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    modifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStandardStatusFieldUpdateOperationsInput | $Enums.StandardStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingCreateManyCalendarInput = {
    id?: string
    title: string
    description?: string | null
    trainingType: $Enums.TrainingType
    status?: $Enums.TrainingStatus
    startDate: Date | string
    endDate: Date | string
    location: string
    maxParticipants?: number | null
    trainerId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainer?: UserUpdateOneRequiredWithoutTrainerTrainingsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedTrainingsNestedInput
    sessions?: TrainingSessionUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutTrainingNestedInput
    documents?: TrainingDocumentUncheckedUpdateManyWithoutTrainingNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutTrainingNestedInput
    participants?: TrainingParticipantUncheckedUpdateManyWithoutTrainingNestedInput
    photos?: TrainingPhotoUncheckedUpdateManyWithoutTrainingNestedInput
    feedback?: TrainingFeedbackUncheckedUpdateManyWithoutTrainingNestedInput
    followups?: TrainingFollowupUncheckedUpdateManyWithoutTrainingNestedInput
    notifications?: TrainingNotificationUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateManyWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trainingType?: EnumTrainingTypeFieldUpdateOperationsInput | $Enums.TrainingType
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    trainerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionCreateManyTrainingInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    venue: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingDocumentCreateManyTrainingInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    documentType: $Enums.DocumentType
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyTrainingInput = {
    id?: string
    sessionId: string
    userId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingParticipantCreateManyTrainingInput = {
    id?: string
    userId: string
    inviteSent?: boolean
    inviteSentAt?: Date | string | null
    inviteAccepted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingPhotoCreateManyTrainingInput = {
    id?: string
    photoUrl: string
    caption?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type TrainingFeedbackCreateManyTrainingInput = {
    id?: string
    userId: string
    contentRating: number
    trainerRating: number
    materialRating: number
    venueRating: number
    overallRating: number
    comments?: string | null
    suggestedImprovements?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingFollowupCreateManyTrainingInput = {
    id?: string
    title: string
    description: string
    dueDate?: Date | string | null
    isCompleted?: boolean
    assignedToId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingNotificationCreateManyTrainingInput = {
    id?: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    sentAt?: Date | string
    readAt?: Date | string | null
  }

  export type TrainingSessionUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
  }

  export type TrainingDocumentUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: TrainingSessionUpdateOneRequiredWithoutAttendanceNestedInput
    user?: UserUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrainingParticipationsNestedInput
  }

  export type TrainingParticipantUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingParticipantUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    inviteSent?: BoolFieldUpdateOperationsInput | boolean
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteAccepted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedPhotosNestedInput
  }

  export type TrainingPhotoUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingPhotoUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type TrainingFeedbackUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFeedbackUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentRating?: IntFieldUpdateOperationsInput | number
    trainerRating?: IntFieldUpdateOperationsInput | number
    materialRating?: IntFieldUpdateOperationsInput | number
    venueRating?: IntFieldUpdateOperationsInput | number
    overallRating?: IntFieldUpdateOperationsInput | number
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    suggestedImprovements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingFollowupUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: UserUpdateOneRequiredWithoutAssignedFollowupsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedFollowupsNestedInput
  }

  export type TrainingFollowupUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingFollowupUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    assignedToId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTrainingNotificationsNestedInput
  }

  export type TrainingNotificationUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingNotificationUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceCreateManySessionInput = {
    id?: string
    trainingId: string
    userId: string
    status: $Enums.AttendanceStatus
    remarks?: string | null
    signatureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    training?: TrainingUpdateOneRequiredWithoutAttendanceNestedInput
    user?: UserUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    trainingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}